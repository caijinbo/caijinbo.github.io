<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CAIJINBO</title>
  <icon>https://www.gravatar.com/avatar/df687bae53da17be25bf911724d042ec</icon>
  <subtitle>努力发挥创造力</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://caijinbo.work/"/>
  <updated>2020-11-23T10:14:49.994Z</updated>
  <id>https://caijinbo.work/</id>
  
  <author>
    <name>caijinbo</name>
    <email>caijinbo_mail@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NFS的搭建与使用</title>
    <link href="https://caijinbo.work/2020/11/21/2020-11-22-NFS%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://caijinbo.work/2020/11/21/2020-11-22-NFS%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2020-11-21T16:00:00.000Z</published>
    <updated>2020-11-23T10:14:49.994Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>NFS  （network file system 网络文件系统）是当前主流异构平台共享文件系统之一。</p><p>NFS的工作原理是使用客户端/服务器架构，由一个客户端程序和服务器程序组成。</p><a id="more"></a><p>NFS与NAS的区别：</p><p>NFS    是一种文件传输协议</p><p>NAS （Network Attached Storage） NAS是存储的一种方式，可以是设备，也可以是存储网络的架构。</p><h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><p>以centos系统为例</p><h3 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h3><h4 id="第一步：安装nfs"><a href="#第一步：安装nfs" class="headerlink" title="第一步：安装nfs"></a>第一步：安装nfs</h4><p><code>yum install -y nfs-utils</code></p><h4 id="第二步：创建一个共享目录"><a href="#第二步：创建一个共享目录" class="headerlink" title="第二步：创建一个共享目录"></a>第二步：创建一个共享目录</h4><p><code>mkdir /data</code></p><h4 id="第三步：配置NFS服务"><a href="#第三步：配置NFS服务" class="headerlink" title="第三步：配置NFS服务"></a>第三步：配置NFS服务</h4><p>编辑exports文件，添加从机<br><code>vim /etc/exports</code></p><p>填入：<br><code>/data                 192.168.203.0/24 (rw,sync,no_root_squash)</code></p><p> 备注： no_root_squash   允许root用户访问挂载上来的NFS卷</p><h4 id="第四步：启动NFS服务"><a href="#第四步：启动NFS服务" class="headerlink" title="第四步：启动NFS服务"></a>第四步：启动NFS服务</h4><p><strong>先启动rpcbind服务，再启动nfs服务</strong><br><code>systemctl start rpcbind.service</code><br><code>systemctl start nfs-server.service</code></p><h4 id="第五步：确认NFS服务启动"><a href="#第五步：确认NFS服务启动" class="headerlink" title="第五步：确认NFS服务启动"></a>第五步：确认NFS服务启动</h4><p><code>exportfs -v</code></p><h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><h4 id="第一步：安装nfs-1"><a href="#第一步：安装nfs-1" class="headerlink" title="第一步：安装nfs"></a>第一步：安装nfs</h4><p><code>yum install -y nfs-utils</code></p><h4 id="第二步：启动rpcbind服务（客户端不用启动nfs-server服务）"><a href="#第二步：启动rpcbind服务（客户端不用启动nfs-server服务）" class="headerlink" title="第二步：启动rpcbind服务（客户端不用启动nfs-server服务）"></a>第二步：启动rpcbind服务（客户端不用启动nfs-server服务）</h4><p><code>systemctl start rpcbind.service</code></p><h4 id="第三步：查看NFS服务端是否有目录共享"><a href="#第三步：查看NFS服务端是否有目录共享" class="headerlink" title="第三步：查看NFS服务端是否有目录共享"></a>第三步：查看NFS服务端是否有目录共享</h4><p><code>showmount -e &lt;服务端的ip地址&gt;</code></p><h4 id="第四步：手动挂载共享盘"><a href="#第四步：手动挂载共享盘" class="headerlink" title="第四步：手动挂载共享盘"></a>第四步：手动挂载共享盘</h4><p>创建一个共享目录</p><p><code>mkdir /data</code></p><p>开始挂载</p><p><code>mount -t nfs &lt;服务端ip或者域名&gt;:/data /data</code></p><p><code>mount -a</code></p><p>查看挂载情况</p><p><code>df -h</code></p><p>如果想卸载：</p><p><code>unmount /data</code></p><h4 id="第五步：配置开机自动挂载"><a href="#第五步：配置开机自动挂载" class="headerlink" title="第五步：配置开机自动挂载"></a>第五步：配置开机自动挂载</h4><p><code>vim /etc/fstab</code></p><p>填入：</p><p><code>&lt;服务端ip或者域名&gt;:/data     /data         nfs              defaults               0    0</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;NFS  （network file system 网络文件系统）是当前主流异构平台共享文件系统之一。&lt;/p&gt;
&lt;p&gt;NFS的工作原理是使用客户端/服务器架构，由一个客户端程序和服务器程序组成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://caijinbo.work/categories/linux/"/>
    
    
      <category term="linux" scheme="https://caijinbo.work/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>docker使用与配置</title>
    <link href="https://caijinbo.work/2020/10/09/2020-10-10-docker%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>https://caijinbo.work/2020/10/09/2020-10-10-docker%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE/</id>
    <published>2020-10-09T16:00:00.000Z</published>
    <updated>2020-11-23T10:14:46.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker基础知识"><a href="#docker基础知识" class="headerlink" title="docker基础知识"></a>docker基础知识</h1><h1 id="第一章docker基础知识"><a href="#第一章docker基础知识" class="headerlink" title="第一章docker基础知识"></a>第一章docker基础知识</h1><h2 id="一、docker简介"><a href="#一、docker简介" class="headerlink" title="一、docker简介"></a>一、docker简介</h2><p>Docker是一个开源的<strong>容器引擎</strong>，它基于LXC容器技术，使用Go语言开发。</p><a id="more"></a><p>源代码托管在Github上，并遵从Apache2.0协议。</p><p>Docker采用<strong>C/S架构</strong>，其可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。</p><p>简单来说：<strong>Docker就是一种快速解决业务稳定环境的一种技术手段(快速搭建环境)。</strong></p><p>一个完整的Docker有以下几个部分组成：</p><ol><li>DockerClient客户端</li><li>Docker Daemon守护进程</li><li>Docker Image镜像备注：有的系统会无效，自行上网搜索解决方法</li><li>DockerContainer容器</li></ol><h2 id="二、原理解析"><a href="#二、原理解析" class="headerlink" title="二、原理解析"></a>二、原理解析</h2><p>Docker Engine是一个<strong>C/S架构</strong>的应用程序，主要包含下面几个组件：</p><blockquote><p>dockerd进程：常驻后台进程Dockerd</p><p>REST API Server：用来和 Dockerd 交互的 </p><p>命令行CLI接口：和 REST API 进行交互（常用docker 命令）</p></blockquote><p><strong>分工合作</strong></p><p>Docker 使用 C/S 体系的架构</p><p>Docker 客户端与 Docker 守护进程通信</p><p>Docker 守护进程负责构建，运行和分发 Docker 容器。</p><p>Docker 客户端和守护进程可以在同一个系统上运行，也可以将 Docker 客户端连接到远程 Docker 守护进程。</p><p>Docker 客户端和守护进程使用 REST API 通过UNIX套接字或网络接口进行通信。</p><h2 id="三、docker安装"><a href="#三、docker安装" class="headerlink" title="三、docker安装"></a>三、docker安装</h2><p><strong>注意：如果安装方法无法就上网查</strong></p><p>ubuntu：<code>sudo apt install docker-ce -y</code></p><p>如果安装不成功：</p><p><code>curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</code></p><p><code>sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \ $(lsb_release -cs) stable&quot;</code></p><p><code>sudo apt install docker-ce -y</code></p><p>centos:  <code>yum install docker-ce docker-ce-cli containerd.io</code></p><p>启动：<code>systemctl start docker</code></p><p>重启：<code>systemctl restart docker</code></p><p>停止：<code>systemctl stop docker</code></p><p>开机自动启动：<code>systemctl enable docker</code></p><p>关闭自动启动：<code>systemctl disable docker</code></p><p>修改docker镜像源：</p><p><code>echo &#39;{&quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]}&#39; &gt; /etc/docker/daemon.json</code></p><p>配置docker免sudo：</p><p><code>sudo usermod -aG docker $USER</code></p><p><code>sudo systemctl restart docker</code></p><p><strong>备注：有的系统会无效，自行上网搜索解决方法</strong></p><h1 id="第二章-docker基础管理"><a href="#第二章-docker基础管理" class="headerlink" title="第二章 docker基础管理"></a>第二章 docker基础管理</h1><h2 id="一、镜像管理"><a href="#一、镜像管理" class="headerlink" title="一、镜像管理"></a>一、镜像管理</h2><p>查找镜像：</p><blockquote><p>docker search 镜像名</p></blockquote><p>下载镜像：</p><blockquote><p>docker pull 镜像名</p></blockquote><p>从本地安装镜像:</p><blockquote><p>docker image  load -i 镜像包</p><p>简写：docker load -i 镜像包 或者 docker load &lt; 镜像包</p></blockquote><p>删除本地镜像:</p><blockquote><p>docker image rm 镜像ID  或者 镜像名称<br>简写：docker rmi image_id</p></blockquote><p>删除全部镜像:</p><blockquote><p>docker rmi $(docker images -q)</p></blockquote><p>镜像历史:</p><blockquote><p>docker history image_id</p></blockquote><p>标签:</p><blockquote><p>docker tag old_image:old_version new_image:new_version</p></blockquote><p>制作镜像：</p><blockquote><p>docker commit -a ‘作者’ -m ‘描述’   容器ID   新镜像名:版本</p></blockquote><p>打包导出:</p><blockquote><p>docker image save -o 镜像包.tar.gz 镜像:版本     # 保存到当前目录下<br>简写：docker save -o 镜像包.tar.gz 镜像</p></blockquote><h2 id="二、容器管理"><a href="#二、容器管理" class="headerlink" title="二、容器管理"></a>二、容器管理</h2><p>查看正在运行的容器：</p><blockquote><p>docker container ls</p><p>简写：docker ps</p></blockquote><p>查看所有容器</p><blockquote><p>docker container ls -a</p><p>简写：docker ps -a</p></blockquote><p>关闭/启动/重启：</p><blockquote><p>docker container stop | start | restart 容器ID</p></blockquote><p>停止所有容器：</p><blockquote><p>docker stop $(docker ps -a -q)</p></blockquote><p>删掉容器：</p><blockquote><p>docker container rm 容器ID<br>简写：docker rm 容器ID</p></blockquote><p>删除全部容器：</p><blockquote><p>docker rm $(docker ps -a -q)</p></blockquote><p>强制删除容器：</p><blockquote><p>docker  container rm -f 容器ID<br>简写：docker rm -f 容器ID</p></blockquote><p>查看容器运行日志：</p><blockquote><p>docker  logs 容器ID</p></blockquote><p>创建新容器并运行容器：</p><blockquote><p>docker run -itd 镜像名:版本</p></blockquote><p>交互式容器（登录容器）:</p><blockquote><p>docker  exec -it  ID /bin/bash</p></blockquote><h2 id="三、数据管理"><a href="#三、数据管理" class="headerlink" title="三、数据管理"></a>三、数据管理</h2><p>数据卷（映射目录）：（重要）</p><blockquote><p>docker run -itd -v [宿主机文件]:[容器文件] [镜像id/镜像名]</p></blockquote><p><strong>注意：-v 宿主机文件:容器文件 可以存在多个，表示同时挂载多个</strong></p><p><strong>宿主机文件尽量用绝对路径，容器文件即使不存在，Docker自动创建</strong></p><h2 id="四、网络管理"><a href="#四、网络管理" class="headerlink" title="四、网络管理"></a>四、网络管理</h2><p>端口映射(随机)       网络模式默认为bridge模式</p><blockquote><p>docker run -itd –name 别名 -P image_id     # -P  大写P</p></blockquote><p>端口映射（指定）  网络模式默认为bridge模式</p><blockquote><p>docker run -itd –name 别名 -p 8080:80 image_id     # -p 小写p</p></blockquote><p>host模式</p><blockquote><p>docker run -itd –name 别名 –netword=host image_id</p></blockquote><h1 id="第三章-Dockerfile"><a href="#第三章-Dockerfile" class="headerlink" title="第三章 Dockerfile"></a>第三章 Dockerfile</h1><p>Dockerfile简而言之就是 编写Dockerfile脚本实现自动化构建自己想要的镜像</p><p><strong>使用准则</strong></p><p>1、大： 首字母必须大写D</p><p>2、空： 尽量将Dockerfile放在空目录中。</p><p>3、单： 每个容器尽量只有一个功能。</p><p>4、少： 执行的命令越少越好。</p><p><strong>基础指令</strong></p><ul><li><code>FROM</code>: 指定基础镜像（镜像要已存在）</li><li><code>MAINTAINER</code>: 维护者信息（姓名/邮箱）</li><li><code>RUN</code>: 镜像操作指令</li><li><code>ADD：</code>上传文件，一般用于上传压缩包，会自动解压压缩包</li><li><code>COPY：</code>上传一般文件</li><li><code>EXPOSE：</code>开放端口</li><li><code>WORKDIR：</code>切换目录</li><li><code>ENTRYPOINT</code>: 容器启动时执行指令</li></ul><p>构建镜像：</p><blockquote><p>cd 到Dockerfile所在的目录</p><p>docker build -t 新镜像名:版本 ./</p></blockquote><p>执行完后会生成一个新的镜像</p><pre><code class="dockerfile"># 选择基础镜像FROM centos:latest# 作者MAINTAINER caijinbo# shell指令安装软件RUN yum install -y nginx python3-devel net-tools openssh-server openssh-clients passwd gcc mariadb-devel# 把工程上传到容器ADD front_end_pc.tar.gz /data/ADD project_admin.tar.gz /data/ADD project.tar.gz /data/COPY requirements.txt /data/# 切换到工程目录，并安装依赖WORKDIR /data/project/RUN pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple --no-cache-dir --default-timeout=1000 -r /data/requirements.txtCOPY 8000.conf /etc/nginx/conf.d/COPY 8080.conf /etc/nginx/conf.d/COPY 8081.conf /etc/nginx/conf.d/# 设置环境变量，作用：指定系统语言为UTF-8，否则，uwsgi运行无法处理中文语言# ENV LC_ALL=zh_CN.UTF-8# 容器开放端口8080和8081EXPOSE 8080 8081# 发送容器启动脚本COPY command.sh /data/# 切换容器目录WORKDIR /data# 指定容器运行的启动脚本ENTRYPOINT [&quot;/bin/bash&quot;,&quot;/data/command.sh&quot;]</code></pre><p>在Dockerfile同级目录下新建一个脚本</p><p>vim command.sh</p><pre><code class="shell">cd /data/project/ uwsgi --ini uwsgi.ini nginx -g &#39;daemon off;&#39; </code></pre><p><strong>注意:所有要操作的文件或压缩包均放在Dockerfile同级目录下</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;docker基础知识&quot;&gt;&lt;a href=&quot;#docker基础知识&quot; class=&quot;headerlink&quot; title=&quot;docker基础知识&quot;&gt;&lt;/a&gt;docker基础知识&lt;/h1&gt;&lt;h1 id=&quot;第一章docker基础知识&quot;&gt;&lt;a href=&quot;#第一章docker基础知识&quot; class=&quot;headerlink&quot; title=&quot;第一章docker基础知识&quot;&gt;&lt;/a&gt;第一章docker基础知识&lt;/h1&gt;&lt;h2 id=&quot;一、docker简介&quot;&gt;&lt;a href=&quot;#一、docker简介&quot; class=&quot;headerlink&quot; title=&quot;一、docker简介&quot;&gt;&lt;/a&gt;一、docker简介&lt;/h2&gt;&lt;p&gt;Docker是一个开源的&lt;strong&gt;容器引擎&lt;/strong&gt;，它基于LXC容器技术，使用Go语言开发。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://caijinbo.work/categories/linux/"/>
    
    
      <category term="linux" scheme="https://caijinbo.work/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Django框架基础</title>
    <link href="https://caijinbo.work/2020/09/21/2020-09-22-Django%20%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/"/>
    <id>https://caijinbo.work/2020/09/21/2020-09-22-Django%20%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/</id>
    <published>2020-09-21T16:00:00.000Z</published>
    <updated>2020-11-23T10:14:00.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Django-框架基础"><a href="#Django-框架基础" class="headerlink" title="Django 框架基础"></a>Django 框架基础</h1><h2 id="一、Django工程搭建"><a href="#一、Django工程搭建" class="headerlink" title="一、Django工程搭建"></a>一、Django工程搭建</h2><h3 id="1-web本质和意义"><a href="#1-web本质和意义" class="headerlink" title="1.web本质和意义"></a>1.web本质和意义</h3><a id="more"></a><h4 id="1-1-web应用程序处理流程"><a href="#1-1-web应用程序处理流程" class="headerlink" title="1.1 web应用程序处理流程"></a>1.1 web应用程序处理流程</h4><p>前端客户端(浏览器、APP、ajax、爬虫程序) </p><p>–HTTP请求–&gt;</p><p>服务器程序（如：gunicorn、uwsgi）接收和解析HTTP请求报文</p><p>–WSGI协议–&gt;</p><p>框架程序（如：flask、Django）HTTP请求对象(request)–&gt;中间层处理–&gt;具体视图处理-业务处理(如数据库、模板、表单)–&gt;中间层处理–&gt;HTTP响应对象(response)</p><p>–WSGI协议–&gt;</p><p>服务器程序（如：gunicorn、uwsgi）构建和返回HTTP响应报文</p><p>–HTTP响应–&gt;</p><p>前端客户端(浏览器、APP、ajax、爬虫程序) </p><h4 id="1-2-Web应用程序的本质"><a href="#1-2-Web应用程序的本质" class="headerlink" title="1.2  Web应用程序的本质"></a>1.2  Web应用程序的本质</h4><ul><li>接收并解析HTTP请求，获取具体的请求信息</li><li>处理本次HTTP请求，即完成本次请求的业务逻辑处理</li><li>构造并返回处理结果——HTTP响应</li></ul><h4 id="1-3-Web程序框架的意义"><a href="#1-3-Web程序框架的意义" class="headerlink" title="1.3  Web程序框架的意义"></a>1.3  Web程序框架的意义</h4><ul><li>用于搭建Web应用程序</li><li>免去不同Web应用相同代码部分的重复编写，只需关心Web应用核心的业务逻辑实现</li></ul><h3 id="2-Django框架介绍"><a href="#2-Django框架介绍" class="headerlink" title="2.Django框架介绍"></a>2.Django框架介绍</h3><h4 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h4><ul><li>Django <strong>发音[`dʒæŋɡəʊ]</strong>，是用python语言写的开源web开发框架，并遵循MVC设计模式。</li><li><strong>Django的主要目的是简便、快速的开发数据库驱动的网站。</strong></li></ul><h4 id="2-2-特点"><a href="#2-2-特点" class="headerlink" title="2.2 特点"></a>2.2 特点</h4><blockquote><p><strong>1. 重量级框架</strong></p></blockquote><ul><li>Django框架相比较于Python其他的Web框架而言是<strong>大而全</strong>的。</li><li>Django提供了原生的众多功能组件，让开发更简便快速。</li><li>提供项目工程管理的自动化脚本工具。</li><li>支持ORM以面向对象的形式操作数据库。（Object Relational Mapping）</li><li>提供了强大的模板引擎，用于渲染页面。</li><li>提供了文件管理、认证权限、session机制和缓存。</li></ul><blockquote><p><strong>2. 遵守MVT设计模式</strong></p></blockquote><h5 id="MVC设计模式说明"><a href="#MVC设计模式说明" class="headerlink" title="MVC设计模式说明"></a>MVC设计模式说明</h5><ul><li><strong>MVC</strong> 的全拼为 <strong>Model-View-Controller</strong></li><li><strong>M</strong> 全拼为 <strong>Model</strong>，主要封装对数据库层的访问，对数据库中的数据进行增、删、改、查操作。</li><li><strong>V</strong> 全拼为 <strong>View</strong>，用于封装结果，生成页面展示的html内容。</li><li><strong>C</strong> 全拼为 <strong>Controller</strong>，用于接收请求，处理业务逻辑，与Model和View交互，返回结果。</li><li><strong>MVC 的核心思想是分工、解耦，让不同的代码块之间降低耦合，增强代码的可扩展性和可移植性，实现向后兼容</strong>。</li></ul><h5 id="Django的MVT设计模式说明"><a href="#Django的MVT设计模式说明" class="headerlink" title="Django的MVT设计模式说明"></a>Django的MVT设计模式说明</h5><ul><li><strong>MVT</strong> 的全拼为 <strong>Model-View-Template</strong></li><li><strong>M</strong> 全拼为 <strong>Model</strong>，与MVC中的M功能相同，负责和数据库交互，进行数据处理。</li><li><strong>V</strong> 全拼为 <strong>View</strong>，与MVC中的C功能相同，接收请求，进行业务处理，返回应答。</li><li><strong>T</strong> 全拼为 <strong>Template</strong>，与MVC中的V功能相同，负责封装构造要返回的html。</li><li><strong>MVT 的核心思想和 MVC 是相同的</strong></li></ul><h3 id="3-虚拟环境"><a href="#3-虚拟环境" class="headerlink" title="3.虚拟环境"></a>3.虚拟环境</h3><h4 id="3-1-为什么要创建虚拟环境"><a href="#3-1-为什么要创建虚拟环境" class="headerlink" title="3.1 为什么要创建虚拟环境"></a>3.1 为什么要创建虚拟环境</h4><ul><li><p>在开发过程中, 当需要使用python的某些工具包/框架时需要联网安装</p><ul><li><p>比如联网安装Django框架 django==2.2.16 版本</p><pre><code>sudo pip install django==2.2.16</code></pre></li></ul></li><li><p><strong>提示</strong>：使用如上命令, 会将<code>django==2.2.16</code>安装到<code>/usr/local/lib/python版本/dist-packages</code>路径下</p></li><li><p><strong>问题</strong> : 如果在一台电脑上, 想开发多个不同的项目, 需要用到同一个包的不同版本, 如果使用上面的命令, 在同一个目录下安装或者更新, 新版本会覆盖以前的版本, 其它的项目就无法运行了。</p></li><li><p>解决方案:   <code>虚拟环境</code></p><ul><li><strong>作用</strong> : <code>虚拟环境</code>可以搭建独立的<code>python运行环境</code>, 使得单个项目的运行环境与其它项目互不影响.</li><li>所有的<code>虚拟环境</code>都位于<code>/home/</code>下的隐藏目录<code>.virtualenvs</code>下</li></ul></li></ul><h4 id="3-2-如何创建虚拟环境"><a href="#3-2-如何创建虚拟环境" class="headerlink" title="3.2 如何创建虚拟环境"></a>3.2 如何创建虚拟环境</h4><ul><li><p>安装虚拟环境的命令 :</p><pre><code class="bash">sudo pip install virtualenvsudo pip install virtualenvwrapper</code></pre></li><li><p>创建虚拟环境的命令 :</p><ul><li>提示：如果不指定python版本，虚拟环境就会使用默认的python版本</li></ul><p>例如：</p><ul><li><p>使用默认的python创建虚拟环境</p><pre><code class="bash">mkvirtualenv 虚拟环境名称例 ：mkvirtualenv py_django</code></pre></li></ul></li></ul><ul><li><p>指定python版本创建虚拟环境</p><pre><code class="bash">mkvirtualenv -p python3 虚拟环境名称例 ：mkvirtualenv -p python3 py_django  # 使用的是默认的python3版本mkvirtualenv -p python3.5 py_django  # 使用的是python3.5版本，注意，所使用的python版本在本机已经安装才行</code></pre><p>提示 :</p><ul><li>创建虚拟环境需要联网</li><li>创建成功后, 会自动工作在这个虚拟环境上</li><li>工作在虚拟环境上, 提示符最前面会出现 “虚拟环境名称”</li></ul></li></ul><h4 id="3-3-如何使用虚拟环境"><a href="#3-3-如何使用虚拟环境" class="headerlink" title="3.3 如何使用虚拟环境"></a>3.3 如何使用虚拟环境</h4><p>查看所有虚拟环境的命令 :</p><pre><code class="bash">  workon 两次tab键</code></pre><p>使用虚拟环境的命令 :</p><pre><code class="bash">  workon 虚拟环境名称  例：  workon py_django</code></pre><p>退出虚拟环境的命令 :</p><pre><code>  deactivate</code></pre><p> 删除虚拟环境的命令 :</p><pre><code class="bash">  rmvirtualenv 虚拟环境名称  先退出：deactivate  再删除：rmvirtualenv 虚拟环境名称</code></pre><h4 id="3-4-如何在虚拟环境中安装工具包"><a href="#3-4-如何在虚拟环境中安装工具包" class="headerlink" title="3.4 如何在虚拟环境中安装工具包"></a>3.4 如何在虚拟环境中安装工具包</h4><ul><li><p>虚拟环境中安装框架、包命令 :</p><pre><code class="shell">  pip install 框架、包名称  例 : 安装`django==2.2.16`  pip install django==2.2.16</code></pre></li><li><p>框架、包安装的位置 :</p><ul><li><code>~/.virtualenvs/虚拟环境名称/lib/python版本/site-packages</code></li></ul></li><li><p>查看虚拟环境中安装的包 :</p><pre><code class="shell">pip freeze 或者 pip list</code></pre></li></ul><h4 id="3-5-特别提示"><a href="#3-5-特别提示" class="headerlink" title="3.5 特别提示"></a>3.5 特别提示</h4><blockquote><ul><li>在虚拟环境中，直接使用 <code>pip install</code> 安装Django框架或者扩展包时，速度特别慢，甚至报红色警告。</li><li>这主要是因为Django框架和很多的扩展包都是从国外服务器进行下载安装的。</li></ul></blockquote><p><strong>指定镜像源：加速下载安装Django框架或者扩展包</strong></p><p><strong><code>pip install django==2.2.16 -i https://pypi.tuna.tsinghua.edu.cn/simple/</code></strong></p><p>如果还是下载安装比较慢，可以把上面的镜像源链接换为下面的任意一个：</p><pre><code class="http">https://mirrors.aliyun.com/pypi/simple/http://pypi.douban.com/simple/http://pypi.mirrors.ustc.edu.cn/simple/</code></pre><h3 id="4-Django工程创建"><a href="#4-Django工程创建" class="headerlink" title="4.Django工程创建"></a>4.Django工程创建</h3><h4 id="4-1-创建工程"><a href="#4-1-创建工程" class="headerlink" title="4.1 创建工程"></a>4.1 创建工程</h4><p>创建工程的命令为：</p><pre><code class="shell">django-admin startproject 工程名称例子：cd ~/Desktop/django-admin startproject Django_test</code></pre><p>执行后，会多出一个新目录名为 <strong>Django_test</strong>，此即为新创建的工程目录。</p><h4 id="4-2-工程目录说明"><a href="#4-2-工程目录说明" class="headerlink" title="4.2 工程目录说明"></a>4.2 工程目录说明</h4><ul><li>与项目同名的目录，此处为 <strong>Django_test</strong>。</li><li><strong>settings.py</strong> 是项目的整体配置文件。</li><li><strong>urls.py</strong> 是项目的URL配置文件。</li><li><strong>wsgi.py</strong> 是项目与WSGI兼容的Web服务器入口。</li><li><strong>manage.py</strong> 是项目管理文件，通过它管理项目。</li></ul><h4 id="4-3-运行开发服务器"><a href="#4-3-运行开发服务器" class="headerlink" title="4.3 运行开发服务器"></a>4.3 运行开发服务器</h4><p>在开发阶段，为了能够快速预览到开发的效果，django提供了一个纯python编写的轻量级web服务器，仅在开发阶段使用。</p><p>运行服务器命令如下：</p><pre><code class="shell">python manage.py runserver ip:端口例：python manage.py runserver 127.0.0.1:9000或：python manage.py runserver    # 可以不写IP和端口，默认IP是127.0.0.1，默认端口为8000。</code></pre><p>在浏览器中输入网址“127.0.0.1:8000”便可看到效果。</p><ul><li>django默认工作在调式Debug模式下，如果增加、修改、删除文件，服务器会自动重启。</li></ul><h3 id="5-Django工程配置"><a href="#5-Django工程配置" class="headerlink" title="5. Django工程配置"></a>5. Django工程配置</h3><p>提示：</p><ul><li>工程的配置文件是 <strong>settings.py</strong></li><li>以下内容仅仅是测试Django工程修改配置文件后的效果</li></ul><h4 id="5-1-BASE-DIR"><a href="#5-1-BASE-DIR" class="headerlink" title="5.1 BASE_DIR"></a>5.1 BASE_DIR</h4><pre><code class="python">BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</code></pre><p>当前工程的根目录，Django会依此来定位工程内的相关文件，我们也可以使用该参数来构造文件路径。</p><h4 id="5-2-DEBUG"><a href="#5-2-DEBUG" class="headerlink" title="5.2 DEBUG"></a>5.2 DEBUG</h4><p>调试模式，创建工程后初始值为<strong>True</strong>，即默认工作在调试模式下。</p><p>作用：</p><ul><li>修改代码文件，程序自动重启</li></ul><p><strong>注意：部署线上运行的Django不要运行在调式模式下，记得修改DEBUG=False。</strong></p><h4 id="5-3-本地语言与时区"><a href="#5-3-本地语言与时区" class="headerlink" title="5.3 本地语言与时区"></a>5.3 本地语言与时区</h4><p>Django支持本地化处理，即显示语言与时区支持本地化。</p><p>本地化是将显示的语言、时间等使用本地的习惯，这里的本地化就是进行中国化，中国大陆地区使用<strong>简体中文</strong>，时区使用<strong>亚洲/上海</strong>时区，注意这里不使用北京时区表示。</p><p>初始化的工程默认语言和时区为英语和UTC标准时区</p><pre><code class="python">LANGUAGE_CODE = &#39;en-us&#39; # 语言：英语TIME_ZONE = &#39;UTC&#39; # UTC标准时区</code></pre><p>将语言和时区修改为中国大陆信息</p><pre><code class="python">LANGUAGE_CODE = &#39;zh-hans&#39; # 语言：简体中文TIME_ZONE = &#39;Asia/Shanghai&#39; # 亚洲上海</code></pre><h3 id="6-Django子应用"><a href="#6-Django子应用" class="headerlink" title="6. Django子应用"></a>6. Django子应用</h3><p>提示：</p><ul><li>在Web应用中，通常有一些业务功能模块是可以在不同的项目中复用的。</li><li>所以，在开发中通常将项目工程拆分为不同的子功能模块。</li><li>而且各功能模块间保持了相对的独立，在其他项目中需要用到某个特定功能模块时，可以将该模块代码整体复制过去，达到复用。</li></ul><h4 id="6-1-创建子应用"><a href="#6-1-创建子应用" class="headerlink" title="6.1 创建子应用"></a>6.1 创建子应用</h4><p>在Django中，创建子应用仍然可以通过命令来操作，即：</p><pre><code class="shell">cd 项目工程django-admin startapp 子应用名称(推荐)或者python manage.py startapp 子应用名称</code></pre><ul><li>例如：<ul><li>在上一步创建的 <strong>Django_test</strong> 工程中，创建一个专门管理 <strong>用户模块</strong> 的子应用</li><li>如果管理 <strong>用户模块</strong> 的子应用名称设计为 <strong>users</strong>，则命令为：</li></ul></li></ul><pre><code class="shell">cd ~/Desktop/Django_test/django-admin startapp users或者python manage.py startapp users</code></pre><h4 id="6-2-子应用目录说明"><a href="#6-2-子应用目录说明" class="headerlink" title="6.2 子应用目录说明"></a>6.2 子应用目录说明</h4><ul><li><strong>admin.py</strong> 文件跟网站的后台管理站点配置相关。</li><li><strong>apps.py</strong> 文件用于配置当前子应用的相关信息。</li><li><strong>migrations</strong> 目录用于存放数据库迁移历史文件。</li><li><strong>models.py</strong> 文件用户保存数据库模型类。</li><li><strong>tests.py</strong> 文件用于开发测试用例，编写单元测试。</li><li><strong>views.py</strong> 文件用于编写Web应用视图。</li></ul><h4 id="6-3-注册子应用"><a href="#6-3-注册子应用" class="headerlink" title="6.3 注册子应用"></a>6.3 注册子应用</h4><p>创建出来的子应用目录文件虽然被放到了工程项目目录中，但是django工程并不能立即直接使用该子应用，需要注册安装后才能使用。</p><p>在工程配置文件settings.py中，<strong>INSTALLED_APPS</strong>项保存了工程中已经注册安装的子应用，初始工程中的INSTALLED_APPS如下：</p><p><strong>注册安装一个子应用的方法，即是将子应用的配置信息文件apps.py中的Config类添加到INSTALLED_APPS列表中。</strong></p><pre><code class="python">INSTALLED_APPS = [    &#39;django.contrib.admin&#39;,    &#39;django.contrib.auth&#39;,    &#39;django.contrib.contenttypes&#39;,    &#39;django.contrib.sessions&#39;,    &#39;django.contrib.messages&#39;,    &#39;django.contrib.staticfiles&#39;,    &#39;users&#39;, # 用户模块子应用]</code></pre><h2 id="二、视图（views）"><a href="#二、视图（views）" class="headerlink" title="二、视图（views）"></a>二、视图（views）</h2><p><strong>经验值分享</strong></p><ol><li><strong>请求对象的</strong>user属性</li></ol><p>参考知识点：<strong>请求HttpRequest</strong></p><ul><li>提示：<ul><li>请求对象的user属性返回的是<strong>请求过程中认证出来的用户对象</strong></li></ul></li><li>使用方式：<ul><li><code>user = request.user</code></li></ul></li><li>使用场景：<ul><li>从请求中获取当前登录用户对象信息</li></ul></li><li>注意点：<ul><li><strong><code>request.user</code></strong>获取到的不一定是当前登录用户对象</li><li>如果当前请求是已登录用户发送的，那么<strong><code>request.user</code></strong>获取到的才是当前登录用户对象</li><li>如果当前请求是未登录用户发送的，那么<strong><code>request.user</code></strong>获取到的会是一个AnonymousUser对象（匿名用户，没有任何用户信息，没有使用价值）。</li></ul></li><li>工作中如何使用<code>request.user</code>？<ul><li><strong><code>request.user</code></strong>需要搭配用户访问的限制来使用。</li><li>需要先判断用户是否已登录，如果用户已登录，就可以大胆放心的使用<strong><code>request.user</code></strong>。</li></ul></li></ul><ol start="2"><li><strong>自定义中间件注册原则</strong></li></ol><p>参考知识点：<strong>中间件Middleware</strong></p><ul><li>提示：多个中间件执行的顺序是有规律的</li></ul><pre><code class="python">多个中间件注册顺序：MIDDLEWARE = [    &#39;Middleware1&#39;,    &#39;Middleware2&#39;,    &#39;Middleware3&#39;,]请求时：按照顺序由上而下进入中间件    [1 ---&gt; 2 ---&gt; 3]响应时：先进入的中间件后执行完的    [3 ---&gt; 2 ---&gt; 1]经验：    中间件中请求优先的逻辑，中间件一定要放在最前注册    中间件中响应优先的逻辑，中间件一定要放在最后注册例子：    解决前后端分离时请求跨域的问题    每个请求都要解决跨域的问题，所以需要用到中间件    而且需要在请求处理时最先处理跨域的问题，所以解决请求跨域时的中间件需要最先注册</code></pre><h3 id="1-函数视图"><a href="#1-函数视图" class="headerlink" title="1.函数视图"></a>1.函数视图</h3><h4 id="1-1-定义函数视图"><a href="#1-1-定义函数视图" class="headerlink" title="1.1 定义函数视图"></a>1.1 定义函数视图</h4><blockquote><p><strong>函数视图定义方式：</strong></p></blockquote><pre><code class="python">1. 函数视图它是一个标准的Python函数。2. 函数视图中，第一个参数必须定义：第一个参数为请求对象，用于接收用户发送的请求报文。3. 函数视图中，必须返回响应对象：用于构造响应报文，并响应给用户。4. 说明：    请求对象：HttpRequest() 对应的对象    响应对象：HttpResponse() 对应的对象from django.shortcuts import renderfrom django import http# Create your views here.def register(request):    &quot;&quot;&quot;    用户注册函数视图    :param request: 请求对象，包含了请求报文信息    :return: 响应对象，用于构造响应报文，并响应给用户    &quot;&quot;&quot;    # 响应数据    return http.HttpResponse(&#39;这里假装返回注册页面&#39;)</code></pre><h4 id="1-2-访问函数视图"><a href="#1-2-访问函数视图" class="headerlink" title="1.2 访问函数视图"></a>1.2 访问函数视图</h4><blockquote><p><strong>提示：</strong></p></blockquote><ul><li>我们定义好的函数视图，需要用户能够访问到。</li><li>用户如何访问函数视图？<ul><li><strong>通过网络地址向Django程序发请求，即可访问到函数视图</strong></li></ul></li></ul><blockquote><p><strong>问题：</strong></p></blockquote><ul><li>如何保证用户发送的请求，能够访问到对应的函数视图？</li></ul><blockquote><p><strong>解决：</strong></p></blockquote><ul><li><strong>路由：使用路由匹配请求地址，每匹配成功一个就执行对应的函数视图逻辑</strong></li><li><strong>定义路由的方法：path()、re_path()、url()</strong></li></ul><blockquote><p><strong>需求：</strong></p></blockquote><ul><li>用户通过网络地址<strong><code>http://127.0.0.1:8000/users/register/</code></strong>访问用户注册视图</li></ul><h4 id="1-3-访问函数视图：需求实现-–-gt-path"><a href="#1-3-访问函数视图：需求实现-–-gt-path" class="headerlink" title="1.3 访问函数视图：需求实现 –&gt; path()"></a>1.3 访问函数视图：需求实现 –&gt; path()</h4><blockquote><p><strong>1. 新建子路由文件</strong></p><ul><li>在<strong><code>子应用</code></strong>中新建一个<strong><code>urls.py</code></strong>文件用于定义该应用的所有路由信息</li></ul></blockquote><blockquote><p><strong>2. 注册子路由</strong></p><ul><li>在<strong><code>子应用/urls.py</code></strong>文件中定义路由信息</li></ul></blockquote><pre><code class="python">from django.urls import pathfrom . import views# urlpatterns是被Django自动识别的路由列表变量：定义该应用的所有路由信息urlpatterns = [    # 函数视图路由语法：    # path(&#39;网络地址正则表达式&#39;, 函数视图名),    # 用户注册：http://127.0.0.1:8000/users/register/    path(&#39;users/register/&#39;, views.register),]</code></pre><blockquote><p><strong>3. 注册总路由</strong></p><ul><li>在工程总路由<strong><code>工程同名目录/urls.py</code></strong>中包含子应用的路由数据</li></ul></blockquote><pre><code class="python">from django.contrib import adminfrom django.urls import path, includeurlpatterns = [    # 自带的后台管理系统的总路由：可以忽略    path(&#39;admin/&#39;, admin.site.urls),    # 总路由包含子路由语法    # path(&#39;网络地址前缀/&#39;, include(&#39;子应用.urls&#39;)),    # 或者    # path(&#39;&#39;, include(&#39;子应用.urls&#39;)),    # 用户模块：http://127.0.0.1:8000/users/register/    path(&#39;&#39;, include(&#39;users.urls&#39;)),]</code></pre><blockquote><p>总路由说明：</p></blockquote><ul><li>一个子应用对应一个总路由。</li><li>总路由中，使用<strong><code>include()</code></strong>来将<strong><code>users子应用</code></strong>里的所有路由都包含进工程总路由中。</li></ul><blockquote><p><strong>4. 启动运行测试</strong></p></blockquote><p>重新启动django程序</p><pre><code class="shell">python manage.py runserver</code></pre><p>使用postman进行请求测试： <strong><code>http://127.0.0.1:8000/users/register/</code></strong></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="2-类视图"><a href="#2-类视图" class="headerlink" title="2.类视图"></a>2.类视图</h3><h4 id="2-1-函数视图问题说明-不推荐使用函数视图"><a href="#2-1-函数视图问题说明-不推荐使用函数视图" class="headerlink" title="2.1 函数视图问题说明(不推荐使用函数视图)"></a>2.1 函数视图问题说明(不推荐使用函数视图)</h4><pre><code class="python"># GET http://127.0.0.1:8000/users/register/def register(request):    &quot;&quot;&quot;    用户注册函数视图    :param request: 请求对象，包含了请求报文信息    :return: 响应对象，用于构造响应报文，并响应给用户    &quot;&quot;&quot;    # 响应数据    return http.HttpResponse(&#39;这里假装返回注册页面&#39;)</code></pre><blockquote><p><strong>需求：</strong></p></blockquote><ul><li>用户向地址<strong><code>http://127.0.0.1:8000/users/register/</code></strong>发送GET请求，用来获取注册页面。</li><li>用户向地址<strong><code>http://127.0.0.1:8000/users/register/</code></strong>发送POST请求，用来实现注册逻辑。</li></ul><blockquote><p><strong>需求实现：</strong></p></blockquote><pre><code class="python">def register(request):    &quot;&quot;&quot;    用户注册函数视图    :param request: 请求对象，包含了请求报文信息    :return: 响应对象，用于构造响应报文，并响应给用户    &quot;&quot;&quot;    # 获取请求方法，判断是GET还是POST请求    if request.method == &#39;GET&#39;:        # 处理GET请求，返回注册页面        return HttpResponse(&#39;这里假装返回注册页面&#39;)    else:        # 处理POST请求，实现注册逻辑        return HttpResponse(&#39;这里假装实现注册逻辑&#39;)</code></pre><blockquote><p><strong>函数视图问题说明：</strong></p></blockquote><ul><li>当遇到视图对应的同一个路径，提供了多种不同HTTP请求方式的支持时，便需要在一个函数中编写不同的业务逻辑，代码可读性与复用性都很差。</li></ul><blockquote><p><strong>解决方案：</strong></p></blockquote><ul><li><strong>类视图</strong></li></ul><h4 id="2-2-定义类视图"><a href="#2-2-定义类视图" class="headerlink" title="2.2 定义类视图"></a>2.2 定义类视图</h4><blockquote><p><strong>类视图定义方式：</strong></p></blockquote><pre><code class="python">1. 类视图它是一个标准的Python类。2. 类视图需要继承自Django提供的父类视图View。3. 在类视图中，    3.1 需要定义跟请求方法同名的函数来对应不同请求方式    3.2 在请求方法同名的函数中，还必须定义一个接收请求的参数（同函数视图）    3.3 在请求方法同名的函数中，还必须返回一个响应对象（同函数视图）from django.views import Viewclass RegisterView(View):    &quot;&quot;&quot;用户注册类视图    http://127.0.0.1:8000/users/register/    &quot;&quot;&quot;    def get(self, request):        &quot;&quot;&quot;        处理GET请求，返回注册页面        :param request: 请求对象，包含了请求报文信息        :return: 响应对象，用于构造响应报文，并响应给用户        &quot;&quot;&quot;        return http.HttpResponse(&#39;这里假装返回注册页面&#39;)    def post(self, request):        &quot;&quot;&quot;        处理POST请求，实现注册逻辑        :param request: 请求对象，包含了请求报文信息        :return: 响应对象，用于构造响应报文，并响应给用户        &quot;&quot;&quot;        return http.HttpResponse(&#39;这里假装实现注册逻辑&#39;)</code></pre><blockquote><p><strong>类视图的好处：</strong></p><ul><li><strong>代码可读性好</strong></li><li><strong>类视图相对于函数视图有更高的复用性</strong>， 如果其他地方需要用到某个类视图的某个特定逻辑，直接继承该类视图即可。</li></ul></blockquote><h4 id="2-3-访问类视图"><a href="#2-3-访问类视图" class="headerlink" title="2.3 访问类视图"></a>2.3 访问类视图</h4><blockquote><p><strong>说明：</strong></p></blockquote><ul><li>类视图的访问和函数视图的访问是一模一样的。</li><li><strong>类视图的访问也是使用路由匹配请求地址，每匹配成功一个就执行对应的类视图逻辑</strong></li></ul><blockquote><p><strong>需求：</strong></p></blockquote><ul><li>用户向地址<strong><code>http://127.0.0.1:8000/users/register/</code></strong>发送GET请求，用来获取注册页面。</li><li>用户向地址<strong><code>http://127.0.0.1:8000/users/register/</code></strong>发送POST请求，用来实现注册逻辑。</li></ul><h4 id="2-4-访问类视图：需求实现-–-gt-path"><a href="#2-4-访问类视图：需求实现-–-gt-path" class="headerlink" title="2.4 访问类视图：需求实现 –&gt; path()"></a>2.4 访问类视图：需求实现 –&gt; path()</h4><blockquote><p><strong>1. 注册子路由</strong></p><ul><li>在<strong><code>子应用/urls.py</code></strong>文件中定义路由信息</li><li>由于当前代码还是编写在users子应用中的，所以总路由注册过一次之后，不用再注册</li></ul></blockquote><pre><code class="python">from django.urls import pathfrom . import views# urlpatterns是被Django自动识别的路由列表变量：定义该应用的所有路由信息urlpatterns = [    # 类视图路由语法：    # path(&#39;网络地址正则表达式&#39;, 类视图.as_view()),    # 用户注册：http://127.0.0.1:8000/users/register/    path(&#39;users/register/&#39;, views.RegisterView.as_view()),]</code></pre><blockquote><p><strong>2. 启动运行测试</strong></p></blockquote><ul><li>2.1 注释CSRF中间件<ul><li><strong>Django默认开启了CSRF防护</strong>，会对非GET请求(POST, PUT, DELETE)进行CSRF防护验证，在测试时可以关闭CSRF防护机制</li><li>关闭CSRF防护机制是在<code>settings.py</code>文件中注释掉<code>CSRF中间件</code></li></ul></li></ul><pre><code class="python"># 中间件MIDDLEWARE = [    &#39;django.middleware.security.SecurityMiddleware&#39;,    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,    &#39;django.middleware.common.CommonMiddleware&#39;,    # 为保证非GET请求(POST, PUT, DELETE)可以正常接收，该中间件需要注释掉    # &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,    &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,    &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,]</code></pre><ul><li><strong>2.2 重新启动Django程序</strong></li></ul><pre><code class="shell">python manage.py runserver</code></pre><ul><li>2.3 使用postman进行请求测试： <strong><code>http://127.0.0.1:8000/users/register/</code></strong></li></ul><h4 id="2-5-as-view-底层原理（仅做了解）"><a href="#2-5-as-view-底层原理（仅做了解）" class="headerlink" title="2.5 as_view()底层原理（仅做了解）"></a>2.5 as_view()底层原理（仅做了解）</h4><pre><code class="python">class View:    &quot;&quot;&quot;    Intentionally simple parent class for all views. Only implements    dispatch-by-method and simple sanity checking.    # 为所有视图定义简单的父类，只实现了请求方法分派和简单的完整性检查。    &quot;&quot;&quot;    # 定义Django允许接收的请求方法    http_method_names = [&#39;get&#39;, &#39;post&#39;, &#39;put&#39;, &#39;patch&#39;, &#39;delete&#39;, &#39;head&#39;, &#39;options&#39;, &#39;trace&#39;]    def __init__(self, **kwargs):        &quot;&quot;&quot;        Constructor. Called in the URLconf; can contain helpful extra        keyword arguments, and other things.        # 类视图的初始化构造函数，创建类视图对象时会被调用，并可以接收额外的参数        &quot;&quot;&quot;        # Go through keyword arguments, and either save their values to our        # instance, or raise an error.        for key, value in kwargs.items():            setattr(self, key, value)    @classonlymethod    def as_view(cls, **initkwargs):        &quot;&quot;&quot;Main entry point for a request-response process.        # 请求-响应过程的主要入口点.        &quot;&quot;&quot;        for key in initkwargs:            # 遍历as_view()接收的参数            # 省略......        def view(request, *args, **kwargs):            &quot;&quot;&quot;准备一个函数视图，将来作为as_view()的返回值，并用于路由匹配&quot;&quot;&quot;            # 初始化类视图对象            self = cls(**initkwargs)            if hasattr(self, &#39;get&#39;) and not hasattr(self, &#39;head&#39;):                self.head = self.get            # 将路由中传入的参数，绑定到类视图对象中            self.setup(request, *args, **kwargs)            # 检查类视图是否完整：类视图中必须要有&#39;request&#39; attribute            if not hasattr(self, &#39;request&#39;):                raise AttributeError(                    &quot;%s instance has no &#39;request&#39; attribute. Did you override &quot;                    &quot;setup() and forget to call super()?&quot; % cls.__name__                )            # 调用请求分发的方法(最核心)：将请求分发给跟请求方法同名的函数            return self.dispatch(request, *args, **kwargs)        view.view_class = cls        view.view_initkwargs = initkwargs        # take name and docstring from class        update_wrapper(view, cls, updated=())        # and possible attributes set by decorators        # like csrf_exempt from dispatch        update_wrapper(view, cls.dispatch, assigned=())        return view    def setup(self, request, *args, **kwargs):        &quot;&quot;&quot;Initialize attributes shared by all view methods.        # 初始化所有视图方法共享的属性：将路由中传入的参数，绑定到类视图对象中        &quot;&quot;&quot;        self.request = request        self.args = args        self.kwargs = kwargs    def dispatch(self, request, *args, **kwargs):        # Try to dispatch to the right method; if a method doesn&#39;t exist,        # defer to the error handler. Also defer to the error handler if the        # request method isn&#39;t on the approved list.        # 尽量采用正确的调度方法;如果方法不存在，请遵从错误处理程序。如果请求方法不在批准的列表中，也遵从错误处理程序。        # 先判断客户端的请求方法是否在允许接收的方法列表中        if request.method.lower() in self.http_method_names:            # 如果客户端的请求方法在允许接收的方法列表中，            # 取出类视图对象中的跟请求方法同名的函数名，赋值给handler            # 比如：当前客户端发送的请求，请求方法是GET，那么，handler=get            handler = getattr(self, request.method.lower(), self.http_method_not_allowed)        else:            # 如果客户端的请求方法不在允许接收的方法列表中，遵从错误处理程序            handler = self.http_method_not_allowed        # 如果请求分发没有问题，那么就去调用该跟请求分发同名的函数        # 如果当前客户端发送的请求，请求方法是GET        # handler(request, *args, **kwargs)等价于get(request, *args, **kwargs)        # 如果handler()调用成功，那么跟请求分发同名的函数就会被调用执行        return handler(request, *args, **kwargs)    def http_method_not_allowed(self, request, *args, **kwargs):        &quot;&quot;&quot;错误处理程序：请求方法不匹配时，响应的错误信息&quot;&quot;&quot;        logger.warning(            &#39;Method Not Allowed (%s): %s&#39;, request.method, request.path,            extra={&#39;status_code&#39;: 405, &#39;request&#39;: request}        )        return HttpResponseNotAllowed(self._allowed_methods())</code></pre><h4 id="2-6-类视图添加扩展类"><a href="#2-6-类视图添加扩展类" class="headerlink" title="2.6 类视图添加扩展类"></a>2.6 类视图添加扩展类</h4><blockquote><p>提示：</p></blockquote><ul><li>使用面向对象多继承的特性，可以给类视图定义扩展类。</li><li>在扩展类中，可以定义想要向类视图补充的方法。</li><li>类视图继承这些扩展类作为父类，便可实现代码复用。</li></ul><blockquote><p>示例：</p></blockquote><pre><code class="python">class ListModelMixin(object):    &quot;&quot;&quot;list扩展类 &quot;&quot;&quot;    def list(self, request, *args, **kwargs):        passclass CreateModelMixin(object):    &quot;&quot;&quot;create扩展类 &quot;&quot;&quot;    def create(self, request, *args, **kwargs):        passclass TestMixinView(CreateModelMixin, ListModelMixin, View):    &quot;&quot;&quot;同时继承两个扩展类，复用list和create方法&quot;&quot;&quot;    def get(self, request):        self.list(request)        pass    def post(self, request):        self.create(request)        pass</code></pre><h3 id="3-路由"><a href="#3-路由" class="headerlink" title="3.路由"></a>3.路由</h3><blockquote><p><strong>提示：</strong></p></blockquote><ul><li><strong>路由可以保证用户发送的请求，能够访问到对应的视图</strong></li><li><strong>使用路由匹配请求地址，每匹配成功一个就执行对应的函数视图逻辑</strong></li><li>定义路由的方法：path()、re_path()、url()<ul><li>Django==1.x版本：url()</li><li>Django==2.x版本：path()、re_path()</li></ul></li><li>说明：<ul><li>为了在版本迭代中，保留旧版本的路由系统，url()在新版中依然可用。</li><li>并新增了一个url()的替代方案re_path()，所以url()几乎跟re_path()一样。</li></ul></li></ul><blockquote><p><strong>需求：</strong></p></blockquote><ul><li>用户通过网络地址<strong><code>http://127.0.0.1:8000/users/login/</code></strong>访问用户登录视图</li><li>我们后续演示路由，都会选择使用类视图。</li></ul><h4 id="3-1-定义用户登录类视图"><a href="#3-1-定义用户登录类视图" class="headerlink" title="3.1 定义用户登录类视图"></a>3.1 定义用户登录类视图</h4><pre><code class="python">class LoginView(View):    &quot;&quot;&quot;用户登录类视图    http://127.0.0.1:8000/users/login/    &quot;&quot;&quot;    def get(self, request):        &quot;&quot;&quot;        处理GET请求，返回登录页面        :param request: 请求对象，包含了请求报文信息        :return: 响应对象，用于构造响应报文，并响应给用户        &quot;&quot;&quot;        return http.HttpResponse(&#39;假装这是个登录页面&#39;)    def post(self, request):        &quot;&quot;&quot;        处理POST请求，实现登录逻辑        :param request: 请求对象，包含了请求报文信息        :return: 响应对象，用于构造响应报文，并响应给用户        &quot;&quot;&quot;        return http.HttpResponse(&#39;假装实现登录逻辑&#39;)</code></pre><h4 id="3-2-re-path-定义路由"><a href="#3-2-re-path-定义路由" class="headerlink" title="3.2 re_path()定义路由"></a>3.2 re_path()定义路由</h4><blockquote><p><strong>1. 注册子路由</strong></p></blockquote><pre><code class="python">from django.urls import re_path， pathurlpatterns = [    # 函数视图re_path()路由语法：    # re_path(r&#39;^网络地址正则表达式$&#39;, 函数视图名),    # 类视图re_path()路由语法：    # re_path(r&#39;^网络地址正则表达式$&#39;, 类视图.as_view()),    # 用户登录：http://127.0.0.1:8000/users/login/    re_path(r&#39;^users/login/$&#39;, views.LoginView.as_view()),    #或者使用 path(&#39;users/login/&#39;, views.LoginView.as_view()),]</code></pre><h4 id="3-3-url-定义路由"><a href="#3-3-url-定义路由" class="headerlink" title="3.3 url()定义路由"></a>3.3 url()定义路由</h4><blockquote><p><strong>1. 注册子路由</strong></p></blockquote><pre><code class="python">from django.urls import re_pathurlpatterns = [    # 函数视图url()路由语法：    # url(r&#39;^网络地址正则表达式$&#39;, 函数视图名),    # 类视图url()路由语法：    # url(r&#39;^网络地址正则表达式$&#39;, 类视图.as_view()),    # 用户登录：http://127.0.0.1:8000/users/login/    url(r&#39;^users/login/$&#39;, views.LoginView.as_view()),]</code></pre><blockquote><p><strong>2. postman进行请求测试</strong></p><ul><li>使用postman分别向<code>http://127.0.0.1:8000/users/login/</code>发送GET和POST请求</li></ul></blockquote><h4 id="3-4-路由方法对比"><a href="#3-4-路由方法对比" class="headerlink" title="3.4 路由方法对比"></a>3.4 路由方法对比</h4><blockquote><p><strong>path()</strong></p></blockquote><pre><code class="python"># 函数视图path()路由语法：# path(&#39;网络地址正则表达式&#39;, 函数视图名),# 类视图path()路由语法：# path(&#39;网络地址正则表达式&#39;, 类视图.as_view()),</code></pre><ul><li><code>path()</code>路由语法中，不需要定义正则表达式严格的开头和结尾，因为已经封装好了</li></ul><blockquote><p><strong>re_path()、url()</strong></p></blockquote><pre><code class="python"># 函数视图re_path()路由语法：# re_path(r&#39;^网络地址正则表达式$&#39;, 函数视图名),# 类视图re_path()路由语法：# re_path(r&#39;^网络地址正则表达式$&#39;, 类视图.as_view()),# 函数视图url()路由语法：# url(r&#39;^网络地址正则表达式$&#39;, 函数视图名),# 类视图url()路由语法：# url(r&#39;^网络地址正则表达式$&#39;, 类视图.as_view()),</code></pre><ul><li><code>re_path()和url()</code>路由语法中，必须要定义正则表达式严格的开头和结尾</li></ul><h4 id="3-5-路由解析顺序"><a href="#3-5-路由解析顺序" class="headerlink" title="3.5 路由解析顺序"></a>3.5 路由解析顺序</h4><ul><li>Django的总路由和子路由都是定义在<strong><code>urlpatterns</code></strong>列表中的。</li><li>Django在接收到一个请求时，从总路由文件中的<code>urlpatterns</code>列表中以由上至下的顺序查找对应路由规则。</li><li>如果发现规则在<code>include</code>中包含了，则再进入被包含的<code>urls</code>中的<code>urlpatterns</code>列表由上至下进行查询。</li></ul><blockquote><p><strong>可能存在的问题：</strong></p></blockquote><ul><li>如果网络地址正则表达式没有写完整，比如，没有写严格的开头和结尾，那么就很容易出现前面的路由屏蔽掉了后面的路由。</li></ul><blockquote><p><strong>提示：</strong></p></blockquote><ul><li><strong>该问题只会出现在使用<code>re_path()、url()</code>定义路由时出现。</strong></li><li>因为 <code>path()</code> 定义路由时，网络地址正则表达式默认就是严格的开头和结尾。</li></ul><blockquote><p><strong>例子：</strong></p></blockquote><pre><code class="python">class SayView(View):    &quot;&quot;&quot;测试路由屏蔽    http://127.0.0.1:8000/say/    &quot;&quot;&quot;    def get(self, request):        return http.HttpResponse(&#39;say&#39;)class SayHelloView(View):    &quot;&quot;&quot;测试路由屏蔽    http://127.0.0.1:8000/sayhello/    &quot;&quot;&quot;    def get(self, request):        return http.HttpResponse(&#39;say hello&#39;)# 测试路由屏蔽# http://127.0.0.1:8000/say/re_path(r&#39;^say&#39;, views.SayView.as_view()),# http://127.0.0.1:8000/sayhello/re_path(r&#39;^sayhello&#39;, views.SayHelloView.as_view()),</code></pre><blockquote><p><strong>完整的、正确的路由定义方式：</strong></p></blockquote><pre><code class="python"># 测试路由屏蔽# http://127.0.0.1:8000/say/re_path(r&#39;^say/$&#39;, views.SayView.as_view()),# # http://127.0.0.1:8000/sayhello/re_path(r&#39;^sayhello/$&#39;, views.SayHelloView.as_view()),</code></pre><h3 id="4-请求HttpRequest"><a href="#4-请求HttpRequest" class="headerlink" title="4.请求HttpRequest"></a>4.请求HttpRequest</h3><blockquote><p>提示：</p></blockquote><ul><li><strong>用户发送请求时携带的参数后端需要使用，而不同的发送参数的方式对应了不同的提取参数的方式</strong></li><li>所以要学会如何提取参数，我们就需要先了解前端传参数有哪些方式</li></ul><blockquote><p>利用HTTP协议向服务器传参有以下几种途径</p></blockquote><ul><li>查询字符串数据（query string）：<ul><li>形如：<code>?key1=value1&amp;key2=value2</code></li><li>比如：<code>http://www.meiduo.site/list/115/1/?sort=price</code>中的<strong><code>?sort=price</code></strong></li></ul></li><li>请求体数据（body）：<ul><li>比如：表单数据、json、……</li></ul></li><li>URL路径中的特定部分数据：<ul><li>比如：<code>http://www.meiduo.site/detail/2/</code>中的<strong><code>/2/</code></strong></li><li>请求地址中的该部分数据，可以在路由中使用正则表达式提取出来</li></ul></li><li>请求头数据：<ul><li>HTTP请求报文中的请求头数据（header）</li></ul></li></ul><h4 id="4-1-提取查询字符串数据"><a href="#4-1-提取查询字符串数据" class="headerlink" title="4.1 提取查询字符串数据"></a>4.1 提取查询字符串数据</h4><blockquote><p><strong>提示：</strong></p></blockquote><ul><li>获取请求路径中的查询字符串参数，形如：<strong><code>?k1=v1&amp;k2=v2</code></strong></li><li>可以通过<strong><code>request.GET</code></strong>属性获取，并返回QueryDict类型的对象</li></ul><pre><code class="python"># 注册总路由urlpatterns = [    # 用户模块：http://127.0.0.1:8000/users/register/    path(&#39;&#39;, include(&#39;users.urls&#39;)),    # 请求和响应    path(&#39;&#39;, include(&#39;request_response.urls&#39;)),]</code></pre><pre><code class="python">class QSParamView(View):    &quot;&quot;&quot;测试提取查询字符串参数    http://127.0.0.1:8000/querystring/?name=zxc&amp;age=18    &quot;&quot;&quot;    def get(self, request):        # 获取查询字符串参数name、age        name = request.GET.get(&#39;name&#39;, &#39;小明&#39;)        age = request.GET.get(&#39;age&#39;, &#39;0&#39;)        return http.HttpResponse(&#39;查询字符串参数：%s--%s&#39; % (name, age))</code></pre><pre><code class="python"># 注册子路由urlpatterns = [    # 测试提取查询字符串参数：http://127.0.0.1:8000/querystring/?name=zxc&amp;age=18    path(&#39;querystring/&#39;, views.QSParamView.as_view()),]</code></pre><blockquote><p><strong>重要提示：</strong></p></blockquote><ul><li><strong>提取查询字符串参数不区分请求方式，即使客户端进行POST方式的请求，依然可以通过request.GET获取请求中的查询字符串参数。</strong></li></ul><blockquote><p><strong><code>QueryDict</code>补充：</strong></p></blockquote><ul><li><p><strong><code>QueryDict</code></strong>是由Django自己封装的一个数据类型，继承自python的字典Dict</p></li><li><p>它被定义在<code>django.http.QueryDict</code>中</p></li><li><p>它专门用来存储请求中提取的查询字符串参数和请求体参数</p><ul><li>即，HttpRequest对象中的属性GET、POST都是QueryDict类型的数据</li></ul></li><li><p><code>QueryDict</code></p><p>的使用：</p><pre><code class="python"># 如果键不存在则返回None值，可以设置默认值进行后续处理query_dict.get(&#39;键&#39;,默认值)# 可简写为：query_dict[&#39;键&#39;]</code></pre></li></ul><h4 id="4-2-提取请求体数据"><a href="#4-2-提取请求体数据" class="headerlink" title="4.2 提取请求体数据"></a>4.2 提取请求体数据</h4><blockquote><p>提示：</p></blockquote><ul><li>可以发送请求体数据的请求方式有：<strong>POST</strong>、<strong>PUT</strong>、<strong>PATCH</strong>、<strong>DELETE</strong></li><li>请求体数据格式不固定，常见的有：<strong><code>表单类型数据和JSON字符串类型</code></strong>，我们应区别对待</li></ul><h5 id="4-2-1-表单类型请求体数据-Form-Data"><a href="#4-2-1-表单类型请求体数据-Form-Data" class="headerlink" title="4.2.1 表单类型请求体数据(Form Data)"></a>4.2.1 表单类型请求体数据(Form Data)</h5><blockquote><p>前端发送的表单类型的请求体数据，可以通过<strong><code>request.POST</code></strong>属性获取，并返回QueryDict对象。</p></blockquote><pre><code class="python"># 测试提取表单类型请求体数据：http://127.0.0.1:8000/formdata/path(&#39;formdata/&#39;, views.FormDataParamView.as_view()),class FormDataParamView(View):    &quot;&quot;&quot;测试提取表单类型请求体参数    http://127.0.0.1:8000/formdata/    &quot;&quot;&quot;    def post(self, request):        # 获取表单类型请求体参数中的username、password        username = request.POST.get(&#39;username&#39;)        password = request.POST.get(&#39;password&#39;)        return http.HttpResponse(&#39;表单类型请求体参数：%s--%s&#39; % (username, password))</code></pre><blockquote><p><strong>重要提示：</strong></p><ul><li><strong><code>request.POST</code>只能用来获取POST表单发送的请求体数据</strong></li></ul></blockquote><h5 id="4-2-2-非表单类型请求体数据-Non-Form-Data-：JSON"><a href="#4-2-2-非表单类型请求体数据-Non-Form-Data-：JSON" class="headerlink" title="4.2.2 非表单类型请求体数据(Non-Form Data)：JSON"></a>4.2.2 非表单类型请求体数据(Non-Form Data)：JSON</h5><blockquote><p>提示：</p></blockquote><ul><li>非表单类型的请求体数据，Django无法自动解析，可以通过<strong><code>request.body</code></strong>属性获取最原始的请求体数据</li><li>然后自己按照具体请求体原始数据的格式（JSON等）进行解析</li><li><strong><code>request.body</code>获取的是<code>bytes类型</code>的请求体原始数据</strong></li></ul><blockquote><p>需求：</p></blockquote><ul><li>获取请求体中的如下JSON数据</li></ul><pre><code class="json">{    &quot;username&quot;: &quot;张三&quot;,    &quot;password&quot;: &quot;123&quot;}</code></pre><p>可以进行如下方法操作：</p><pre><code class="python"># 测试提取非表单类型请求体参数：http://127.0.0.1:8000/json/path(&#39;json/&#39;, views.JSONParamView.as_view()),import jsonclass JSONParamView(View):    &quot;&quot;&quot;测试提取非表单类型请求体参数    http://127.0.0.1:8000/json/    &quot;&quot;&quot;    def post(self, request):        # 获取请求体中原始的JSON数据        json_str = request.body        # 使用json模块将原始的JSON数据转字典        json_dict = json.loads(json_str)        # 提取JSON数据中的参数        username = json_dict.get(&#39;username&#39;)        password = json_dict.get(&#39;password&#39;)        return http.HttpResponse(&#39;非表单类型请求体参数：%s--%s&#39; % (username, password))</code></pre><h4 id="4-3-URL路径参数：提取URL路径中的特定部分数据"><a href="#4-3-URL路径参数：提取URL路径中的特定部分数据" class="headerlink" title="4.3 URL路径参数：提取URL路径中的特定部分数据"></a>4.3 URL路径参数：提取URL路径中的特定部分数据</h4><blockquote><p>提示：</p></blockquote><ul><li>在定义路由时，可以从URL中获取特定部分的路径参数</li><li>Django的路由系统会将提取的路径参数传递到视图的内部</li><li>path()和re_path()都可以提取路径参数</li></ul><blockquote><p>需求：</p></blockquote><ul><li><p>需求1：</p><pre><code>http://127.0.0.1:8000/url_param1/18/</code></pre><ul><li>提取路径中的数字<code>18</code></li></ul></li><li><p>需求2：</p><pre><code>http://127.0.0.1:8000/url_param2/18500001111/</code></pre><ul><li>提取路径中的手机号<code>18500001111</code></li></ul></li></ul><h5 id="4-3-1-path-提取路径参数"><a href="#4-3-1-path-提取路径参数" class="headerlink" title="4.3.1 path()提取路径参数"></a>4.3.1 path()提取路径参数</h5><blockquote><p><strong>实现需求1</strong></p></blockquote><pre><code class="python"># 测试path()提取普通路径参数：http://127.0.0.1:8000/url_param1/18/path(&#39;url_param1/&lt;int:age&gt;/&#39;, views.URLParam1View.as_view()),class URLParam1View(View):    &quot;&quot;&quot;测试path()提取普通路径参数    http://127.0.0.1:8000/url_param1/18/    &quot;&quot;&quot;    def get(self, request, age):        &quot;&quot;&quot;        :param age: 路由提取的关键字参数        &quot;&quot;&quot;        return http.HttpResponse(&#39;测试path()提取普通路径参数：%s&#39; % age)</code></pre><blockquote><p>重要提示：</p></blockquote><ul><li><strong>路由中提取路径参数时，使用的关键字，必须跟视图中参数名一致</strong></li></ul><blockquote><p>思考：</p></blockquote><ul><li>实现需求1时提取age数字的<strong><code>&lt;int:age&gt;</code></strong>是什么？</li></ul><blockquote><p>结论：</p></blockquote><ul><li><strong>路由转换器</strong></li><li>Django默认封装了一些正则表达式，用于在path()中要提取路径参数时使用</li></ul><blockquote><p>默认的路由转换器：</p><ul><li>位置在<code>django.urls.converters.py</code></li></ul></blockquote><pre><code class="python">DEFAULT_CONVERTERS = {    &#39;int&#39;: IntConverter(), # 匹配正整数，包含0    &#39;path&#39;: PathConverter(), # 匹配任何非空字符串，包含了路径分隔符    &#39;slug&#39;: SlugConverter(), # 匹配字母、数字以及横杠、下划线组成的字符串    &#39;str&#39;: StringConverter(), # 匹配除了路径分隔符（/）之外的非空字符串，这是默认的形式    &#39;uuid&#39;: UUIDConverter(), # 匹配格式化的uuid，如 075194d3-6885-417e-a8a8-6c931e272f00}</code></pre><blockquote><p><strong>实现需求2</strong></p></blockquote><ul><li><pre><code>http://127.0.0.1:8000/url_param2/18500001111/</code></pre><ul><li>提取路径中的手机号<code>18500001111</code></li></ul></li></ul><blockquote><p>问题：</p></blockquote><ul><li>默认的路由转换器中，没有专门用来匹配手机号的路由转换器</li><li>所以在使用path()实现需求2时，就无法直接使用默认的路由转换器</li></ul><blockquote><p>解决方案：</p></blockquote><ul><li>如果默认的路由转换器无法满足需求时，我们就需要<strong>自定义路由转换器</strong></li></ul><blockquote><p>实现需求2：自定义路由转换器</p></blockquote><ul><li><p>在任意可以被导入的python文件中，都可以自定义路由转换器</p></li><li><p>比如：在工程根目录下，新建<strong><code>converters.py</code></strong>文件，用于自定义路由转换器</p><pre><code class="python">class MobileConverter:  &quot;&quot;&quot;自定义路由转换器：匹配手机号&quot;&quot;&quot;  # 匹配手机号码的正则  regex = &#39;1[3-9]\d{9}&#39;  def to_python(self, value):      # 将匹配结果传递到视图内部时使用      return int(value)  def to_url(self, value):      # 将匹配结果用于反向解析传值时使用      return str(value)</code></pre></li><li><p>注册自定义路由转换器</p><ul><li><p>在总路由中，注册自定义路由转换器</p><pre><code class="python">from django.urls import register_converterfrom converters import MobileConverter# 注册自定义路由转换器# register_converter(自定义路由转换器, &#39;别名&#39;)register_converter(MobileConverter, &#39;mobile&#39;)urlpatterns = []</code></pre></li></ul></li><li><p>使用自定义路由转换器</p><pre><code class="python"># 测试path()中自定义路由转换器提取路径参数：手机号 http://127.0.0.1:8000/url_param2/18500001111/path(&#39;url_param2/&lt;mobile:phone_num&gt;/&#39;, views.URLParam2View.as_view()),</code></pre><pre><code class="python">class URLParam2View(View):  &quot;&quot;&quot;测试path()中自定义路由转换器提取路径参数：手机号  http://127.0.0.1:8000/url_param2/18500001111/  &quot;&quot;&quot;  def get(self, request, phone_num):      &quot;&quot;&quot;      :param phone_num: 路由提取的关键字参数      &quot;&quot;&quot;      return http.HttpResponse(&#39;测试path()提取路径参数手机号：%s&#39; % phone_num)</code></pre></li></ul><h5 id="4-3-2-re-path-提取路径参数"><a href="#4-3-2-re-path-提取路径参数" class="headerlink" title="4.3.2 re_path()提取路径参数"></a>4.3.2 re_path()提取路径参数</h5><pre><code class="python"># 测试re_path()提取路径参数：http://127.0.0.1:8000/url_param3/18500001111/re_path(r&#39;^url_param3/(?P&lt;phone_num&gt;1[3-9]\d{9})/$&#39;, views.URLParam3View.as_view()),class URLParam3View(View):    &quot;&quot;&quot;测试re_path()提取路径参数    http://127.0.0.1:8000/url_param3/18500001111/    &quot;&quot;&quot;    def get(self, request, phone_num):        &quot;&quot;&quot;        :param phone_num: 路由提取的关键字参数        &quot;&quot;&quot;        return http.HttpResponse(&#39;测试re_path()提取路径参数：%s&#39; % phone_num)</code></pre><h5 id="4-3-3-path-和re-path-如何选择？"><a href="#4-3-3-path-和re-path-如何选择？" class="headerlink" title="4.3.3 path()和re_path()如何选择？"></a>4.3.3 path()和re_path()如何选择？</h5><ul><li>path()语法相对简洁一些，如果没有路径参数要提取或者要提取的路径参数可以使用默认的路由转换器实现时，就选择path()。</li><li>re_path()语法相对复杂一些，但是，如果希望在匹配路由时，由自己编写所有的正则表达式，就选择re_path()。</li><li>需要注意的是，在使用re_path()时，网络地址正则表达式一定要写完整，要有严格的开头和结尾</li></ul><h4 id="4-4-请求头"><a href="#4-4-请求头" class="headerlink" title="4.4 请求头"></a>4.4 请求头</h4><p>可以通过<strong><code>request.META</code></strong>属性获取请求头headers中的数据，<strong><code>request.META</code>为字典类型</strong>。</p><p>常见的请求头如：</p><ul><li><code>CONTENT_LENGTH</code> – The length of the request body (as a string).</li><li><code>CONTENT_TYPE</code> – The MIME type of the request body.</li><li><code>HTTP_ACCEPT</code> – Acceptable content types for the response.</li><li><code>HTTP_ACCEPT_ENCODING</code> – Acceptable encodings for the response.</li><li><code>HTTP_ACCEPT_LANGUAGE</code> – Acceptable languages for the response.</li><li><code>HTTP_HOST</code> – The HTTP Host header sent by the client.</li><li><code>HTTP_REFERER</code> – The referring page, if any.</li><li><code>HTTP_USER_AGENT</code> – The client’s user-agent string.</li><li><code>QUERY_STRING</code> – The query string, as a single (unparsed) string.</li><li><code>REMOTE_ADDR</code> – The IP address of the client.</li><li><code>REMOTE_HOST</code> – The hostname of the client.</li><li><code>REMOTE_USER</code> – The user authenticated by the Web server, if any.</li><li><code>REQUEST_METHOD</code> – A string such as <code>&quot;GET&quot;</code> or <code>&quot;POST&quot;</code>.</li><li><code>SERVER_NAME</code> – The hostname of the server.</li><li><code>SERVER_PORT</code> – The port of the server (as a string).</li></ul><p>具体使用如:</p><pre><code class="python">class HeadersParamView(View):    &quot;&quot;&quot;测试提取请求头参数&quot;&quot;&quot;    def get(self, request):        # 获取请求头中文件的类型        ret = request.META.get(&#39;CONTENT_TYPE&#39;)        return http.HttpResponse(&#39;OK&#39;)</code></pre><h4 id="4-5-其他常用HttpRequest对象属性"><a href="#4-5-其他常用HttpRequest对象属性" class="headerlink" title="4.5 其他常用HttpRequest对象属性"></a>4.5 其他常用HttpRequest对象属性</h4><ul><li>method：一个字符串，表示请求使用的HTTP方法，常用值包括：’GET’、’POST’。</li><li>FILES：一个类似于字典的对象，包含所有的上传文件。</li><li>COOKIES：一个字符串，包含了浏览器自动发送的cookie缓存数据。</li><li><strong>user：请求中认证出来的用户对象。</strong></li></ul><h3 id="5-响应HttpResponse"><a href="#5-响应HttpResponse" class="headerlink" title="5.响应HttpResponse"></a>5.响应HttpResponse</h3><blockquote><p>提示：</p></blockquote><ul><li>视图在接收请求并处理后，必须返回HttpResponse对象或子对象。</li><li>HttpRequest对象由Django创建，<strong>HttpResponse对象或子对象由开发人员创建</strong>。</li><li>常见的响应方式：<ul><li><strong><code>HttpResponse()</code></strong>：响应多种数据类型</li><li><strong><code>JsonResponse()</code></strong>：响应JSON</li><li><strong><code>redirect()</code></strong>：重定向</li><li><strong><code>render()</code></strong>：渲染并响应HTML模板</li></ul></li></ul><h4 id="5-1-HttpResponse"><a href="#5-1-HttpResponse" class="headerlink" title="5.1 HttpResponse"></a>5.1 HttpResponse</h4><blockquote><p>提示：</p></blockquote><ul><li><p>可以使用</p><p><code>django.http.HttpResponse</code></p><p>来构造响应对象。</p><pre><code class="python">response = HttpResponse(content=响应体, content_type=响应体数据类型，默认为text/html, status=状态码，默认为200)</code></pre></li></ul><blockquote><p>示例：</p></blockquote><pre><code class="python"># 测试HttpResponse：http://127.0.0.1:8000/response1/path(&#39;response1/&#39;, views.Response1View.as_view()),class Response1View(View):    &quot;&quot;&quot;测试HttpResponse    http://127.0.0.1:8000/response1/    &quot;&quot;&quot;    def get(self, request):        # 使用HttpResponse构造响应数据        # return http.HttpResponse(content=&#39;itcast python&#39;, status=200)        # 可简写        # return http.HttpResponse(&#39;itcast python&#39;)        # 另外一种写法        response = http.HttpResponse(&#39;itcast python&#39;)        return response</code></pre><blockquote><p>补充：HttpResponse子类</p></blockquote><p>Django提供了一系列HttpResponse的子类，可以快速设置状态码</p><ul><li><strong><code>HttpResponseRedirect</code></strong> 默认响应状态码为 <strong>301</strong></li><li><strong><code>HttpResponsePermanentRedirect</code></strong> 默认响应状态码为 <strong>302</strong></li><li><strong><code>HttpResponseNotModified</code></strong> 默认响应状态码为 <strong>304</strong></li><li><strong><code>HttpResponseBadRequest</code></strong> 默认响应状态码为 <strong>400</strong></li><li><strong><code>HttpResponseNotFound</code></strong> 默认响应状态码为 <strong>404</strong></li><li><strong><code>HttpResponseForbidden</code></strong> 默认响应状态码为 <strong>403</strong></li><li><strong><code>HttpResponseNotAllowed</code></strong> 默认响应状态码为 <strong>405</strong></li><li><strong><code>HttpResponseGone</code></strong> 默认响应状态码为 <strong>410</strong></li><li><strong><code>HttpResponseServerError</code></strong> 默认响应状态码为 <strong>500</strong></li></ul><h4 id="5-2-JsonResponse：响应JSON"><a href="#5-2-JsonResponse：响应JSON" class="headerlink" title="5.2 JsonResponse：响应JSON"></a>5.2 JsonResponse：响应JSON</h4><blockquote><p>提示：</p></blockquote><ul><li><p>在开发功能时，如果前端需要JSON数据，那么后端就需要构造并响应JSON数据</p></li><li><p>而Django提供了<strong><code>JsonResponse</code></strong>来构造并响应JSON数据</p></li><li><p><code>JsonResponse</code></p><p>作用：</p><ul><li>帮助我们将响应的数据转换为JSON字符串</li><li>设置响应头<strong>Content-Type</strong>为 <strong>application/json</strong></li></ul></li></ul><blockquote><p>示例：</p></blockquote><pre><code class="python"># 测试JSONResponse：http://127.0.0.1:8000/json_resp/path(&#39;json_resp/&#39;, views.JSONResponseView.as_view()),class JSONResponseView(View):    &quot;&quot;&quot;测试JSONResponse    http://127.0.0.1:8000/json_resp/    &quot;&quot;&quot;    def get(self, request):        # 准备要响应的数据        dict_data = {            &#39;city&#39;: &#39;beijing&#39;,            &#39;subject&#39;: &#39;python&#39;        }        # 使用JSONResponse构造并响应JSON数据        return http.JsonResponse(dict_data)</code></pre><h4 id="5-3-redirect-：重定向"><a href="#5-3-redirect-：重定向" class="headerlink" title="5.3 redirect()：重定向"></a>5.3 redirect()：重定向</h4><blockquote><p>提示：</p></blockquote><ul><li>在开发中，我们经常会遇到一种需求，当某个逻辑操作完成后，将用户引导到另外一个逻辑、页面中<ul><li>比如：用户注册、登录成功后，直接将用户引导到网站首页</li></ul></li></ul><blockquote><p>解决方案：</p></blockquote><ul><li><strong><code>redirect()</code></strong>：重定向</li></ul><blockquote><p>需求：</p></blockquote><ul><li>准备一个用于处理用户登录类视图<code>LoginRedirectView</code></li><li>访问<code>LoginRedirectView</code>时，如果其中的登录逻辑处理完成，我们将用户重定向到首页</li></ul><blockquote><p>示例：</p></blockquote><pre><code class="python"># 测试重定向path(&#39;login_redirect/&#39;, views.LoginRedirectView.as_view()),path(&#39;index/&#39;, views.IndexView.as_view()),from django.shortcuts import render, redirectclass IndexView(View):    &quot;&quot;&quot;测试重定向    http://127.0.0.1:8000/index/    &quot;&quot;&quot;    def get(self, request):        return http.HttpResponse(&#39;假装这是个网站首页&#39;)class LoginRedirectView(View):    &quot;&quot;&quot;测试重定向    http://127.0.0.1:8000/login_redirect/    &quot;&quot;&quot;    def post(self, request):        # 假装正在处理登录逻辑        # 假装登录逻辑处理完成        # ......        # 将用户通过重定向引导到首页        return redirect(&#39;/index/&#39;)</code></pre><h4 id="5-4-redirect-重定向-搭配-反向解析"><a href="#5-4-redirect-重定向-搭配-反向解析" class="headerlink" title="5.4 redirect()重定向 搭配 反向解析"></a>5.4 redirect()重定向 搭配 反向解析</h4><blockquote><p>思考：</p></blockquote><ul><li>我们定义的路由中的地址是否可能会做修改？</li><li>如果我们定义的路由中的地址在某次开发新版本时被修改了，那么重定向的地方是否也需要跟着改变？</li><li>如果该地址被很多地方都用到了，那么是否就意味着我们要修改代码的很多地方？</li></ul><blockquote><p>结论：</p></blockquote><ul><li>以上思考的问题，确实会存在的</li><li>我们定义的路由中的地址可能会在某次版本迭代时，做修改，使用新设计的地址</li><li>那么一旦地址变了，所有用到这个地址的地方，代码都需要修改，还可能会修改很多个地方的代码</li><li>而同时修改多个地方的代码，在开发中是个很危险的动作，而且也有一定的工作量</li></ul><blockquote><p>需求：</p></blockquote><ul><li>能否可以实现一种效果，可以保证即使在版本迭代时，使用了新设计的地址替换了路由中原有的地址，我们之前编写的使用该地址的代码不用去修改，达到动态获取的目的。</li></ul><blockquote><p>解决方案：</p></blockquote><ul><li><strong>路由反向解析</strong></li><li><strong>路由反向解析 是使用路由的别名，动态的解析出该路由中的真实地址</strong></li></ul><blockquote><p>示例：</p></blockquote><p>总路由中，给子应用的总路由起别名</p><pre><code class="python">urlpatterns = [    # 请求和响应    # path(&#39;&#39;, include((&#39;子路由&#39;, &#39;子应用名字&#39;), namespace=&#39;总路由别名，可以随便命名&#39;)),    path(&#39;&#39;, include((&#39;request_response.urls&#39;, &#39;request_response&#39;), namespace=&#39;request_response&#39;)),]</code></pre><p>子路由中，给子应用的子路由起别名</p><pre><code class="python"># 测试重定向path(&#39;login_redirect/&#39;, views.LoginRedirectView.as_view()),path(&#39;index/&#39;, views.IndexView.as_view(), name=&#39;index&#39;),</code></pre><p>视图中，使用路由的别名，动态的解析出该路由中的真实地址</p><pre><code class="python">from django.shortcuts import render, redirect, reverseclass IndexView(View):    &quot;&quot;&quot;测试重定向    http://127.0.0.1:8000/index/    &quot;&quot;&quot;    def get(self, request):        return http.HttpResponse(&#39;假装这是个网站首页&#39;)class LoginRedirectView(View):    &quot;&quot;&quot;测试重定向    http://127.0.0.1:8000/login_redirect/    &quot;&quot;&quot;    def post(self, request):        # 假装正在处理登录逻辑        # 假装登录逻辑处理完成        # ......        # 将用户通过重定向引导到首页        # return redirect(&#39;/index/&#39;)        # ret_url = reverse(&#39;总路由别名:子路由别名&#39;)        ret_url = reverse(&#39;request_response:index&#39;)        return redirect(ret_url)</code></pre><h3 id="6-中间件Middleware"><a href="#6-中间件Middleware" class="headerlink" title="6.中间件Middleware"></a>6.中间件Middleware</h3><h4 id="6-1-中间件介绍"><a href="#6-1-中间件介绍" class="headerlink" title="6.1 中间件介绍"></a>6.1 中间件介绍</h4><blockquote><p>概念：</p></blockquote><ul><li>Django中的中间件是一个轻量级、底层的插件系统，可以<strong>介入Django的请求和响应处理过程</strong>，修改Django的输入或输出</li><li>中间件的设计为开发者提供了一种无侵入式的开发方式，增强了Django框架的健壮性，其它的MVC框架也有这个功能</li></ul><blockquote><p>使用场景：</p></blockquote><ul><li><strong>当某些操作在每次请求或响应时都会执行时，可以写在中间件中</strong></li><li>比如，每次发送post请求都要进行CSRF验证，就把CSRF验证的代码写在中间件中</li></ul><blockquote><p>设计思想：</p></blockquote><ul><li>面向切面编程、无侵害式编程</li><li>不用直接修改框架源码，就可以达到自己想要的执行结果</li></ul><blockquote><p>默认的中间件</p></blockquote><pre><code class="python"># 中间件MIDDLEWARE = [    &#39;django.middleware.security.SecurityMiddleware&#39;,    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,    &#39;django.middleware.common.CommonMiddleware&#39;,    # 为保证非GET请求(POST, PUT, DELETE)可以正常接收，该中间件需要注释掉    # &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,    &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,    &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,]</code></pre><h4 id="6-2-中间件方法"><a href="#6-2-中间件方法" class="headerlink" title="6.2 中间件方法"></a>6.2 中间件方法</h4><blockquote><p>提示：</p><ul><li>Django在中间件中预置了六个方法，这六个方法会在不同的阶段自动执行，对输入或输出进行干预。</li></ul></blockquote><ul><li><p>2.1 初始化方法：</p><ul><li><p>启动Django程序，初始化中间件时，自动调用一次，用于确定是否启用当前中间件</p><pre><code class="python">def __init__(self, get_response=None):  pass</code></pre></li></ul></li><li><p>2.2 处理请求前的方法：(重要)</p><ul><li><p>在处理每个请求前，自动调用，返回None或HttpResponse对象</p><pre><code class="python">def process_request(self, request):  pass</code></pre></li></ul></li><li><p>2.3 处理视图前的方法：（重要）</p><ul><li><p>在处理每个视图前，自动调用，返回None或HttpResponse对象</p><pre><code class="python">def process_view(self, request, view_func, view_args, view_kwargs):  pass</code></pre></li></ul></li><li><p>2.4 处理模板响应前的方法：</p><ul><li><p>在处理每个模板响应前，自动调用，返回实现了render方法的响应对象</p><pre><code class="python">def process_template_response(self, request, response):  pass</code></pre></li></ul></li><li><p>2.5 处理响应后的方法：（重要）</p><ul><li><p>在每个响应返回给客户端之前，自动调用，返回HttpResponse对象</p><pre><code class="python">def process_response(self, request, response):  pass</code></pre></li></ul></li><li><p>2.6 异常处理：</p><ul><li><p>当视图抛出异常时，自动调用，返回一个HttpResponse对象</p><pre><code class="python">def process_exception(self, request,exception):  pass</code></pre></li></ul></li></ul><h4 id="6-3-自定义中间件"><a href="#6-3-自定义中间件" class="headerlink" title="6.3 自定义中间件"></a>6.3 自定义中间件</h4><ul><li>中间件是一个独立的Python类，可以定义Django提供的六个方法中的一个或多个</li><li>在工程根目录下，新建<code>middlewares.py</code>文件来自定义中间件</li><li>我们在自定义的中间件中，会去实现最重要的三个方法</li></ul><pre><code class="python"># 导入中间件的父类from django.utils.deprecation import MiddlewareMixinclass TestMiddleware1(MiddlewareMixin):    &quot;&quot;&quot;自定义中间件&quot;&quot;&quot;    def process_request(self, request):        &quot;&quot;&quot;处理请求前自动调用&quot;&quot;&quot;        print(&#39;process_request1 被调用&#39;)    def process_view(self, request, view_func, view_args, view_kwargs):        # 处理视图前自动调用        print(&#39;process_view1 被调用&#39;)    def process_response(self, request, response):        &quot;&quot;&quot;在每个响应返回给客户端之前自动调用&quot;&quot;&quot;        print(&#39;process_response1 被调用&#39;)        return response</code></pre><blockquote><p>注册自定义的中间件</p></blockquote><pre><code class="python"># 中间件MIDDLEWARE = [    &#39;django.middleware.security.SecurityMiddleware&#39;,    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,    &#39;django.middleware.common.CommonMiddleware&#39;,    # 为保证非GET请求(POST, PUT, DELETE)可以正常接收，该中间件需要注释掉    # &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,    &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,    &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,    &#39;middlewares.TestMiddleware1&#39;, # 注册自定义的中间件1]</code></pre><h4 id="6-4-中间件执行顺序"><a href="#6-4-中间件执行顺序" class="headerlink" title="6.4 中间件执行顺序"></a>6.4 中间件执行顺序</h4><blockquote><p>准备两个自定义的中间件</p></blockquote><pre><code class="python">from django.utils.deprecation import MiddlewareMixinclass TestMiddleware1(MiddlewareMixin):    &quot;&quot;&quot;自定义中间件&quot;&quot;&quot;    def process_request(self, request):        &quot;&quot;&quot;处理请求前自动调用&quot;&quot;&quot;        print(&#39;process_request1 被调用&#39;)    def process_view(self, request, view_func, view_args, view_kwargs):        # 处理视图前自动调用        print(&#39;process_view1 被调用&#39;)    def process_response(self, request, response):        &quot;&quot;&quot;在每个响应返回给客户端之前自动调用&quot;&quot;&quot;        print(&#39;process_response1 被调用&#39;)        return responseclass TestMiddleware2(MiddlewareMixin):    &quot;&quot;&quot;自定义中间件&quot;&quot;&quot;    def process_request(self, request):        &quot;&quot;&quot;处理请求前自动调用&quot;&quot;&quot;        print(&#39;process_request2 被调用&#39;)    def process_view(self, request, view_func, view_args, view_kwargs):        # 处理视图前自动调用        print(&#39;process_view2 被调用&#39;)    def process_response(self, request, response):        &quot;&quot;&quot;在每个响应返回给客户端之前自动调用&quot;&quot;&quot;        print(&#39;process_response2 被调用&#39;)        return response</code></pre><blockquote><p>注册多个自定义的中间件</p></blockquote><pre><code class="python"># 中间件MIDDLEWARE = [    &#39;django.middleware.security.SecurityMiddleware&#39;,    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,    &#39;django.middleware.common.CommonMiddleware&#39;,    # 为保证非GET请求(POST, PUT, DELETE)可以正常接收，该中间件需要注释掉    # &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,    &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,    &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,    &#39;middlewares.TestMiddleware1&#39;, # 注册自定义的中间件1    &#39;middlewares.TestMiddleware2&#39;, # 注册自定义中的间件2]</code></pre><blockquote><p><strong>重要提示：中间件执行顺序</strong></p></blockquote><ul><li>在视图被处理前(输入)，中间件<strong>由上至下</strong>依次执行</li><li>在视图被处理后(输出)，中间件<strong>由下至上</strong>依次执行</li></ul><h2 id="三、模型（models）"><a href="#三、模型（models）" class="headerlink" title="三、模型（models）"></a>三、模型（models）</h2><p><strong>提示：</strong></p><blockquote><ul><li>模型是Django程序处理数据库数据的模块</li><li>Django的模型是定义在子应用的<strong><code>models.py</code></strong>中的</li></ul></blockquote><p><strong>经验值分享</strong></p><p><strong>1. 读取外键</strong></p><ul><li>以图书和英雄这两个模型类为例</li></ul><pre><code>class BookInfo(models.Model):    &quot;&quot;&quot;图书信息模型类&quot;&quot;&quot;    btitle = models.CharField(max_length=20, verbose_name=&#39;名称&#39;)class HeroInfo(models.Model):    hname = models.CharField(max_length=20, verbose_name=&#39;名称&#39;)     # 外键    hbook = models.ForeignKey(BookInfo, on_delete=models.CASCADE, verbose_name=&#39;图书&#39;)</code></pre><ul><li>读取外键的方式：<ul><li>方式一：<strong><code>hero.hbook.id</code></strong></li><li>方式二：<strong><code>hero.hbook_id</code></strong></li></ul></li><li>问题：<ul><li><strong><code>hero.hbook.id</code></strong>：不安全，如果hbook为空，会报错，因为空对象不能读取任何属性</li><li><strong><code>hero.hbook_id</code></strong>：安全，如果hbook_id为空，不会报错，获取的是空值</li></ul></li><li>结论：<ul><li>如果外键允许为空，那么务必使用<strong><code>方式二</code></strong>读取外键</li><li>如果外键一定不为空，那么使用哪种方式读取外键都可以</li></ul></li></ul><p><strong>2. 查询集QuerySet缓存的特点</strong></p><blockquote><ul><li>参考知识点：<strong>查询集QuerySet</strong></li></ul></blockquote><ul><li>提示：<ul><li>查询集表示从数据库中获取的对象集合。具有自动缓存的特点。</li></ul></li><li>查询集自动缓存：<ul><li>使用同一个查询集，第一次使用时会发生数据库的查询，然后Django会把结果缓存下来，再次使用这个查询集时会使用缓存的数据，减少了数据库的查询次数。</li></ul></li><li>问题：<ul><li>如果某些数据需要频繁的更新，那么在查询和使用时就不能有缓存出现</li><li>比如：实时更新库存和销量，库存和销量每次在使用时必须是最新的结果，不能是之前缓存中的结果</li></ul></li><li>结论：<ul><li>如果我们要频繁的更新数据时，那么要更新的数据不要使用查询集获取</li><li>返回查询集的方法：all()、filter()、exclude()、order_by()</li><li>不返回查询集的方法：get()</li><li>所以<strong>如果要实时更新数据，建议采用get()查询要更新的数据</strong></li></ul></li></ul><h3 id="1-准备数据库"><a href="#1-准备数据库" class="headerlink" title="1.准备数据库"></a>1.准备数据库</h3><h4 id="1-1-创建MySQL数据库"><a href="#1-1-创建MySQL数据库" class="headerlink" title="1.1 创建MySQL数据库"></a>1.1 创建MySQL数据库</h4><blockquote><p>在ubuntu系统的MySQL程序中创建一个数据库</p></blockquote><pre><code class="sql">mysql -uroot -pcreate database django_demo default charset=utf8;</code></pre><h4 id="1-2-配置MySQL数据库"><a href="#1-2-配置MySQL数据库" class="headerlink" title="1.2 配置MySQL数据库"></a>1.2 配置MySQL数据库</h4><blockquote><p>在<strong><code>settings.py</code></strong>中配置数据库的连接信息</p><ul><li>以下是默认的数据库配置信息</li></ul></blockquote><pre><code class="python">DATABASES = {    &#39;default&#39;: {        &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,        &#39;NAME&#39;: os.path.join(BASE_DIR, &#39;db.sqlite3&#39;),    }}</code></pre><blockquote><p>修改<strong><code>DATABASES</code></strong>配置信息</p></blockquote><pre><code class="python">DATABASES = {    &#39;default&#39;: {        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,        &#39;HOST&#39;: &#39;192.168.103.240&#39;,  # 数据库主机        &#39;PORT&#39;: 3306,  # 数据库端口        &#39;USER&#39;: &#39;root&#39;,  # 数据库用户名        &#39;PASSWORD&#39;: &#39;mysql&#39;,  # 数据库用户密码        &#39;NAME&#39;: &#39;django_demo&#39;  # 数据库名字    }}</code></pre><h4 id="1-3-安装mysqlclient：MySQL数据库的客户端驱动"><a href="#1-3-安装mysqlclient：MySQL数据库的客户端驱动" class="headerlink" title="1.3 安装mysqlclient：MySQL数据库的客户端驱动"></a>1.3 安装mysqlclient：MySQL数据库的客户端驱动</h4><blockquote><p>安装mysqlclient</p></blockquote><pre><code class="python"># 进入虚拟环境pip install mysqlclient -i https://pypi.tuna.tsinghua.edu.cn/simple/</code></pre><h4 id="1-4-解决mysqlclient安装出错的问题"><a href="#1-4-解决mysqlclient安装出错的问题" class="headerlink" title="1.4 解决mysqlclient安装出错的问题"></a>1.4 解决mysqlclient安装出错的问题</h4><pre><code class="shell">1. 更换ubuntu中默认的源为国内的源：提升软件下载速度2. 更新apt-get的源和升级3. 安装libmysqlclient-dev：因为mysqlclient依赖这个软件4. 虚拟环境中安装mysqlclient==1.4.65. 测试：重启Django程序</code></pre><blockquote><p><strong>1.4.1 更换ubuntu中默认的源为国内的源</strong></p></blockquote><pre><code class="shell"># 第一步：备份 /etc/apt/sources.list# 第二步：在/etc/apt/sources.list中添加以下阿里源deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse# 备份$ cp /etc/apt/sources.list /etc/apt/sources.list.bak# 添加阿里源$ sudo vim /etc/apt/sources.list</code></pre><blockquote><p><strong>1.4.2 更新apt-get的源和升级</strong></p><ul><li>其中<code>upgrade</code>会执行很久，大家需要耐心等待</li></ul></blockquote><pre><code class="shell">$ sudo apt-get update$ sudo apt-get upgrade</code></pre><blockquote><p><strong>1.4.3 安装libmysqlclient-dev</strong></p></blockquote><pre><code class="shell">$ sudo apt-get install libmysqlclient-dev</code></pre><h3 id="2-模型类迁移建表"><a href="#2-模型类迁移建表" class="headerlink" title="2.模型类迁移建表"></a>2.模型类迁移建表</h3><p>如何创建数据库表？</p><ul><li>可以使用原生的SQL语句创建数据库表</li><li>也可以<strong>使用Django提供的模型类创建数据库表</strong></li></ul><blockquote><p>如何使用Django提供的模型类创建数据库表？</p></blockquote><ul><li>我们需要了解ORM框架</li><li>我们需要学会定义模型类</li><li>我们需要学会迁移模型类建表</li></ul><h4 id="2-1-ORM框架"><a href="#2-1-ORM框架" class="headerlink" title="2.1 ORM框架"></a>2.1 ORM框架</h4><blockquote><p>ORM框架介绍</p></blockquote><ul><li>O是object，也就是<strong>类或者对象</strong>的意思，这里的类就是模型类</li><li>R是relation，也就是关系数据库中<strong>数据表</strong>的意思</li><li>M是mapping，也就是<strong>映射</strong>的意思</li><li>在ORM框架中，它帮我们把模型类和数据表进行了一个映射，可以让我们<strong>通过模型类及对象就能操作它所对应的数据表中的数据</strong></li><li>ORM框架它还可以<strong>根据我们设计的模型类自动帮我们生成数据库中对应的数据表</strong>，省去了我们自己建表的过程</li></ul><blockquote><p>提示：</p></blockquote><ul><li><strong>Django框架中内嵌了ORM框架</strong>，所以在使用Django框架时，我们不需要直接面向数据库编程</li><li>而是定义模型类，通过模型类及对象完成数据表的增删改查操作</li></ul><blockquote><p><strong>ORM框架作用：</strong></p></blockquote><ul><li>帮助Django的开发者以面向对象的思想去操作数据库。</li><li>并且ORM框架也帮助程序员屏蔽了数据库之间的差异。</li></ul><h4 id="2-2-定义模型类"><a href="#2-2-定义模型类" class="headerlink" title="2.2 定义模型类"></a>2.2 定义模型类</h4><blockquote><p>提示：模型类的定义思路</p></blockquote><pre><code>1. 先根据需求设计数据表2. 再根据数据表设计方案定义模型类</code></pre><blockquote><p><strong>2.2.1 根据需求设计数据表</strong></p></blockquote><ul><li>需求：<ul><li>“图书-英雄”管理</li></ul></li><li>分析关联关系：<ul><li>一本书里面会有多个英雄人物，每个英雄人物都会属于某一本书</li><li>数据表一：图书信息表 (一方)</li><li>数据表二：英雄信息表 (多方)</li></ul></li><li>绑定关联关系：<ul><li>外键定义在多方对应的数据表中，即，外键需要定义在英雄信息表中</li></ul></li></ul><blockquote><p><strong>2.2.2 定义模型类</strong></p></blockquote><ul><li>模型类被定义在<strong><code>子应用/models.py</code></strong>文件中</li><li><strong>模型类必须继承自Model类</strong>，位于<code>django.db.models</code>中</li><li>创建子应用<strong><code>booktest</code></strong>，并在其<code>models.py</code>文件中定义模型类</li></ul><pre><code class="python">class BookInfo(models.Model):    &quot;&quot;&quot;图书信息：演示一对多，一方&quot;&quot;&quot;    btitle = models.CharField(max_length=20, verbose_name=&#39;书名&#39;)    bpub_date = models.DateField(verbose_name=&#39;发布日期&#39;)    bread = models.IntegerField(default=0, verbose_name=&#39;阅读量&#39;)    bcomment = models.IntegerField(default=0, verbose_name=&#39;评论量&#39;)    is_delete = models.BooleanField(default=False, verbose_name=&#39;逻辑删除&#39;)    class Meta:        &quot;&quot;&quot;模型类的元类：用于修改、配置模型类对应的数据表&quot;&quot;&quot;        db_table = &#39;tb_books&#39;  # 自定义数据库表名    def __str__(self):        &quot;&quot;&quot;定义每个数据对象的显示信息&quot;&quot;&quot;        return self.btitle # 输出该模型数据对象时，只输出书名class HeroInfo(models.Model):    &quot;&quot;&quot;英雄信息：演示一对多，多方&quot;&quot;&quot;    # 确定性别字段的取值范围    GENDER_CHOICES = (        (0, &#39;female&#39;),        (1, &#39;male&#39;)    )    hbook = models.ForeignKey(BookInfo, on_delete=models.CASCADE, verbose_name=&#39;英雄属于的图书&#39;)    hname = models.CharField(max_length=20, verbose_name=&#39;人名&#39;)    hgender = models.SmallIntegerField(choices=GENDER_CHOICES, default=0, verbose_name=&#39;性别&#39;)    hcomment = models.CharField(max_length=200, null=True, verbose_name=&#39;描述信息&#39;)    is_delete = models.BooleanField(default=False, verbose_name=&#39;逻辑删除&#39;)    class Meta:        db_table = &#39;tb_heros&#39;    def __str__(self):        return self.hname</code></pre><h4 id="2-3-模型类说明"><a href="#2-3-模型类说明" class="headerlink" title="2.3 模型类说明"></a>2.3 模型类说明</h4><blockquote><p><strong>2.3.1 关于主键</strong></p></blockquote><ul><li>Django会为表创建自动增长的主键列，每个模型只能有一个主键列</li><li>默认创建的主键列属性为<code>id</code>，可以使用<code>pk</code>代替，pk全拼为primary key</li><li>如果使用选项设置某属性为主键列后Django不会再创建自动增长的主键列</li></ul><blockquote><p><strong>2.3.2 关于属性命名</strong></p></blockquote><ul><li><p>不能是python的保留关键字</p></li><li><p>不允许使用连续的下划线，这是由Django的查询方式决定的</p></li><li><p>定义属性时需要指定字段类型，通过字段类型的参数指定选项，语法如下：</p><pre><code class="python">属性 = models.字段类型(选项)</code></pre></li></ul><blockquote><p><strong>2.3.3 关于数据库表名</strong></p></blockquote><ul><li>模型类如果未指明表名，Django默认以 <strong>小写app应用名_小写模型类名</strong> 为数据库表名</li><li>但是，可通过模型的元类中的<strong><code>db_table</code></strong>自定义数据库表名</li></ul><blockquote><p><strong>2.3.4 关于字段类型</strong></p></blockquote><pre><code class="sql">CREATE TABLE `tb_books` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `btitle` varchar(20) NOT NULL,  `bpub_date` date NOT NULL,  `bread` int(11) NOT NULL,  `bcomment` int(11) NOT NULL,  `is_delete` tinyint(1) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;</code></pre><table><thead><tr><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">AutoField</td><td align="left">自动增长的IntegerField，通常不用指定，不指定时Django会自动创建属性名为id的自动增长属性</td></tr><tr><td align="left">BooleanField</td><td align="left">布尔字段，值为True或False</td></tr><tr><td align="left">NullBooleanField</td><td align="left">支持Null、True、False三种值</td></tr><tr><td align="left">CharField</td><td align="left">字符串，参数max_length表示最大字符个数</td></tr><tr><td align="left">TextField</td><td align="left">大文本字段，一般超过4000个字符时使用</td></tr><tr><td align="left">IntegerField</td><td align="left">整数</td></tr><tr><td align="left">DecimalField</td><td align="left">十进制浮点数， 参数max_digits表示总位数， 参数decimal_places表示小数位数</td></tr><tr><td align="left">FloatField</td><td align="left">浮点数</td></tr><tr><td align="left">DateField</td><td align="left">日期， 参数auto_now表示每次保存对象时，自动设置该字段为当前时间，用于”最后一次修改”的时间戳，它总是使用当前日期，默认为False； 参数auto_now_add表示当对象第一次被创建时自动设置当前时间，用于创建的时间戳，它总是使用当前日期，默认为False; 参数auto_now_add和auto_now是相互排斥的，组合将会发生错误</td></tr><tr><td align="left">TimeField</td><td align="left">时间，参数同DateField</td></tr><tr><td align="left">DateTimeField</td><td align="left">日期时间，参数同DateField</td></tr><tr><td align="left">FileField</td><td align="left">上传文件字段</td></tr><tr><td align="left">ImageField</td><td align="left">继承于FileField，对上传的内容进行校验，确保是有效的图片</td></tr></tbody></table><blockquote><p><strong>2.3.5 关于字段选项</strong></p></blockquote><table><thead><tr><th align="left">选项</th><th>说明</th></tr></thead><tbody><tr><td align="left">null</td><td>如果为True，表示允许为空，默认值是False</td></tr><tr><td align="left">db_column</td><td>字段的名称，如果未指定，则使用属性的名称</td></tr><tr><td align="left">db_index</td><td>若值为True, 则在表中会为此字段创建索引，默认值是False</td></tr><tr><td align="left">default</td><td>默认</td></tr><tr><td align="left">primary_key</td><td>若为True，则该字段会成为模型的主键字段，默认值是False，一般作为AutoField的选项使用</td></tr><tr><td align="left">unique</td><td>如果为True, 这个字段在表中必须有唯一值，默认值是False</td></tr></tbody></table><blockquote><p><strong>2.3.6 关于外键</strong></p></blockquote><p>在设置外键时，需要通过<strong>on_delete</strong>选项指明主表删除数据时，对于外键引用表数据如何处理，在django.db.models中包含了可选常量：</p><ul><li><strong>CASCADE</strong> 级联，删除主表数据时连通一起删除外键表中数据</li><li><strong>PROTECT</strong> 保护，通过抛出<strong>ProtectedError</strong>异常，来阻止删除主表中被外键应用的数据</li><li><strong>SET_NULL</strong> 设置为NULL，仅在该字段null=True允许为null时可用</li><li><strong>SET_DEFAULT</strong> 设置为默认值，仅在该字段设置了默认值时可用</li><li><strong>SET()</strong> 设置为特定值或者调用特定方法</li><li><strong>DO_NOTHING</strong> 不做任何操作，如果数据库前置指明级联性，此选项会抛出<strong>IntegrityError</strong>异常</li></ul><h4 id="2-4-迁移模型类建表"><a href="#2-4-迁移模型类建表" class="headerlink" title="2.4 迁移模型类建表"></a>2.4 迁移模型类建表</h4><blockquote><p><strong>2.4.1 生成迁移文件</strong></p></blockquote><pre><code class="python">python manage.py makemigrations</code></pre><blockquote><p><strong>2.4.2 同步到数据库中</strong></p></blockquote><pre><code class="python">python manage.py migrate</code></pre><h4 id="2-5-添加测试数据"><a href="#2-5-添加测试数据" class="headerlink" title="2.5 添加测试数据"></a>2.5 添加测试数据</h4><pre><code class="mysql">insert into tb_books(btitle,bpub_date,bread,bcomment,is_delete) values(&#39;射雕英雄传&#39;,&#39;1980-5-1&#39;,12,34,0),(&#39;天龙八部&#39;,&#39;1986-7-24&#39;,36,40,0),(&#39;笑傲江湖&#39;,&#39;1995-12-24&#39;,20,80,0),(&#39;雪山飞狐&#39;,&#39;1987-11-11&#39;,58,24,0);</code></pre><pre><code class="mysql">insert into tb_heros(hname,hgender,hbook_id,hcomment,is_delete) values(&#39;郭靖&#39;,1,1,&#39;降龙十八掌&#39;,0),(&#39;黄蓉&#39;,0,1,&#39;打狗棍法&#39;,0),(&#39;黄药师&#39;,1,1,&#39;弹指神通&#39;,0),(&#39;欧阳锋&#39;,1,1,&#39;蛤蟆功&#39;,0),(&#39;梅超风&#39;,0,1,&#39;九阴白骨爪&#39;,0),(&#39;乔峰&#39;,1,2,&#39;降龙十八掌&#39;,0),(&#39;段誉&#39;,1,2,&#39;六脉神剑&#39;,0),(&#39;虚竹&#39;,1,2,&#39;天山六阳掌&#39;,0),(&#39;王语嫣&#39;,0,2,&#39;神仙姐姐&#39;,0),(&#39;令狐冲&#39;,1,3,&#39;独孤九剑&#39;,0),(&#39;任盈盈&#39;,0,3,&#39;弹琴&#39;,0),(&#39;岳不群&#39;,1,3,&#39;华山剑法&#39;,0),(&#39;东方不败&#39;,0,3,&#39;葵花宝典&#39;,0),(&#39;胡斐&#39;,1,4,&#39;胡家刀法&#39;,0),(&#39;苗若兰&#39;,0,4,&#39;黄衣&#39;,0),(&#39;程灵素&#39;,0,4,&#39;医术&#39;,0),(&#39;袁紫衣&#39;,0,4,&#39;六合拳&#39;,0);</code></pre><h3 id="3-增删改查"><a href="#3-增删改查" class="headerlink" title="3.增删改查"></a>3.增删改查</h3><h4 id="3-1-shell工具-用于在终端交互环境测试代码的"><a href="#3-1-shell工具-用于在终端交互环境测试代码的" class="headerlink" title="3.1 shell工具 (用于在终端交互环境测试代码的)"></a>3.1 shell工具 (用于在终端交互环境测试代码的)</h4><p>Django的manage工具提供了<strong>shell</strong>命令，帮助我们配置好当前工程的运行环境（如连接好数据库等），以便可以直接在终端中执行测试python语句。</p><p>如果有需要，通过如下命令进入shell</p><pre><code class="python">python manage.py shell</code></pre><p>导入两个模型类，以便后续使用</p><pre><code class="python">from booktest.models import BookInfo, HeroInfo</code></pre><h4 id="3-2-新增"><a href="#3-2-新增" class="headerlink" title="3.2 新增"></a>3.2 新增</h4><p>增加数据有两种方法。</p><p><strong>1）save</strong></p><p>通过创建模型类对象，<strong><code>模型对象.save()</code></strong>方法保存到数据库中。</p><pre><code class="python"># 新增：方式一book = BookInfo()book.btitle = &#39;西游记&#39;book.bpub_date = &#39;2020-05-18&#39;book.bread = 20book.bcomment = 30book.save()</code></pre><p><strong>2）create</strong></p><p>通过<strong><code>模型类.objects.create()</code></strong>保存。</p><pre><code class="python"># 新增：方式二BookInfo.objects.create(    btitle=&#39;三国演义&#39;,    bpub_date=&#39;2020-05-20&#39;,    bread=100,    bcomment=200)</code></pre><h4 id="3-3-修改"><a href="#3-3-修改" class="headerlink" title="3.3 修改"></a>3.3 修改</h4><p>修改更新有两种方法</p><p><strong>1）save</strong></p><p><strong>修改模型类对象的属性，然后执行<code>save()</code>方法</strong></p><pre><code class="python">hero = HeroInfo.objects.get(hname=&#39;猪八戒&#39;)hero.hname = &#39;猪悟能&#39;hero.save()</code></pre><p><strong>2）update</strong></p><p>使用<strong><code>模型类.objects.filter().update()</code></strong>，会返回受影响的行数</p><pre><code class="python">HeroInfo.objects.filter(hname=&#39;沙悟净&#39;).update(hname=&#39;沙僧&#39;)</code></pre><h4 id="3-4-删除"><a href="#3-4-删除" class="headerlink" title="3.4 删除"></a>3.4 删除</h4><p>删除有两种方法</p><p><strong>1）模型类对象delete</strong></p><pre><code class="python">hero = HeroInfo.objects.get(id=13)hero.delete()</code></pre><p><strong>2）模型类.objects.filter().delete()</strong></p><pre><code class="python">HeroInfo.objects.filter(id=14).delete()</code></pre><h4 id="3-5-查询"><a href="#3-5-查询" class="headerlink" title="3.5 查询"></a>3.5 查询</h4><h5 id="3-5-1-基本查询"><a href="#3-5-1-基本查询" class="headerlink" title="3.5.1 基本查询"></a>3.5.1 基本查询</h5><p><strong>get</strong> 查询单一结果，如果不存在会抛出<strong>模型类.DoesNotExist</strong>异常。</p><p><strong>all</strong> 查询多个结果。</p><p><strong>count</strong> 查询结果数量。</p><pre><code class="python">&gt;&gt;&gt; BookInfo.objects.all()&lt;QuerySet [&lt;BookInfo: 射雕英雄传&gt;, &lt;BookInfo: 天龙八部&gt;, &lt;BookInfo: 笑傲江湖&gt;, &lt;BookInfo: 雪山飞狐&gt;, &lt;BookInfo: 西游记&gt;]&gt;&gt;&gt;&gt; book = BookInfo.objects.get(btitle=&#39;西游记&#39;)&gt;&gt;&gt; book.id5&gt;&gt;&gt; BookInfo.objects.get(id=3)&lt;BookInfo: 笑傲江湖&gt;&gt;&gt;&gt; BookInfo.objects.get(pk=3)&lt;BookInfo: 笑傲江湖&gt;&gt;&gt;&gt; BookInfo.objects.get(id=100)Traceback (most recent call last):  File &quot;&lt;console&gt;&quot;, line 1, in &lt;module&gt;  File &quot;/Users/delron/.virtualenv/dj/lib/python3.6/site-packages/django/db/models/manager.py&quot;, line 85, in manager_method    return getattr(self.get_queryset(), name)(*args, **kwargs)  File &quot;/Users/delron/.virtualenv/dj/lib/python3.6/site-packages/django/db/models/query.py&quot;, line 380, in get    self.model._meta.object_namedb.models.DoesNotExist: BookInfo matching query does not exist.&gt;&gt;&gt; BookInfo.objects.count()6</code></pre><h5 id="3-5-2-过滤查询"><a href="#3-5-2-过滤查询" class="headerlink" title="3.5.2 过滤查询"></a>3.5.2 过滤查询</h5><p>实现SQL中的where功能，包括</p><ul><li><strong>filter</strong> 过滤出满足条件的多个结果</li><li><strong>exclude</strong> 排除掉符合条件剩下的结果</li></ul><p>过滤条件的表达语法如下：</p><pre><code class="python">属性名称__比较运算符=值# 属性名称和比较运算符间使用两个下划线，所以属性名不能包括多个下划线</code></pre><p><strong>1）相等</strong></p><p><strong>exact：表示判等。</strong></p><p>例：查询编号为1的图书。</p><pre><code>BookInfo.objects.filter(id__exact=1)可简写为：BookInfo.objects.filter(id=1)</code></pre><p><strong>2）模糊查询</strong></p><p><strong>contains：是否包含。</strong></p><blockquote><p>说明：如果要包含%无需转义，直接写即可。</p></blockquote><p>例：查询书名包含’传’的图书。</p><pre><code class="python">BookInfo.objects.filter(btitle__contains=&#39;传&#39;)</code></pre><p><strong>startswith、endswith：以指定值开头或结尾。</strong></p><p>例：查询书名以’部’结尾的图书</p><pre><code class="python">BookInfo.objects.filter(btitle__endswith=&#39;部&#39;)</code></pre><blockquote><p>以上运算符都区分大小写，在这些运算符前加上i表示不区分大小写，如iexact、icontains、istartswith、iendswith.</p></blockquote><p><strong>3） 空查询</strong></p><p><strong>isnull：是否为null。</strong></p><p>例：查询书名不为空的图书。</p><pre><code class="python">BookInfo.objects.filter(btitle__isnull=False)</code></pre><p><strong>4） 范围查询</strong></p><p><strong>in：是否包含在范围内。</strong></p><p>例：查询编号为1或3或5的图书</p><pre><code class="python">BookInfo.objects.filter(id__in=[1, 3, 5])</code></pre><p><strong>5）比较查询</strong></p><ul><li><strong>gt</strong> 大于 (greater then)</li><li><strong>gte</strong> 大于等于 (greater then equal)</li><li><strong>lt</strong> 小于 (less then)</li><li><strong>lte</strong> 小于等于 (less then equal)</li></ul><p>例：查询编号大于3的图书</p><pre><code class="python">BookInfo.objects.filter(id__gt=3)</code></pre><p><strong>不等于的运算符，使用exclude()过滤器。</strong></p><p>例：查询编号不等于3的图书</p><pre><code class="python">BookInfo.objects.exclude(id=3)</code></pre><p><strong>6）日期查询</strong></p><p><strong>year、month、day、week_day、hour、minute、second：对日期时间类型的属性进行运算。</strong></p><p>例：查询1980年发表的图书。</p><pre><code class="python">BookInfo.objects.filter(bpub_date__year=1980)</code></pre><p>例：查询1980年1月1日后发表的图书。</p><pre><code class="python">BookInfo.objects.filter(bpub_date__gt=date(1990, 1, 1))</code></pre><h5 id="F对象"><a href="#F对象" class="headerlink" title="F对象"></a>F对象</h5><p>之前的查询都是对象的属性与常量值比较，两个属性怎么比较呢？ 答：使用F对象，被定义在django.db.models中。</p><p>语法如下：</p><pre><code>F(属性名)</code></pre><p>例：查询阅读量大于等于评论量的图书。</p><pre><code class="python">from django.db.models import FBookInfo.objects.filter(bread__gte=F(&#39;bcomment&#39;))</code></pre><p>可以在F对象上使用算数运算。</p><p>例：查询阅读量大于2倍评论量的图书。</p><pre><code class="python">BookInfo.objects.filter(bread__gt=F(&#39;bcomment&#39;) * 2)</code></pre><h5 id="Q对象"><a href="#Q对象" class="headerlink" title="Q对象"></a>Q对象</h5><p><strong>多个过滤器逐个调用表示逻辑与关系，同sql语句中where部分的and关键字。</strong></p><p>例：查询阅读量大于20，并且编号小于3的图书。</p><pre><code class="python">BookInfo.objects.filter(bread__gt=20,id__lt=3)或BookInfo.objects.filter(bread__gt=20).filter(id__lt=3)</code></pre><p><strong>如果需要实现逻辑或or的查询，需要使用Q()对象结合|运算符</strong>，Q对象被义在django.db.models中。</p><p>语法如下：</p><pre><code>Q(属性名__运算符=值)</code></pre><p>例：查询阅读量大于20的图书，改写为Q对象如下。</p><pre><code class="python">from django.db.models import QBookInfo.objects.filter(Q(bread__gt=20))</code></pre><p>Q对象可以使用&amp;、|连接，&amp;表示逻辑与，|表示逻辑或。</p><p>例：查询阅读量大于20，或编号小于3的图书，只能使用Q对象实现</p><pre><code class="python">BookInfo.objects.filter(Q(bread__gt=20) | Q(pk__lt=3))</code></pre><p>Q对象前可以使用~操作符，表示非not。</p><p>例：查询编号不等于3的图书。</p><pre><code class="python">BookInfo.objects.filter(~Q(pk=3))</code></pre><h5 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h5><p>使用aggregate()过滤器调用聚合函数。聚合函数包括：<strong>Avg</strong> 平均，<strong>Count</strong> 数量，<strong>Max</strong> 最大，<strong>Min</strong> 最小，<strong>Sum</strong> 求和，被定义在django.db.models中。</p><p>例：查询图书的总阅读量。</p><pre><code class="python">from django.db.models import SumBookInfo.objects.aggregate(Sum(&#39;bread&#39;))</code></pre><p>注意aggregate的返回值是一个字典类型，格式如下：</p><pre><code class="python">  {&#39;属性名__聚合类小写&#39;:值}  如:{&#39;bread__sum&#39;:3}</code></pre><p>使用count时一般不使用aggregate()过滤器。</p><p>例：查询图书总数。</p><pre><code class="python">BookInfo.objects.count()</code></pre><p>注意count函数的返回值是一个数字。</p><h5 id="3-5-3-排序"><a href="#3-5-3-排序" class="headerlink" title="3.5.3 排序"></a>3.5.3 排序</h5><p>使用<strong>order_by</strong>对结果进行排序</p><pre><code class="python">BookInfo.objects.all().order_by(&#39;bread&#39;)  # 升序BookInfo.objects.all().order_by(&#39;-bread&#39;)  # 降序</code></pre><h5 id="3-5-4-关联查询"><a href="#3-5-4-关联查询" class="headerlink" title="3.5.4 关联查询"></a>3.5.4 关联查询</h5><p>由一到多的访问语法：</p><p>一对应的模型类对象.多对应的模型类名小写_set<br>例：</p><pre><code class="python">b = BookInfo.objects.get(id=1)b.heroinfo_set.all()</code></pre><p>由多到一的访问语法:</p><p>多对应的模型类对象.多对应的模型类中的关系类属性名<br>例：</p><pre><code class="python">h = HeroInfo.objects.get(id=1)h.hbook</code></pre><p>访问一对应的模型类关联对象的id语法:</p><p>多对应的模型类对象.关联类属性_id</p><p>例：</p><pre><code class="python">h = HeroInfo.objects.get(id=1)h.hbook_id</code></pre><h3 id="4-查询集QuerySet"><a href="#4-查询集QuerySet" class="headerlink" title="4.查询集QuerySet"></a>4.查询集QuerySet</h3><h4 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h4><p>Django的ORM中存在查询集的概念。</p><p>查询集，也称查询结果集、QuerySet，表示从数据库中获取的对象集合。</p><p>当调用如下过滤器方法时，Django会返回查询集（而不是简单的列表）：</p><ul><li>all()：返回所有数据。</li><li>filter()：返回满足条件的数据。</li><li>exclude()：返回满足条件之外的数据。</li><li>order_by()：对结果进行排序。</li></ul><p>对查询集可以再次调用过滤器进行过滤，如</p><pre><code class="python">BookInfo.objects.filter(bread__gt=30).order_by(&#39;bpub_date&#39;)</code></pre><p>也就意味着查询集可以含有零个、一个或多个过滤器。过滤器基于所给的参数限制查询的结果。</p><p><strong>从SQL的角度讲，查询集与select语句等价，过滤器像where、limit、order by子句。</strong></p><p><strong>判断某一个查询集中是否有数据</strong>：</p><ul><li>exists()：判断查询集中是否有数据，如果有则返回True，没有则返回False。</li></ul><h4 id="4-2-两大特性"><a href="#4-2-两大特性" class="headerlink" title="4.2 两大特性"></a>4.2 两大特性</h4><h5 id="1）惰性执行"><a href="#1）惰性执行" class="headerlink" title="1）惰性执行"></a>1）惰性执行</h5><p>创建查询集不会访问数据库，直到调用数据时，才会访问数据库，调用数据的情况包括迭代、序列化、与if合用</p><p>例如，当执行如下语句时，并未进行数据库查询，只是创建了一个查询集qs</p><pre><code class="python">qs = BookInfo.objects.all()</code></pre><p>继续执行遍历迭代操作后，才真正的进行了数据库的查询</p><pre><code class="python">for book in qs:    print(book.btitle)</code></pre><h5 id="2）缓存"><a href="#2）缓存" class="headerlink" title="2）缓存"></a>2）缓存</h5><p>使用同一个查询集，第一次使用时会发生数据库的查询，然后Django会把结果缓存下来，再次使用这个查询集时会使用缓存的数据，减少了数据库的查询次数。</p><p><strong>情况一</strong>：如下是两个查询集，无法重用缓存，每次查询都会与数据库进行一次交互，增加了数据库的负载。</p><pre><code class="python">from booktest.models import BookInfo[book.id for book in BookInfo.objects.all()][book.id for book in BookInfo.objects.all()]</code></pre><p><strong>情况二</strong>：经过存储后，可以重用查询集，第二次使用缓存中的数据。</p><pre><code class="python">qs=BookInfo.objects.all()[book.id for book in qs][book.id for book in qs]</code></pre><h2 id="四、模板（templates）"><a href="#四、模板（templates）" class="headerlink" title="四、模板（templates）"></a>四、模板（templates）</h2><p><strong>提示：</strong></p><blockquote><ul><li>模板是Django程序渲染页面的模块</li><li>Django的模板是定义在<strong><code>templates</code></strong>文件目录中的</li></ul></blockquote><h3 id="1-配置模板"><a href="#1-配置模板" class="headerlink" title="1. 配置模板"></a>1. 配置模板</h3><blockquote><p><strong>1.1 准备模板文件目录</strong></p></blockquote><ul><li>在工程根目录下创建模板文件目录<strong><code>templates</code></strong></li></ul><blockquote><p><strong>1.2 配置模板</strong></p></blockquote><ul><li><p>在</p><pre><code>settings.py</code></pre><p>配置文件中修改</p><p><code>TEMPLATES</code></p><p>配置项的</p><p><code>DIRS</code></p><p>值：</p><pre><code class="python"># 配置模板TEMPLATES = [  {      &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,      #指定模板文件目录的路径      &#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)],      &#39;APP_DIRS&#39;: True,      &#39;OPTIONS&#39;: {          &#39;context_processors&#39;: [              &#39;django.template.context_processors.debug&#39;,              &#39;django.template.context_processors.request&#39;,              &#39;django.contrib.auth.context_processors.auth&#39;,              &#39;django.contrib.messages.context_processors.messages&#39;,          ],      },  },]</code></pre></li></ul><h3 id="2-定义和响应模板"><a href="#2-定义和响应模板" class="headerlink" title="2. 定义和响应模板"></a>2. 定义和响应模板</h3><blockquote><p><strong>2.1 新建模板文件</strong></p></blockquote><ul><li>在<code>templates</code>目录中新建一个模板文件，如：<code>temp.html</code></li></ul><blockquote><p><strong>2.2 响应模板文件</strong></p></blockquote><pre><code class="python">class TempView(View):    &quot;&quot;&quot;图书信息    http://127.0.0.1:8000/temp/    &quot;&quot;&quot;    def get(self, request):        return render(request, &#39;temp.html&#39;)</code></pre><h3 id="3-测试模板渲染"><a href="#3-测试模板渲染" class="headerlink" title="3. 测试模板渲染"></a>3. 测试模板渲染</h3><blockquote><p><strong>3.1 模板语法</strong></p></blockquote><ul><li><p>模板语法如下：</p><ul><li><p>变量名必须由字母、数字、下划线（不能以下划线开头）和点组成</p></li></ul></li></ul><blockquote><p><strong>3.2 使用模板语法渲染HTML模板</strong></p></blockquote><pre><code class="python">class BooksView(View):    &quot;&quot;&quot;图书信息    http://127.0.0.1:8000/books/    &quot;&quot;&quot;    def get(self, request):        # 构造上下文        context = {            &#39;name&#39;: &#39;张三&#39;,            &#39;age&#39;: 18        }        # 使用上下文渲染&#39;book.html&#39;，并返回给客户端        return render(request, &#39;book.html&#39;, context)</code></pre><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;图书信息页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;{{ name }}&lt;/h1&gt;    &lt;h1&gt;{{ age }}&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="4-数据库数据渲染模板"><a href="#4-数据库数据渲染模板" class="headerlink" title="4. 数据库数据渲染模板"></a>4. 数据库数据渲染模板</h3><blockquote><p>需求：</p></blockquote><ul><li>渲染数据库中所有的图书信息</li></ul><pre><code class="python">class BooksView(View):    &quot;&quot;&quot;测试模板    http://127.0.0.1:8000/books/    &quot;&quot;&quot;    def get(self, request):        # 查询所有图书信息        books = BookInfo.objects.all()        # 构造上下文        context = {            &#39;books&#39;: books        }        # 使用上下文渲染&#39;book.html&#39;，并返回给客户端        return render(request, &#39;books.html&#39;, context)</code></pre><pre><code class="html">&lt;body&gt;    &lt;ul&gt;        {% for book in books %}            <li>《{{ book.btitle }}》</li>        {% endfor %}    &lt;/ul&gt;&lt;/body&gt;</code></pre><h2 id="五、cookie和session"><a href="#五、cookie和session" class="headerlink" title="五、cookie和session"></a>五、cookie和session</h2><p>提示：</p><blockquote><ul><li>Cookie和Session是Django程序中用来缓存数据的</li></ul></blockquote><p><strong>经验值分享</strong></p><p><strong>1. 状态保持和Cookie、Session的关系</strong></p><p>提示：</p><ul><li>容易出现的误解：状态保持就是Cookie和Session，Cookie和Session就是状态保持。</li><li>状态保持和Cookie、Session是两种不同的概念，需要区分开，不能混淆。</li></ul><p><strong>状态保持：</strong></p><pre><code>* 用于记录当前用户的状态，比如，用户登录后记录登录的状态。</code></pre><p><strong>Cookie、Session：</strong></p><pre><code>* Cookie、Session仅仅是Django提供的缓存机制而已，用于缓存数据的。* 比如：    * Cookie和Session缓存购物车数据    * Cookie和Session缓存用户登录状态 (状态保持)</code></pre><p><strong>状态保持和Cookie、Session的关系</strong></p><pre><code>* Cookie和Session仅仅是状态保持的一种实现方式而已* 而能够实现状态保持的方式不仅仅只有Cookie和Session，比如JWT也可以实现状态保持</code></pre><h3 id="1-cookie"><a href="#1-cookie" class="headerlink" title="1.cookie"></a>1.cookie</h3><blockquote><p><strong>提示：</strong></p></blockquote><ul><li><strong>HTTP协议本身是无状态的</strong>，即服务器无法判断用户身份。</li></ul><blockquote><p>问题：</p></blockquote><ul><li>服务器默认是无法识别当前登录用户是谁的，即<strong>无法记住登录状态</strong>。</li></ul><blockquote><p>解决：</p></blockquote><ul><li><strong><code>Cookie</code></strong></li><li>我们可以使用Cookie机制记住用户的登录状态</li></ul><h4 id="1-1-Cookie的介绍"><a href="#1-1-Cookie的介绍" class="headerlink" title="1.1 Cookie的介绍"></a>1.1 Cookie的介绍</h4><ul><li>Cookie，最早是网景公司的前雇员 Lou Montulli 在 1993 年 3 月发明的。</li><li>Cookie，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。</li><li><strong>Cookie，实际上是一小段存储在用户浏览器中的文本信息</strong>。</li></ul><blockquote><p><strong>Cookie的机制：</strong></p></blockquote><ul><li>客户端向服务器发起请求，如果服务器需要记录该用户状态，就通过响应向客户端浏览器颁发一个Cookie。<ul><li>该Cookie中需要包含用户的唯一标识信息</li></ul></li><li>客户端浏览器会把Cookie保存起来。</li><li>当浏览器再次请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。</li><li>服务器检查该Cookie，以此来辨认用户状态。</li></ul><blockquote><p><strong>Cookie的特点：</strong></p></blockquote><ul><li><p>Cookie，以键值对<strong><code>Key-Value</code></strong>形式进行信息的存储</p></li><li><p>Cookie，基于域名安全，不同域名的</p><p><code>Cookie</code></p><p>是不能互相访问的</p><ul><li>例如： 保存在<code>www.baidu.com</code>域名下面的<code>Cookie</code>是不能被其他域名访问的</li></ul></li><li><p>Cookie，它会自动跟随当前的请求传递到对应域名所在的服务器中。</p></li></ul><h4 id="2-2-操作Cookie"><a href="#2-2-操作Cookie" class="headerlink" title="2.2 操作Cookie"></a>2.2 操作Cookie</h4><blockquote><p>提示：</p></blockquote><ul><li>关于操作Cookie，分为<strong>设置Cookie</strong>和<strong>读取Cookie</strong></li></ul><h5 id="2-2-1-设置Cookie"><a href="#2-2-1-设置Cookie" class="headerlink" title="2.2.1 设置Cookie"></a>2.2.1 设置Cookie</h5><p>可以通过<strong>HttpResponse()</strong>对象中的<strong><code>set_cookie()</code></strong>方法来设置Cookie。</p><pre><code class="python"># 创建响应对象response = HttpResponse()# 使用响应对象设置Cookieresponse.set_cookie(key, value, max_age=cookie有效期)</code></pre><ul><li><strong>响应对象</strong>：常见的构造响应对象的方式<ul><li><strong><code>HttpResponse()</code></strong>：响应多种数据类型</li><li><strong><code>JsonResponse()</code></strong>：响应JSON</li><li><strong><code>redirect()</code></strong>：重定向</li><li><strong><code>render()</code></strong>：渲染并响应HTML模板</li></ul></li><li><strong>max_age</strong>：单位为秒，默认为<strong>None</strong>。<ul><li>如果是临时Cookie，可将<code>max_age</code>设置为<code>None</code>。</li><li>如果是有具体有效期的Cookie，可将<code>max_age</code>设置为<code>具体的秒数</code>。</li></ul></li></ul><p>示例：</p><pre><code class="python">class BooksView(View):    &quot;&quot;&quot;测试模板    http://127.0.0.1:8000/books/    &quot;&quot;&quot;    def get(self, request):        # 查询所有图书信息        books = BookInfo.objects.all()        # 构造上下文        context = {            &#39;books&#39;: books        }        # 使用上下文渲染&#39;book.html&#39;，并返回给客户端        response = render(request, &#39;books.html&#39;, context)        # 设置Cookie        response.set_cookie(&#39;name&#39;, &#39;itcast&#39;, max_age=None)        # 响应结果，并写Cookie到浏览器        return response</code></pre><h5 id="2-2-2-读取Cookie"><a href="#2-2-2-读取Cookie" class="headerlink" title="2.2.2 读取Cookie"></a>2.2.2 读取Cookie</h5><p>可以通过<strong>HttpRequest</strong>对象的<strong><code>COOKIES</code></strong>属性来读取本次请求携带的cookie值。</p><pre><code class="python">class TestCookieView(View):    &quot;&quot;&quot;测试Cookie    http://127.0.0.1:8000/cookies/    &quot;&quot;&quot;    def get(self, request):        # 读取Cookie        name = request.COOKIES.get(&#39;name&#39;)        print(name)        return http.HttpResponse(&#39;测试Cookie&#39;)</code></pre><h3 id="2-session"><a href="#2-session" class="headerlink" title="2.session"></a>2.session</h3><h4 id="2-1-Session的介绍"><a href="#2-1-Session的介绍" class="headerlink" title="2.1.Session的介绍"></a>2.1.Session的介绍</h4><ul><li><p>Session，是一种会话控制方式。由服务端创建，并且保存在服务端的数据存储形式。</p></li><li><p>Session，内部也是以<strong><code>key-value</code></strong> 键值对的形式存储数据。</p></li><li><p>Session，有些内容会被加密，所以可以存储敏感信息。</p></li><li><p>处理Session数据的子应用：</p></li><li><pre><code>INSTALLED_APPS = [    &#39;django.contrib.admin&#39;,    &#39;django.contrib.auth&#39;,    &#39;django.contrib.contenttypes&#39;,    &#39;django.contrib.sessions&#39;,       &lt;============    &#39;django.contrib.messages&#39;,    &#39;django.contrib.staticfiles&#39;,</code></pre></li></ul><p>处理Session的中间件：</p><pre><code>MIDDLEWARE = [    &#39;django.middleware.security.SecurityMiddleware&#39;,    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,     &lt;==============    &#39;django.middleware.common.CommonMiddleware&#39;,    # &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,    &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,    &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,]</code></pre><p>PS：如需禁用Session，将上图中的session中间件注释掉即可。</p><blockquote><p><strong>Session的机制：</strong></p></blockquote><ul><li>客户端向服务器发起请求，如果服务器需要记录该用户状态，就可以通过Session在服务端将该用户的唯一标识信息存储起来。<ul><li><strong><code>session_key</code></strong>：一个随机的唯一的不重复的字符串</li><li><strong><code>session_data</code></strong>：用户的唯一标识信息（密文）</li></ul></li><li>然后，服务端会向客户端浏览器颁发一个Cookie。<ul><li>该Cookie中包含了Session存储数据时使用的那个<strong><code>session_key</code></strong></li><li>该Cookie的具体形式为：<strong><code>&#39;session_id&#39;: &#39;session_key&#39;</code></strong></li></ul></li><li>当浏览器再次请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。</li><li>服务器提取该Cookie中的<strong><code>session_key</code></strong>，再使用它提取<strong><code>session_data</code></strong>。</li><li>最后使用<strong><code>session_data</code></strong>来辨认用户状态</li></ul><blockquote><p><strong>Session的特点：</strong></p></blockquote><ul><li>存储敏感、重要的信息<ul><li>因为session数据是存储在服务端的，不会直接暴露给用户</li></ul></li><li>相比较Cookie可以存储更多的内容<ul><li>不同的浏览器，对Cookie都有不同的数量和大小的限制</li></ul></li><li>依赖于Cookie<ul><li>因为<strong><code>session_key</code></strong>需要存储在Cookie中</li></ul></li><li>Session共享<ul><li>利用独立部署的session服务器（集群）统一管理Session，服务器每次读写Session时，都访问Session服务器。</li></ul></li></ul><h4 id="2-2-操作Session"><a href="#2-2-操作Session" class="headerlink" title="2.2 操作Session"></a>2.2 操作Session</h4><blockquote><p>提示：</p></blockquote><ul><li>对于Session的操作，分为<strong><code>设置Session</code></strong>和<strong><code>读取session</code></strong></li></ul><h5 id="2-2-1-设置Session"><a href="#2-2-1-设置Session" class="headerlink" title="2.2.1 设置Session"></a>2.2.1 设置Session</h5><p>可以通过<strong>HttpRequest()</strong>对象中的<strong><code>session</code></strong>属性来设置Session。</p><pre><code class="python">request.session[&#39;key&#39;] = valueclass BooksView(View):    &quot;&quot;&quot;测试模板    http://127.0.0.1:8000/books/    &quot;&quot;&quot;    def get(self, request):        # 查询所有图书信息        books = BookInfo.objects.all()        # 构造上下文        context = {            &#39;books&#39;: books        }        # 使用上下文渲染&#39;book.html&#39;，并返回给客户端        response = render(request, &#39;books.html&#39;, context)        # 设置Cookie        response.set_cookie(&#39;name&#39;, &#39;itcast&#39;, max_age=3600)        # 设置Session        request.session[&#39;name&#39;] = &#39;itcast&#39;        # 响应结果，并写Cookie到浏览器        return response</code></pre><h5 id="2-2-2-读取Session"><a href="#2-2-2-读取Session" class="headerlink" title="2.2.2 读取Session"></a>2.2.2 读取Session</h5><p>根据键读取值</p><pre><code class="python">request.session.get(&#39;key&#39;, 默认值)class TestSessionView(View):    &quot;&quot;&quot;测试Session    http://127.0.0.1:8000/session/    &quot;&quot;&quot;    def get(self, request):        # 读取Session        name = request.session.get(&#39;name&#39;)        print(name)        return http.HttpResponse(&#39;测试Session&#39;)</code></pre><h5 id="2-2-3-操作Session的其他方式"><a href="#2-2-3-操作Session的其他方式" class="headerlink" title="2.2.3 操作Session的其他方式"></a>2.2.3 操作Session的其他方式</h5><blockquote><p>清除所有Session，在存储中删除值部分。</p></blockquote><pre><code class="python">request.session.clear()</code></pre><blockquote><p>清除session数据，在存储中删除session的整条数据。</p></blockquote><pre><code class="python">request.session.flush()</code></pre><blockquote><p>删除session中的指定键及值，在存储中只删除某个键及对应的值。</p></blockquote><pre><code class="python">del request.session[&#39;key&#39;]</code></pre><blockquote><p>设置session的有效期</p></blockquote><pre><code class="python">request.session.set_expiry(value)</code></pre><ul><li>如果value是一个整数，session将在value秒没有活动后过期。</li><li>如果value为0，那么用户session的Cookie将在用户的浏览器关闭时过期。</li><li>如果value为None，那么session有效期将采用系统默认值，默认为两周。<ul><li>可以通过在settings.py中设置SESSION_COOKIE_AGE来设置全局默认值。</li></ul></li></ul><h4 id="2-3-Session数据存储的位置"><a href="#2-3-Session数据存储的位置" class="headerlink" title="2.3 Session数据存储的位置"></a>2.3 Session数据存储的位置</h4><h5 id="2-3-1-默认的存储位置"><a href="#2-3-1-默认的存储位置" class="headerlink" title="2.3.1 默认的存储位置"></a>2.3.1 默认的存储位置</h5><blockquote><p>Session数据默认存储的位置是在<code>settings.py</code>的<code>DATABASES</code>配置项指定的SQL数据库中</p></blockquote><ul><li><p>因为Session引擎默认的配置为：</p><pre><code class="python">SESSION_ENGINE = &#39;django.contrib.sessions.backends.db&#39;</code></pre></li></ul><h5 id="2-3-2-本地缓存"><a href="#2-3-2-本地缓存" class="headerlink" title="2.3.2 本地缓存"></a>2.3.2 本地缓存</h5><p>存储在本机内存中，如果丢失则不能找回，比数据库的方式读写更快。</p><pre><code class="python">SESSION_ENGINE=&#39;django.contrib.sessions.backends.cache&#39;</code></pre><h5 id="2-3-3-混合存储"><a href="#2-3-3-混合存储" class="headerlink" title="2.3.3 混合存储"></a>2.3.3 混合存储</h5><p>优先从本机内存中存取，如果没有则从数据库中存取。</p><pre><code class="python">SESSION_ENGINE=&#39;django.contrib.sessions.backends.cached_db&#39;</code></pre><h5 id="2-3-4-Redis"><a href="#2-3-4-Redis" class="headerlink" title="2.3.4 Redis"></a>2.3.4 Redis</h5><p>在Redis中保存Session，需要引入第三方扩展，我们可以使用<strong>django-redis</strong>来解决。</p><p>1）安装扩展</p><pre><code class="python">pip install django-redis</code></pre><p>2）配置</p><p>在settings.py文件中做如下设置</p><pre><code class="python">CACHES = {    &quot;default&quot;: {        &quot;BACKEND&quot;: &quot;django_redis.cache.RedisCache&quot;,        &quot;LOCATION&quot;: &quot;redis://127.0.0.1:6379/1&quot;,        &quot;OPTIONS&quot;: {            &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot;,        }    }}SESSION_ENGINE = &quot;django.contrib.sessions.backends.cache&quot;SESSION_CACHE_ALIAS = &quot;default&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Django-框架基础&quot;&gt;&lt;a href=&quot;#Django-框架基础&quot; class=&quot;headerlink&quot; title=&quot;Django 框架基础&quot;&gt;&lt;/a&gt;Django 框架基础&lt;/h1&gt;&lt;h2 id=&quot;一、Django工程搭建&quot;&gt;&lt;a href=&quot;#一、Django工程搭建&quot; class=&quot;headerlink&quot; title=&quot;一、Django工程搭建&quot;&gt;&lt;/a&gt;一、Django工程搭建&lt;/h2&gt;&lt;h3 id=&quot;1-web本质和意义&quot;&gt;&lt;a href=&quot;#1-web本质和意义&quot; class=&quot;headerlink&quot; title=&quot;1.web本质和意义&quot;&gt;&lt;/a&gt;1.web本质和意义&lt;/h3&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://caijinbo.work/categories/python/"/>
    
    
      <category term="python" scheme="https://caijinbo.work/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>redis</title>
    <link href="https://caijinbo.work/2020/09/21/2020-09-22-redis/"/>
    <id>https://caijinbo.work/2020/09/21/2020-09-22-redis/</id>
    <published>2020-09-21T16:00:00.000Z</published>
    <updated>2020-11-23T10:13:59.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h3 id="nosql介绍"><a href="#nosql介绍" class="headerlink" title="nosql介绍"></a>nosql介绍</h3><h3 id="NoSQL：一类新出现的数据库-not-only-sql"><a href="#NoSQL：一类新出现的数据库-not-only-sql" class="headerlink" title="NoSQL：一类新出现的数据库(not only sql)"></a>NoSQL：一类新出现的数据库(not only sql)</h3><a id="more"></a><ul><li>泛指非关系型的数据库</li><li>不支持SQL语法</li><li>存储结构跟传统关系型数据库中的那种关系表完全不同，nosql中存储的数据都是KV形式</li><li>NoSQL的世界中没有一种通用的语言，每种nosql数据库都有自己的api和语法，以及擅长的业务场景</li><li>NoSQL中的产品种类相当多：<ul><li>Redis</li><li>Mongodb</li><li>Hbase hadoop</li><li>Cassandra hadoop</li></ul></li></ul><h3 id="NoSQL和SQL数据库的比较："><a href="#NoSQL和SQL数据库的比较：" class="headerlink" title="NoSQL和SQL数据库的比较："></a>NoSQL和SQL数据库的比较：</h3><ul><li>适用场景不同：sql数据库适合用于关系特别复杂的数据查询场景，nosql反之</li><li><strong>事务</strong> 特性的支持：sql对事务的支持非常完善，而nosql基本不支持事务</li><li>两者在不断地取长补短，呈现融合趋势</li></ul><h3 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h3><ul><li>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。</li><li>Redis是 NoSQL技术阵营中的一员，它通过多种键值数据类型来适应不同场景下的存储需求，借助一些高层级的接口使用其可以胜任，如缓存、队列系统的不同角色</li></ul><h3 id="Redis特性"><a href="#Redis特性" class="headerlink" title="Redis特性"></a>Redis特性</h3><ul><li>Redis 与其他 key - value 缓存产品有以下三个特点：</li><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><h3 id="Redis-优势"><a href="#Redis-优势" class="headerlink" title="Redis 优势"></a>Redis 优势</h3><ul><li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li><li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li><li>原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li><li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li></ul><h3 id="Redis应用场景"><a href="#Redis应用场景" class="headerlink" title="Redis应用场景"></a>Redis应用场景</h3><ul><li>用来做缓存(ehcache/memcached)——redis的所有数据是放在内存中的（内存数据库）</li><li>可以在某些特定应用场景下替代传统数据库——比如社交类的应用</li><li>在一些大型系统中，巧妙地实现一些特定的功能：session共享、购物车</li><li>只要你有丰富的想象力，redis可以给你无限的惊喜…….</li></ul><h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p>官网：<a href="http://download.redis.io/releases/redis-6.0.8.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-6.0.8.tar.gz</a>      </p><p><strong>安装方法一：源码编译安装</strong></p><p>step1:下载</p><blockquote><p>wget <a href="http://download.redis.io/releases/redis-6.0.8.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-6.0.8.tar.gz</a>      </p></blockquote><p>step2:解压</p><blockquote><p>tar zxf redis-6.0.8.tar.gz      </p></blockquote><p>step3:移动，放到usr/local⽬录下</p><blockquote><p>sudo mv ./redis-x.x.x /usr/local/redis/</p></blockquote><p>step4:进⼊redis⽬录</p><blockquote><p>cd /usr/local/redis/</p></blockquote><p>step5:生成</p><blockquote><p>sudo make</p></blockquote><p>step6:测试,这段运⾏时间会较⻓</p><blockquote><p>sudo make test</p></blockquote><p>step7:安装,将redis的命令安装到<code>/usr/local/bin/</code>⽬录</p><blockquote><p>sudo make install</p></blockquote><p>step8:安装完成后，我们进入目录<code>/usr/local/bin</code>中查看</p><blockquote><p>cd /usr/local/bin<br>ls -all</p></blockquote><ul><li>redis-server redis服务器</li><li>redis-cli redis命令行客户端</li><li>redis-benchmark redis性能测试工具</li><li>redis-check-aof AOF文件修复工具</li><li>redis-check-rdb RDB文件检索工具</li></ul><p>step9:配置⽂件，移动到<code>/etc/</code>⽬录下</p><ul><li><p>配置⽂件⽬录为<code>/usr/local/redis/redis.conf</code></p><blockquote><p>sudo cp /usr/local/redis/redis.conf /etc/redis/</p></blockquote></li></ul><p>安装方法二：</p><p>sudo apt install redis</p><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p><strong>提示：</strong></p><ul><li><p>Redis的配置信息在<code>/etc/redis/redis.conf</code>下。</p></li><li><p>查看</p><blockquote><p>sudo vi /etc/redis/redis.conf</p></blockquote></li></ul><h3 id="核心配置选项"><a href="#核心配置选项" class="headerlink" title="核心配置选项"></a>核心配置选项</h3><ul><li><p>绑定ip：如果需要远程访问，可将此⾏注释，或绑定⼀个真实ip</p><blockquote><p>bind 127.0.0.1</p></blockquote></li><li><p>端⼝，默认为6379</p><blockquote><p>port 6379</p></blockquote></li><li><p>是否以守护进程运⾏</p><ul><li>如果以守护进程运⾏，则不会在命令⾏阻塞，类似于服务</li><li>如果以⾮守护进程运⾏，则当前终端被阻塞</li><li>设置为yes表示守护进程，设置为no表示⾮守护进程</li><li>推荐设置为yes</li></ul><blockquote><p>daemonize yes</p></blockquote></li><li><p>数据⽂件</p><blockquote><p>dbfilename dump.rdb</p></blockquote></li><li><p>数据⽂件存储路径</p><blockquote><p>dir /var/lib/redis</p></blockquote></li><li><p>⽇志⽂件</p><blockquote><p>logfile “/var/log/redis/redis-server.log”</p></blockquote></li><li><p>数据库，默认有16个</p><blockquote><p>database 16</p></blockquote></li><li><p>主从复制，类似于双机备份。</p><blockquote><p>slaveof</p></blockquote></li></ul><h2 id="三、服务端和客户端命令"><a href="#三、服务端和客户端命令" class="headerlink" title="三、服务端和客户端命令"></a>三、服务端和客户端命令</h2><ul><li><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3></li><li><p>服务器端的命令为redis-server</p></li><li><p>可以使⽤help查看帮助⽂档</p><blockquote><p>redis-server –help</p></blockquote></li><li><p>个人习惯</p><blockquote><p>ps aux | grep redis 查看redis服务器进程<br>sudo kill -9 pid 杀死redis服务器<br>sudo redis-server /etc/redis/redis.conf 指定加载的配置文件</p></blockquote></li></ul><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul><li><p>客户端的命令为redis-cli</p></li><li><p>可以使⽤help查看帮助⽂档</p><blockquote><p>redis-cli –help</p></blockquote></li><li><p>连接redis</p><blockquote><p>redis-cli</p></blockquote></li><li><p>运⾏测试命令</p><blockquote><p>ping</p></blockquote></li><li><p>切换数据库</p></li><li><p>数据库没有名称，默认有16个，通过0-15来标识，连接redis默认选择第一个数据库</p><blockquote><p>select 10</p></blockquote></li></ul><h2 id="四、数据操作"><a href="#四、数据操作" class="headerlink" title="四、数据操作"></a>四、数据操作</h2><h3 id="重要文档"><a href="#重要文档" class="headerlink" title="重要文档"></a>重要文档</h3><ul><li><a href="http://doc.redisfans.com/" target="_blank" rel="noopener">Redis 参考命令</a></li><li><a href="https://redis-py.readthedocs.io/en/latest/#indices-and-tables" target="_blank" rel="noopener">Redis 官方文档</a></li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li><p>redis是key-value的数据结构，每条数据都是⼀个键值对</p></li><li><p>键的类型是字符串</p></li><li><p>注意：键不能重复</p></li><li><p>值的类型分为五种：</p><ul><li>字符串string</li><li>哈希hash</li><li>列表list</li><li>集合set</li><li>有序集合zset</li></ul></li></ul><h3 id="数据操作行为"><a href="#数据操作行为" class="headerlink" title="数据操作行为"></a>数据操作行为</h3><ul><li>保存</li><li>修改</li><li>获取</li><li>删除</li></ul><p>点击中⽂官⽹查看命令⽂档<a href="http://redis.cn/commands.html" target="_blank" rel="noopener">http://redis.cn/commands.html</a></p><h3 id="1-string类型"><a href="#1-string类型" class="headerlink" title="1.string类型"></a>1.string类型</h3><ul><li>字符串类型是 Redis 中最为基础的数据存储类型，它在 Redis 中是二进制的，这便意味着该类型可以接受任何格式的数据，如JPEG图像数据或Json对象描述信息等。在Redis中字符串类型的Value最多可以容纳的数据长度是512M。</li></ul><h4 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h4><p>如果设置的键不存在则为添加，如果设置的键已经存在则修改</p><ul><li><p>设置键值</p><blockquote><p>set key value</p></blockquote></li><li><p>例1：设置键为<code>name</code>值为<code>itcast</code>的数据</p><blockquote><p>set name itcast</p></blockquote></li><li><p>设置键值及过期时间，以秒为单位</p><blockquote><p>setex key seconds value</p></blockquote></li><li><p>例2：设置键为<code>aa</code>值为<code>aa</code>过期时间为3秒的数据</p><blockquote><p>setex aa 3 aa</p></blockquote></li><li><p>设置多个键值</p><blockquote><p>mset key1 value1 key2 value2 …</p></blockquote></li><li><p>例3：设置键为<code>a1</code>值为<code>python</code>、键为<code>a2</code>值为<code>java</code>、键为<code>a3</code>值为<code>c</code></p><blockquote><p>mset a1 python a2 java a3 c</p></blockquote></li></ul><h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><ul><li><p>获取：根据键获取值，如果不存在此键则返回<code>nil</code></p><blockquote><p>get key</p></blockquote></li><li><p>例5：获取键<code>name</code>的值</p><blockquote><p>get name</p></blockquote></li><li><p>根据多个键获取多个值</p><blockquote><p>mget key1 key2 …</p></blockquote></li><li><p>例6：获取键<code>a1、a2、a3</code>的值</p><blockquote><p>mget a1 a2 a3</p></blockquote></li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><blockquote><p>del key</p></blockquote><h3 id="2-键命令"><a href="#2-键命令" class="headerlink" title="2.键命令"></a>2.键命令</h3><ul><li><p>查找键，参数⽀持正则表达式</p><blockquote><p>keys pattern</p></blockquote></li><li><p>例1：查看所有键</p><blockquote><p>keys *</p></blockquote></li><li><p>例2：查看名称中包含<code>a</code>的键</p><blockquote><p>keys a*</p></blockquote></li><li><p>判断键是否存在，如果存在返回<code>1</code>，不存在返回<code>0</code></p><blockquote><p>exists key1</p></blockquote></li><li><p>例3：判断键<code>a1</code>是否存在</p><blockquote><p>exists a1</p></blockquote></li><li><p>查看键对应的<code>value</code>的类型</p><blockquote><p>type key</p></blockquote></li><li><p>例4：查看键<code>a1</code>的值类型，为redis⽀持的五种类型中的⼀种</p><blockquote><p>type a1</p></blockquote></li><li><p>删除键及对应的值</p><blockquote><p>del key1 key2 …</p></blockquote></li><li><p>例5：删除键<code>a2、a3</code></p><blockquote><p>del a2 a3</p></blockquote></li><li><p>设置过期时间，以秒为单位</p></li><li><p>如果没有指定过期时间则⼀直存在，直到使⽤<code>DEL</code>移除</p><blockquote><p>expire key seconds</p></blockquote></li><li><p>例6：设置键<code>a1</code>的过期时间为3秒</p><blockquote><p>expire a1 3</p></blockquote></li><li><p>查看有效时间，以秒为单位</p><blockquote><p>ttl key</p></blockquote></li><li><p>例7：查看键<code>bb</code>的有效时间</p><blockquote><p>ttl bb</p></blockquote></li></ul><h3 id="3-hash"><a href="#3-hash" class="headerlink" title="3.hash"></a>3.hash</h3><ul><li><strong>hash</strong>⽤于存储对象，对象的结构为属性、值</li><li><strong>值</strong>的类型为<strong>string</strong></li></ul><h4 id="增加、修改"><a href="#增加、修改" class="headerlink" title="增加、修改"></a>增加、修改</h4><ul><li><p>设置单个属性</p><blockquote><p>hset key field value</p></blockquote></li><li><p>例1：设置键 <code>user</code>的属性<code>name</code>为<code>itheima</code></p><blockquote><p>hset user name itheima</p></blockquote></li><li><p>设置多个属性</p><blockquote><p>hmset key field1 value1 field2 value2 …</p></blockquote></li><li><p>例2：设置键<code>u2</code>的属性<code>name</code>为<code>itcast</code>、属性<code>age</code>为<code>11</code></p><blockquote><p>hmset u2 name itcast age 11</p></blockquote></li></ul><h4 id="获取-1"><a href="#获取-1" class="headerlink" title="获取"></a>获取</h4><ul><li><p>获取指定键所有的属性</p><blockquote><p>hkeys key</p></blockquote></li><li><p>例3：获取键u2的所有属性</p><blockquote><p>hkeys u2</p></blockquote></li><li><p>获取⼀个属性的值</p><blockquote><p>hget key field</p></blockquote></li><li><p>例4：获取键<code>u2</code>属性<code>name</code>的值</p><blockquote><p>hget u2 name</p></blockquote></li><li><p>获取多个属性的值</p><blockquote><p>hmget key field1 field2 …</p></blockquote></li><li><p>例5：获取键<code>u2</code>属性<code>name</code>、<code>age</code>的值</p><blockquote><p>hmget u2 name age</p></blockquote></li></ul><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><ul><li><p><strong>删除整个hash键及值，使⽤del命令</strong></p></li><li><p>删除属性，属性对应的值会被⼀起删除</p><blockquote><p>hdel key field1 field2 …</p></blockquote></li><li><p>例7：删除键<code>u2</code>的属性<code>age</code></p><blockquote><p>hdel u2 age</p></blockquote></li></ul><h3 id="4-list"><a href="#4-list" class="headerlink" title="4.list"></a>4.list</h3><ul><li>列表的元素类型为string</li><li>按照插⼊顺序排序</li></ul><h4 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h4><ul><li><p>在左侧插⼊数据</p><blockquote><p>lpush key value1 value2 …</p></blockquote></li><li><p>例1：从键为<code>a1</code>的列表左侧加⼊数据<code>a 、 b 、c</code></p><blockquote><p>lpush a1 a b c</p></blockquote></li><li><p>在右侧插⼊数据</p><blockquote><p>rpush key value1 value2 …</p></blockquote></li><li><p>例2：从键为<code>a1</code>的列表右侧加⼊数据<code>0、1</code></p><blockquote><p>rpush a1 0 1</p></blockquote></li><li><p>在指定元素的前或后插⼊新元素</p><blockquote><p>linsert key before或after 现有元素 新元素</p></blockquote></li><li><p>例3：在键为<code>a1</code>的列表中元素<code>b</code>前加⼊<code>3</code></p><blockquote><p>linsert a1 before b 3</p></blockquote></li></ul><h4 id="获取-2"><a href="#获取-2" class="headerlink" title="获取"></a>获取</h4><ul><li><p>返回列表⾥指定范围内的元素</p><ul><li><code>start</code>、<code>stop</code>为元素的下标索引</li><li>索引从左侧开始，第⼀个元素为0</li><li>索引可以是负数，表示从尾部开始计数，如<code>-1</code>表示最后⼀个元素</li></ul><blockquote><p>lrange key start stop</p></blockquote></li><li><p>例4：获取键为<code>a1</code>的列表所有元素</p><blockquote><p>lrange a1 0 -1</p></blockquote></li></ul><h4 id="设置指定索引位置的元素值"><a href="#设置指定索引位置的元素值" class="headerlink" title="设置指定索引位置的元素值"></a>设置指定索引位置的元素值</h4><ul><li><p>索引从左侧开始，第⼀个元素为0</p></li><li><p>索引可以是负数，表示尾部开始计数，如<code>-1</code>表示最后⼀个元素</p><blockquote><p>lset key index value</p></blockquote></li><li><p>例5：修改键为<code>a1</code>的列表中下标为<code>1</code>的元素值为<code>z</code></p><blockquote><p>lset a 1 z</p></blockquote></li></ul><h4 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h4><ul><li><p>删除指定元素</p><ul><li>将列表中前<code>count</code>次出现的值为<code>value</code>的元素移除</li><li>count &gt; 0: 从头往尾移除</li><li>count &lt; 0: 从尾往头移除</li><li>count = 0: 移除所有</li></ul><blockquote><p>lrem key count value</p></blockquote></li><li><p>例6.1：向列表<code>a2</code>中加⼊元素<code>a、b、a、b、a、b</code></p><blockquote><p>lpush a2 a b a b a b</p></blockquote></li><li><p>例6.2：从<code>a2</code>列表右侧开始删除2个<code>b</code></p><blockquote><p>lrem a2 -2 b</p></blockquote></li><li><p>例6.3：查看列表<code>a2</code>的所有元素</p><blockquote><p>lrange a2 0 -1</p></blockquote></li></ul><h4 id="截取修剪"><a href="#截取修剪" class="headerlink" title="截取修剪"></a>截取修剪</h4><ul><li><p>修剪(截取) 在[start stop]区间内的元素,区间外的元素全部删除</p><blockquote><p>ltrim key start stop</p></blockquote></li></ul><h3 id="5-set"><a href="#5-set" class="headerlink" title="5.set"></a>5.set</h3><ul><li>⽆序集合</li><li>元素为string类型</li><li>元素具有唯⼀性，不重复</li><li>说明：对于集合没有修改操作</li></ul><h4 id="增加-1"><a href="#增加-1" class="headerlink" title="增加"></a>增加</h4><ul><li><p>添加元素</p><blockquote><p>sadd key member1 member2 …</p></blockquote></li><li><p>例1：向键<code>a3</code>的集合中添加元素<code>zhangsan</code>、<code>lisi</code>、<code>wangwu</code></p><blockquote><p>sadd a3 zhangsan sili wangwu</p></blockquote></li></ul><h4 id="获取-3"><a href="#获取-3" class="headerlink" title="获取"></a>获取</h4><ul><li><p>返回所有的元素</p><blockquote><p>smembers key</p></blockquote></li><li><p>例2：获取键<code>a3</code>的集合中所有元素</p><blockquote><p>smembers a3</p></blockquote></li></ul><h4 id="删除-3"><a href="#删除-3" class="headerlink" title="删除"></a>删除</h4><ul><li><p>删除指定元素</p><blockquote><p>srem key</p></blockquote></li><li><p>例3：删除键<code>a3</code>的集合中元素<code>wangwu</code></p><blockquote><p>srem a3 wangwu</p></blockquote></li></ul><h3 id="6-zset"><a href="#6-zset" class="headerlink" title="6.zset"></a>6.zset</h3><ul><li>sorted set，有序集合</li><li>元素为string类型</li><li>元素具有唯⼀性，不重复</li><li>每个元素都会关联⼀个double类型的score，表示权重，通过权重将元素从⼩到⼤排序</li><li>说明：没有修改操作</li></ul><h4 id="增加-2"><a href="#增加-2" class="headerlink" title="增加"></a>增加</h4><ul><li><p>添加</p><blockquote><p>zadd key score1 member1 score2 member2 …</p></blockquote></li><li><p>例1：向键<code>a4</code>的集合中添加元素<code>lisi</code>、<code>wangwu</code>、<code>zhaoliu</code>、<code>zhangsan</code>，权重分别为<code>4、5、6、3</code></p><blockquote><p>zadd a4 4 lisi 5 wangwu 6 zhaoliu 3 zhangsan</p></blockquote></li></ul><h4 id="获取-4"><a href="#获取-4" class="headerlink" title="获取"></a>获取</h4><ul><li><p>返回指定范围内的元素</p></li><li><p>start、stop为元素的下标索引</p></li><li><p>索引从左侧开始，第⼀个元素为0</p></li><li><p>索引可以是负数，表示从尾部开始计数，如<code>-1</code>表示最后⼀个元素</p><blockquote><p>zrange key start stop</p></blockquote></li><li><p>例2：获取键<code>a4</code>的集合中所有元素</p><blockquote><p>zrange a4 0 -1</p></blockquote></li><li><p>返回<code>score</code>值在<code>min</code>和<code>max</code>之间的成员</p><blockquote><p>zrangebyscore key min max</p></blockquote></li><li><p>例3：获取键<code>a4</code>的集合中权限值在<code>5和6之间</code>的成员</p><blockquote><p>zrangebyscore a4 5 6</p></blockquote></li><li><p>返回成员<code>member</code>的<code>score</code>值</p><blockquote><p>zscore key member</p></blockquote></li><li><p>例4：获取键<code>a4</code>的集合中元素<code>zhangsan</code>的权重</p><blockquote><p>zscore a4 zhangsan</p></blockquote></li></ul><h4 id="删除-4"><a href="#删除-4" class="headerlink" title="删除"></a>删除</h4><ul><li><p>删除指定元素</p><blockquote><p>zrem key member1 member2 …</p></blockquote></li><li><p>例5：删除集合<code>a4</code>中元素<code>zhangsan</code></p><blockquote><p>zrem a4 zhangsan</p></blockquote></li><li><p>删除权重在指定范围的元素</p><blockquote><p>zremrangebyscore key min max</p></blockquote></li><li><p>例6：删除集合<code>a4</code>中权限在<code>5、6之间</code>的元素</p><blockquote><p>zremrangebyscore a4 5 6</p></blockquote></li></ul><h2 id="五、与python交互"><a href="#五、与python交互" class="headerlink" title="五、与python交互"></a>五、与python交互</h2><h4 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h4><p>安装Redis的有3种方式<a href="https://github.com/andymccurdy/redis-py" target="_blank" rel="noopener">https://github.com/andymccurdy/redis-py</a></p><ul><li><p>第一种：进⼊虚拟环境，联⽹安装包redis</p><blockquote><p>pip install redis</p></blockquote></li><li><p>第二种：进⼊虚拟环境，联⽹安装包redis</p><blockquote><p>easy_install redis</p></blockquote></li><li><p>第三种：到中⽂官⽹-客户端下载redis包的源码，使⽤源码安装</p><blockquote><p>一步步执行 wget <a href="https://github.com/andymccurdy/redis-py/archive/master.zip" target="_blank" rel="noopener">https://github.com/andymccurdy/redis-py/archive/master.zip</a><br>unzip master.zip<br>cd redis-py-master<br>sudo python setup.py install</p></blockquote></li></ul><h4 id="调⽤模块"><a href="#调⽤模块" class="headerlink" title="调⽤模块"></a>调⽤模块</h4><ul><li><p>引⼊模块</p><blockquote><p>from redis import StrictRedis</p></blockquote></li><li><p>这个模块中提供了<code>StrictRedis对象</code>，⽤于连接redis服务器，并按照不同类型提供 了不同⽅法，进⾏交互操作</p></li></ul><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ul><li>在桌面上创建redis目录</li><li>使用pycharm打开 redis目录</li><li>创建redis_string.py文件</li></ul><pre><code class="python">from redis import *if __name__==&quot;__main__&quot;:    try:        #创建StrictRedis对象，与redis服务器建⽴连接        sr=StrictRedis()    except Exception as e:        print(e)</code></pre><h4 id="string-增加"><a href="#string-增加" class="headerlink" title="string-增加"></a>string-增加</h4><ul><li>⽅法set，添加键、值，如果添加成功则返回True，如果添加失败则返回False</li><li>编写代码如下</li></ul><pre><code class="python">from redis import *if __name__==&quot;__main__&quot;:    try:        #创建StrictRedis对象，与redis服务器建⽴连接        sr=StrictRedis()        #添加键name，值为itheima        result=sr.set(&#39;name&#39;,&#39;itheima&#39;)        #输出响应结果，如果添加成功则返回True，否则返回False        print(result)    except Exception as e:        print(e)</code></pre><h4 id="string-获取"><a href="#string-获取" class="headerlink" title="string-获取"></a>string-获取</h4><ul><li>⽅法get，添加键对应的值，如果键存在则返回对应的值，如果键不存在则返回None</li><li>编写代码如下</li></ul><pre><code class="python">from redis import *if __name__==&quot;__main__&quot;:    try:        #创建StrictRedis对象，与redis服务器建⽴连接        sr=StrictRedis()        #获取键name的值        result = sr.get(&#39;name&#39;)        #输出键的值，如果键不存在则返回None        print(result)    except Exception as e:        print(e)</code></pre><h4 id="string-修改"><a href="#string-修改" class="headerlink" title="string-修改"></a>string-修改</h4><ul><li>⽅法set，如果键已经存在则进⾏修改，如果键不存在则进⾏添加</li><li>编写代码如下</li></ul><pre><code class="python">from redis import *if __name__==&quot;__main__&quot;:    try:        #创建StrictRedis对象，与redis服务器建⽴连接        sr=StrictRedis()        #设置键name的值，如果键已经存在则进⾏修改，如果键不存在则进⾏添加        result = sr.set(&#39;name&#39;,&#39;itcast&#39;)        #输出响应结果，如果操作成功则返回True，否则返回False        print(result)    except Exception as e:        print(e)</code></pre><h4 id="string-删除"><a href="#string-删除" class="headerlink" title="string-删除"></a>string-删除</h4><ul><li>⽅法delete，删除键及对应的值，如果删除成功则返回受影响的键数，否则则返 回0</li><li>编写代码如下</li></ul><pre><code class="python">from redis import *if __name__==&quot;__main__&quot;:    try:        #创建StrictRedis对象，与redis服务器建⽴连接        sr=StrictRedis()        #设置键name的值，如果键已经存在则进⾏修改，如果键不存在则进⾏添加        result = sr.delete(&#39;name&#39;)        #输出响应结果，如果删除成功则返回受影响的键数，否则则返回0        print(result)    except Exception as e:        print(e)</code></pre><h4 id="获取键"><a href="#获取键" class="headerlink" title="获取键"></a>获取键</h4><ul><li>⽅法keys，根据正则表达式获取键</li><li>编写代码如下</li></ul><pre><code class="python">from redis import *if __name__==&quot;__main__&quot;:    try:        #创建StrictRedis对象，与redis服务器建⽴连接        sr=StrictRedis()        #获取所有的键        result=sr.keys()        #输出响应结果，所有的键构成⼀个列表，如果没有键则返回空列表        print(result)    except Exception as e:        print(e)</code></pre><h3 id="StrictRedis对象⽅法"><a href="#StrictRedis对象⽅法" class="headerlink" title="StrictRedis对象⽅法"></a>StrictRedis对象⽅法</h3><ul><li>通过init创建对象，指定参数host、port与指定的服务器和端⼝连接，host默认为localhost，port默认为6379，db默认为0</li></ul><pre><code>sr = StrictRedis(host=&#39;localhost&#39;, port=6379, db=0)简写sr=StrictRedis()</code></pre><ul><li>根据不同的类型，拥有不同的实例⽅法可以调⽤，与前⾯学的redis命令对应，⽅法需要的参数与命令的参数⼀致</li></ul><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><ul><li>set</li><li>setex</li><li>mset</li><li>append</li><li>get</li><li>mget</li><li>key</li></ul><h4 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h4><ul><li>exists</li><li>type</li><li>delete</li><li>expire</li><li>getrange</li><li>ttl</li></ul><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><ul><li>hset</li><li>hmset</li><li>hkeys</li><li>hget</li><li>hmget</li><li>hvals</li><li>hdel</li></ul><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><ul><li>lpush</li><li>rpush</li><li>linsert</li><li>lrange</li><li>lset</li><li>lrem</li></ul><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><ul><li>sadd</li><li>smembers</li><li>srem</li></ul><h4 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h4><ul><li>zadd</li><li>zrange</li><li>zrangebyscore</li><li>zscore</li><li>zrem</li><li>zremrangebyscore</li></ul><h3 id="string-1"><a href="#string-1" class="headerlink" title="string"></a>string</h3><h4 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h4><ul><li>在桌面上创建redis目录</li><li>使用pycharm打开 redis目录</li><li>创建redis_string.py文件</li></ul><pre><code class="python">from redis import *if __name__==&quot;__main__&quot;:    try:        #创建StrictRedis对象，与redis服务器建⽴连接        sr=StrictRedis()    except Exception as e:        print(e)</code></pre><h4 id="string-增加-1"><a href="#string-增加-1" class="headerlink" title="string-增加"></a>string-增加</h4><ul><li>⽅法set，添加键、值，如果添加成功则返回True，如果添加失败则返回False</li><li>编写代码如下</li></ul><pre><code class="python">from redis import *if __name__==&quot;__main__&quot;:    try:        #创建StrictRedis对象，与redis服务器建⽴连接        sr=StrictRedis()        #添加键name，值为itheima        result=sr.set(&#39;name&#39;,&#39;itheima&#39;)        #输出响应结果，如果添加成功则返回True，否则返回False        print(result)    except Exception as e:        print(e)</code></pre><h4 id="string-获取-1"><a href="#string-获取-1" class="headerlink" title="string-获取"></a>string-获取</h4><ul><li>⽅法get，添加键对应的值，如果键存在则返回对应的值，如果键不存在则返回None</li><li>编写代码如下</li></ul><pre><code class="python">from redis import *if __name__==&quot;__main__&quot;:    try:        #创建StrictRedis对象，与redis服务器建⽴连接        sr=StrictRedis()        #获取键name的值        result = sr.get(&#39;name&#39;)        #输出键的值，如果键不存在则返回None        print(result)    except Exception as e:        print(e)</code></pre><h4 id="string-修改-1"><a href="#string-修改-1" class="headerlink" title="string-修改"></a>string-修改</h4><ul><li>⽅法set，如果键已经存在则进⾏修改，如果键不存在则进⾏添加</li><li>编写代码如下</li></ul><pre><code class="python">from redis import *if __name__==&quot;__main__&quot;:    try:        #创建StrictRedis对象，与redis服务器建⽴连接        sr=StrictRedis()        #设置键name的值，如果键已经存在则进⾏修改，如果键不存在则进⾏添加        result = sr.set(&#39;name&#39;,&#39;itcast&#39;)        #输出响应结果，如果操作成功则返回True，否则返回False        print(result)    except Exception as e:        print(e)</code></pre><h4 id="string-删除-1"><a href="#string-删除-1" class="headerlink" title="string-删除"></a>string-删除</h4><ul><li>⽅法delete，删除键及对应的值，如果删除成功则返回受影响的键数，否则则返 回0</li><li>编写代码如下</li></ul><pre><code class="python">from redis import *if __name__==&quot;__main__&quot;:    try:        #创建StrictRedis对象，与redis服务器建⽴连接        sr=StrictRedis()        #设置键name的值，如果键已经存在则进⾏修改，如果键不存在则进⾏添加        result = sr.delete(&#39;name&#39;)        #输出响应结果，如果删除成功则返回受影响的键数，否则则返回0        print(result)    except Exception as e:        print(e)</code></pre><h4 id="获取键-1"><a href="#获取键-1" class="headerlink" title="获取键"></a>获取键</h4><ul><li>⽅法keys，根据正则表达式获取键</li><li>编写代码如下</li></ul><pre><code class="python">from redis import *if __name__==&quot;__main__&quot;:    try:        #创建StrictRedis对象，与redis服务器建⽴连接        sr=StrictRedis()        #获取所有的键        result=sr.keys()        #输出响应结果，所有的键构成⼀个列表，如果没有键则返回空列表        print(result)    except Exception as e:        print(e)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h1&gt;&lt;h3 id=&quot;nosql介绍&quot;&gt;&lt;a href=&quot;#nosql介绍&quot; class=&quot;headerlink&quot; title=&quot;nosql介绍&quot;&gt;&lt;/a&gt;nosql介绍&lt;/h3&gt;&lt;h3 id=&quot;NoSQL：一类新出现的数据库-not-only-sql&quot;&gt;&lt;a href=&quot;#NoSQL：一类新出现的数据库-not-only-sql&quot; class=&quot;headerlink&quot; title=&quot;NoSQL：一类新出现的数据库(not only sql)&quot;&gt;&lt;/a&gt;NoSQL：一类新出现的数据库(not only sql)&lt;/h3&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://caijinbo.work/categories/python/"/>
    
    
      <category term="python" scheme="https://caijinbo.work/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python高级11-mini-Web框架</title>
    <link href="https://caijinbo.work/2020/08/22/2020-08-23-python%E9%AB%98%E7%BA%A711-mini-Web%E6%A1%86%E6%9E%B6/"/>
    <id>https://caijinbo.work/2020/08/22/2020-08-23-python%E9%AB%98%E7%BA%A711-mini-Web%E6%A1%86%E6%9E%B6/</id>
    <published>2020-08-22T16:00:00.000Z</published>
    <updated>2020-11-23T10:13:48.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mini-Web框架"><a href="#mini-Web框架" class="headerlink" title="mini-Web框架"></a>mini-Web框架</h1><h2 id="一、web框架概述"><a href="#一、web框架概述" class="headerlink" title="一、web框架概述"></a>一、web框架概述</h2><h3 id="1-web框架和web服务器的关系介绍"><a href="#1-web框架和web服务器的关系介绍" class="headerlink" title="1. web框架和web服务器的关系介绍"></a>1. web框架和web服务器的关系介绍</h3><a id="more"></a><p><strong>使用web框架专门负责处理用户的动态资源请求，这个web框架其实就是一个为web服务器提供服务的应用程序</strong>，简称web框架。</p><p><img src="E:%5Ccaijinbo_posts%5Cpicture/web%E6%A1%86%E6%9E%B6%E5%92%8Cweb%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="web框架和web服务器的关系"></p><p><strong>关系说明:</strong></p><ul><li>web服务器接收浏览器发起的请求，如果是动态资源请求找web框架来处理</li><li>web框架负责处理浏览器的动态资源请求，把处理的结果发生给web服务器</li><li>web服务器再把响应结果发生给浏览器</li></ul><h3 id="2-静态资源"><a href="#2-静态资源" class="headerlink" title="2. 静态资源"></a>2. 静态资源</h3><p>不需要经常变化的资源，这种资源web服务器可以提前准备好，比如: png/jpg/css/js等文件。</p><h3 id="3-动态资源"><a href="#3-动态资源" class="headerlink" title="3. 动态资源"></a>3. 动态资源</h3><p>和静态资源相反, 这种资源会经常变化，比如: 我们在京东浏览商品时经常会根据条件进行筛选，选择不同条件, 浏览的商品就不同，这种资源web服务器无法提前准备好，需要web框架来帮web服务器进行准备，在这里web服务器可以把.html的资源请求认为是动态资源请求交由web框架进行处理。</p><h3 id="4-WSGI协议"><a href="#4-WSGI协议" class="headerlink" title="4. WSGI协议"></a>4. WSGI协议</h3><p>它是web服务器和web框架之间进行协同工作的一个规则，WSGI协议规定web服务器把动态资源的请求信息传给web框架处理，web框架把处理好的结果返回给web服务器。</p><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><ul><li>web框架是专门为web服务器处理动态资源请求的一个应用程序</li><li>web框架和web服务器的关系是web框架专门服务于web服务器，给web服务器提供处理动态资源请求的服务。</li></ul><h2 id="二、框架程序开发"><a href="#二、框架程序开发" class="headerlink" title="二、框架程序开发"></a>二、框架程序开发</h2><h3 id="1-框架职责介绍"><a href="#1-框架职责介绍" class="headerlink" title="1. 框架职责介绍"></a>1. 框架职责介绍</h3><ul><li>接收web服务器的动态资源请求，给web服务器提供处理动态资源请求的服务。</li></ul><h3 id="2-动态资源判断"><a href="#2-动态资源判断" class="headerlink" title="2. 动态资源判断"></a>2. 动态资源判断</h3><ul><li>根据请求资源路径的后缀名进行判断<ul><li>如果请求资源路径的后缀名是.html则是动态资源请求, 让web框架程序进行处理。</li><li>否则是静态资源请求，让web服务器程序进行处理。</li></ul></li></ul><p><strong>web服务器程序(web.py)代码:</strong></p><pre><code class="python">import socketimport threadingimport sysimport framework# 定义web服务器类class HttpWebServer(object):    def __init__(self, port):        # 创建tcp服务端套接字        tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        # 设置端口号复用, 程序退出端口立即释放        tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)        # 绑定端口号        tcp_server_socket.bind((&quot;&quot;, port))        # 设置监听        tcp_server_socket.listen(128)        self.tcp_server_socket = tcp_server_socket    # 处理客户的请求    @staticmethod    def handle_client_quest(new_socket):        # 代码执行到此，说明连接建立成功        recv_client_data = new_socket.recv(4096)        if len(recv_client_data) == 0:            print(&quot;关闭浏览器了&quot;)            # 关闭服务与客户端的套接字            new_socket.close()            return        # 对二进制数据进行解码        recv_client_content = recv_client_data.decode(&quot;utf-8&quot;)        print(recv_client_content)        # 根据指定字符串进行分割， 最大分割次数指定2        request_list = recv_client_content.split(&quot; &quot;, maxsplit=2)        # 获取请求资源路径        request_path = request_list[1]        print(request_path)        # 判断请求的是否是根目录，如果条件成立，指定首页数据返回        if request_path == &quot;/&quot;:            request_path = &quot;/index.html&quot;        # 判断是否是动态资源请求        if request_path.endswith(&quot;.html&quot;):            &quot;&quot;&quot;这里是动态资源请求，把请求信息交给框架处理&quot;&quot;&quot;            # 字典存储用户的请求信息            env = {                &quot;request_path&quot;: request_path            }            # 获取处理结果            status, headers, response_body = framework.handle_request(env)            # 使用框架处理的数据拼接响应报文            # 响应行            response_line = &quot;HTTP/1.1 %s\r\n&quot; % status            # 响应头            response_header = &quot;&quot;            # 遍历头部信息            for header in headers:                # 拼接多个响应头                response_header += &quot;%s: %s\r\n&quot; % header            response_data = (response_line +                             response_header +                             &quot;\r\n&quot; +                             response_body).encode(&quot;utf-8&quot;)            # 发送数据            new_socket.send(response_data)            # 关闭socket            new_socket.close()        else:            &quot;&quot;&quot;这里是静态资源请求&quot;&quot;&quot;            try:                # 动态打开指定文件                with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file:                    # 读取文件数据                    file_data = file.read()            except Exception as e:                # 请求资源不存在，返回404数据                # 响应行                response_line = &quot;HTTP/1.1 404 Not Found\r\n&quot;                # 响应头                response_header = &quot;Server: PWS1.0\r\n&quot;                with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file:                    file_data = file.read()                # 响应体                response_body = file_data                # 拼接响应报文                response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body                # 发送数据                new_socket.send(response_data)            else:                # 响应行                response_line = &quot;HTTP/1.1 200 OK\r\n&quot;                # 响应头                response_header = &quot;Server: PWS1.0\r\n&quot;                # 响应体                response_body = file_data                # 拼接响应报文                response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body                # 发送数据                new_socket.send(response_data)            finally:                # 关闭服务与客户端的套接字                new_socket.close()    def start(self):        while True:            # 等待接受客户端的连接请求            new_socket, ip_port = self.tcp_server_socket.accept()            sub_thread = threading.Thread(target=self.handle_client_quest, args=(new_socket,))            # 设置守护线程            sub_thread.setDaemon(True)            sub_thread.start()# 程序入口函数def main():    # 获取命令行参数判断长度    if len(sys.argv) != 2:        print(&quot;执行命令如下: python3 xxx.py 9000&quot;)        return    # 判断端口号是否是数字    if not sys.argv[1].isdigit():        print(&quot;执行命令如下: python3 xxx.py 9000&quot;)        return    # 需要转成int类型    port = int(sys.argv[1])    # 创建web服务器    web_server = HttpWebServer(port)    # 启动web服务器    web_server.start()if __name__ == &#39;__main__&#39;:    main()</code></pre><h3 id="3-处理客户端的动态资源请求"><a href="#3-处理客户端的动态资源请求" class="headerlink" title="3. 处理客户端的动态资源请求"></a>3. 处理客户端的动态资源请求</h3><ol><li>创建web框架程序</li><li>接收web服务器的动态资源请求</li><li>处理web服务器的动态资源请求并把处理结果返回给web服务器</li><li>web服务器把处理结果组装成响应报文发送给浏览器</li></ol><p><strong>web框架程序(framework.py)代码:</strong></p><pre><code class="python">&quot;&quot;&quot;miniweb框架，负责处理动态资源请求&quot;&quot;&quot;import time# 获取首页数据def index():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 处理后的数据    data = time.ctime()    return status, response_header, data# 没有找到动态资源def not_found():    # 响应状态    status = &quot;404 Not Found&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 处理后的数据    data = &quot;not found&quot;    return status, response_header, data# 处理动态资源请求def handle_request(env):    # 获取动态请求资源路径    request_path = env[&quot;request_path&quot;]    print(&quot;接收到的动态资源请求:&quot;, request_path)    if request_path == &quot;/index.html&quot;:        # 获取首页数据        result = index()        return result    else:        # 没有找到动态资源        result = not_found()        return result</code></pre><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><ul><li>动态资源的判断通过请求资源路径的后缀是.html来完成，否则是静态资源</li><li>处理客户端的动态资源请求<ol><li>接收web服务器的动态资源请求</li><li>处理动态资源请求并把处理结果返回给web服务器</li><li>web服务器把处理结果组装成响应报文发送给浏览器</li></ol></li></ul><h2 id="三、模板替换功能开发"><a href="#三、模板替换功能开发" class="headerlink" title="三、模板替换功能开发"></a>三、模板替换功能开发</h2><h3 id="1-读取股票信息模板文件"><a href="#1-读取股票信息模板文件" class="headerlink" title="1. 读取股票信息模板文件"></a>1. 读取股票信息模板文件</h3><p><strong>framework.py示例代码:</strong></p><pre><code class="python"># 获取首页数据def index():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/index.html&quot;, &quot;r&quot;) as file:        file_data = file.read()</code></pre><h3 id="2-使用模拟数据替换模板变量"><a href="#2-使用模拟数据替换模板变量" class="headerlink" title="2. 使用模拟数据替换模板变量"></a>2. 使用模拟数据替换模板变量</h3><p><strong>framework.py示例代码:</strong></p><pre><code class="python"># 获取首页数据def index():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 1. 打开模板文件，读取数据    with open(&quot;template/index.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 处理后的数据, 从数据库查询    data = time.ctime()    # 2. 替换模板文件中的模板遍历    result = file_data.replace(&quot;{%content%}&quot;, data)    return status, response_header, result</code></pre><h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h3><ul><li>模板替换功能<ol><li>打开template目录下的index.html模板文件，读取模板文件数据</li><li>把模板文件中的模板变量进行替换</li></ol></li></ul><h2 id="四、路由列表功能开发"><a href="#四、路由列表功能开发" class="headerlink" title="四、路由列表功能开发"></a>四、路由列表功能开发</h2><h3 id="1-路由的介绍"><a href="#1-路由的介绍" class="headerlink" title="1. 路由的介绍"></a>1. 路由的介绍</h3><p>接着上面程序的判断场景，假如咱们再处理一个个人中心的动态资源请求非常简单，再添加一个函数和更加一个分支判断就可以实现了。</p><p><strong>framework.py 示例代码:</strong></p><pre><code class="python"># 获取个人中心数据def center():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/center.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 处理后的数据, 从数据库查询    data = time.ctime()    # 替换模板文件中的模板遍历    result = file_data.replace(&quot;{%content%}&quot;, data)    return status, response_header, result# 处理动态资源请求def handle_request(env):    # 获取动态请求资源路径    request_path = env[&quot;request_path&quot;]    print(&quot;接收到的动态资源请求:&quot;, request_path)    if request_path == &quot;/index.html&quot;:        # 获取首页数据        result = index()        return result    elif request_path == &quot;/center.html&quot;:        # 获取个人中心数据        result = center()        return result    else:        # 没有找到动态资源        result = not_found()        return result</code></pre><p>那如果咱们的框架处理的页面请求路径再多一些，比如:5个路径判断，大家可能感觉条件分支完全可以胜任，如果是40个甚至更多呢? 如果这是还是用普通的条件分支简直无法忍受。</p><p>解决办法: <strong>可以使用路由</strong></p><p><strong>什么是路由？</strong></p><p>路由就是请求的URL到处理函数的映射，也就是说提前把请求的URL和处理函数关联好。</p><p><strong>路由列表</strong></p><p>这么多的路由如何管理呢， 可以使用一个路由列表进行管理，通过路由列表保存每一个路由。</p><table><thead><tr><th align="left">请求路径</th><th align="left">处理函数</th></tr></thead><tbody><tr><td align="left">/login.html</td><td align="left">login函数</td></tr><tr><td align="left">/index.html</td><td align="left">index函数</td></tr><tr><td align="left">/center.html</td><td align="left">center函数</td></tr></tbody></table><h3 id="2-在路由列表添加路由"><a href="#2-在路由列表添加路由" class="headerlink" title="2. 在路由列表添加路由"></a>2. 在路由列表添加路由</h3><p><strong>framework.py 示例代码:</strong></p><pre><code class="python"># 定义路由列表route_list = [    (&quot;/index.html&quot;, index),    (&quot;/center.html&quot;, center)]</code></pre><h3 id="3-根据用户请求遍历路由列表处理用户请求"><a href="#3-根据用户请求遍历路由列表处理用户请求" class="headerlink" title="3. 根据用户请求遍历路由列表处理用户请求"></a>3. 根据用户请求遍历路由列表处理用户请求</h3><p><strong>framework.py 示例代码:</strong></p><pre><code class="python"># 处理动态资源请求def handle_request(env):    # 获取动态请求资源路径    request_path = env[&quot;request_path&quot;]    print(&quot;接收到的动态资源请求:&quot;, request_path)    # 遍历路由列表，选择执行的函数    for path, func in route_list:        if request_path == path:            result = func()            return result    else:        # 没有找到动态资源        result = not_found()        return result    # if request_path == &quot;/index.html&quot;:    #     # 获取首页数据    #     result = index()    #     return result    # elif request_path == &quot;/center.html&quot;:    #     # 获取个人中心数据    #     result = center()    #     return result    # else:    #     # 没有找到动态资源    #     result = not_found()    #     return result</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>路由是请求的URL到处理函数的映射</li><li>路由列表是用来保存每一个设置好的路由</li><li>用户的动态资源请求通过遍历路由列表找到对应的处理函数来完成。</li></ul><h2 id="五、装饰器方式的添加路由"><a href="#五、装饰器方式的添加路由" class="headerlink" title="五、装饰器方式的添加路由"></a>五、装饰器方式的添加路由</h2><h3 id="1-使用带有参数的装饰器添加路由"><a href="#1-使用带有参数的装饰器添加路由" class="headerlink" title="1. 使用带有参数的装饰器添加路由"></a>1. 使用带有参数的装饰器添加路由</h3><p>前面我们已经实现了路由列表，但是每次添加路由都需要手动添加来完成，接下来我们想要完成路由的自动添加，可以通过装饰器来实现，在使用装饰器对处理函数进行装饰的时候我们需要知道装饰的函数和那个请求路径进行关联，也就是说装饰器需要接收一个url参数，这样我们定义的装饰器是一个带有参数的装饰器。</p><p><strong>示例代码:</strong></p><pre><code class="python">&quot;&quot;&quot;miniweb框架，负责处理动态资源请求&quot;&quot;&quot;import time# 定义路由列表route_list = []# 定义带有参数的装饰器def route(path):    # 装饰器    def decorator(func):        # 当执行装饰器装饰指定函数的时候，把路径和函数添加到路由列表        route_list.append((path, func))        def inner():            # 执行指定函数            return func()        return inner    # 返回装饰器    return decorator# 获取首页数据@route(&quot;/index.html&quot;)def index():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/index.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 处理后的数据, 从数据库查询    data = time.ctime()    # 替换模板文件中的模板遍历    result = file_data.replace(&quot;{%content%}&quot;, data)    return status, response_header, result# 获取个人中心数据@route(&quot;/center.html&quot;)def center():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/center.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 处理后的数据, 从数据库查询    data = time.ctime()    # 替换模板文件中的模板遍历    result = file_data.replace(&quot;{%content%}&quot;, data)    return status, response_header, result# 没有找到动态资源def not_found():    # 响应状态    status = &quot;404 Not Found&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 处理后的数据    data = &quot;not found&quot;    return status, response_header, data# 处理动态资源请求def handle_request(env):    # 获取动态请求资源路径    request_path = env[&quot;request_path&quot;]    print(&quot;接收到的动态资源请求:&quot;, request_path)    # 遍历路由列表，选择执行的函数    for path, func in route_list:        if request_path == path:            result = func()            return result    else:        # 没有找到动态资源        result = not_found()        return result</code></pre><h3 id="2-小结"><a href="#2-小结" class="headerlink" title="2. 小结"></a>2. 小结</h3><ul><li>使用带有参数的装饰器对处理函数进行装饰，并完成路由的添加功能。</li></ul><h2 id="六、显示股票信息页面的开发"><a href="#六、显示股票信息页面的开发" class="headerlink" title="六、显示股票信息页面的开发"></a>六、显示股票信息页面的开发</h2><h3 id="1-数据准备"><a href="#1-数据准备" class="headerlink" title="1. 数据准备"></a>1. 数据准备</h3><pre><code class="sql">-- 创建数据库create database stock_db charset=utf8;-- 切换数据库use stock_db;-- 执行sql文件source stock_db.sql;</code></pre><h3 id="2-根据sql语句查询股票信息"><a href="#2-根据sql语句查询股票信息" class="headerlink" title="2. 根据sql语句查询股票信息"></a>2. 根据sql语句查询股票信息</h3><p><strong>示例代码:</strong></p><pre><code class="python"># 获取首页数据@route(&quot;/index.html&quot;)def index():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/index.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 处理后的数据, 从数据库查询    conn = pymysql.connect(host=&quot;localhost&quot;,                           port=3306,                           user=&quot;root&quot;,                           password=&quot;mysql&quot;,                           database=&quot;stock_db&quot;,                           charset=&quot;utf8&quot;)    # 获取游标    cursor = conn.cursor()    # 查询sql语句    sql = &quot;select * from info;&quot;    # 执行sql    cursor.execute(sql)    # 获取结果集    result = cursor.fetchall()    print(result)</code></pre><h3 id="3-使用查询数据替换模板变量"><a href="#3-使用查询数据替换模板变量" class="headerlink" title="3. 使用查询数据替换模板变量"></a>3. 使用查询数据替换模板变量</h3><p><strong>示例代码:</strong></p><pre><code class="python"># 获取首页数据@route(&quot;/index.html&quot;)def index():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/index.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 处理后的数据, 从数据库查询    conn = pymysql.connect(host=&quot;localhost&quot;,                           port=3306,                           user=&quot;root&quot;,                           password=&quot;mysql&quot;,                           database=&quot;stock_db&quot;,                           charset=&quot;utf8&quot;)    # 获取游标    cursor = conn.cursor()    # 查询sql语句    sql = &quot;select * from info;&quot;    # 执行sql    cursor.execute(sql)    # 获取结果集    result = cursor.fetchall()    print(result)    data = &quot;&quot;    for row in result:        data += &#39;&#39;&#39;&lt;tr&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;&lt;input type=&quot;button&quot; value=&quot;添加&quot; id=&quot;toAdd&quot; name=&quot;toAdd&quot; systemidvaule=&quot;000007&quot;&gt;&lt;/td&gt;                   &lt;/tr&gt;&#39;&#39;&#39; % row    # 替换模板文件中的模板遍历    result = file_data.replace(&quot;{%content%}&quot;, data)    return status, response_header, result</code></pre><h3 id="4-小结-1"><a href="#4-小结-1" class="headerlink" title="4. 小结"></a>4. 小结</h3><ul><li>根据sql语句查询股票信息</li><li>使用查询数据替换模板变量</li></ul><h2 id="七、个人中心数据接口的开发"><a href="#七、个人中心数据接口的开发" class="headerlink" title="七、个人中心数据接口的开发"></a>七、个人中心数据接口的开发</h2><h3 id="1-根据sql语句查询个人中心数据"><a href="#1-根据sql语句查询个人中心数据" class="headerlink" title="1. 根据sql语句查询个人中心数据"></a>1. 根据sql语句查询个人中心数据</h3><pre><code class="python"># 个人中心数据接口开发@route(&quot;/center_data.html&quot;)def center_data():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;), (&quot;Content-Type&quot;, &quot;text/html;charset=utf-8&quot;)]    conn = pymysql.connect(host=&quot;localhost&quot;,                           port=3306,                           user=&quot;root&quot;,                           password=&quot;mysql&quot;,                           database=&quot;stock_db&quot;,                           charset=&quot;utf8&quot;)    # 获取游标    cursor = conn.cursor()    # 查询sql语句    sql = &#39;&#39;&#39;select i.code, i.short, i.chg,              i.turnover, i.price, i.highs, f.note_info              from info as i inner join focus as f on i.id = f.info_id;&#39;&#39;&#39;    # 执行sql    cursor.execute(sql)    # 获取结果集    result = cursor.fetchall()    # 关闭游标    cursor.close()    # 关闭数据库连接    conn.close()    print(result)</code></pre><h3 id="2-将个人中心数据转成json字符串并返回"><a href="#2-将个人中心数据转成json字符串并返回" class="headerlink" title="2. 将个人中心数据转成json字符串并返回"></a>2. 将个人中心数据转成json字符串并返回</h3><pre><code class="python"># 个人中心数据接口开发@route(&quot;/center_data.html&quot;)def center_data():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;), (&quot;Content-Type&quot;, &quot;text/html;charset=utf-8&quot;)]    conn = pymysql.connect(host=&quot;localhost&quot;,                           port=3306,                           user=&quot;root&quot;,                           password=&quot;mysql&quot;,                           database=&quot;stock_db&quot;,                           charset=&quot;utf8&quot;)    # 获取游标    cursor = conn.cursor()    # 查询sql语句    sql = &#39;&#39;&#39;select i.code, i.short, i.chg,              i.turnover, i.price, i.highs, f.note_info              from info as i inner join focus as f on i.id = f.info_id;&#39;&#39;&#39;    # 执行sql    cursor.execute(sql)    # 获取结果集    result = cursor.fetchall()    # 关闭游标    cursor.close()    # 关闭数据库连接    conn.close()    # 个人中心数据列表    center_data_list = list()    # 遍历每一行数据转成字典    for row in result:        # 创建空的字典        center_dict = dict()        center_dict[&quot;code&quot;] = row[0]        center_dict[&quot;short&quot;] = row[1]        center_dict[&quot;chg&quot;] = row[2]        center_dict[&quot;turnover&quot;] = row[3]        center_dict[&quot;price&quot;] = str(row[4])        center_dict[&quot;highs&quot;] = str(row[5])        center_dict[&quot;note_info&quot;] = row[6]        # 添加每个字典信息        center_data_list.append(center_dict)    # 把列表字典转成json字符串, 并在控制台显示    json_str = json.dumps(center_data_list,ensure_ascii=False)    print(json_str)    return status, response_header, json_str</code></pre><p><strong>代码说明:</strong></p><ul><li>json.dumps函数把字典转成json字符串<ol><li>函数的第一个参数表示要把指定对象转成json字符串</li><li>参数的第二个参数ensure_ascii=False表示不使用ascii编码，可以在控制台显示中文。</li></ol></li><li>响应头添加Content-Type表示指定数据的编码格式</li></ul><h3 id="3-小结-1"><a href="#3-小结-1" class="headerlink" title="3. 小结"></a>3. 小结</h3><ul><li>web框架程序还可以开发数据接口，为客户端程序提供数据服务。<ul><li><ol><li>根据sql语句查询数据库</li></ol></li><li><ol><li>把数据转成json字符串返回</li></ol></li><li><ol><li>浏览器通过指定接口地址获取web框架提供的数据。</li></ol></li></ul></li></ul><h2 id="八、ajax请求数据渲染个人中心页面"><a href="#八、ajax请求数据渲染个人中心页面" class="headerlink" title="八、ajax请求数据渲染个人中心页面"></a>八、ajax请求数据渲染个人中心页面</h2><h3 id="1-根据用户请求返回个人中心空模板文件数据"><a href="#1-根据用户请求返回个人中心空模板文件数据" class="headerlink" title="1. 根据用户请求返回个人中心空模板文件数据"></a>1. 根据用户请求返回个人中心空模板文件数据</h3><pre><code class="python"># 获取个人中心数据@route(&quot;/center.html&quot;)def center():    # 响应状态    status = &quot;200 OK&quot;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/center.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 替换模板文件中的模板遍历    result = file_data.replace(&quot;{%content%}&quot;, &quot;&quot;)    return status, response_header, result</code></pre><h3 id="2-在个人中心模板文件添加ajax请求获取个人中心数据"><a href="#2-在个人中心模板文件添加ajax请求获取个人中心数据" class="headerlink" title="2. 在个人中心模板文件添加ajax请求获取个人中心数据"></a>2. 在个人中心模板文件添加ajax请求获取个人中心数据</h3><pre><code class="js">// 发送ajax请求获取个人中心页面数据// 路径写成 center_data.html，发送ajax的时候路径其实是http://ip地址:端口号/center.data.html$.get(&quot;center_data.html&quot;, function (data) {        alert(data);    }}, &quot;json&quot;);</code></pre><h3 id="3-将个人中心数据在页面完成展示"><a href="#3-将个人中心数据在页面完成展示" class="headerlink" title="3. 将个人中心数据在页面完成展示"></a>3. 将个人中心数据在页面完成展示</h3><pre><code class="js">// 发送ajax请求获取个人中心页面数据$.get(&quot;center_data.html&quot;, function (data) {    var data_array = data;    // 获取table标签对象    var $table = $(&quot;.table&quot;)    for(var i = 0; i &lt; data_array.length; i++){        // 获取每一条对象        var center_obj = data_array[i];        var row_html = &#39;&lt;tr&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.code +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.short +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.chg +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.turnover +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.price +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.highs +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.note_info +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&lt;a type=&quot;button&quot; class=&quot;btn btn-default btn-xs&quot; href=&quot;/update/000007.html&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-star&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; 修改 &lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;button&quot; value=&quot;删除&quot; id=&quot;toDel&quot; name=&quot;toDel&quot; systemidvaule=&quot;000007&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&#39;;        // 为table标签添加每一行组装的html数据        $table.append(row_html);    }}, &quot;json&quot;);</code></pre><h3 id="4-小结-2"><a href="#4-小结-2" class="headerlink" title="4. 小结"></a>4. 小结</h3><ul><li>根据用户请求返回个人中心空模板文件数据</li><li>在个人中心模板文件添加ajax请求获取个人中心数据</li><li>将个人中心数据在页面完成展示</li></ul><h2 id="九、logging日志"><a href="#九、logging日志" class="headerlink" title="九、logging日志"></a>九、logging日志</h2><h3 id="1-logging日志的介绍"><a href="#1-logging日志的介绍" class="headerlink" title="1. logging日志的介绍"></a>1. logging日志的介绍</h3><p>在现实生活中，记录日志非常重要，比如:银行转账时会有转账记录；飞机飞行过程中，会有个黑盒子（飞行数据记录器）记录着飞机的飞行过程，那在咱们python程序中想要记录程序在运行时所产生的日志信息，怎么做呢?</p><p>可以使用 <strong>logging</strong> 这个包来完成</p><p><strong>记录程序日志信息的目的是:</strong></p><ol><li>可以很方便的了解程序的运行情况</li><li>可以分析用户的操作行为、喜好等信息</li><li>方便开发人员检查bug</li></ol><h3 id="2-logging日志级别介绍"><a href="#2-logging日志级别介绍" class="headerlink" title="2. logging日志级别介绍"></a>2. logging日志级别介绍</h3><p>日志等级可以分为5个，从低到高分别是:</p><ol><li>DEBUG</li><li>INFO</li><li>WARNING</li><li>ERROR</li><li>CRITICAL</li></ol><p><strong>日志等级说明:</strong></p><ul><li>DEBUG：程序调试bug时使用</li><li>INFO：程序正常运行时使用</li><li>WARNING：程序未按预期运行时使用，但并不是错误，如:用户登录密码错误</li><li>ERROR：程序出错误时使用，如:IO操作失败</li><li>CRITICAL：特别严重的问题，导致程序不能再继续运行时使用，如:磁盘空间为空，一般很少使用</li><li>默认的是WARNING等级，当在WARNING或WARNING之上等级的才记录日志信息。</li><li>日志等级从低到高的顺序是: DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL</li></ul><h3 id="3-logging日志的使用"><a href="#3-logging日志的使用" class="headerlink" title="3. logging日志的使用"></a>3. logging日志的使用</h3><p>在 logging 包中记录日志的方式有两种:</p><ol><li>输出到控制台</li><li>保存到日志文件</li></ol><p><strong>日志信息输出到控制台的示例代码:</strong></p><pre><code class="python">import logginglogging.debug(&#39;这是一个debug级别的日志信息&#39;)logging.info(&#39;这是一个info级别的日志信息&#39;)logging.warning(&#39;这是一个warning级别的日志信息&#39;)logging.error(&#39;这是一个error级别的日志信息&#39;)logging.critical(&#39;这是一个critical级别的日志信息&#39;)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">WARNING:root:这是一个warning级别的日志信息ERROR:root:这是一个error级别的日志信息CRITICAL:root:这是一个critical级别的日志信息</code></pre><p><strong>说明:</strong></p><ul><li>日志信息只显示了大于等于WARNING级别的日志，这说明默认的日志级别设置为WARNING</li></ul><p><strong>logging日志等级和输出格式的设置:</strong></p><pre><code class="python">import logging# 设置日志等级和输出日志格式logging.basicConfig(level=logging.DEBUG,                    format=&#39;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&#39;)logging.debug(&#39;这是一个debug级别的日志信息&#39;)logging.info(&#39;这是一个info级别的日志信息&#39;)logging.warning(&#39;这是一个warning级别的日志信息&#39;)logging.error(&#39;这是一个error级别的日志信息&#39;)logging.critical(&#39;这是一个critical级别的日志信息&#39;)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">2019-02-13 20:41:33,080 - hello.py[line:6] - DEBUG: 这是一个debug级别的日志信息2019-02-13 20:41:33,080 - hello.py[line:7] - INFO: 这是一个info级别的日志信息2019-02-13 20:41:33,080 - hello.py[line:8] - WARNING: 这是一个warning级别的日志信息2019-02-13 20:41:33,080 - hello.py[line:9] - ERROR: 这是一个error级别的日志信息2019-02-13 20:41:33,080 - hello.py[line:10] - CRITICAL: 这是一个critical级别的日志信息</code></pre><p><strong>代码说明:</strong></p><ul><li>level 表示设置的日志等级</li><li>format 表示日志的输出格式, 参数说明:<ul><li>%(levelname)s: 打印日志级别名称</li><li>%(filename)s: 打印当前执行程序名</li><li>%(lineno)d: 打印日志的当前行号</li><li>%(asctime)s: 打印日志的时间</li><li>%(message)s: 打印日志信息</li></ul></li></ul><p><strong>日志信息保存到日志文件的示例代码:</strong></p><pre><code class="python">import logginglogging.basicConfig(level=logging.DEBUG,                    format=&#39;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&#39;,                    filename=&quot;log.txt&quot;,                    filemode=&quot;w&quot;)logging.debug(&#39;这是一个debug级别的日志信息&#39;)logging.info(&#39;这是一个info级别的日志信息&#39;)logging.warning(&#39;这是一个warning级别的日志信息&#39;)logging.error(&#39;这是一个error级别的日志信息&#39;)logging.critical(&#39;这是一个critical级别的日志信息&#39;)</code></pre><h3 id="4-logging日志在mini-web项目中应用"><a href="#4-logging日志在mini-web项目中应用" class="headerlink" title="4. logging日志在mini-web项目中应用"></a>4. logging日志在mini-web项目中应用</h3><p><strong>web.py 程序使用logging日志示例:</strong></p><ol><li><p>程序入口模块设置logging日志的设置</p><pre><code class="python"> import socket import threading import sys import framework import logging # logging日志的配置 logging.basicConfig(level=logging.DEBUG,                     format=&#39;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&#39;,                     filename=&quot;log.txt&quot;,                     filemode=&quot;w&quot;)</code></pre></li><li><p>INFO级别的日志输出，示例代码:</p><pre><code class="python"> # 判断是否是动态资源请求 if request_path.endswith(&quot;.html&quot;):     &quot;&quot;&quot;这里是动态资源请求，把请求信息交给框架处理&quot;&quot;&quot;     logging.info(&quot;动态资源请求:&quot; + request_path)     ... else:     &quot;&quot;&quot;这里是静态资源请求&quot;&quot;&quot;     logging.info(&quot;静态资源请求:&quot; + request_path)     ...</code></pre></li><li><p>WARNING级别的日志输出，示例代码:</p><pre><code class="python"> # 获取命令行参数判断长度 if len(sys.argv) != 2:     print(&quot;执行命令如下: python3 xxx.py 9000&quot;)     logging.warning(&quot;用户在命令行启动程序参数个数不正确!&quot;)     return # 判断端口号是否是数字 if not sys.argv[1].isdigit():     print(&quot;执行命令如下: python3 xxx.py 9000&quot;)     logging.warning(&quot;用户在命令行启动程序参数不是数字字符串!&quot;)     return</code></pre></li></ol><p><strong>framework.py 程序使用logging日志示例:</strong></p><ol><li><p>ERROR级别的日志输出，示例代码:</p><pre><code class="python"> # 处理动态资源请求 def handle_request(env):     # 获取动态请求资源路径     request_path = env[&quot;request_path&quot;]     print(&quot;接收到的动态资源请求:&quot;, request_path)     # 遍历路由列表，选择执行的函数     for path, func in route_list:         if request_path == path:             result = func()             return result     else:         logging.error(&quot;没有设置相应的路由:&quot; + request_path)         # 没有找到动态资源         result = not_found()         return result</code></pre></li></ol><p><strong>说明:</strong></p><ul><li>logging日志配置信息在程序入口模块设置一次，整个程序都可以生效。<ul><li>logging.basicConfig 表示 logging 日志配置操作</li></ul></li></ul><h3 id="5-小结-1"><a href="#5-小结-1" class="headerlink" title="5. 小结"></a>5. 小结</h3><ul><li>记录python程序中日志信息使用 logging 包来完成</li><li>logging日志等级有5个:<ol><li>DEBUG</li><li>INFO</li><li>WARNING</li><li>ERROR</li><li>CRITICAL</li></ol></li><li>打印(记录)日志的函数有5个:<ol><li>logging.debug函数, 表示: 打印(记录)DEBUG级别的日志信息</li><li>logging.info函数, 表示: 打印(记录)INFO级别的日志信息</li><li>logging.warning函数, 表示: 打印(记录)WARNING级别的日志信息</li><li>logging.error函数, 表示: 打印(记录)ERROR级别的日志信息</li><li>logging.critical函数, 表示: 打印(记录)CRITICAL级别的日志信息</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mini-Web框架&quot;&gt;&lt;a href=&quot;#mini-Web框架&quot; class=&quot;headerlink&quot; title=&quot;mini-Web框架&quot;&gt;&lt;/a&gt;mini-Web框架&lt;/h1&gt;&lt;h2 id=&quot;一、web框架概述&quot;&gt;&lt;a href=&quot;#一、web框架概述&quot; class=&quot;headerlink&quot; title=&quot;一、web框架概述&quot;&gt;&lt;/a&gt;一、web框架概述&lt;/h2&gt;&lt;h3 id=&quot;1-web框架和web服务器的关系介绍&quot;&gt;&lt;a href=&quot;#1-web框架和web服务器的关系介绍&quot; class=&quot;headerlink&quot; title=&quot;1. web框架和web服务器的关系介绍&quot;&gt;&lt;/a&gt;1. web框架和web服务器的关系介绍&lt;/h3&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://caijinbo.work/categories/python/"/>
    
    
      <category term="python" scheme="https://caijinbo.work/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python高级09-闭包和装饰器</title>
    <link href="https://caijinbo.work/2020/08/22/2020-08-23-python%E9%AB%98%E7%BA%A709-%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>https://caijinbo.work/2020/08/22/2020-08-23-python%E9%AB%98%E7%BA%A709-%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/</id>
    <published>2020-08-22T16:00:00.000Z</published>
    <updated>2020-11-23T10:13:45.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="闭包和装饰器"><a href="#闭包和装饰器" class="headerlink" title="闭包和装饰器"></a>闭包和装饰器</h1><h2 id="一、闭包"><a href="#一、闭包" class="headerlink" title="一、闭包"></a>一、闭包</h2><h3 id="1-闭包的介绍"><a href="#1-闭包的介绍" class="headerlink" title="1. 闭包的介绍"></a>1. 闭包的介绍</h3><a id="more"></a><p>我们知道当函数调用完，函数内定义的变量都销毁了，但是我们有时候需要保存函数内的这个变量，每次在这个变量的基础上完成一些列的操作，比如: 每次在这个变量的基础上和其它数字进行求和计算，那怎么办呢?</p><p>我们就可以通过咱们今天学习的<strong>闭包</strong>来解决这个需求。</p><p><strong>闭包的定义:</strong></p><p>在函数嵌套的前提下，内部函数使用了外部函数的变量，并且外部函数返回了内部函数，我们把这个<strong>使用外部函数变量的内部函数称为闭包</strong>。</p><h3 id="2-闭包的构成条件"><a href="#2-闭包的构成条件" class="headerlink" title="2. 闭包的构成条件"></a>2. 闭包的构成条件</h3><p>通过闭包的定义，我们可以得知闭包的形成条件:</p><ol><li>在函数嵌套(函数里面再定义函数)的前提下</li><li>内部函数使用了外部函数的变量(还包括外部函数的参数)</li><li>外部函数返回了内部函数</li></ol><h3 id="3-简单闭包的示例代码"><a href="#3-简单闭包的示例代码" class="headerlink" title="3. 简单闭包的示例代码"></a>3. 简单闭包的示例代码</h3><pre><code class="python"># 定义一个外部函数def func_out(num1):    # 定义一个内部函数    def func_inner(num2):        # 内部函数使用了外部函数的变量(num1)        result = num1 + num2        print(&quot;结果是:&quot;, result)    # 外部函数返回了内部函数，这里返回的内部函数就是闭包    return func_inner# 创建闭包实例    f = func_out(1)# 执行闭包f(2)f(3)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">结果是: 3结果是: 4</code></pre><p><strong>闭包执行结果的说明:</strong></p><p>通过上面的输出结果可以看出闭包保存了外部函数内的变量num1，每次执行闭包都是在num1 = 1 基础上进行计算。</p><h3 id="4-闭包的作用"><a href="#4-闭包的作用" class="headerlink" title="4. 闭包的作用"></a>4. 闭包的作用</h3><ul><li>闭包可以保存外部函数内的变量，不会随着外部函数调用完而销毁。</li></ul><p><strong>注意点:</strong></p><ul><li>由于闭包引用了外部函数的变量，则外部函数的变量没有及时释放，消耗内存。</li></ul><h2 id="二、闭包的使用"><a href="#二、闭包的使用" class="headerlink" title="二、闭包的使用"></a>二、闭包的使用</h2><h3 id="1-案例"><a href="#1-案例" class="headerlink" title="1. 案例"></a>1. 案例</h3><p>需求: 根据配置信息使用闭包实现不同人的对话信息，例如对话:</p><p>张三: 到北京了吗?<br>李四: 已经到了，放心吧。</p><h3 id="2-实现步骤说明"><a href="#2-实现步骤说明" class="headerlink" title="2. 实现步骤说明"></a>2. 实现步骤说明</h3><ol><li>定义外部函数接收不同的配置信息参数，参数是人名</li><li>定义内部函数接收对话信息参数</li><li>在内部函数里面把配置信息和对话信息进行拼接输出</li></ol><h3 id="3-功能代码的实现"><a href="#3-功能代码的实现" class="headerlink" title="3. 功能代码的实现"></a>3. 功能代码的实现</h3><pre><code class="python"># 外部函数def config_name(name):    # 内部函数    def say_info(info):        print(name + &quot;: &quot; + info)    return say_infotom = config_name(&quot;Tom&quot;)tom(&quot;你好!&quot;)tom(&quot;你好, 在吗?&quot;)jerry = config_name(&quot;jerry&quot;)jerry(&quot;不在!&quot;)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">Tom: 你好!Tom: 你好, 在吗?jerry: 不在!</code></pre><p><strong>闭包案例说明:</strong></p><ul><li>闭包还可以提高代码的可重用性，不需要再手动定义额外的功能函数。</li></ul><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><ul><li>闭包不仅可以保存外部函数的变量还可以提高代码的可重用行。</li></ul><h2 id="三、修改闭包内使用的外部变量"><a href="#三、修改闭包内使用的外部变量" class="headerlink" title="三、修改闭包内使用的外部变量"></a>三、修改闭包内使用的外部变量</h2><h3 id="1-修改闭包内使用的外部变量"><a href="#1-修改闭包内使用的外部变量" class="headerlink" title="1. 修改闭包内使用的外部变量"></a>1. 修改闭包内使用的外部变量</h3><p><strong>修改闭包内使用的外部变量的错误示例:</strong></p><pre><code class="python"># 定义一个外部函数def func_out(num1):    # 定义一个内部函数    def func_inner(num2):        # 这里本意想要修改外部num1的值，实际上是在内部函数定义了一个局部变量num1        num1 = 10        # 内部函数使用了外部函数的变量(num1)        result = num1 + num2        print(&quot;结果是:&quot;, result)    print(num1)    func_inner(1)    print(num1)    # 外部函数返回了内部函数，这里返回的内部函数就是闭包    return func_inner# 创建闭包实例f = func_out(1)# 执行闭包f(2)</code></pre><p><strong>修改闭包内使用的外部变量的正确示例:</strong></p><pre><code class="python"># 定义一个外部函数def func_out(num1):    # 定义一个内部函数    def func_inner(num2):        # 这里本意想要修改外部num1的值，实际上是在内部函数定义了一个局部变量num1        nonlocal num1  # 告诉解释器，此处使用的是 外部变量a        # 修改外部变量num1        num1 = 10        # 内部函数使用了外部函数的变量(num1)        result = num1 + num2        print(&quot;结果是:&quot;, result)    print(num1)    func_inner(1)    print(num1)    # 外部函数返回了内部函数，这里返回的内部函数就是闭包    return func_inner# 创建闭包实例f = func_out(1)# 执行闭包f(2)</code></pre><h3 id="2-小结"><a href="#2-小结" class="headerlink" title="2. 小结"></a>2. 小结</h3><ul><li>修改闭包内使用的外部函数变量使用 nonlocal 关键字来完成。</li></ul><h2 id="四、装饰器"><a href="#四、装饰器" class="headerlink" title="四、装饰器"></a>四、装饰器</h2><h3 id="1-装饰器的定义"><a href="#1-装饰器的定义" class="headerlink" title="1. 装饰器的定义"></a>1. 装饰器的定义</h3><p>就是<strong>给已有函数增加额外功能的函数，它本质上就是一个闭包函数</strong>。</p><p><strong>装饰器的功能特点:</strong></p><ol><li>不修改已有函数的源代码</li><li>不修改已有函数的调用方式</li><li>给已有函数增加额外的功能</li></ol><h3 id="2-装饰器的示例代码"><a href="#2-装饰器的示例代码" class="headerlink" title="2. 装饰器的示例代码"></a>2. 装饰器的示例代码</h3><pre><code class="python"># 添加一个登录验证的功能def check(fn):    def inner():        print(&quot;请先登录....&quot;)        fn()    return innerdef comment():    print(&quot;发表评论&quot;)# 使用装饰器来装饰函数comment = check(comment)comment()# 装饰器的基本雏形# def decorator(fn): # fn:目标函数.#     def inner():#         &#39;&#39;&#39;执行函数之前&#39;&#39;&#39;#         fn() # 执行被装饰的函数#         &#39;&#39;&#39;执行函数之后&#39;&#39;&#39;#     return inner</code></pre><p><strong>代码说明:</strong></p><ul><li>闭包函数有且只有一个参数，必须是函数类型，这样定义的函数才是装饰器。</li><li>写代码要遵循开放封闭原则，它规定已经实现的功能代码不允许被修改，但可以被扩展。</li></ul><p><strong>执行结果:</strong></p><pre><code class="python">请先登录....发表评论</code></pre><h3 id="3-装饰器的语法糖写法"><a href="#3-装饰器的语法糖写法" class="headerlink" title="3. 装饰器的语法糖写法"></a>3. 装饰器的语法糖写法</h3><p>如果有多个函数都需要添加登录验证的功能，每次都需要编写func = check(func)这样代码对已有函数进行装饰，这种做法还是比较麻烦。</p><p>Python给提供了一个装饰函数更加简单的写法，那就是语法糖，语法糖的书写格式是: @装饰器名字，通过语法糖的方式也可以完成对已有函数的装饰</p><pre><code class="python"># 添加一个登录验证的功能def check(fn):    print(&quot;装饰器函数执行了&quot;)    def inner():        print(&quot;请先登录....&quot;)        fn()    return inner# 使用语法糖方式来装饰函数@checkdef comment():    print(&quot;发表评论&quot;)comment()</code></pre><p><strong>说明:</strong></p><ul><li>@check 等价于 comment = check(comment)</li><li>装饰器的执行时间是加载模块时立即执行。</li></ul><p><strong>执行结果:</strong></p><pre><code class="python">请先登录....发表评论</code></pre><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><ul><li><p>装饰器本质上就是一个闭包函数，它可以对已有函数进行额外的功能扩展。</p></li><li><p>装饰器的语法格式:</p><pre><code class="python"># 装饰器# def decorator(fn): # fn:被装饰的目标函数.#     def inner():#         &#39;&#39;&#39;执行函数之前&#39;&#39;&#39;#         fn() # 执行被装饰的目标函数#         &#39;&#39;&#39;执行函数之后&#39;&#39;&#39;#     return inner</code></pre></li><li><p>装饰器的语法糖用法: @装饰器名称，同样可以完成对已有函数的装饰操作。</p></li></ul><h2 id="五、装饰器的作用"><a href="#五、装饰器的作用" class="headerlink" title="五、装饰器的作用"></a>五、装饰器的作用</h2><h3 id="1-装饰器的使用场景"><a href="#1-装饰器的使用场景" class="headerlink" title="1. 装饰器的使用场景"></a>1. 装饰器的使用场景</h3><ol><li>函数执行时间的统计</li><li>输出日志信息</li></ol><h3 id="2-装饰器实现已有函数执行时间的统计"><a href="#2-装饰器实现已有函数执行时间的统计" class="headerlink" title="2. 装饰器实现已有函数执行时间的统计"></a>2. 装饰器实现已有函数执行时间的统计</h3><pre><code class="python">import time# 装饰器函数def get_time(func):    def inner():        begin = time.time()        func()        end = time.time()        print(&quot;函数执行花费%f&quot; % (end-begin))    return inner@get_timedef func1():    for i in range(100000):        print(i)func1()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">...9999599996999979999899999函数执行花费0.329066</code></pre><h2 id="六、通用装饰器的使用"><a href="#六、通用装饰器的使用" class="headerlink" title="六、通用装饰器的使用"></a>六、通用装饰器的使用</h2><h3 id="1-装饰带有参数的函数"><a href="#1-装饰带有参数的函数" class="headerlink" title="1. 装饰带有参数的函数"></a>1. 装饰带有参数的函数</h3><pre><code class="python"># 添加输出日志的功能def logging(fn):    def inner(num1, num2):        print(&quot;--正在努力计算--&quot;)        fn(num1, num2)    return inner# 使用装饰器装饰函数@loggingdef sum_num(a, b):    result = a + b    print(result)sum_num(1, 2)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">--正在努力计算--3</code></pre><h3 id="2-装饰带有返回值的函数"><a href="#2-装饰带有返回值的函数" class="headerlink" title="2. 装饰带有返回值的函数"></a>2. 装饰带有返回值的函数</h3><pre><code class="python"># 添加输出日志的功能def logging(fn):    def inner(num1, num2):        print(&quot;--正在努力计算--&quot;)        result = fn(num1, num2)        return result    return inner# 使用装饰器装饰函数@loggingdef sum_num(a, b):    result = a + b    return resultresult = sum_num(1, 2)print(result)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">--正在努力计算--3</code></pre><h3 id="3-装饰带有不定长参数的函数"><a href="#3-装饰带有不定长参数的函数" class="headerlink" title="3. 装饰带有不定长参数的函数"></a>3. 装饰带有不定长参数的函数</h3><pre><code class="python"># 添加输出日志的功能def logging(fn):    def inner(*args, **kwargs):        print(&quot;--正在努力计算--&quot;)        fn(*args, **kwargs)    return inner# 使用语法糖装饰函数@loggingdef sum_num(*args, **kwargs):    result = 0    for value in args:        result += value    for value in kwargs.values():        result += value    print(result)sum_num(1, 2, a=10)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">--正在努力计算--13</code></pre><h3 id="4-通用装饰器"><a href="#4-通用装饰器" class="headerlink" title="4. 通用装饰器"></a>4. 通用装饰器</h3><pre><code class="python"># 添加输出日志的功能def logging(fn):    def inner(*args, **kwargs):        print(&quot;--正在努力计算--&quot;)        result = fn(*args, **kwargs)        return result    return inner# 使用语法糖装饰函数@loggingdef sum_num(*args, **kwargs):    result = 0    for value in args:        result += value    for value in kwargs.values():        result += value    return result@loggingdef subtraction(a, b):    result = a - b    print(result)result = sum_num(1, 2, a=10)print(result)subtraction(4, 2)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">--正在努力计算--13--正在努力计算--2</code></pre><h3 id="5-小结-1"><a href="#5-小结-1" class="headerlink" title="5. 小结"></a>5. 小结</h3><ul><li><p>通用装饰器的语法格式:</p><pre><code class="python"># 通用装饰器def logging(fn):  def inner(*args, **kwargs):      print(&quot;--正在努力计算--&quot;)      result = fn(*args, **kwargs)      return result  return inner</code></pre></li></ul><h2 id="七、多个装饰器的使用"><a href="#七、多个装饰器的使用" class="headerlink" title="七、多个装饰器的使用"></a>七、多个装饰器的使用</h2><h3 id="1-多个装饰器的使用示例代码"><a href="#1-多个装饰器的使用示例代码" class="headerlink" title="1. 多个装饰器的使用示例代码"></a>1. 多个装饰器的使用示例代码</h3><pre><code class="python">def make_div(func):    &quot;&quot;&quot;对被装饰的函数的返回值 div标签&quot;&quot;&quot;    def inner():        return &quot;&lt;div&gt;&quot; + func() + &quot;&lt;/div&gt;&quot;    return innerdef make_p(func):    &quot;&quot;&quot;对被装饰的函数的返回值 p标签&quot;&quot;&quot;    def inner():        return &quot;&lt;p&gt;&quot; + func() + &quot;&lt;/p&gt;&quot;    return inner# 装饰过程: 1 content = make_p(content) 2 content = make_div(content)# content = make_div(make_p(content))@make_div@make_pdef content():    return &quot;人生苦短&quot;result = content()print(result)</code></pre><p><strong>代码说明:</strong></p><ul><li>多个装饰器的装饰过程是: 离函数最近的装饰器先装饰，然后外面的装饰器再进行装饰，由内到外的装饰过程</li></ul><h2 id="八、带有参数的装饰器"><a href="#八、带有参数的装饰器" class="headerlink" title="八、带有参数的装饰器"></a>八、带有参数的装饰器</h2><h3 id="1-带有参数的装饰器介绍"><a href="#1-带有参数的装饰器介绍" class="headerlink" title="1. 带有参数的装饰器介绍"></a>1. 带有参数的装饰器介绍</h3><p>带有参数的装饰器就是使用装饰器装饰函数的时候可以传入指定参数，<strong>语法格式: @装饰器(参数,…)</strong></p><p><strong>正确写法:</strong></p><p>在装饰器外面再包裹上一个函数，让最外面的函数接收参数，返回的是装饰器，因为@符号后面必须是装饰器实例。</p><pre><code class="python"># 添加输出日志的功能def logging(flag):    def decorator(fn):        def inner(num1, num2):            if flag == &quot;+&quot;:                print(&quot;--正在努力加法计算--&quot;)            elif flag == &quot;-&quot;:                print(&quot;--正在努力减法计算--&quot;)            result = fn(num1, num2)            return result        return inner    # 返回装饰器    return decorator# 使用装饰器装饰函数@logging(&quot;+&quot;)def add(a, b):    result = a + b    return result@logging(&quot;-&quot;)def sub(a, b):    result = a - b    return resultresult = add(1, 2)print(result)result = sub(1, 2)print(result)</code></pre><h3 id="2-小结-1"><a href="#2-小结-1" class="headerlink" title="2. 小结"></a>2. 小结</h3><ul><li>使用带有参数的装饰器，其实是在装饰器外面又包裹了一个函数，使用该函数接收参数，返回是装饰器，因为 @ 符号需要配合装饰器实例使用</li></ul><h2 id="九、类装饰器的使用"><a href="#九、类装饰器的使用" class="headerlink" title="九、类装饰器的使用"></a>九、类装饰器的使用</h2><h3 id="1-类装饰器的介绍"><a href="#1-类装饰器的介绍" class="headerlink" title="1. 类装饰器的介绍"></a>1. 类装饰器的介绍</h3><p>装饰器还有一种特殊的用法就是类装饰器，就是通过定义一个类来装饰函数。</p><p><strong>类装饰器示例代码:</strong></p><pre><code class="python">class Check(object):    def __init__(self, fn):        # 初始化操作在此完成        self.__fn = fn    # 实现__call__方法，表示对象是一个可调用对象，可以像调用函数一样进行调用。    def __call__(self, *args, **kwargs):        # 添加装饰功能        print(&quot;请先登陆...&quot;)        self.__fn()@Checkdef comment():    print(&quot;发表评论&quot;)comment()</code></pre><p><strong>代码说明:</strong></p><ul><li>@Check 等价于 comment = Check(comment), 所以需要提供一个<strong>init</strong>方法，并多增加一个fn参数。</li><li>要想类的实例对象能够像函数一样调用，需要在类里面使用<strong>call</strong>方法，把类的实例变成可调用对象(callable)，也就是说可以像调用函数一样进行调用。</li><li>在<strong>call</strong>方法里进行对fn函数的装饰，可以添加额外的功能。</li></ul><p><strong>执行结果:</strong></p><pre><code class="python">请先登陆...发表评论</code></pre><h3 id="2-小结-2"><a href="#2-小结-2" class="headerlink" title="2. 小结"></a>2. 小结</h3><ul><li>想要让类的实例对象能够像函数一样进行调用，需要在类里面使用<strong>call</strong>方法，把类的实例变成可调用对象(callable)</li><li>类装饰器装饰函数功能在<strong>call</strong>方法里面进行添加</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;闭包和装饰器&quot;&gt;&lt;a href=&quot;#闭包和装饰器&quot; class=&quot;headerlink&quot; title=&quot;闭包和装饰器&quot;&gt;&lt;/a&gt;闭包和装饰器&lt;/h1&gt;&lt;h2 id=&quot;一、闭包&quot;&gt;&lt;a href=&quot;#一、闭包&quot; class=&quot;headerlink&quot; title=&quot;一、闭包&quot;&gt;&lt;/a&gt;一、闭包&lt;/h2&gt;&lt;h3 id=&quot;1-闭包的介绍&quot;&gt;&lt;a href=&quot;#1-闭包的介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 闭包的介绍&quot;&gt;&lt;/a&gt;1. 闭包的介绍&lt;/h3&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://caijinbo.work/categories/python/"/>
    
    
      <category term="python" scheme="https://caijinbo.work/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python高级11-mini-Web框架</title>
    <link href="https://caijinbo.work/2020/08/22/2020-08-23-python%E9%AB%98%E7%BA%A711-mini-Web%E6%A1%86%E6%9E%B6%20(%E6%8F%92%E5%9B%BE%E7%89%88)/"/>
    <id>https://caijinbo.work/2020/08/22/2020-08-23-python%E9%AB%98%E7%BA%A711-mini-Web%E6%A1%86%E6%9E%B6%20(%E6%8F%92%E5%9B%BE%E7%89%88)/</id>
    <published>2020-08-22T16:00:00.000Z</published>
    <updated>2020-11-23T10:13:51.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mini-Web框架"><a href="#mini-Web框架" class="headerlink" title="mini-Web框架"></a>mini-Web框架</h1><h2 id="一、web框架概述"><a href="#一、web框架概述" class="headerlink" title="一、web框架概述"></a>一、web框架概述</h2><h3 id="1-web框架和web服务器的关系介绍"><a href="#1-web框架和web服务器的关系介绍" class="headerlink" title="1. web框架和web服务器的关系介绍"></a>1. web框架和web服务器的关系介绍</h3><a id="more"></a><p><strong>使用web框架专门负责处理用户的动态资源请求，这个web框架其实就是一个为web服务器提供服务的应用程序</strong>，简称web框架。</p><p><img src="https://img-blog.csdnimg.cn/20200826140436159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxODEyNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>关系说明:</strong></p><ul><li>web服务器接收浏览器发起的请求，如果是动态资源请求找web框架来处理</li><li>web框架负责处理浏览器的动态资源请求，把处理的结果发生给web服务器</li><li>web服务器再把响应结果发生给浏览器</li></ul><h3 id="2-静态资源"><a href="#2-静态资源" class="headerlink" title="2. 静态资源"></a>2. 静态资源</h3><p>不需要经常变化的资源，这种资源web服务器可以提前准备好，比如: png/jpg/css/js等文件。</p><h3 id="3-动态资源"><a href="#3-动态资源" class="headerlink" title="3. 动态资源"></a>3. 动态资源</h3><p>和静态资源相反, 这种资源会经常变化，比如: 我们在京东浏览商品时经常会根据条件进行筛选，选择不同条件, 浏览的商品就不同，这种资源web服务器无法提前准备好，需要web框架来帮web服务器进行准备，在这里web服务器可以把.html的资源请求认为是动态资源请求交由web框架进行处理。</p><h3 id="4-WSGI协议"><a href="#4-WSGI协议" class="headerlink" title="4. WSGI协议"></a>4. WSGI协议</h3><p>它是web服务器和web框架之间进行协同工作的一个规则，WSGI协议规定web服务器把动态资源的请求信息传给web框架处理，web框架把处理好的结果返回给web服务器。</p><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><ul><li>web框架是专门为web服务器处理动态资源请求的一个应用程序</li><li>web框架和web服务器的关系是web框架专门服务于web服务器，给web服务器提供处理动态资源请求的服务。</li></ul><h2 id="二、框架程序开发"><a href="#二、框架程序开发" class="headerlink" title="二、框架程序开发"></a>二、框架程序开发</h2><h3 id="1-框架职责介绍"><a href="#1-框架职责介绍" class="headerlink" title="1. 框架职责介绍"></a>1. 框架职责介绍</h3><ul><li>接收web服务器的动态资源请求，给web服务器提供处理动态资源请求的服务。</li></ul><h3 id="2-动态资源判断"><a href="#2-动态资源判断" class="headerlink" title="2. 动态资源判断"></a>2. 动态资源判断</h3><ul><li>根据请求资源路径的后缀名进行判断<ul><li>如果请求资源路径的后缀名是.html则是动态资源请求, 让web框架程序进行处理。</li><li>否则是静态资源请求，让web服务器程序进行处理。</li></ul></li></ul><p><strong>web服务器程序(web.py)代码:</strong></p><pre><code class="python">import socketimport threadingimport sysimport framework# 定义web服务器类class HttpWebServer(object):    def __init__(self, port):        # 创建tcp服务端套接字        tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        # 设置端口号复用, 程序退出端口立即释放        tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)        # 绑定端口号        tcp_server_socket.bind((&quot;&quot;, port))        # 设置监听        tcp_server_socket.listen(128)        self.tcp_server_socket = tcp_server_socket    # 处理客户的请求    @staticmethod    def handle_client_quest(new_socket):        # 代码执行到此，说明连接建立成功        recv_client_data = new_socket.recv(4096)        if len(recv_client_data) == 0:            print(&quot;关闭浏览器了&quot;)            # 关闭服务与客户端的套接字            new_socket.close()            return        # 对二进制数据进行解码        recv_client_content = recv_client_data.decode(&quot;utf-8&quot;)        print(recv_client_content)        # 根据指定字符串进行分割， 最大分割次数指定2        request_list = recv_client_content.split(&quot; &quot;, maxsplit=2)        # 获取请求资源路径        request_path = request_list[1]        print(request_path)        # 判断请求的是否是根目录，如果条件成立，指定首页数据返回        if request_path == &quot;/&quot;:            request_path = &quot;/index.html&quot;        # 判断是否是动态资源请求        if request_path.endswith(&quot;.html&quot;):            &quot;&quot;&quot;这里是动态资源请求，把请求信息交给框架处理&quot;&quot;&quot;            # 字典存储用户的请求信息            env = {                &quot;request_path&quot;: request_path            }            # 获取处理结果            status, headers, response_body = framework.handle_request(env)            # 使用框架处理的数据拼接响应报文            # 响应行            response_line = &quot;HTTP/1.1 %s\r\n&quot; % status            # 响应头            response_header = &quot;&quot;            # 遍历头部信息            for header in headers:                # 拼接多个响应头                response_header += &quot;%s: %s\r\n&quot; % header            response_data = (response_line +                             response_header +                             &quot;\r\n&quot; +                             response_body).encode(&quot;utf-8&quot;)            # 发送数据            new_socket.send(response_data)            # 关闭socket            new_socket.close()        else:            &quot;&quot;&quot;这里是静态资源请求&quot;&quot;&quot;            try:                # 动态打开指定文件                with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file:                    # 读取文件数据                    file_data = file.read()            except Exception as e:                # 请求资源不存在，返回404数据                # 响应行                response_line = &quot;HTTP/1.1 404 Not Found\r\n&quot;                # 响应头                response_header = &quot;Server: PWS1.0\r\n&quot;                with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file:                    file_data = file.read()                # 响应体                response_body = file_data                # 拼接响应报文                response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body                # 发送数据                new_socket.send(response_data)            else:                # 响应行                response_line = &quot;HTTP/1.1 200 OK\r\n&quot;                # 响应头                response_header = &quot;Server: PWS1.0\r\n&quot;                # 响应体                response_body = file_data                # 拼接响应报文                response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body                # 发送数据                new_socket.send(response_data)            finally:                # 关闭服务与客户端的套接字                new_socket.close()    def start(self):        while True:            # 等待接受客户端的连接请求            new_socket, ip_port = self.tcp_server_socket.accept()            sub_thread = threading.Thread(target=self.handle_client_quest, args=(new_socket,))            # 设置守护线程            sub_thread.setDaemon(True)            sub_thread.start()# 程序入口函数def main():    # 获取命令行参数判断长度    if len(sys.argv) != 2:        print(&quot;执行命令如下: python3 xxx.py 9000&quot;)        return    # 判断端口号是否是数字    if not sys.argv[1].isdigit():        print(&quot;执行命令如下: python3 xxx.py 9000&quot;)        return    # 需要转成int类型    port = int(sys.argv[1])    # 创建web服务器    web_server = HttpWebServer(port)    # 启动web服务器    web_server.start()if __name__ == &#39;__main__&#39;:    main()</code></pre><h3 id="3-处理客户端的动态资源请求"><a href="#3-处理客户端的动态资源请求" class="headerlink" title="3. 处理客户端的动态资源请求"></a>3. 处理客户端的动态资源请求</h3><ol><li>创建web框架程序</li><li>接收web服务器的动态资源请求</li><li>处理web服务器的动态资源请求并把处理结果返回给web服务器</li><li>web服务器把处理结果组装成响应报文发送给浏览器</li></ol><p><strong>web框架程序(framework.py)代码:</strong></p><pre><code class="python">&quot;&quot;&quot;miniweb框架，负责处理动态资源请求&quot;&quot;&quot;import time# 获取首页数据def index():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 处理后的数据    data = time.ctime()    return status, response_header, data# 没有找到动态资源def not_found():    # 响应状态    status = &quot;404 Not Found&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 处理后的数据    data = &quot;not found&quot;    return status, response_header, data# 处理动态资源请求def handle_request(env):    # 获取动态请求资源路径    request_path = env[&quot;request_path&quot;]    print(&quot;接收到的动态资源请求:&quot;, request_path)    if request_path == &quot;/index.html&quot;:        # 获取首页数据        result = index()        return result    else:        # 没有找到动态资源        result = not_found()        return result</code></pre><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><ul><li>动态资源的判断通过请求资源路径的后缀是.html来完成，否则是静态资源</li><li>处理客户端的动态资源请求<ol><li>接收web服务器的动态资源请求</li><li>处理动态资源请求并把处理结果返回给web服务器</li><li>web服务器把处理结果组装成响应报文发送给浏览器</li></ol></li></ul><h2 id="三、模板替换功能开发"><a href="#三、模板替换功能开发" class="headerlink" title="三、模板替换功能开发"></a>三、模板替换功能开发</h2><h3 id="1-读取股票信息模板文件"><a href="#1-读取股票信息模板文件" class="headerlink" title="1. 读取股票信息模板文件"></a>1. 读取股票信息模板文件</h3><p><strong>framework.py示例代码:</strong></p><pre><code class="python"># 获取首页数据def index():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/index.html&quot;, &quot;r&quot;) as file:        file_data = file.read()</code></pre><h3 id="2-使用模拟数据替换模板变量"><a href="#2-使用模拟数据替换模板变量" class="headerlink" title="2. 使用模拟数据替换模板变量"></a>2. 使用模拟数据替换模板变量</h3><p><strong>framework.py示例代码:</strong></p><pre><code class="python"># 获取首页数据def index():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 1. 打开模板文件，读取数据    with open(&quot;template/index.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 处理后的数据, 从数据库查询    data = time.ctime()    # 2. 替换模板文件中的模板遍历    result = file_data.replace(&quot;{%content%}&quot;, data)    return status, response_header, result</code></pre><h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h3><ul><li>模板替换功能<ol><li>打开template目录下的index.html模板文件，读取模板文件数据</li><li>把模板文件中的模板变量进行替换</li></ol></li></ul><h2 id="四、路由列表功能开发"><a href="#四、路由列表功能开发" class="headerlink" title="四、路由列表功能开发"></a>四、路由列表功能开发</h2><h3 id="1-路由的介绍"><a href="#1-路由的介绍" class="headerlink" title="1. 路由的介绍"></a>1. 路由的介绍</h3><p>接着上面程序的判断场景，假如咱们再处理一个个人中心的动态资源请求非常简单，再添加一个函数和更加一个分支判断就可以实现了。</p><p><strong>framework.py 示例代码:</strong></p><pre><code class="python"># 获取个人中心数据def center():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/center.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 处理后的数据, 从数据库查询    data = time.ctime()    # 替换模板文件中的模板遍历    result = file_data.replace(&quot;{%content%}&quot;, data)    return status, response_header, result# 处理动态资源请求def handle_request(env):    # 获取动态请求资源路径    request_path = env[&quot;request_path&quot;]    print(&quot;接收到的动态资源请求:&quot;, request_path)    if request_path == &quot;/index.html&quot;:        # 获取首页数据        result = index()        return result    elif request_path == &quot;/center.html&quot;:        # 获取个人中心数据        result = center()        return result    else:        # 没有找到动态资源        result = not_found()        return result</code></pre><p>那如果咱们的框架处理的页面请求路径再多一些，比如:5个路径判断，大家可能感觉条件分支完全可以胜任，如果是40个甚至更多呢? 如果这是还是用普通的条件分支简直无法忍受。</p><p>解决办法: <strong>可以使用路由</strong></p><p><strong>什么是路由？</strong></p><p>路由就是请求的URL到处理函数的映射，也就是说提前把请求的URL和处理函数关联好。</p><p><strong>路由列表</strong></p><p>这么多的路由如何管理呢， 可以使用一个路由列表进行管理，通过路由列表保存每一个路由。</p><table><thead><tr><th align="left">请求路径</th><th align="left">处理函数</th></tr></thead><tbody><tr><td align="left">/login.html</td><td align="left">login函数</td></tr><tr><td align="left">/index.html</td><td align="left">index函数</td></tr><tr><td align="left">/center.html</td><td align="left">center函数</td></tr></tbody></table><h3 id="2-在路由列表添加路由"><a href="#2-在路由列表添加路由" class="headerlink" title="2. 在路由列表添加路由"></a>2. 在路由列表添加路由</h3><p><strong>framework.py 示例代码:</strong></p><pre><code class="python"># 定义路由列表route_list = [    (&quot;/index.html&quot;, index),    (&quot;/center.html&quot;, center)]</code></pre><h3 id="3-根据用户请求遍历路由列表处理用户请求"><a href="#3-根据用户请求遍历路由列表处理用户请求" class="headerlink" title="3. 根据用户请求遍历路由列表处理用户请求"></a>3. 根据用户请求遍历路由列表处理用户请求</h3><p><strong>framework.py 示例代码:</strong></p><pre><code class="python"># 处理动态资源请求def handle_request(env):    # 获取动态请求资源路径    request_path = env[&quot;request_path&quot;]    print(&quot;接收到的动态资源请求:&quot;, request_path)    # 遍历路由列表，选择执行的函数    for path, func in route_list:        if request_path == path:            result = func()            return result    else:        # 没有找到动态资源        result = not_found()        return result    # if request_path == &quot;/index.html&quot;:    #     # 获取首页数据    #     result = index()    #     return result    # elif request_path == &quot;/center.html&quot;:    #     # 获取个人中心数据    #     result = center()    #     return result    # else:    #     # 没有找到动态资源    #     result = not_found()    #     return result</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>路由是请求的URL到处理函数的映射</li><li>路由列表是用来保存每一个设置好的路由</li><li>用户的动态资源请求通过遍历路由列表找到对应的处理函数来完成。</li></ul><h2 id="五、装饰器方式的添加路由"><a href="#五、装饰器方式的添加路由" class="headerlink" title="五、装饰器方式的添加路由"></a>五、装饰器方式的添加路由</h2><h3 id="1-使用带有参数的装饰器添加路由"><a href="#1-使用带有参数的装饰器添加路由" class="headerlink" title="1. 使用带有参数的装饰器添加路由"></a>1. 使用带有参数的装饰器添加路由</h3><p>前面我们已经实现了路由列表，但是每次添加路由都需要手动添加来完成，接下来我们想要完成路由的自动添加，可以通过装饰器来实现，在使用装饰器对处理函数进行装饰的时候我们需要知道装饰的函数和那个请求路径进行关联，也就是说装饰器需要接收一个url参数，这样我们定义的装饰器是一个带有参数的装饰器。</p><p><strong>示例代码:</strong></p><pre><code class="python">&quot;&quot;&quot;miniweb框架，负责处理动态资源请求&quot;&quot;&quot;import time# 定义路由列表route_list = []# 定义带有参数的装饰器def route(path):    # 装饰器    def decorator(func):        # 当执行装饰器装饰指定函数的时候，把路径和函数添加到路由列表        route_list.append((path, func))        def inner():            # 执行指定函数            return func()        return inner    # 返回装饰器    return decorator# 获取首页数据@route(&quot;/index.html&quot;)def index():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/index.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 处理后的数据, 从数据库查询    data = time.ctime()    # 替换模板文件中的模板遍历    result = file_data.replace(&quot;{%content%}&quot;, data)    return status, response_header, result# 获取个人中心数据@route(&quot;/center.html&quot;)def center():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/center.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 处理后的数据, 从数据库查询    data = time.ctime()    # 替换模板文件中的模板遍历    result = file_data.replace(&quot;{%content%}&quot;, data)    return status, response_header, result# 没有找到动态资源def not_found():    # 响应状态    status = &quot;404 Not Found&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 处理后的数据    data = &quot;not found&quot;    return status, response_header, data# 处理动态资源请求def handle_request(env):    # 获取动态请求资源路径    request_path = env[&quot;request_path&quot;]    print(&quot;接收到的动态资源请求:&quot;, request_path)    # 遍历路由列表，选择执行的函数    for path, func in route_list:        if request_path == path:            result = func()            return result    else:        # 没有找到动态资源        result = not_found()        return result</code></pre><h3 id="2-小结"><a href="#2-小结" class="headerlink" title="2. 小结"></a>2. 小结</h3><ul><li>使用带有参数的装饰器对处理函数进行装饰，并完成路由的添加功能。</li></ul><h2 id="六、显示股票信息页面的开发"><a href="#六、显示股票信息页面的开发" class="headerlink" title="六、显示股票信息页面的开发"></a>六、显示股票信息页面的开发</h2><h3 id="1-数据准备"><a href="#1-数据准备" class="headerlink" title="1. 数据准备"></a>1. 数据准备</h3><pre><code class="sql">-- 创建数据库create database stock_db charset=utf8;-- 切换数据库use stock_db;-- 执行sql文件source stock_db.sql;</code></pre><h3 id="2-根据sql语句查询股票信息"><a href="#2-根据sql语句查询股票信息" class="headerlink" title="2. 根据sql语句查询股票信息"></a>2. 根据sql语句查询股票信息</h3><p><strong>示例代码:</strong></p><pre><code class="python"># 获取首页数据@route(&quot;/index.html&quot;)def index():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/index.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 处理后的数据, 从数据库查询    conn = pymysql.connect(host=&quot;localhost&quot;,                           port=3306,                           user=&quot;root&quot;,                           password=&quot;mysql&quot;,                           database=&quot;stock_db&quot;,                           charset=&quot;utf8&quot;)    # 获取游标    cursor = conn.cursor()    # 查询sql语句    sql = &quot;select * from info;&quot;    # 执行sql    cursor.execute(sql)    # 获取结果集    result = cursor.fetchall()    print(result)</code></pre><h3 id="3-使用查询数据替换模板变量"><a href="#3-使用查询数据替换模板变量" class="headerlink" title="3. 使用查询数据替换模板变量"></a>3. 使用查询数据替换模板变量</h3><p><strong>示例代码:</strong></p><pre><code class="python"># 获取首页数据@route(&quot;/index.html&quot;)def index():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/index.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 处理后的数据, 从数据库查询    conn = pymysql.connect(host=&quot;localhost&quot;,                           port=3306,                           user=&quot;root&quot;,                           password=&quot;mysql&quot;,                           database=&quot;stock_db&quot;,                           charset=&quot;utf8&quot;)    # 获取游标    cursor = conn.cursor()    # 查询sql语句    sql = &quot;select * from info;&quot;    # 执行sql    cursor.execute(sql)    # 获取结果集    result = cursor.fetchall()    print(result)    data = &quot;&quot;    for row in result:        data += &#39;&#39;&#39;&lt;tr&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;&lt;input type=&quot;button&quot; value=&quot;添加&quot; id=&quot;toAdd&quot; name=&quot;toAdd&quot; systemidvaule=&quot;000007&quot;&gt;&lt;/td&gt;                   &lt;/tr&gt;&#39;&#39;&#39; % row    # 替换模板文件中的模板遍历    result = file_data.replace(&quot;{%content%}&quot;, data)    return status, response_header, result</code></pre><h3 id="4-小结-1"><a href="#4-小结-1" class="headerlink" title="4. 小结"></a>4. 小结</h3><ul><li>根据sql语句查询股票信息</li><li>使用查询数据替换模板变量</li></ul><h2 id="七、个人中心数据接口的开发"><a href="#七、个人中心数据接口的开发" class="headerlink" title="七、个人中心数据接口的开发"></a>七、个人中心数据接口的开发</h2><h3 id="1-根据sql语句查询个人中心数据"><a href="#1-根据sql语句查询个人中心数据" class="headerlink" title="1. 根据sql语句查询个人中心数据"></a>1. 根据sql语句查询个人中心数据</h3><pre><code class="python"># 个人中心数据接口开发@route(&quot;/center_data.html&quot;)def center_data():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;), (&quot;Content-Type&quot;, &quot;text/html;charset=utf-8&quot;)]    conn = pymysql.connect(host=&quot;localhost&quot;,                           port=3306,                           user=&quot;root&quot;,                           password=&quot;mysql&quot;,                           database=&quot;stock_db&quot;,                           charset=&quot;utf8&quot;)    # 获取游标    cursor = conn.cursor()    # 查询sql语句    sql = &#39;&#39;&#39;select i.code, i.short, i.chg,              i.turnover, i.price, i.highs, f.note_info              from info as i inner join focus as f on i.id = f.info_id;&#39;&#39;&#39;    # 执行sql    cursor.execute(sql)    # 获取结果集    result = cursor.fetchall()    # 关闭游标    cursor.close()    # 关闭数据库连接    conn.close()    print(result)</code></pre><h3 id="2-将个人中心数据转成json字符串并返回"><a href="#2-将个人中心数据转成json字符串并返回" class="headerlink" title="2. 将个人中心数据转成json字符串并返回"></a>2. 将个人中心数据转成json字符串并返回</h3><pre><code class="python"># 个人中心数据接口开发@route(&quot;/center_data.html&quot;)def center_data():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;), (&quot;Content-Type&quot;, &quot;text/html;charset=utf-8&quot;)]    conn = pymysql.connect(host=&quot;localhost&quot;,                           port=3306,                           user=&quot;root&quot;,                           password=&quot;mysql&quot;,                           database=&quot;stock_db&quot;,                           charset=&quot;utf8&quot;)    # 获取游标    cursor = conn.cursor()    # 查询sql语句    sql = &#39;&#39;&#39;select i.code, i.short, i.chg,              i.turnover, i.price, i.highs, f.note_info              from info as i inner join focus as f on i.id = f.info_id;&#39;&#39;&#39;    # 执行sql    cursor.execute(sql)    # 获取结果集    result = cursor.fetchall()    # 关闭游标    cursor.close()    # 关闭数据库连接    conn.close()    # 个人中心数据列表    center_data_list = list()    # 遍历每一行数据转成字典    for row in result:        # 创建空的字典        center_dict = dict()        center_dict[&quot;code&quot;] = row[0]        center_dict[&quot;short&quot;] = row[1]        center_dict[&quot;chg&quot;] = row[2]        center_dict[&quot;turnover&quot;] = row[3]        center_dict[&quot;price&quot;] = str(row[4])        center_dict[&quot;highs&quot;] = str(row[5])        center_dict[&quot;note_info&quot;] = row[6]        # 添加每个字典信息        center_data_list.append(center_dict)    # 把列表字典转成json字符串, 并在控制台显示    json_str = json.dumps(center_data_list,ensure_ascii=False)    print(json_str)    return status, response_header, json_str</code></pre><p><strong>代码说明:</strong></p><ul><li>json.dumps函数把字典转成json字符串<ol><li>函数的第一个参数表示要把指定对象转成json字符串</li><li>参数的第二个参数ensure_ascii=False表示不使用ascii编码，可以在控制台显示中文。</li></ol></li><li>响应头添加Content-Type表示指定数据的编码格式</li></ul><h3 id="3-小结-1"><a href="#3-小结-1" class="headerlink" title="3. 小结"></a>3. 小结</h3><ul><li>web框架程序还可以开发数据接口，为客户端程序提供数据服务。<ul><li><ol><li>根据sql语句查询数据库</li></ol></li><li><ol><li>把数据转成json字符串返回</li></ol></li><li><ol><li>浏览器通过指定接口地址获取web框架提供的数据。</li></ol></li></ul></li></ul><h2 id="八、ajax请求数据渲染个人中心页面"><a href="#八、ajax请求数据渲染个人中心页面" class="headerlink" title="八、ajax请求数据渲染个人中心页面"></a>八、ajax请求数据渲染个人中心页面</h2><h3 id="1-根据用户请求返回个人中心空模板文件数据"><a href="#1-根据用户请求返回个人中心空模板文件数据" class="headerlink" title="1. 根据用户请求返回个人中心空模板文件数据"></a>1. 根据用户请求返回个人中心空模板文件数据</h3><pre><code class="python"># 获取个人中心数据@route(&quot;/center.html&quot;)def center():    # 响应状态    status = &quot;200 OK&quot;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/center.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 替换模板文件中的模板遍历    result = file_data.replace(&quot;{%content%}&quot;, &quot;&quot;)    return status, response_header, result</code></pre><h3 id="2-在个人中心模板文件添加ajax请求获取个人中心数据"><a href="#2-在个人中心模板文件添加ajax请求获取个人中心数据" class="headerlink" title="2. 在个人中心模板文件添加ajax请求获取个人中心数据"></a>2. 在个人中心模板文件添加ajax请求获取个人中心数据</h3><pre><code class="js">// 发送ajax请求获取个人中心页面数据// 路径写成 center_data.html，发送ajax的时候路径其实是http://ip地址:端口号/center.data.html$.get(&quot;center_data.html&quot;, function (data) {        alert(data);    }}, &quot;json&quot;);</code></pre><h3 id="3-将个人中心数据在页面完成展示"><a href="#3-将个人中心数据在页面完成展示" class="headerlink" title="3. 将个人中心数据在页面完成展示"></a>3. 将个人中心数据在页面完成展示</h3><pre><code class="js">// 发送ajax请求获取个人中心页面数据$.get(&quot;center_data.html&quot;, function (data) {    var data_array = data;    // 获取table标签对象    var $table = $(&quot;.table&quot;)    for(var i = 0; i &lt; data_array.length; i++){        // 获取每一条对象        var center_obj = data_array[i];        var row_html = &#39;&lt;tr&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.code +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.short +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.chg +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.turnover +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.price +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.highs +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.note_info +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&lt;a type=&quot;button&quot; class=&quot;btn btn-default btn-xs&quot; href=&quot;/update/000007.html&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-star&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; 修改 &lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;button&quot; value=&quot;删除&quot; id=&quot;toDel&quot; name=&quot;toDel&quot; systemidvaule=&quot;000007&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&#39;;        // 为table标签添加每一行组装的html数据        $table.append(row_html);    }}, &quot;json&quot;);</code></pre><h3 id="4-小结-2"><a href="#4-小结-2" class="headerlink" title="4. 小结"></a>4. 小结</h3><ul><li>根据用户请求返回个人中心空模板文件数据</li><li>在个人中心模板文件添加ajax请求获取个人中心数据</li><li>将个人中心数据在页面完成展示</li></ul><h2 id="九、logging日志"><a href="#九、logging日志" class="headerlink" title="九、logging日志"></a>九、logging日志</h2><h3 id="1-logging日志的介绍"><a href="#1-logging日志的介绍" class="headerlink" title="1. logging日志的介绍"></a>1. logging日志的介绍</h3><p>在现实生活中，记录日志非常重要，比如:银行转账时会有转账记录；飞机飞行过程中，会有个黑盒子（飞行数据记录器）记录着飞机的飞行过程，那在咱们python程序中想要记录程序在运行时所产生的日志信息，怎么做呢?</p><p>可以使用 <strong>logging</strong> 这个包来完成</p><p><strong>记录程序日志信息的目的是:</strong></p><ol><li>可以很方便的了解程序的运行情况</li><li>可以分析用户的操作行为、喜好等信息</li><li>方便开发人员检查bug</li></ol><h3 id="2-logging日志级别介绍"><a href="#2-logging日志级别介绍" class="headerlink" title="2. logging日志级别介绍"></a>2. logging日志级别介绍</h3><p>日志等级可以分为5个，从低到高分别是:</p><ol><li>DEBUG</li><li>INFO</li><li>WARNING</li><li>ERROR</li><li>CRITICAL</li></ol><p><strong>日志等级说明:</strong></p><ul><li>DEBUG：程序调试bug时使用</li><li>INFO：程序正常运行时使用</li><li>WARNING：程序未按预期运行时使用，但并不是错误，如:用户登录密码错误</li><li>ERROR：程序出错误时使用，如:IO操作失败</li><li>CRITICAL：特别严重的问题，导致程序不能再继续运行时使用，如:磁盘空间为空，一般很少使用</li><li>默认的是WARNING等级，当在WARNING或WARNING之上等级的才记录日志信息。</li><li>日志等级从低到高的顺序是: DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL</li></ul><h3 id="3-logging日志的使用"><a href="#3-logging日志的使用" class="headerlink" title="3. logging日志的使用"></a>3. logging日志的使用</h3><p>在 logging 包中记录日志的方式有两种:</p><ol><li>输出到控制台</li><li>保存到日志文件</li></ol><p><strong>日志信息输出到控制台的示例代码:</strong></p><pre><code class="python">import logginglogging.debug(&#39;这是一个debug级别的日志信息&#39;)logging.info(&#39;这是一个info级别的日志信息&#39;)logging.warning(&#39;这是一个warning级别的日志信息&#39;)logging.error(&#39;这是一个error级别的日志信息&#39;)logging.critical(&#39;这是一个critical级别的日志信息&#39;)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">WARNING:root:这是一个warning级别的日志信息ERROR:root:这是一个error级别的日志信息CRITICAL:root:这是一个critical级别的日志信息</code></pre><p><strong>说明:</strong></p><ul><li>日志信息只显示了大于等于WARNING级别的日志，这说明默认的日志级别设置为WARNING</li></ul><p><strong>logging日志等级和输出格式的设置:</strong></p><pre><code class="python">import logging# 设置日志等级和输出日志格式logging.basicConfig(level=logging.DEBUG,                    format=&#39;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&#39;)logging.debug(&#39;这是一个debug级别的日志信息&#39;)logging.info(&#39;这是一个info级别的日志信息&#39;)logging.warning(&#39;这是一个warning级别的日志信息&#39;)logging.error(&#39;这是一个error级别的日志信息&#39;)logging.critical(&#39;这是一个critical级别的日志信息&#39;)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">2019-02-13 20:41:33,080 - hello.py[line:6] - DEBUG: 这是一个debug级别的日志信息2019-02-13 20:41:33,080 - hello.py[line:7] - INFO: 这是一个info级别的日志信息2019-02-13 20:41:33,080 - hello.py[line:8] - WARNING: 这是一个warning级别的日志信息2019-02-13 20:41:33,080 - hello.py[line:9] - ERROR: 这是一个error级别的日志信息2019-02-13 20:41:33,080 - hello.py[line:10] - CRITICAL: 这是一个critical级别的日志信息</code></pre><p><strong>代码说明:</strong></p><ul><li>level 表示设置的日志等级</li><li>format 表示日志的输出格式, 参数说明:<ul><li>%(levelname)s: 打印日志级别名称</li><li>%(filename)s: 打印当前执行程序名</li><li>%(lineno)d: 打印日志的当前行号</li><li>%(asctime)s: 打印日志的时间</li><li>%(message)s: 打印日志信息</li></ul></li></ul><p><strong>日志信息保存到日志文件的示例代码:</strong></p><pre><code class="python">import logginglogging.basicConfig(level=logging.DEBUG,                    format=&#39;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&#39;,                    filename=&quot;log.txt&quot;,                    filemode=&quot;w&quot;)logging.debug(&#39;这是一个debug级别的日志信息&#39;)logging.info(&#39;这是一个info级别的日志信息&#39;)logging.warning(&#39;这是一个warning级别的日志信息&#39;)logging.error(&#39;这是一个error级别的日志信息&#39;)logging.critical(&#39;这是一个critical级别的日志信息&#39;)</code></pre><h3 id="4-logging日志在mini-web项目中应用"><a href="#4-logging日志在mini-web项目中应用" class="headerlink" title="4. logging日志在mini-web项目中应用"></a>4. logging日志在mini-web项目中应用</h3><p><strong>web.py 程序使用logging日志示例:</strong></p><ol><li><p>程序入口模块设置logging日志的设置</p><pre><code class="python"> import socket import threading import sys import framework import logging # logging日志的配置 logging.basicConfig(level=logging.DEBUG,                     format=&#39;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&#39;,                     filename=&quot;log.txt&quot;,                     filemode=&quot;w&quot;)</code></pre></li><li><p>INFO级别的日志输出，示例代码:</p><pre><code class="python"> # 判断是否是动态资源请求 if request_path.endswith(&quot;.html&quot;):     &quot;&quot;&quot;这里是动态资源请求，把请求信息交给框架处理&quot;&quot;&quot;     logging.info(&quot;动态资源请求:&quot; + request_path)     ... else:     &quot;&quot;&quot;这里是静态资源请求&quot;&quot;&quot;     logging.info(&quot;静态资源请求:&quot; + request_path)     ...</code></pre></li><li><p>WARNING级别的日志输出，示例代码:</p><pre><code class="python"> # 获取命令行参数判断长度 if len(sys.argv) != 2:     print(&quot;执行命令如下: python3 xxx.py 9000&quot;)     logging.warning(&quot;用户在命令行启动程序参数个数不正确!&quot;)     return # 判断端口号是否是数字 if not sys.argv[1].isdigit():     print(&quot;执行命令如下: python3 xxx.py 9000&quot;)     logging.warning(&quot;用户在命令行启动程序参数不是数字字符串!&quot;)     return</code></pre></li></ol><p><strong>framework.py 程序使用logging日志示例:</strong></p><ol><li><p>ERROR级别的日志输出，示例代码:</p><pre><code class="python"> # 处理动态资源请求 def handle_request(env):     # 获取动态请求资源路径     request_path = env[&quot;request_path&quot;]     print(&quot;接收到的动态资源请求:&quot;, request_path)     # 遍历路由列表，选择执行的函数     for path, func in route_list:         if request_path == path:             result = func()             return result     else:         logging.error(&quot;没有设置相应的路由:&quot; + request_path)         # 没有找到动态资源         result = not_found()         return result</code></pre></li></ol><p><strong>说明:</strong></p><ul><li>logging日志配置信息在程序入口模块设置一次，整个程序都可以生效。<ul><li>logging.basicConfig 表示 logging 日志配置操作</li></ul></li></ul><h3 id="5-小结-1"><a href="#5-小结-1" class="headerlink" title="5. 小结"></a>5. 小结</h3><ul><li>记录python程序中日志信息使用 logging 包来完成</li><li>logging日志等级有5个:<ol><li>DEBUG</li><li>INFO</li><li>WARNING</li><li>ERROR</li><li>CRITICAL</li></ol></li><li>打印(记录)日志的函数有5个:<ol><li>logging.debug函数, 表示: 打印(记录)DEBUG级别的日志信息</li><li>logging.info函数, 表示: 打印(记录)INFO级别的日志信息</li><li>logging.warning函数, 表示: 打印(记录)WARNING级别的日志信息</li><li>logging.error函数, 表示: 打印(记录)ERROR级别的日志信息<br>ng(“用户在命令行启动程序参数不是数字字符串!”)<br>   return<pre><code></code></pre></li></ol></li></ul><p><strong>framework.py 程序使用logging日志示例:</strong></p><ol><li><p>ERROR级别的日志输出，示例代码:</p><pre><code class="python"> # 处理动态资源请求 def handle_request(env):     # 获取动态请求资源路径     request_path = env[&quot;request_path&quot;]     print(&quot;接收到的动态资源请求:&quot;, request_path)     # 遍历路由列表，选择执行的函数     for path, func in route_list:         if request_path == path:             result = func()             return result     else:         logging.error(&quot;没有设置相应的路由:&quot; + request_path)         # 没有找到动态资源         result = not_found()         return result</code></pre></li></ol><p><strong>说明:</strong></p><ul><li>logging日志配置信息在程序入口模块设置一次，整个程序都可以生效。<ul><li>logging.basicConfig 表示 logging 日志配置操作</li></ul></li></ul><h3 id="5-小结-2"><a href="#5-小结-2" class="headerlink" title="5. 小结"></a>5. 小结</h3><ul><li>记录python程序中日志信息使用 logging 包来完成</li><li>logging日志等级有5个:<ol><li>DEBUG</li><li>INFO</li><li>WARNING</li><li>ERROR</li><li>CRITICAL</li></ol></li><li>打印(记录)日志的函数有5个:<ol><li>logging.debug函数, 表示: 打印(记录)DEBUG级别的日志信息</li><li>logging.info函数, 表示: 打印(记录)INFO级别的日志信息</li><li>logging.warning函数, 表示: 打印(记录)WARNING级别的日志信息</li><li>logging.error函数, 表示: 打印(记录)ERROR级别的日志信息</li><li>logging.critical函数, 表示: 打印(记录)CRITICAL级别的日志信息</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mini-Web框架&quot;&gt;&lt;a href=&quot;#mini-Web框架&quot; class=&quot;headerlink&quot; title=&quot;mini-Web框架&quot;&gt;&lt;/a&gt;mini-Web框架&lt;/h1&gt;&lt;h2 id=&quot;一、web框架概述&quot;&gt;&lt;a href=&quot;#一、web框架概述&quot; class=&quot;headerlink&quot; title=&quot;一、web框架概述&quot;&gt;&lt;/a&gt;一、web框架概述&lt;/h2&gt;&lt;h3 id=&quot;1-web框架和web服务器的关系介绍&quot;&gt;&lt;a href=&quot;#1-web框架和web服务器的关系介绍&quot; class=&quot;headerlink&quot; title=&quot;1. web框架和web服务器的关系介绍&quot;&gt;&lt;/a&gt;1. web框架和web服务器的关系介绍&lt;/h3&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://caijinbo.work/categories/python/"/>
    
    
      <category term="python" scheme="https://caijinbo.work/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>linux 安装mysql并设置密码</title>
    <link href="https://caijinbo.work/2020/08/22/2020-08-23-linux-%E5%AE%89%E8%A3%85mysql%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81/"/>
    <id>https://caijinbo.work/2020/08/22/2020-08-23-linux-%E5%AE%89%E8%A3%85mysql%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81/</id>
    <published>2020-08-22T16:00:00.000Z</published>
    <updated>2020-11-23T10:13:09.643Z</updated>
    
    <content type="html"><![CDATA[<h3 id="manjaro安装MySQL并设置密码"><a href="#manjaro安装MySQL并设置密码" class="headerlink" title="manjaro安装MySQL并设置密码:"></a>manjaro安装MySQL并设置密码:</h3><p>安装MySQL：</p><pre><code class="bash">sudo pacman -S mysql</code></pre><p>修改配置文件：</p><pre><code class="bash">sudo vim /etc/mysql/my.cnf  </code></pre><a id="more"></a><p>末行添加：</p><pre><code class="bash">skip-grant-tables</code></pre><p>终端输入：</p><pre><code class="bash">$ mysql</code></pre><pre><code class="bash">修改密码，把passwd替换成想要修改的密码：mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;passwd&#39;;ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement报错的解决方法：mysql&gt; flush privileges;再次修改密码：mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;passwd&#39;;Query OK, 0 rows affected (0.03 sec)刷新MySQL的系统权限相关表：mysql&gt; flush privileges;Query OK, 0 rows affected (0.02 sec)退出MySQL：mysql&gt; quitBye</code></pre><p>注释最后一行</p><pre><code class="bash">sudo vim /etc/mysql/my.cnf # skip-grant-tables  或者直接删除</code></pre><p>重启mysql                                                                  </p><pre><code class="bash">sudo systemctl restart mysqld.service    </code></pre><p>连接mysql测试一下是否成功：</p><pre><code class="bash">~ &gt;&gt;&gt; mysql -uroot -p                                                                                                                                                     Enter password: Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 10Server version: 8.0.21 Source distributionCopyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.mysql&gt; quitBye</code></pre><p>Welcome to the MySQL monitor.代表已成功登录MySQL；</p><h3 id="ubuntu20-04设置mysql8-0密码"><a href="#ubuntu20-04设置mysql8-0密码" class="headerlink" title="ubuntu20.04设置mysql8.0密码"></a>ubuntu20.04设置mysql8.0密码</h3><p>刚安装完mysql时是默认没有密码的，终端直接输入mysql可以直接进入了</p><p>按照以下步骤输入：</p><pre><code class="sql">1. ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39; PASSWORD EXPIRE NEVER;2. ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39;;3. FLUSH PRIVILEGES;4. alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;123456&#39;;重置密码用户名为root的密码</code></pre><h3 id="centos-安装mysql-并设置密码"><a href="#centos-安装mysql-并设置密码" class="headerlink" title="centos 安装mysql 并设置密码"></a>centos 安装mysql 并设置密码</h3><pre><code class="bash">安装mysql：yum install mysql mysql-devel -y查看是否安装成功：yum list mysql-server</code></pre><p>修改密码：</p><pre><code class="sql">$ mysqlmysql&gt; use mysql;mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;mysql&gt; FLUSH PRIVILEGES;mysql&gt; quit</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;manjaro安装MySQL并设置密码&quot;&gt;&lt;a href=&quot;#manjaro安装MySQL并设置密码&quot; class=&quot;headerlink&quot; title=&quot;manjaro安装MySQL并设置密码:&quot;&gt;&lt;/a&gt;manjaro安装MySQL并设置密码:&lt;/h3&gt;&lt;p&gt;安装MySQL：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;sudo pacman -S mysql&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;sudo vim /etc/mysql/my.cnf  &lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://caijinbo.work/categories/python/"/>
    
    
      <category term="python" scheme="https://caijinbo.work/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python高级10-正则表达式</title>
    <link href="https://caijinbo.work/2020/08/22/2020-08-23-python%E9%AB%98%E7%BA%A710-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://caijinbo.work/2020/08/22/2020-08-23-python%E9%AB%98%E7%BA%A710-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-08-22T16:00:00.000Z</published>
    <updated>2020-11-23T10:13:46.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="一、property属性"><a href="#一、property属性" class="headerlink" title="一、property属性"></a>一、property属性</h2><h3 id="1-property属性的介绍"><a href="#1-property属性的介绍" class="headerlink" title="1. property属性的介绍"></a>1. property属性的介绍</h3><p>property属性就是负责把一个方法当做属性进行使用，这样做可以简化代码使用。</p><a id="more"></a><p><strong>定义property属性有两种方式</strong></p><ol><li>装饰器方式</li><li>类属性方式</li></ol><h3 id="2-装饰器方式"><a href="#2-装饰器方式" class="headerlink" title="2. 装饰器方式"></a>2. 装饰器方式</h3><pre><code class="python">class Person(object):    def __init__(self):        self.__age = 0    # 装饰器方式的property, 把age方法当做属性使用, 表示当获取属性时会执行下面修饰的方法    @property    def age(self):        return self.__age    # 把age方法当做属性使用, 表示当设置属性时会执行下面修饰的方法    @age.setter    def age(self, new_age):        if new_age &gt;= 150:            print(&quot;成精了&quot;)        else:            self.__age = new_age# 创建personp = Person()print(p.age)p.age = 100print(p.age)p.age = 1000</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">0100成精了</code></pre><p><strong>代码说明:</strong></p><ul><li>@property 表示把方法当做属性使用, 表示当获取属性时会执行下面修饰的方法</li><li>@方法名.setter 表示把方法当做属性使用,表示当设置属性时会执行下面修饰的方法</li><li>装饰器方式的property属性修饰的方法名一定要一样。</li></ul><h3 id="3-类属性方式"><a href="#3-类属性方式" class="headerlink" title="3. 类属性方式"></a>3. 类属性方式</h3><pre><code class="python">class Person(object):    def __init__(self):        self.__age = 0    def get_age(self):        &quot;&quot;&quot;当获取age属性的时候会执行该方法&quot;&quot;&quot;        return self.__age    def set_age(self, new_age):        &quot;&quot;&quot;当设置age属性的时候会执行该方法&quot;&quot;&quot;        if new_age &gt;= 150:            print(&quot;成精了&quot;)        else:            self.__age = new_age    # 类属性方式的property属性    age = property(get_age, set_age)# 创建personp = Person()print(p.age)p.age = 100print(p.age)p.age = 1000</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">0100成精了</code></pre><p><strong>代码说明:</strong></p><ul><li>property的参数说明:<ul><li>第一个参数是获取属性时要执行的方法</li><li>第二个参数是设置属性时要执行的方法</li></ul></li></ul><h2 id="二、with语句和上下文管理器"><a href="#二、with语句和上下文管理器" class="headerlink" title="二、with语句和上下文管理器"></a>二、with语句和上下文管理器</h2><h3 id="1-with语句的使用"><a href="#1-with语句的使用" class="headerlink" title="1. with语句的使用"></a>1. with语句的使用</h3><p><strong>基础班向文件中写入数据的示例代码:</strong></p><pre><code class="python"> # 1、以写的方式打开文件 f = open(&quot;1.txt&quot;, &quot;w&quot;) # 2、写入文件内容 f.write(&quot;hello world&quot;) # 3、关闭文件 f.close()</code></pre><p><strong>代码说明:</strong></p><ul><li>文件使用完后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的</li></ul><p><strong>这种写法可能出现一定的安全隐患，错误代码如下:</strong></p><pre><code class="python"> # 1、以读的方式打开文件 f = open(&quot;1.txt&quot;, &quot;r&quot;) # 2、读取文件内容 f.write(&quot;hello world&quot;) # 3、关闭文件 f.close()</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">Traceback (most recent call last):  File &quot;/home/python/Desktop/test/xxf.py&quot;, line 4, in &lt;module&gt;    f.write(&quot;hello world&quot;)io.UnsupportedOperation: not writable</code></pre><p><strong>代码说明:</strong></p><ul><li>由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。</li><li>为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来解决</li></ul><p><strong>安全写法, 代码如下:</strong></p><pre><code class="python">try:    # 1、以读的方式打开文件    f = open(&quot;1.txt&quot;, &quot;r&quot;)    # 2、读取文件内容    f.write(&quot;xxxxx&quot;)except IOError as e:    print(&quot;文件操作出错&quot;, e)finally:    # 3、关闭文件    f.close()</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">文件操作出错 not writable</code></pre><p>这种方法虽然代码运行良好,但是缺点就是代码过于冗长,并且需要添加try-except-finally语句,不是很方便,也容易忘记.</p><p>在这种情况下,<strong>Python提供了 with 语句的这种写法，既简单又安全，并且 with 语句执行完成以后自动调用关闭文件操作，即使出现异常也会自动调用关闭文件操作</strong>。</p><p><strong>with 语句的示例代码:</strong></p><pre><code class="python"># 1、以写的方式打开文件with open(&quot;1.txt&quot;, &quot;w&quot;) as f:    # 2、读取文件内容    f.write(&quot;hello world&quot;)</code></pre><h3 id="2-上下文管理器"><a href="#2-上下文管理器" class="headerlink" title="2. 上下文管理器"></a>2. 上下文管理器</h3><p>一个类只要实现了<code>__enter__()和__exit__()</code>这个两个方法，通过该类创建的对象我们就称之为上下文管理器。</p><p>上下文管理器可以使用 with 语句，<strong>with语句之所以这么强大，背后是由上下文管理器做支撑的</strong>，也就是说刚才使用 open 函数创建的文件对象就是就是一个上下文管理器对象。</p><p><strong>自定义上下文管理器类,模拟文件操作:</strong></p><p>定义一个File类，实现 <code>__enter__() 和 __exit__()</code>方法，然后使用 with 语句来完成操作文件， 示例代码:</p><pre><code class="python">class File(object):    # 初始化方法    def __init__(self, file_name, file_model):        # 定义变量保存文件名和打开模式        self.file_name = file_name        self.file_model = file_model    # 上文方法    def __enter__(self):        print(&quot;进入上文方法&quot;)        # 返回文件资源        self.file = open(self.file_name,self.file_model)        return self.file    # 下文方法    def __exit__(self, exc_type, exc_val, exc_tb):        print(&quot;进入下文方法&quot;)        self.file.close()if __name__ == &#39;__main__&#39;:    # 使用with管理文件    with File(&quot;1.txt&quot;, &quot;r&quot;) as file:        file_data = file.read()        print(file_data)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">进入上文方法hello world进入下文方法</code></pre><p><strong>代码说明:</strong></p><ul><li><code>__enter__</code>表示上文方法，需要返回一个操作文件对象</li><li><code>__exit__</code>表示下文方法，with语句执行完成会自动执行，即使出现异常也会执行该方法。</li></ul><h2 id="三、生成器的创建方式"><a href="#三、生成器的创建方式" class="headerlink" title="三、生成器的创建方式"></a>三、生成器的创建方式</h2><h3 id="1-生成器的介绍"><a href="#1-生成器的介绍" class="headerlink" title="1. 生成器的介绍"></a>1. 生成器的介绍</h3><p>根据程序员制定的规则循环生成数据，当条件不成立时则生成数据结束。数据不是一次性全部生成出来，而是使用一个，再生成一个，可以<strong>节约大量的内存</strong>。</p><h3 id="2-创建生成器的方式"><a href="#2-创建生成器的方式" class="headerlink" title="2. 创建生成器的方式"></a>2. 创建生成器的方式</h3><ol><li>生成器推导式</li><li>yield 关键字</li></ol><p><strong>生成器推导式:</strong></p><ul><li>与列表推导式类似，只不过生成器推导式使用小括号</li></ul><pre><code class="python"># 创建生成器my_generator = (i * 2 for i in range(5))print(my_generator)# next获取生成器下一个值# value = next(my_generator)# print(value)# 遍历生成器for value in my_generator:    print(value)</code></pre><p><strong>代码说明:</strong></p><ul><li>next 函数获取生成器中的下一个值</li><li>for 循环遍历生成器中的每一个值</li></ul><p><strong>运行结果:</strong></p><pre><code class="python">&lt;generator object &lt;genexpr&gt; at 0x101367048&gt;02468</code></pre><p><strong>yield 关键字:</strong></p><ul><li>只要在def函数里面看到有 yield 关键字那么就是生成器</li></ul><pre><code class="python">def mygenerater(n):    for i in range(n):        print(&#39;开始生成...&#39;)        yield i        print(&#39;完成一次...&#39;)if __name__ == &#39;__main__&#39;:    g = mygenerater(2)    # 获取生成器中下一个值    # result = next(g)    # print(result)    # while True:    #     try:    #         result = next(g)    #         print(result)    #     except StopIteration as e:    #         break    # # for遍历生成器, for 循环内部自动处理了停止迭代异常，使用起来更加方便    for i in g:        print(i)</code></pre><p><strong>代码说明:</strong></p><ul><li>代码执行到 yield 会暂停，然后把结果返回出去，下次启动生成器会在暂停的位置继续往下执行</li><li>生成器如果把数据生成完成，再次获取生成器中的下一个数据会抛出一个StopIteration 异常，表示停止迭代异常</li><li>while 循环内部没有处理异常操作，需要手动添加处理异常操作</li><li>for 循环内部自动处理了停止迭代异常，使用起来更加方便，推荐大家使用。</li></ul><p><strong>运行结果:</strong></p><pre><code class="python">开始生成...0完成一次...开始生成...1完成一次...</code></pre><h3 id="3-生成器的使用场景"><a href="#3-生成器的使用场景" class="headerlink" title="3. 生成器的使用场景"></a>3. 生成器的使用场景</h3><p>数学中有个著名的斐波拉契数列（Fibonacci），数列中第一个数为0，第二个数为1，其后的每一个数都可由前两个数相加得到：</p><p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, …</p><p>现在我们使用生成器来实现这个斐波那契数列，每次取值都通过算法来生成下一个数据, <strong>生成器每次调用只生成一个数据，可以节省大量的内存。</strong></p><pre><code class="python">def fibonacci(num):    a = 0    b = 1    # 记录生成fibonacci数字的下标    current_index = 0    while current_index &lt; num:        result = a        a, b = b, a + b        current_index += 1        # 代码执行到yield会暂停，然后把结果返回出去，下次启动生成器会在暂停的位置继续往下执行        yield resultfib = fibonacci(5)# 遍历生成的数据for value in fib:    print(value)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">01123</code></pre><h2 id="四、深拷贝和浅拷贝"><a href="#四、深拷贝和浅拷贝" class="headerlink" title="四、深拷贝和浅拷贝"></a>四、深拷贝和浅拷贝</h2><h3 id="1-浅拷贝"><a href="#1-浅拷贝" class="headerlink" title="1. 浅拷贝"></a>1. 浅拷贝</h3><p>copy函数是浅拷贝，只对可变类型的第一层对象进行拷贝，对拷贝的对象开辟新的内存空间进行存储，不会拷贝对象内部的子对象。</p><p><strong>不可变类型的浅拷贝示例代码:</strong></p><pre><code class="python">import copy  # 使用浅拷贝需要导入copy模块# 不可变类型有: 数字、字符串、元组a1 = 123123b1 = copy.copy(a1)  # 使用copy模块里的copy()函数就是浅拷贝了# 查看内存地址print(id(a1))print(id(b1))print(&quot;-&quot; * 10)a2 = &quot;abc&quot;b2 = copy.copy(a2)# 查看内存地址print(id(a2))print(id(b2))print(&quot;-&quot; * 10)a3 = (1, 2, [&quot;hello&quot;, &quot;world&quot;])b3 = copy.copy(a3)# 查看内存地址print(id(a3))print(id(b3))</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">140459558944048140459558944048----------140459558648776140459558648776----------140459558073328140459558073328</code></pre><p><strong>不可变类型的浅拷贝说明:</strong></p><ul><li><strong>通过上面的执行结果可以得知，不可变类型进行浅拷贝不会给拷贝的对象开辟新的内存空间，而只是拷贝了这个对象的引用。</strong></li></ul><p><strong>可变类型的浅拷贝示例代码:</strong></p><pre><code class="python">import copy # 使用浅拷贝需要导入copy模块# 可变类型有: 列表、字典、集合a1 = [1, 2]b1 = copy.copy(a1) # 使用copy模块里的copy()函数就是浅拷贝了# 查看内存地址print(id(a1))print(id(b1))print(&quot;-&quot; * 10)a2 = {&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 20}b2 = copy.copy(a2)# 查看内存地址print(id(a2))print(id(b2))print(&quot;-&quot; * 10)a3 = {1, 2, &quot;王五&quot;}b3 = copy.copy(a3)# 查看内存地址print(id(a3))print(id(b3))print(&quot;-&quot; * 10)a4 = [1, 2, [4, 5]]# 注意：浅拷贝只会拷贝父对象，不会对子对象进行拷贝b4 = copy.copy(a4) # 使用copy模块里的copy()函数就是浅拷贝了# 查看内存地址print(id(a4))print(id(b4))print(&quot;-&quot; * 10)# 查看内存地址print(id(a4[2]))print(id(b4[2]))# 修改数据a4[2][0] = 6# 子对象的数据会受影响print(a4)print(b4)</code></pre><p><strong>运行结果:</strong></p><pre><code class="py">139882899585608139882899585800----------139882919626432139882919626504----------139882919321672139882899616264----------139882899587016139882899586952----------139882899693640139882899693640[1, 2, [6, 5]][1, 2, [6, 5]]</code></pre><p><strong>可变类型的浅拷贝说明:</strong></p><ul><li><strong>通过上面的执行结果可以得知，可变类型进行浅拷贝只对可变类型的第一层对象进行拷贝，对拷贝的对象会开辟新的内存空间进行存储，子对象不进行拷贝。</strong></li></ul><h3 id="2-深拷贝"><a href="#2-深拷贝" class="headerlink" title="2. 深拷贝"></a>2. 深拷贝</h3><p>deepcopy函数是深拷贝, 只要发现对象有可变类型就会对该对象到最后一个可变类型的每一层对象就行拷贝, 对每一层拷贝的对象都会开辟新的内存空间进行存储。</p><p><strong>不可变类型的深拷贝示例代码:</strong></p><pre><code class="python">import copy  # 使用深拷贝需要导入copy模块# 不可变类型有: 数字、字符串、元组a1 = 1b1 = copy.deepcopy(a1)  # 使用copy模块里的deepcopy()函数就是深拷贝了# 查看内存地址print(id(a1))print(id(b1))print(&quot;-&quot; * 10)a2 = &quot;张三&quot;b2 = copy.deepcopy(a2)# 查看内存地址print(id(a2))print(id(b2))print(&quot;-&quot; * 10)a3 = (1, 2)b3 = copy.deepcopy(a3)# 查看内存地址print(id(a3))print(id(b3))print(&quot;-&quot; * 10)# 注意: 元组里面要是有可变类型对象，发现对象有可变类型就会该对象到最后一个可变类型的每一层对象进行拷贝a4 = (1, [&quot;李四&quot;])b4 = copy.deepcopy(a4)# 查看内存地址print(id(a4))print(id(b4))# 元组里面的可变类型子对象也会进行拷贝print(id(a4[1]))print(id(b4[1]))</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">92891209289120----------140115621848320140115621848320----------140115621859592140115621859592----------140115602480584140115621834568140115602328136140115602436168</code></pre><p><strong>不可变类型的深拷贝说明:</strong></p><ul><li>通过上面的执行结果可以得知：<ul><li><strong>不可变类型进行深拷贝如果子对象没有可变类型则不会进行拷贝，而只是拷贝了这个对象的引用，否则会对该对象到最后一个可变类型的每一层对象就行拷贝, 对每一层拷贝的对象都会开辟新的内存空间进行存储</strong></li></ul></li></ul><p><strong>可变类型的深拷贝示例代码:</strong></p><pre><code class="python">import copy  # 使用深拷贝需要导入copy模块# 可变类型有: 列表、字典、集合a1 = [1, 2]b1 = copy.deepcopy(a1)  # 使用copy模块里的deepcopy()函数就是深拷贝了# 查看内存地址print(id(a1))print(id(b1))print(&quot;-&quot; * 10)a2 = {&quot;name&quot;: &quot;张三&quot;}b2 = copy.deepcopy(a2)# 查看内存地址print(id(a2))print(id(b2))print(&quot;-&quot; * 10)a3 = {1, 2}b3 = copy.deepcopy(a3)# 查看内存地址print(id(a3))print(id(b3))print(&quot;-&quot; * 10)a4 = [1, 2, [&quot;李四&quot;, &quot;王五&quot;]]b4 = copy.deepcopy(a4)  # 使用copy模块里的deepcopy()函数就是深拷贝了# 查看内存地址print(id(a4))print(id(b4))# 查看内存地址print(id(a4[2]))print(id(b4[2]))a4[2][0] = &quot;王五&quot;# 因为列表的内存地址不同，所以数据不会收到影响print(a4)print(b4)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">140348291721736140348291721928----------140348311762624140348311221592----------140348311457864140348291752456----------140348291723080140348291723144140348291723208140348291723016[1, 2, [&#39;王五&#39;, &#39;王五&#39;]][1, 2, [&#39;李四&#39;, &#39;王五&#39;]]</code></pre><p><strong>可变类型的深拷贝说明:</strong></p><ul><li>通过上面的执行结果可以得知, 可变类型进行深拷贝会对该对象到最后一个可变类型的每一层对象就行拷贝, 对每一层拷贝的对象都会开辟新的内存空间进行存储。</li></ul><h3 id="3-浅拷贝和深拷贝的区别"><a href="#3-浅拷贝和深拷贝的区别" class="headerlink" title="3. 浅拷贝和深拷贝的区别"></a>3. 浅拷贝和深拷贝的区别</h3><ul><li>浅拷贝最多拷贝对象的一层</li><li>深拷贝可能拷贝对象的多层</li></ul><h2 id="五、正则表达式的概述"><a href="#五、正则表达式的概述" class="headerlink" title="五、正则表达式的概述"></a>五、正则表达式的概述</h2><h3 id="1-正则表达式的介绍"><a href="#1-正则表达式的介绍" class="headerlink" title="1. 正则表达式的介绍"></a>1. 正则表达式的介绍</h3><p>在实际开发过程中经常会有查找符合某些复杂规则的字符串的需要，比如:邮箱、图片地址、手机号码等，这时候想匹配或者查找符合某些规则的字符串就可以使用正则表达式了。</p><h3 id="2-正则表达式概念"><a href="#2-正则表达式概念" class="headerlink" title="2. 正则表达式概念"></a>2. 正则表达式概念</h3><p><strong>正则表达式就是记录文本规则的代码</strong></p><h3 id="3-正则表达式的样子"><a href="#3-正则表达式的样子" class="headerlink" title="3. 正则表达式的样子"></a>3. 正则表达式的样子</h3><p>0\d{2}-\d{8} 这个就是一个正则表达式，表达的意思是匹配的是座机号码</p><h3 id="4-正则表达式的特点"><a href="#4-正则表达式的特点" class="headerlink" title="4. 正则表达式的特点"></a>4. 正则表达式的特点</h3><ul><li>正则表达式的语法很令人头疼，可读性差</li><li>正则表达式通用行很强，能够适用于很多编程语言</li></ul><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><ul><li>正则表达式是匹配符合某些规则的字符串数据</li><li></li></ul><h2 id="六、re模块介绍"><a href="#六、re模块介绍" class="headerlink" title="六、re模块介绍"></a>六、re模块介绍</h2><h1 id="re模块介绍"><a href="#re模块介绍" class="headerlink" title="re模块介绍"></a>re模块介绍</h1><p><strong>学习目标</strong></p><ul><li>能够知道在python中使用正则表达式需要导入的模块</li></ul><hr><h3 id="1-re模块的介绍"><a href="#1-re模块的介绍" class="headerlink" title="1. re模块的介绍"></a>1. re模块的介绍</h3><p>在Python中需要通过正则表达式对字符串进行匹配的时候，可以使用一个 re 模块</p><pre><code class="python"># 导入re模块import re# 使用match方法进行匹配操作result = re.match(正则表达式,要匹配的字符串)# 如果上一步匹配到数据的话，可以使用group方法来提取数据result.group()</code></pre><h3 id="2-re模块的使用"><a href="#2-re模块的使用" class="headerlink" title="2. re模块的使用"></a>2. re模块的使用</h3><pre><code class="python">import re# 使用match方法进行匹配操作result = re.match(&quot;itcast&quot;,&quot;itcast.cn&quot;)# 获取匹配结果info = result.group()print(info)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">itcast</code></pre><h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h3><ul><li>re.match() 根据正则表达式从头开始匹配字符串数据</li></ul><h2 id="七、匹配单个字符"><a href="#七、匹配单个字符" class="headerlink" title="七、匹配单个字符"></a>七、匹配单个字符</h2><h1 id="匹配单个字符"><a href="#匹配单个字符" class="headerlink" title="匹配单个字符"></a>匹配单个字符</h1><p><strong>学习目标</strong></p><ul><li>能够使用re模块匹配单个字符</li></ul><hr><h3 id="1-匹配单个字符"><a href="#1-匹配单个字符" class="headerlink" title="1. 匹配单个字符"></a>1. 匹配单个字符</h3><p>在上一小节中，了解到通过re模块能够完成使用正则表达式来匹配字符串</p><p>本小节，将要讲解正则表达式的单字符匹配</p><table><thead><tr><th align="center">代码</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center">.</td><td align="left">匹配任意1个字符（除了\n）</td></tr><tr><td align="center">[ ]</td><td align="left">匹配[ ]中列举的字符</td></tr><tr><td align="center">\d</td><td align="left">匹配数字，即0-9</td></tr><tr><td align="center">\D</td><td align="left">匹配非数字，即不是数字</td></tr><tr><td align="center">\s</td><td align="left">匹配空白，即 空格，tab键</td></tr><tr><td align="center">\S</td><td align="left">匹配非空白</td></tr><tr><td align="center">\w</td><td align="left">匹配非特殊字符，即a-z、A-Z、0-9、_、汉字</td></tr><tr><td align="center">\W</td><td align="left">匹配特殊字符，即非字母、非数字、非汉字</td></tr></tbody></table><h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1： ."></a>示例1： .</h3><pre><code class="python">import reret = re.match(&quot;.&quot;,&quot;M&quot;)print(ret.group())ret = re.match(&quot;t.o&quot;,&quot;too&quot;)print(ret.group())ret = re.match(&quot;t.o&quot;,&quot;two&quot;)print(ret.group())</code></pre><p>运行结果：</p><pre><code class="python">Mtootwo</code></pre><h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2：[ ]"></a>示例2：[ ]</h3><pre><code class="python">import re# 如果hello的首字符小写，那么正则表达式需要小写的hret = re.match(&quot;h&quot;,&quot;hello Python&quot;) print(ret.group())# 如果hello的首字符大写，那么正则表达式需要大写的Hret = re.match(&quot;H&quot;,&quot;Hello Python&quot;) print(ret.group())# 大小写h都可以的情况ret = re.match(&quot;[hH]&quot;,&quot;hello Python&quot;)print(ret.group())ret = re.match(&quot;[hH]&quot;,&quot;Hello Python&quot;)print(ret.group())ret = re.match(&quot;[hH]ello Python&quot;,&quot;Hello Python&quot;)print(ret.group())# 匹配0到9第一种写法ret = re.match(&quot;[0123456789]Hello Python&quot;,&quot;7Hello Python&quot;)print(ret.group())# 匹配0到9第二种写法ret = re.match(&quot;[0-9]Hello Python&quot;,&quot;7Hello Python&quot;)print(ret.group())ret = re.match(&quot;[0-35-9]Hello Python&quot;,&quot;7Hello Python&quot;)print(ret.group())# 下面这个正则不能够匹配到数字4，因此ret为Noneret = re.match(&quot;[0-35-9]Hello Python&quot;,&quot;4Hello Python&quot;)# print(ret.group())</code></pre><p>运行结果：</p><pre><code class="python">hHhHHello Python7Hello Python7Hello Python7Hello Python</code></pre><h3 id="示例3：-d"><a href="#示例3：-d" class="headerlink" title="示例3：\d"></a>示例3：\d</h3><pre><code class="python">import re# 普通的匹配方式ret = re.match(&quot;嫦娥1号&quot;,&quot;嫦娥1号发射成功&quot;) print(ret.group())ret = re.match(&quot;嫦娥2号&quot;,&quot;嫦娥2号发射成功&quot;) print(ret.group())ret = re.match(&quot;嫦娥3号&quot;,&quot;嫦娥3号发射成功&quot;) print(ret.group())# 使用\d进行匹配ret = re.match(&quot;嫦娥\d号&quot;,&quot;嫦娥1号发射成功&quot;) print(ret.group())ret = re.match(&quot;嫦娥\d号&quot;,&quot;嫦娥2号发射成功&quot;) print(ret.group())ret = re.match(&quot;嫦娥\d号&quot;,&quot;嫦娥3号发射成功&quot;) print(ret.group())</code></pre><p>运行结果：</p><pre><code class="python">嫦娥1号嫦娥2号嫦娥3号嫦娥1号嫦娥2号嫦娥3号</code></pre><h3 id="示例4：-D"><a href="#示例4：-D" class="headerlink" title="示例4：\D"></a>示例4：\D</h3><pre><code class="python">import rematch_obj = re.match(&quot;\D&quot;, &quot;f&quot;)if match_obj:    # 获取匹配结果    print(match_obj.group())else:    print(&quot;匹配失败&quot;)</code></pre><p>运行结果:</p><pre><code class="python">f</code></pre><h3 id="示例5：-s"><a href="#示例5：-s" class="headerlink" title="示例5：\s"></a>示例5：\s</h3><pre><code class="python">import re# 空格属于空白字符match_obj = re.match(&quot;hello\sworld&quot;, &quot;hello world&quot;)if match_obj:    result = match_obj.group()    print(result)else:    print(&quot;匹配失败&quot;)# \t 属于空白字符match_obj = re.match(&quot;hello\sworld&quot;, &quot;hello\tworld&quot;)if match_obj:    result = match_obj.group()    print(result)else:    print(&quot;匹配失败&quot;)</code></pre><p>运行结果:</p><pre><code class="python">hello worldhello world</code></pre><h3 id="示例6：-S"><a href="#示例6：-S" class="headerlink" title="示例6：\S"></a>示例6：\S</h3><pre><code class="python">import rematch_obj = re.match(&quot;hello\Sworld&quot;, &quot;hello&amp;world&quot;)if match_obj:result = match_obj.group()print(result)else:print(&quot;匹配失败&quot;)match_obj = re.match(&quot;hello\Sworld&quot;, &quot;hello$world&quot;)if match_obj:result = match_obj.group()print(result)else:print(&quot;匹配失败&quot;)</code></pre><p>运行结果:</p><pre><code class="python">hello&amp;world  hello$world</code></pre><h3 id="示例7：-w"><a href="#示例7：-w" class="headerlink" title="示例7：\w"></a>示例7：\w</h3><pre><code class="python">import re# 匹配非特殊字符中的一位match_obj = re.match(&quot;\w&quot;, &quot;A&quot;)if match_obj:    # 获取匹配结果    print(match_obj.group())else:    print(&quot;匹配失败&quot;)</code></pre><p>执行结果:</p><pre><code>A</code></pre><h3 id="示例8：-W"><a href="#示例8：-W" class="headerlink" title="示例8：\W"></a>示例8：\W</h3><pre><code class="python"># 匹配特殊字符中的一位match_obj = re.match(&quot;\W&quot;, &quot;&amp;&quot;)if match_obj:    # 获取匹配结果    print(match_obj.group())else:    print(&quot;匹配失败&quot;)</code></pre><p>执行结果:</p><pre><code>&amp;</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>. 表示匹配任意1个字符（除了\n）</li><li><input disabled="" type="checkbox"> 表示匹配[ ]中列举的1个字符</li><li>\d 表示匹配一个数字，即0-9</li><li>\D 表示匹配一个非数字，即不是数字</li><li>\s 表示匹配一个空白字符，即 空格，tab键</li><li>\S | 匹配一个非空白字符</li><li>\w | 匹配一个非特殊字符，即a-z、A-Z、0-9、_、汉字</li><li>\W | 匹配一个特殊字符，即非字母、非数字、非汉字</li></ul><h2 id="八、匹配多个字符"><a href="#八、匹配多个字符" class="headerlink" title="八、匹配多个字符"></a>八、匹配多个字符</h2><h3 id="1-匹配多个字符"><a href="#1-匹配多个字符" class="headerlink" title="1. 匹配多个字符"></a>1. 匹配多个字符</h3><table><thead><tr><th align="center">代码</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center">*</td><td align="left">匹配前一个字符出现0次或者无限次，即可有可无</td></tr><tr><td align="center">+</td><td align="left">匹配前一个字符出现1次或者无限次，即至少有1次</td></tr><tr><td align="center">?</td><td align="left">匹配前一个字符出现1次或者0次，即要么有1次，要么没有</td></tr><tr><td align="center">{m}</td><td align="left">匹配前一个字符出现m次</td></tr><tr><td align="center">{m,n}</td><td align="left">匹配前一个字符出现从m到n次</td></tr></tbody></table><h3 id="示例1：-1"><a href="#示例1：-1" class="headerlink" title="示例1：*"></a>示例1：*</h3><p>需求：匹配出一个字符串第一个字母为大小字符，后面都是小写字母并且这些小写字母可 有可无</p><pre><code class="python">import reret = re.match(&quot;[A-Z][a-z]*&quot;,&quot;M&quot;)print(ret.group())ret = re.match(&quot;[A-Z][a-z]*&quot;,&quot;MnnM&quot;)print(ret.group())ret = re.match(&quot;[A-Z][a-z]*&quot;,&quot;Aabcdef&quot;)print(ret.group())</code></pre><p>运行结果：</p><pre><code class="python">MMnnAabcdef</code></pre><h3 id="示例2：-1"><a href="#示例2：-1" class="headerlink" title="示例2：+"></a>示例2：+</h3><p>需求：匹配一个字符串，第一个字符是t,最后一个字符串是o,中间至少有一个字符</p><pre><code class="python">import rematch_obj = re.match(&quot;t.+o&quot;, &quot;two&quot;)if match_obj:    print(match_obj.group())else:    print(&quot;匹配失败&quot;)</code></pre><p>运行结果：</p><pre><code class="python">two</code></pre><h3 id="示例3："><a href="#示例3：" class="headerlink" title="示例3：?"></a>示例3：?</h3><p>需求：匹配出这样的数据，但是https 这个s可能有，也可能是http 这个s没有</p><pre><code class="python">import rematch_obj = re.match(&quot;https?&quot;, &quot;http&quot;)if match_obj:    print(match_obj.group())else:    print(&quot;匹配失败&quot;)</code></pre><p>运行结果：</p><pre><code class="python">https</code></pre><h3 id="示例4：-m-、-m-n"><a href="#示例4：-m-、-m-n" class="headerlink" title="示例4：{m}、{m,n}"></a>示例4：{m}、{m,n}</h3><p>需求：匹配出，8到20位的密码，可以是大小写英文字母、数字、下划线</p><pre><code class="python">import reret = re.match(&quot;[a-zA-Z0-9_]{6}&quot;,&quot;12a3g45678&quot;)print(ret.group())ret = re.match(&quot;[a-zA-Z0-9_]{8,20}&quot;,&quot;1ad12f23s34455ff66&quot;)print(ret.group())</code></pre><p>运行结果：</p><pre><code class="python">12a3g41ad12f23s34455ff66</code></pre><h3 id="2-小结"><a href="#2-小结" class="headerlink" title="2. 小结"></a>2. 小结</h3><ul><li>*表示匹配前一个字符出现0次或者无限次，即可有可无</li><li>+表示匹配前一个字符出现1次或者无限次，即至少有1次</li><li>?表示匹配前一个字符出现1次或者0次，即要么有1次，要么没有</li><li>{m}表示匹配前一个字符出现m次</li><li>{m,n}表示匹配前一个字符出现从m到n次</li><li></li></ul><h2 id="九、匹配开头和结尾"><a href="#九、匹配开头和结尾" class="headerlink" title="九、匹配开头和结尾"></a>九、匹配开头和结尾</h2><h3 id="1-匹配开头和结尾"><a href="#1-匹配开头和结尾" class="headerlink" title="1. 匹配开头和结尾"></a>1. 匹配开头和结尾</h3><table><thead><tr><th align="center">代码</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center">^</td><td align="left">匹配字符串开头</td></tr><tr><td align="center">$</td><td align="left">匹配字符串结尾</td></tr></tbody></table><h3 id="示例1：-2"><a href="#示例1：-2" class="headerlink" title="示例1：^"></a>示例1：^</h3><p>需求：匹配以数字开头的数据</p><pre><code class="python">import re# 匹配以数字开头的数据match_obj = re.match(&quot;^\d.*&quot;, &quot;3hello&quot;)if match_obj:    # 获取匹配结果    print(match_obj.group())else:    print(&quot;匹配失败&quot;)</code></pre><p>运行结果:</p><pre><code class="python">3hello</code></pre><h3 id="示例2：-2"><a href="#示例2：-2" class="headerlink" title="示例2：$"></a>示例2：$</h3><p>需求: 匹配以数字结尾的数据</p><pre><code class="python">import re# 匹配以数字结尾的数据match_obj = re.match(&quot;.*\d$&quot;, &quot;hello5&quot;)if match_obj:    # 获取匹配结果    print(match_obj.group())else:    print(&quot;匹配失败&quot;)</code></pre><p>运行结果：</p><pre><code class="python">hello5</code></pre><h3 id="示例3：-和"><a href="#示例3：-和" class="headerlink" title="示例3：^ 和 $"></a>示例3：^ 和 $</h3><p>需求: 匹配以数字开头中间内容不管以数字结尾</p><pre><code class="python">match_obj = re.match(&quot;^\d.*\d$&quot;, &quot;4hello4&quot;)if match_obj:    # 获取匹配结果    print(match_obj.group())else:    print(&quot;匹配失败&quot;)</code></pre><p>运行结果:</p><pre><code class="python">4hello4</code></pre><h3 id="2-除了指定字符以外都匹配"><a href="#2-除了指定字符以外都匹配" class="headerlink" title="2.除了指定字符以外都匹配"></a>2.除了指定字符以外都匹配</h3><p>需求: 第一个字符除了aeiou的字符都匹配</p><pre><code class="python">import rematch_obj = re.match(&quot;[^aeiou]&quot;, &quot;h&quot;)if match_obj:    # 获取匹配结果    print(match_obj.group())else:    print(&quot;匹配失败&quot;)</code></pre><p>执行结果</p><pre><code>h</code></pre><h3 id="3-小结-1"><a href="#3-小结-1" class="headerlink" title="3. 小结"></a>3. 小结</h3><ul><li>^ 表示匹配字符串开头</li><li>$ 表示匹配字符串结尾</li></ul><h2 id="十、匹配分组"><a href="#十、匹配分组" class="headerlink" title="十、匹配分组"></a>十、匹配分组</h2><h3 id="1-匹配分组相关正则表达式"><a href="#1-匹配分组相关正则表达式" class="headerlink" title="1. 匹配分组相关正则表达式"></a>1. 匹配分组相关正则表达式</h3><table><thead><tr><th align="center">代码</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center">|</td><td align="left">匹配左右任意一个表达式</td></tr><tr><td align="center">(ab)</td><td align="left">将括号中字符作为一个分组</td></tr><tr><td align="center"><code>\num</code></td><td align="left">引用分组num匹配到的字符串</td></tr><tr><td align="center"><code>(?P&lt;name&gt;)</code></td><td align="left">分组起别名</td></tr><tr><td align="center">(?P=name)</td><td align="left">引用别名为name分组匹配到的字符串</td></tr></tbody></table><h3 id="示例1：-3"><a href="#示例1：-3" class="headerlink" title="示例1：|"></a>示例1：|</h3><p>需求：在列表中[“apple”, “banana”, “orange”, “pear”]，匹配apple和pear</p><pre><code class="python">import re# 水果列表fruit_list = [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;, &quot;pear&quot;]# 遍历数据for value in fruit_list:    # |    匹配左右任意一个表达式    match_obj = re.match(&quot;apple|pear&quot;, value)    if match_obj:        print(&quot;%s是我想要的&quot; % match_obj.group())    else:        print(&quot;%s不是我要的&quot; % value)</code></pre><p>执行结果:</p><pre><code class="python">apple是我想要的banana不是我要的orange不是我要的pear是我想要的</code></pre><h3 id="示例2：-3"><a href="#示例2：-3" class="headerlink" title="示例2：( )"></a>示例2：( )</h3><p>需求：匹配出163、126、qq等邮箱</p><pre><code class="python">import rematch_obj = re.match(&quot;[a-zA-Z0-9_]{4,20}@(163|126|qq|sina|yahoo)\.com&quot;, &quot;hello@163.com&quot;)if match_obj:    print(match_obj.group())    # 获取分组数据    print(match_obj.group(1))else:    print(&quot;匹配失败&quot;)</code></pre><p>执行结果:</p><pre><code>hello@163.com163</code></pre><p>需求: 匹配qq:10567这样的数据，提取出来qq文字和qq号码</p><pre><code class="python">import rematch_obj = re.match(&quot;(qq):([1-9]\d{4,10})&quot;, &quot;qq:10567&quot;)if match_obj:    print(match_obj.group())    # 分组:默认是1一个分组，多个分组从左到右依次加1    print(match_obj.group(1))    # 提取第二个分组数据    print(match_obj.group(2))else:    print(&quot;匹配失败&quot;)</code></pre><p>执行结果:</p><pre><code>qq10567</code></pre><h3 id="示例3：-num"><a href="#示例3：-num" class="headerlink" title="示例3：\num"></a>示例3：\num</h3><p>需求：匹配出<code>&lt;html&gt;hh&lt;/html&gt;</code></p><pre><code class="python">match_obj = re.match(&quot;&lt;[a-zA-Z1-6]+&gt;.*&lt;/[a-zA-Z1-6]+&gt;&quot;, &quot;&lt;html&gt;hh&lt;/div&gt;&quot;)if match_obj:    print(match_obj.group())else:    print(&quot;匹配失败&quot;)match_obj = re.match(&quot;&lt;([a-zA-Z1-6]+)&gt;.*&lt;/\\1&gt;&quot;, &quot;&lt;html&gt;hh&lt;/html&gt;&quot;)if match_obj:    print(match_obj.group())else:    print(&quot;匹配失败&quot;)</code></pre><p>运行结果：</p><pre><code class="html">&lt;html&gt;hh&lt;/div&gt;&lt;html&gt;hh&lt;/html&gt;</code></pre><p>需求：匹配出<code>&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;</code></p><pre><code class="python">match_obj = re.match(&quot;&lt;([a-zA-Z1-6]+)&gt;&lt;([a-zA-Z1-6]+)&gt;.*&lt;/\\2&gt;&lt;/\\1&gt;&quot;, &quot;&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;&quot;)if match_obj:    print(match_obj.group())else:    print(&quot;匹配失败&quot;)</code></pre><p>运行结果：</p><pre><code class="html">&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;</code></pre><h3 id="示例4：-P-lt-name-gt-P-name"><a href="#示例4：-P-lt-name-gt-P-name" class="headerlink" title="示例4：(?P&lt;name&gt;) (?P=name)"></a>示例4：<code>(?P&lt;name&gt;)</code> <code>(?P=name)</code></h3><p>需求：匹配出<code>&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;</code></p><pre><code class="python">match_obj = re.match(&quot;&lt;(?P&lt;name1&gt;[a-zA-Z1-6]+)&gt;&lt;(?P&lt;name2&gt;[a-zA-Z1-6]+)&gt;.*&lt;/(?P=name2)&gt;&lt;/(?P=name1)&gt;&quot;, &quot;&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;&quot;)if match_obj:    print(match_obj.group())else:    print(&quot;匹配失败&quot;)</code></pre><p>运行结果：</p><pre><code class="html">&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;</code></pre><h3 id="2-小结-1"><a href="#2-小结-1" class="headerlink" title="2. 小结"></a>2. 小结</h3><ul><li>| 表示匹配左右任意一个表达式</li><li>(ab) 表示将括号中字符作为一个分组</li><li><code>\num</code> 表示引用分组num匹配到的字符串</li><li><code>(?P&lt;name&gt;)</code> 表示分组起别名</li><li>(?P=name) 表示引用别名为name分组匹配到的字符串</li><li>(分组数据)：分组数是从左到右的方式进行分配的，最左边的是第一个分组，依次类推</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h1&gt;&lt;h2 id=&quot;一、property属性&quot;&gt;&lt;a href=&quot;#一、property属性&quot; class=&quot;headerlink&quot; title=&quot;一、property属性&quot;&gt;&lt;/a&gt;一、property属性&lt;/h2&gt;&lt;h3 id=&quot;1-property属性的介绍&quot;&gt;&lt;a href=&quot;#1-property属性的介绍&quot; class=&quot;headerlink&quot; title=&quot;1. property属性的介绍&quot;&gt;&lt;/a&gt;1. property属性的介绍&lt;/h3&gt;&lt;p&gt;property属性就是负责把一个方法当做属性进行使用，这样做可以简化代码使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://caijinbo.work/categories/python/"/>
    
    
      <category term="python" scheme="https://caijinbo.work/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python高级08-MySQL数据库</title>
    <link href="https://caijinbo.work/2020/08/21/2020-08-22-python%E9%AB%98%E7%BA%A708-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93(%E6%8F%92%E5%9B%BE%E7%89%88)/"/>
    <id>https://caijinbo.work/2020/08/21/2020-08-22-python%E9%AB%98%E7%BA%A708-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93(%E6%8F%92%E5%9B%BE%E7%89%88)/</id>
    <published>2020-08-21T16:00:00.000Z</published>
    <updated>2020-11-23T10:13:50.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h1><h2 id="一、MySQL数据库的基本使用"><a href="#一、MySQL数据库的基本使用" class="headerlink" title="一、MySQL数据库的基本使用"></a>一、MySQL数据库的基本使用</h2><h3 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1.数据库"></a>1.数据库</h3><a id="more"></a><h4 id="1-1-数据库的介绍"><a href="#1-1-数据库的介绍" class="headerlink" title="1.1 数据库的介绍"></a>1.1 数据库的介绍</h4><p>数据库就是<strong>存储和管理数据的仓库</strong>，数据按照一定的格式进行存储，用户可以对数据库中的数据进行增加、修改、删除、查询等操作。</p><h4 id="1-2-数据库的分类"><a href="#1-2-数据库的分类" class="headerlink" title="1.2 数据库的分类"></a>1.2 数据库的分类</h4><ul><li>关系型数据库</li><li>非关系型数据库</li></ul><p><strong>关系型数据库:</strong></p><p>是指采用了关系模型来组织数据的数据库，简单来说，<strong>关系模型指的就是二维表格模型</strong>，好比Excel文件中的表格，强调使用表格的方式存储数据。</p><p><strong>关系型数据库中核心元素</strong></p><ul><li>数据行</li><li>数据列</li><li>数据表</li><li>数据库(数据表的集合)</li></ul><p><strong>常用的关系型数据库:</strong></p><ul><li>Oracle</li><li>Microsoft SQL Server</li><li>MySQL</li><li>SQLite</li></ul><p><strong>非关系型数据库:</strong></p><p>非关系型数据库，又被称为NoSQL（Not Only SQL )，意为不仅仅是SQL，对NoSQL 最普遍的定义是“非关联型的”，强调 Key-Value 的方式存储数据。</p><p><strong>常用的非关系型数据库:</strong></p><ul><li>MongoDB</li><li>Redis</li></ul><h4 id="1-3-数据库的作用"><a href="#1-3-数据库的作用" class="headerlink" title="1.3 数据库的作用"></a>1.3 数据库的作用</h4><p>数据库的作用就是存储和管理数据的，比如: 我们在京东网站上的浏览的商品列表数据，这些数据都会存储在数据库。</p><h4 id="1-4-数据库的特点"><a href="#1-4-数据库的特点" class="headerlink" title="1.4 数据库的特点"></a>1.4 数据库的特点</h4><ol><li>持久化存储</li><li>读写速度极高</li><li>保证数据的有效性</li></ol><h3 id="2-关系型数据库管理系统"><a href="#2-关系型数据库管理系统" class="headerlink" title="2.关系型数据库管理系统"></a>2.关系型数据库管理系统</h3><h4 id="2-1-关系型数据库管理系统的介绍"><a href="#2-1-关系型数据库管理系统的介绍" class="headerlink" title="2.1 关系型数据库管理系统的介绍"></a>2.1 关系型数据库管理系统的介绍</h4><p>数据库管理系统（英语全拼：Relational Database Management System，简称RDBMS）是<strong>为管理关系型数据库而设计的软件系统，如果大家想要使用关系型数据库就需要安装数据库管理系统，其实就是一个应用软件</strong>。</p><p><strong>关系型数据库管理系统可以分为:</strong></p><ul><li>关系型数据库服务端软件</li><li>关系型数据库客户端软件</li></ul><p><strong>关系型数据库服务端软件:</strong></p><p>主要负责管理不同的数据库，而每个数据库里面会有一系列数据文件，数据文件是用来存储数据的, 其实数据库就是一系列数据文件的集合。</p><p><strong>关系型数据库客户端软件:</strong></p><p>主要负责和关系型数据库服务端软件进行通信, 向服务端传输数据或者从服务端获取数据.</p><p><strong>说明:</strong></p><ol><li>用户操作关系型数据库客户端，实现数据库相关操作。</li><li>关系数据库客户端借助网络使用SQL语言和关系型数据库服务端进行数据通信</li><li>关系型数据库服务端管理着不同的数据库，每个数据库会有一系列的数据文件，数据都保存在数据文件里面，每个数据库可以理解成是一个文件夹。</li><li>数据库客户端和数据库服务器想要通信需要使用SQL。</li></ol><h4 id="2-2-SQL的介绍"><a href="#2-2-SQL的介绍" class="headerlink" title="2.2 SQL的介绍"></a>2.2 SQL的介绍</h4><p>SQL(Structured Query Language)是结构化查询语言，是一种用来操作RDBMS的数据库的语言。也就是说通过 SQL 可以操作 oracle,sql server,mysql,sqlite 等关系型的数据库。</p><p>SQL的作用是实现数据库客户端和数据库服务端之间的通信，SQL就是通信的桥梁。</p><p><strong>SQL语言主要分为：</strong></p><ul><li><strong>DQL：数据查询语言，用于对数据进行查询，如select</strong></li><li><strong>DML：数据操作语言，对数据进行增加、修改、删除，如insert、update、delete</strong></li><li>TPL：事务处理语言，对事务进行处理，包括begin transaction、commit、rollback</li><li>DCL：数据控制语言，进行授权与权限回收，如grant、revoke</li><li>DDL：数据定义语言，进行数据库、表的管理等，如create、drop</li></ul><p><strong>说明:</strong></p><ul><li>对于程序员来讲，重点是数据的增、删、改、查，必须熟练编写DQL、DML，能够编写DDL完成数据库、表的操作，其它操作如TPL、DCL了解即可.</li><li>SQL语言不区分大小写</li></ul><p>​    </p><h3 id="3-MySQL数据库"><a href="#3-MySQL数据库" class="headerlink" title="3.MySQL数据库"></a>3.MySQL数据库</h3><h4 id="3-1-MySQL数据库的介绍"><a href="#3-1-MySQL数据库的介绍" class="headerlink" title="3.1 MySQL数据库的介绍"></a>3.1 MySQL数据库的介绍</h4><p>MySQL是一个关系型数据库管理系统，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件，它是由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品，MySQL 是最流行的关系型数据库管理系统中的一个。</p><p><strong>MySQL的特点:</strong></p><ol><li>MySQL是开源的，所以你不需要支付额外的费用。</li><li>MySQL支持大型的数据库。可以处理拥有上千万条记录的大型数据库。</li><li>MySQL使用标准的SQL数据语言形式。</li><li>MySQL可以安装在不同的操作系统，并且提供多种编程语言的操作接口。这些编程语言包括C、C++、Python、Java、Ruby等等。</li></ol><h4 id="3-2-MySQL数据库的安装"><a href="#3-2-MySQL数据库的安装" class="headerlink" title="3.2 MySQL数据库的安装"></a>3.2 MySQL数据库的安装</h4><ul><li>MySQL数据库服务端软件的安装</li><li>MySQL数据库客户端软件的安装</li></ul><p><strong>MySQL数据库服务端软件的安装:</strong></p><p>在Ubuntu中打开终端，输入下面的命令:</p><pre><code class="bash">sudo apt install mysql-server mysql-client</code></pre><p>manjaro安装mysql：</p><pre><code class="bash">sudo pacman -S mysql</code></pre><p>centos 安装mysql </p><pre><code class="bash">yum install mysql mysql-devel -y</code></pre><p><strong>查看MySQL服务状态:</strong></p><pre><code class="bash">sudo service mysql status</code></pre><p><strong>停止MySQL服务:</strong></p><pre><code class="bash">sudo service mysql stop</code></pre><p><strong>启动MySQL服务:</strong></p><pre><code class="bash">sudo service mysql start</code></pre><p><strong>重启MySQL服务:</strong></p><pre><code class="bash">sudo service mysql restart</code></pre><p><strong>MySQL配置文件的介绍:</strong>（ubutnu）</p><p>配置文件路径为: /etc/mysql/mysql.conf.d/mysqld.cnf</p><p><strong>主要配置信息说明:</strong></p><pre><code class="bash">port表示端口号，默认为3306bind-address表示服务器绑定的ip，默认为127.0.0.1datadir表示数据库保存路径，默认为/var/lib/mysqllog_error表示错误日志，默认为/var/log/mysql/error.log</code></pre><p><strong>MySQL数据库客户端软件的安装:</strong></p><p>客户端是程序员或者dba使用的软件，通过socket方式与服务端程序通信。</p><p>常用的MySQL数据库客户端软件有</p><ol><li>图形化界面客户端Navicat</li><li>命令行客户端mysql</li></ol><p><strong>mysql命令的使用帮助:</strong></p><pre><code class="bash">mysql --help</code></pre><p><strong>MySQL客户端的使用:</strong></p><p>MySQL客户端连接MySQL服务端命令</p><pre><code class="bash">mysql -uroot -p</code></pre><p><strong>说明:</strong></p><ul><li>-u: 表示MySQL服务端的用户名</li><li>-p: 表示MySQL服务端的密码</li><li>quit 或者 exit 或者 ctr + d 表示退出</li></ul><h3 id="4-数据类型和约束"><a href="#4-数据类型和约束" class="headerlink" title="4.数据类型和约束"></a>4.数据类型和约束</h3><h4 id="4-1-数据类型"><a href="#4-1-数据类型" class="headerlink" title="4.1 数据类型"></a>4.1 数据类型</h4><p>数据类型是指在创建表的时候为表中字段指定数据类型，只有数据符合类型要求才能存储起来，使用数据类型的原则是:够用就行，尽量使用取值范围小的，而不用大的，这样可以更多的节省存储空间。</p><p><strong>常用数据类型如下:</strong></p><ul><li>整数：int，bit</li><li>小数：decimal</li><li>字符串：varchar,char</li><li>日期时间: date, time, datetime</li><li>枚举类型(enum)</li></ul><p><strong>数据类型说明:</strong></p><ul><li>decimal表示浮点数，如 decimal(5, 2) 表示共存5位数，小数占 2 位.</li><li>char表示固定长度的字符串，如char(3)，如果填充’ab’时会补一个空格为’ab ‘，3表示字符数</li><li>varchar表示可变长度的字符串，如varchar(3)，填充’ab’时就会存储’ab’，3表示字符数</li><li>对于图片、音频、视频等文件，不存储在数据库中，而是上传到某个服务器上，然后在表中存储这个文件的保存路径.</li><li>字符串 text 表示存储大文本，当字符大于 4000 时推荐使用, 比如技术博客.</li></ul><h4 id="4-2-数据约束"><a href="#4-2-数据约束" class="headerlink" title="4.2 数据约束"></a>4.2 数据约束</h4><p>约束是指数据在数据类型限定的基础上额外增加的要求.</p><p><strong>常见的约束如下:</strong></p><ul><li>主键 primary key: 物理上存储的顺序. MySQL 建议所有表的主键字段都叫 id, 类型为 int unsigned.</li><li>非空 not null: 此字段不允许填写空值.</li><li>惟一 unique: 此字段的值不允许重复.</li><li>默认 default: 当不填写字段对应的值会使用默认值，如果填写时以填写为准.</li><li>外键 foreign key: 对关系字段进行约束, 当为关系字段填写值时, 会到关联的表中查询此值是否存在, 如果存在则填写成功, 如果不存在则填写失败并抛出异常.</li></ul><h4 id="4-3-数据类型附录表"><a href="#4-3-数据类型附录表" class="headerlink" title="4.3 数据类型附录表"></a>4.3 数据类型附录表</h4><h5 id="4-3-1-整数类型"><a href="#4-3-1-整数类型" class="headerlink" title="4.3.1 整数类型"></a>4.3.1 整数类型</h5><table><thead><tr><th align="left">类型</th><th align="left">字节大小</th><th align="left">有符号范围(Signed)</th><th align="left">无符号范围(Unsigned)</th></tr></thead><tbody><tr><td align="left">TINYINT</td><td align="left">1</td><td align="left">-128 ~ 127</td><td align="left">0 ~ 255</td></tr><tr><td align="left">SMALLINT</td><td align="left">2</td><td align="left">-32768 ~ 32767</td><td align="left">0 ~ 65535</td></tr><tr><td align="left">MEDIUMINT</td><td align="left">3</td><td align="left">-8388608 ~ 8388607</td><td align="left">0 ~ 16777215</td></tr><tr><td align="left">INT/INTEGER</td><td align="left">4</td><td align="left">-2147483648 ~2147483647</td><td align="left">0 ~ 4294967295</td></tr><tr><td align="left">BIGINT</td><td align="left">8</td><td align="left">-9223372036854775808 ~ 9223372036854775807</td><td align="left">0 ~ 18446744073709551615</td></tr></tbody></table><h5 id="4-3-2-字符串"><a href="#4-3-2-字符串" class="headerlink" title="4.3.2 字符串"></a>4.3.2 字符串</h5><table><thead><tr><th align="left">类型</th><th align="left">说明</th><th align="left">使用场景</th></tr></thead><tbody><tr><td align="left">CHAR</td><td align="left">固定长度，小型数据</td><td align="left">身份证号、手机号、电话、密码</td></tr><tr><td align="left">VARCHAR</td><td align="left">可变长度，小型数据</td><td align="left">姓名、地址、品牌、型号</td></tr><tr><td align="left">TEXT</td><td align="left">可变长度，字符个数大于 4000</td><td align="left">存储小型文章或者新闻</td></tr><tr><td align="left">LONGTEXT</td><td align="left">可变长度， 极大型文本数据</td><td align="left">存储极大型文本数据</td></tr></tbody></table><h5 id="4-3-3-时间类型"><a href="#4-3-3-时间类型" class="headerlink" title="4.3.3 时间类型"></a>4.3.3 时间类型</h5><table><thead><tr><th align="left">类型</th><th align="left">字节大小</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">DATE</td><td align="left">4</td><td align="left">‘2020-01-01’</td></tr><tr><td align="left">TIME</td><td align="left">3</td><td align="left">‘12:29:59’</td></tr><tr><td align="left">DATETIME</td><td align="left">8</td><td align="left">‘2020-01-01 12:29:59’</td></tr><tr><td align="left">YEAR</td><td align="left">1</td><td align="left">‘2017’</td></tr><tr><td align="left">TIMESTAMP</td><td align="left">4</td><td align="left">‘1970-01-01 00:00:01’ UTC ~ ‘2038-01-01 00:00:01’ UTC</td></tr></tbody></table><h5 id="4-3-4-小结"><a href="#4-3-4-小结" class="headerlink" title="4.3.4 小结"></a>4.3.4 小结</h5><ul><li>常用的数据类型:<ul><li>整数：int，bit</li><li>小数：decimal</li><li>字符串：varchar,char</li><li>日期时间: date, time, datetime</li><li>枚举类型(enum)</li></ul></li><li>常见的约束:<ul><li>主键约束 primary key</li><li>非空约束 not null</li><li>惟一约束 unique</li><li>默认约束 default</li><li>外键约束 foreign key</li></ul></li><li>数据类型和约束保证了表中数据的准确性和完整性</li></ul><h3 id="5-命令行客户端MySQL的使用"><a href="#5-命令行客户端MySQL的使用" class="headerlink" title="5.命令行客户端MySQL的使用"></a>5.命令行客户端MySQL的使用</h3><h4 id="5-1-登录和登出数据库"><a href="#5-1-登录和登出数据库" class="headerlink" title="5.1 登录和登出数据库"></a>5.1 登录和登出数据库</h4><p><strong>登录数据库:</strong></p><p>输入下面命令:</p><pre><code class="bash">mysql -uroot -p</code></pre><p><strong>说明:</strong></p><ul><li>-u 后面是登录的用户名</li><li>-p 后面是登录密码, 如果不填写, 回车之后会提示输入密码</li></ul><p><strong>登录成功后, 输入如下命令查看效果：</strong></p><pre><code class="sql"># 显示当前时间select now();</code></pre><p><strong>登出(退出)数据库:</strong></p><pre><code class="sql">quit 或 exit 或 ctrl + d</code></pre><h4 id="5-2-数据库操作的SQL语句"><a href="#5-2-数据库操作的SQL语句" class="headerlink" title="5.2 数据库操作的SQL语句"></a>5.2 数据库操作的SQL语句</h4><ol><li><p>查看所有数据库</p><pre><code class="sql">show databases;</code></pre></li><li><p>创建数据库</p><pre><code class="sql">create database 数据库名 charset=utf8;例：create database python charset=utf8;</code></pre></li><li><p>使用数据库</p><pre><code class="sql">use 数据库名;</code></pre></li><li><p>查看当前使用的数据库</p><pre><code class="sql">select database();</code></pre></li><li><p>删除数据库-慎重</p><pre><code class="sql">drop database 数据库名;例：drop database python;</code></pre></li></ol><h4 id="5-3-表结构操作的SQL语句"><a href="#5-3-表结构操作的SQL语句" class="headerlink" title="5.3 表结构操作的SQL语句"></a>5.3 表结构操作的SQL语句</h4><ol><li><p>查看当前数据库中所有表</p><pre><code class="sql">show tables;</code></pre></li><li><p>创建表</p><pre><code class="sql">create table students( id int unsigned primary key auto_increment not null, name varchar(20) not null, age tinyint unsigned default 0, height decimal(5,2), gender enum(&#39;男&#39;,&#39;女&#39;,&#39;人妖&#39;,&#39;保密&#39;) default &#39;保密&#39;);</code></pre><p><strong>说明:</strong></p><pre><code class="sql">create table 表名(字段名称 数据类型  可选的约束条件,column1 datatype contrai,...);</code></pre></li><li><p>修改表-添加字段</p><pre><code class="sql">alter table 表名 add 列名 类型 约束;例：alter table students add birthday datetime;</code></pre></li><li><p>修改表-修改字段类型</p><pre><code class="sql">alter table 表名 modify 列名 类型 约束;例：alter table students modify birthday date not null;</code></pre><p><strong>说明:</strong></p><ul><li>modify: 只能修改字段类型或者约束，不能修改字段名</li></ul></li><li><p>修改表-修改字段名和字段类型</p><pre><code class="sql">alter table 表名 change 原名 新名 类型及约束;例：alter table students change birthday birth datetime not null;</code></pre><p><strong>说明:</strong></p><ul><li>change: 既能对字段重命名又能修改字段类型还能修改约束</li></ul></li><li><p>修改表-删除字段</p><pre><code class="sql">alter table 表名 drop 列名;例：alter table students drop birthday;</code></pre></li><li><p>查看创表SQL语句</p><pre><code class="sql">show create table 表名;例：show create table students;</code></pre></li><li><p>查看创库SQL语句</p><pre><code class="sql">show create database 数据库名;例：show create database mytest;</code></pre></li><li><p>删除表</p><pre><code class="sql">drop table 表名;例：drop table students;</code></pre></li></ol><h4 id="5-4-表数据操作的SQL语句"><a href="#5-4-表数据操作的SQL语句" class="headerlink" title="5.4 表数据操作的SQL语句"></a>5.4 表数据操作的SQL语句</h4><ol><li><p>查询数据</p><pre><code class="sql">-- 1. 查询所有列select * from 表名;例：select * from students;-- 2. 查询指定列select 列1,列2,... from 表名;例：select id,name from students;</code></pre></li><li><p>添加数据</p><pre><code class="sql">-- 1. 全列插入：值的顺序与表结构字段的顺序完全一一对应insert into 表名 values (...)例:insert into students values(0, &#39;xx&#39;, default, default, &#39;男&#39;);-- 2. 部分列插入：值的顺序与给出的列顺序对应insert into 表名 (列1,...) values(值1,...)例:insert into students(name, age) values(&#39;王二小&#39;, 15);-- 3. 全列多行插入insert into 表名 values(...),(...)...;例:insert into students values(0, &#39;张飞&#39;, 55, 1.75, &#39;男&#39;),(0, &#39;关羽&#39;, 58, 1.85, &#39;男&#39;);-- 4. 部分列多行插入insert into 表名(列1,...) values(值1,...),(值1,...)...;例：insert into students(name, height) values(&#39;刘备&#39;, 1.75),(&#39;曹操&#39;, 1.6);</code></pre><p><strong>说明:</strong></p><ul><li>主键列是自动增长，但是在全列插入时需要占位，通常使用空值(0或者null或者default)</li><li>在全列插入时，如果字段列有默认值可以使用 default 来占位，插入后的数据就是之前设置的默认值</li></ul></li><li><p>修改数据</p><pre><code class="sql">update 表名 set 列1=值1,列2=值2... where 条件例：update students set age = 18, gender = &#39;女&#39; where id = 6;</code></pre></li><li><p>删除数据</p><pre><code class="sql">delete from 表名 where 条件例：delete from students where id=5;</code></pre><p>问题:</p><p>上面的操作称之为物理删除，一旦删除就不容易恢复，我们可以使用逻辑删除的方式来解决这个问题。</p><pre><code class="sql">-- 添加删除表示字段，0表示未删除 1表示删除alter table students add isdelete bit default 0;-- 逻辑删除数据update students set isdelete = 1 where id = 8;</code></pre><p><strong>说明:</strong></p><ul><li>逻辑删除，本质就是修改操作</li></ul></li></ol><h3 id="6-as和distinct关键字"><a href="#6-as和distinct关键字" class="headerlink" title="6.as和distinct关键字"></a>6.as和distinct关键字</h3><h4 id="6-1-as关键字"><a href="#6-1-as关键字" class="headerlink" title="6.1 as关键字"></a>6.1 as关键字</h4><p>在使用SQL语句显示结果的时候，往往在屏幕显示的字段名并不具备良好的可读性，此时可以使用 as 给字段起一个别名。</p><ol><li><p>使用 as 给字段起别名</p><pre><code class="sql">select id as 序号, name as 名字, gender as 性别 from students;</code></pre></li><li><p>可以通过 as 给表起别名</p><pre><code class="sql">-- 如果是单表查询 可以省略表名select id, name, gender from students;-- 表名.字段名select students.id,students.name,students.gender from students;-- 可以通过 as 给表起别名 select s.id,s.name,s.gender from students as s;</code></pre></li></ol><h4 id="6-2-distinct关键字"><a href="#6-2-distinct关键字" class="headerlink" title="6.2 distinct关键字"></a>6.2 distinct关键字</h4><p>distinct可以去除重复数据行。</p><pre><code class="sql">select distinct 列1,... from 表名;例： 查询班级中学生的性别select name, gender from students;-- 看到了很多重复数据 想要对其中重复数据行进行去重操作可以使用 distinctselect distinct name, gender from students;</code></pre><h3 id="7-where条件查询"><a href="#7-where条件查询" class="headerlink" title="7.where条件查询"></a>7.where条件查询</h3><h4 id="7-1-where条件查询的介绍"><a href="#7-1-where条件查询的介绍" class="headerlink" title="7.1 where条件查询的介绍"></a>7.1 where条件查询的介绍</h4><p>使用where条件查询可以对表中的数据进行筛选，条件成立的记录会出现在结果集中。</p><p><strong>where语句支持的运算符:</strong></p><ol><li>比较运算符</li><li>逻辑运算符</li><li>模糊查询</li><li>范围查询</li><li>空判断</li></ol><p><strong>where条件查询语法格式如下:</strong></p><pre><code class="sql">select * from 表名 where 条件;例：select * from students where id = 1;</code></pre><h4 id="7-2-比较运算符查询"><a href="#7-2-比较运算符查询" class="headerlink" title="7.2 比较运算符查询"></a>7.2 比较运算符查询</h4><ol><li>等于: =</li><li>大于: &gt;</li><li>大于等于: &gt;=</li><li>小于: &lt;</li><li>小于等于: &lt;=</li><li>不等于: != 或 &lt;&gt;</li></ol><p><strong>例1：查询编号大于3的学生:</strong></p><pre><code class="sql">select * from students where id &gt; 3;</code></pre><p><strong>例2：查询编号不大于4的学生:</strong></p><pre><code class="sql">select * from students where id &lt;= 4;</code></pre><p><strong>例3：查询姓名不是“黄蓉”的学生:</strong></p><pre><code class="sql">select * from students where name != &#39;黄蓉&#39;;</code></pre><p><strong>例4：查询没被删除的学生:</strong></p><pre><code class="sql">select * from students where is_delete=0;</code></pre><h4 id="7-3-逻辑运算符查询"><a href="#7-3-逻辑运算符查询" class="headerlink" title="7.3 逻辑运算符查询"></a>7.3 逻辑运算符查询</h4><ol><li>and</li><li>or</li><li>not</li></ol><p><strong>例1：查询编号大于3的女同学:</strong></p><pre><code class="sql">select * from students where id &gt; 3 and gender=0;</code></pre><p><strong>例2：查询编号小于4或没被删除的学生:</strong></p><pre><code class="sql">select * from students where id &lt; 4 or is_delete=0;</code></pre><p><strong>例3：查询年龄不在10岁到15岁之间的学生:</strong></p><pre><code class="sql">select * from students where not (age &gt;= 10 and age &lt;= 15);</code></pre><p><strong>说明:</strong></p><ul><li>多个条件判断想要作为一个整体，可以结合‘()’。</li></ul><h4 id="7-4-模糊查询"><a href="#7-4-模糊查询" class="headerlink" title="7.4 模糊查询"></a>7.4 模糊查询</h4><ol><li>like是模糊查询关键字</li><li>%表示任意多个任意字符</li><li>_表示一个任意字符</li></ol><p><strong>例1：查询姓黄的学生:</strong></p><pre><code class="sql">select * from students where name like &#39;黄%&#39;;</code></pre><p><strong>例2：查询姓黄并且“名”是一个字的学生:</strong></p><pre><code class="sql">select * from students where name like &#39;黄_&#39;;</code></pre><p><strong>例3：查询姓黄或叫靖的学生:</strong></p><pre><code class="sql">select * from students where name like &#39;黄%&#39; or name like &#39;%靖&#39;;</code></pre><h4 id="7-5-范围查询"><a href="#7-5-范围查询" class="headerlink" title="7.5 范围查询"></a>7.5 范围查询</h4><ol><li>between .. and .. 表示在一个连续的范围内查询</li><li>in 表示在一个非连续的范围内查询</li></ol><p><strong>例1：查询编号为3至8的学生:</strong></p><pre><code class="sql">select * from students where id between 3 and 8;</code></pre><p><strong>例2：查询编号不是3至8的男生:</strong></p><pre><code>select * from students where (not id between 3 and 8) and gender=&#39;男&#39;;</code></pre><h4 id="7-6-空判断查询"><a href="#7-6-空判断查询" class="headerlink" title="7.6 空判断查询"></a>7.6 空判断查询</h4><ol><li>判断为空使用: is null</li><li>判断非空使用: is not null</li></ol><p><strong>例1：查询没有填写身高的学生:</strong></p><pre><code class="sql">select * from students where height is null;</code></pre><p><strong>注意:</strong></p><ol><li>不能使用 where height = null 判断为空</li><li>不能使用 where height != null 判断非空</li><li>null 不等于 ‘’ 空字符串</li></ol><h3 id="8-排序"><a href="#8-排序" class="headerlink" title="8.排序"></a>8.排序</h3><h4 id="8-1-排序查询语法"><a href="#8-1-排序查询语法" class="headerlink" title="8.1 排序查询语法"></a>8.1 排序查询语法</h4><p>排序查询语法：</p><pre><code class="sql">select * from 表名 order by 列1 asc|desc [,列2 asc|desc,...]</code></pre><p><strong>语法说明:</strong></p><ol><li>先按照列1进行排序，如果列1的值相同时，则按照 列2 排序，以此类推</li><li>asc从小到大排列，即升序</li><li>desc从大到小排序，即降序</li><li>默认按照列值从小到大排序（即asc关键字）</li></ol><p><strong>例1：查询未删除男生信息，按学号降序:</strong></p><pre><code class="sql">select * from students where gender=1 and is_delete=0 order by id desc;</code></pre><p><strong>例2：显示所有的学生信息，先按照年龄从大–&gt;小排序，当年龄相同时 按照身高从高–&gt;矮排序:</strong></p><pre><code class="sql">select * from students  order by age desc,height desc;</code></pre><p>小结：</p><ol><li>排序使用 order by 关键字</li><li>asc 表示升序</li><li>desc 表示降序</li></ol><h3 id="9-分页查询"><a href="#9-分页查询" class="headerlink" title="9.分页查询"></a>9.分页查询</h3><h4 id="9-1-分页查询的介绍"><a href="#9-1-分页查询的介绍" class="headerlink" title="9.1 分页查询的介绍"></a>9.1 分页查询的介绍</h4><p>当我们在京东购物，浏览商品列表的时候，由于数据特别多，一页显示不完，一页一页的进行显示，这就是分页查询</p><h4 id="9-2-分页查询的语法"><a href="#9-2-分页查询的语法" class="headerlink" title="9.2 分页查询的语法"></a>9.2 分页查询的语法</h4><pre><code class="sql">select * from 表名 limit start,count</code></pre><p><strong>说明:</strong></p><ol><li>limit是分页查询关键字</li><li>start表示开始行索引，默认是0</li><li>count表示查询条数</li></ol><p><strong>例1：查询前3行男生信息:</strong></p><pre><code class="sql">select * from students where gender=1 limit 0,3;简写select * from students where gender=1 limit 3;</code></pre><h4 id="9-3-分页查询案例"><a href="#9-3-分页查询案例" class="headerlink" title="9.3 分页查询案例"></a>9.3 分页查询案例</h4><p>已知每页显示m条数据，求第n页显示的数据</p><p>提示: 关键是求每页的开始行索引</p><p><strong>查询学生表，获取第n页数据的SQL语句:</strong></p><pre><code class="sql">select * from students limit (n-1)*m,m</code></pre><h2 id="二、MySQL数据库的条件查询"><a href="#二、MySQL数据库的条件查询" class="headerlink" title="二、MySQL数据库的条件查询"></a>二、MySQL数据库的条件查询</h2><h3 id="1-聚合函数"><a href="#1-聚合函数" class="headerlink" title="1.聚合函数"></a>1.聚合函数</h3><h4 id="1-1-聚合函数的介绍"><a href="#1-1-聚合函数的介绍" class="headerlink" title="1.1 聚合函数的介绍"></a>1.1 聚合函数的介绍</h4><p>聚合函数又叫组函数，通常是对表中的数据进行统计和计算，一般结合分组(group by)来使用，用于统计和计算分组数据。</p><p><strong>常用的聚合函数:</strong></p><ol><li>count(col): 表示求指定列的总行数</li><li>max(col): 表示求指定列的最大值</li><li>min(col): 表示求指定列的最小值</li><li>sum(col): 表示求指定列的和</li><li>avg(col): 表示求指定列的平均值</li></ol><h4 id="1-2-求总行数"><a href="#1-2-求总行数" class="headerlink" title="1.2 求总行数"></a>1.2 求总行数</h4><pre><code class="sql">-- 返回非NULL数据的总行数.select count(height) from students; -- 返回总行数，包含null值记录;select count(*) from students;</code></pre><h4 id="1-3-求最大值"><a href="#1-3-求最大值" class="headerlink" title="1.3 求最大值"></a>1.3 求最大值</h4><pre><code class="sql">-- 查询女生的编号最大值select max(id) from students where gender = 2;</code></pre><h4 id="1-4-求最小值"><a href="#1-4-求最小值" class="headerlink" title="1.4 求最小值"></a>1.4 求最小值</h4><pre><code class="sql">-- 查询未删除的学生最小编号select min(id) from students where is_delete = 0;</code></pre><h4 id="1-5-求和"><a href="#1-5-求和" class="headerlink" title="1.5 求和"></a>1.5 求和</h4><pre><code class="sql">-- 查询男生的总身高select sum(height) from students where gender = 1;-- 平均身高select sum(height) / count(*) from students where gender = 1;</code></pre><h4 id="1-6-求平均值"><a href="#1-6-求平均值" class="headerlink" title="1.6 求平均值"></a>1.6 求平均值</h4><pre><code class="sql">-- 求男生的平均身高, 聚合函数不统计null值，平均身高有误select avg(height) from students where gender = 1;-- 求男生的平均身高, 包含身高是null的select avg(ifnull(height,0)) from students where gender = 1;</code></pre><p><strong>说明</strong></p><ul><li>ifnull函数: 表示判断指定字段的值是否为null，如果为空使用自己提供的值。</li></ul><h4 id="1-7-聚合函数的特点"><a href="#1-7-聚合函数的特点" class="headerlink" title="1.7 聚合函数的特点"></a>1.7 聚合函数的特点</h4><ul><li>聚合函数默认忽略字段为null的记录 要想列值为null的记录也参与计算，必须使用ifnull函数对null值做替换。</li></ul><h3 id="2-分组查询"><a href="#2-分组查询" class="headerlink" title="2. 分组查询"></a>2. 分组查询</h3><ul><li>group by 根据指定的一个或者多个字段对数据进行分组</li><li>group_concat(字段名)函数是统计每个分组指定字段的信息集合</li><li>聚合函数在和 group by 结合使用时, 聚合函数统计和计算的是每个分组的数据</li><li>having 是对分组数据进行条件过滤</li><li>with rollup在最后记录后面新增一行，显示select查询时聚合函数的统计和计算结果</li></ul><h4 id="2-1-分组查询介绍"><a href="#2-1-分组查询介绍" class="headerlink" title="2.1 分组查询介绍"></a>2.1 分组查询介绍</h4><p>分组查询就是将查询结果按照指定字段进行分组，字段中数据相等的分为一组。</p><p><strong>分组查询基本的语法格式如下：</strong></p><p>GROUP BY 列名 [HAVING 条件表达式] [WITH ROLLUP]</p><p><strong>说明:</strong></p><ul><li>列名: 是指按照指定字段的值进行分组。</li><li>HAVING 条件表达式: 用来过滤分组后的数据。</li><li>WITH ROLLUP：在所有记录的最后加上一条记录，显示select查询时聚合函数的统计和计算结果</li></ul><h4 id="2-2-group-by的使用"><a href="#2-2-group-by的使用" class="headerlink" title="2.2 group by的使用"></a>2.2 group by的使用</h4><p>group by可用于单个字段分组，也可用于多个字段分组</p><pre><code class="sql">-- 根据gender字段来分组select gender from students group by gender;-- 根据name和gender字段进行分组select name, gender from students group by name, gender;</code></pre><h4 id="2-3-group-by-group-concat-的使用"><a href="#2-3-group-by-group-concat-的使用" class="headerlink" title="2.3 group by + group_concat()的使用"></a>2.3 group by + group_concat()的使用</h4><p>group_concat(字段名): 统计每个分组指定字段的信息集合，每个信息之间使用逗号进行分割</p><pre><code class="sql">-- 根据gender字段进行分组， 查询gender字段和分组的name字段信息select gender,group_concat(name) from students group by gender;</code></pre><h4 id="2-4-group-by-聚合函数的使用"><a href="#2-4-group-by-聚合函数的使用" class="headerlink" title="2.4 group by + 聚合函数的使用"></a>2.4 group by + 聚合函数的使用</h4><pre><code class="sql">-- 统计不同性别的人的平均年龄select gender,avg(age) from students group by gender;-- 统计不同性别的人的个数select gender,count(*) from students group by gender;</code></pre><h4 id="2-5-group-by-having的使用"><a href="#2-5-group-by-having的使用" class="headerlink" title="2.5 group by + having的使用"></a>2.5 group by + having的使用</h4><p>having作用和where类似都是过滤数据的，但having是过滤分组数据的，只能用于group by</p><pre><code class="sql">-- 根据gender字段进行分组，统计分组条数大于2的select gender,count(*) from students group by gender having count(*)&gt;2;</code></pre><h4 id="2-6-group-by-with-rollup的使用"><a href="#2-6-group-by-with-rollup的使用" class="headerlink" title="2.6 group by + with rollup的使用"></a>2.6 group by + with rollup的使用</h4><p>with rollup的作用是：在最后记录后面新增一行，显示select查询时聚合函数的统计和计算结果</p><pre><code class="sql">-- 根据gender字段进行分组，汇总总人数select gender,count(*) from students group by gender with rollup;-- 根据gender字段进行分组，汇总所有人的年龄select gender,group_concat(age) from students group by gender with rollup;</code></pre><h3 id="3-连接查询-内连接"><a href="#3-连接查询-内连接" class="headerlink" title="3.连接查询-内连接"></a>3.连接查询-内连接</h3><ul><li>内连接使用inner join .. on .., on 表示两个表的连接查询条件</li><li>内连接根据连接查询条件取出两个表的 “交集”</li></ul><h4 id="3-1-连接查询的介绍"><a href="#3-1-连接查询的介绍" class="headerlink" title="3.1 连接查询的介绍"></a>3.1 连接查询的介绍</h4><p>连接查询可以实现多个表的查询，当查询的字段数据来自不同的表就可以使用连接查询来完成。</p><p>连接查询可以分为:</p><ol><li>内连接查询</li><li>左连接查询</li><li>右连接查询</li><li>自连接查询</li></ol><h4 id="3-2-内连接查询"><a href="#3-2-内连接查询" class="headerlink" title="3.2 内连接查询"></a>3.2 内连接查询</h4><p>查询两个表中符合条件的共有记录</p><p><strong>内连接查询效果图:</strong></p><p><img src="https://img-blog.csdnimg.cn/20200826140225147.png#pic_center" alt="在这里插入图片描述"></p><p><strong>内连接查询语法格式:</strong></p><pre><code class="sql">select 字段 from 表1 inner join 表2 on 表1.字段1 = 表2.字段2</code></pre><p><strong>说明:</strong></p><ul><li>inner join 就是内连接查询关键字</li><li>on 就是连接查询条件</li></ul><p><strong>例1：使用内连接查询学生表与班级表:</strong></p><pre><code class="sql">select * from students as s inner join classes as c on s.cls_id = c.id;</code></pre><h3 id="4-连接查询-左连接"><a href="#4-连接查询-左连接" class="headerlink" title="4.连接查询-左连接"></a>4.连接查询-左连接</h3><ul><li>左连接使用left join .. on .., on 表示两个表的连接查询条件</li><li>左连接以左表为主根据条件查询右表数据，右表数据不存在使用null值填充。</li></ul><h4 id="4-1-左连接查询"><a href="#4-1-左连接查询" class="headerlink" title="4.1 左连接查询"></a>4.1 左连接查询</h4><p>以左表为主根据条件查询右表数据，如果根据条件查询右表数据不存在使用null值填充</p><p><strong>左连接查询效果图:</strong></p><p><img src="https://img-blog.csdnimg.cn/20200826140206298.png#pic_center" alt="在这里插入图片描述"></p><p><strong>左连接查询语法格式:</strong></p><pre><code class="sql">select 字段 from 表1 left join 表2 on 表1.字段1 = 表2.字段2</code></pre><p><strong>说明:</strong></p><ul><li>left join 就是左连接查询关键字</li><li>on 就是连接查询条件</li><li>表1 是左表</li><li>表2 是右表</li></ul><p><strong>例1：使用左连接查询学生表与班级表:</strong></p><pre><code class="sql">select * from students as s left join classes as c on s.cls_id = c.id;</code></pre><h3 id="5-连接查询-右连接"><a href="#5-连接查询-右连接" class="headerlink" title="5.连接查询-右连接"></a>5.连接查询-右连接</h3><ul><li>右连接使用right join .. on .., on 表示两个表的连接查询条件</li><li>右连接以右表为主根据条件查询左表数据，左表数据不存在使用null值填充。</li></ul><h4 id="5-1-右连接查询"><a href="#5-1-右连接查询" class="headerlink" title="5.1 右连接查询"></a>5.1 右连接查询</h4><p>以右表为主根据条件查询左表数据，如果根据条件查询左表数据不存在使用null值填充</p><p><strong>右连接查询效果图:</strong></p><p><img src="https://img-blog.csdnimg.cn/20200826140058482.png#pic_center" alt="右连接"></p><p><strong>右连接查询语法格式:</strong></p><pre><code class="sql">select 字段 from 表1 right join 表2 on 表1.字段1 = 表2.字段2</code></pre><p><strong>说明:</strong></p><ul><li>right join 就是右连接查询关键字</li><li>on 就是连接查询条件</li><li>表1 是左表</li><li>表2 是右表</li></ul><p><strong>例1：使用右连接查询学生表与班级表:</strong></p><pre><code class="sql">select * from students as s right join classes as c on s.cls_id = c.id;</code></pre><h3 id="6-连接查询-自连接"><a href="#6-连接查询-自连接" class="headerlink" title="6.连接查询-自连接"></a>6.连接查询-自连接</h3><ul><li>自连接查询就是把一张表模拟成左右两张表，然后进行连表查询。</li><li>自连接就是一种特殊的连接方式，连接的表还是本身这张表</li></ul><h4 id="6-1-自连接查询"><a href="#6-1-自连接查询" class="headerlink" title="6.1 自连接查询"></a>6.1 自连接查询</h4><p>左表和右表是同一个表，根据连接查询条件查询两个表中的数据。</p><p><strong>自连接查询的用法:</strong></p><pre><code class="sql">select c.title, c.pid, p.id, p.title from areas as c inner join areas as p on c.pid = p.id where p.title = &#39;目标&#39;;</code></pre><p><strong>说明:</strong></p><ul><li><strong>自连接查询必须对表起别名</strong></li></ul><p><strong>这个直连接没有配图说明，可能会难以理解</strong></p><h3 id="7-子查询"><a href="#7-子查询" class="headerlink" title="7.子查询"></a>7.子查询</h3><h4 id="7-1-子查询的介绍"><a href="#7-1-子查询的介绍" class="headerlink" title="7.1 子查询的介绍"></a>7.1 子查询的介绍</h4><p>在一个 select 语句中,嵌入了另外一个 select 语句, 那么被嵌入的 select 语句称之为子查询语句，外部那个select语句则称为主查询.</p><p><strong>主查询和子查询的关系:</strong></p><ol><li>子查询是嵌入到主查询中</li><li>子查询是辅助主查询的,要么充当条件,要么充当数据源</li><li>子查询是可以独立存在的语句,是一条完整的 select 语句</li></ol><h4 id="7-2-子查询的使用"><a href="#7-2-子查询的使用" class="headerlink" title="7.2 子查询的使用"></a>7.2 子查询的使用</h4><p><strong>例1. 查询大于平均年龄的学生:</strong></p><pre><code class="sql">select * from students where age &gt; (select avg(age) from students);</code></pre><p><strong>例2. 查询学生在班的所有班级名字:</strong></p><pre><code class="sql">select name from classes where id in (select cls_id from students where cls_id is not null);</code></pre><p><strong>例3. 查找年龄最大,身高最高的学生:</strong></p><pre><code class="sql">select * from students where (age, height) =  (select max(age), max(height) from students);</code></pre><h4 id="7-3-小结"><a href="#7-3-小结" class="headerlink" title="7.3 小结"></a>7.3 小结</h4><ul><li>子查询是一个完整的SQL语句，子查询被嵌入到一对小括号里面</li></ul><h3 id="8-数据库设计之三范式"><a href="#8-数据库设计之三范式" class="headerlink" title="8.数据库设计之三范式"></a>8.数据库设计之三范式</h3><h4 id="8-1-数据库设计之三范式的介绍"><a href="#8-1-数据库设计之三范式的介绍" class="headerlink" title="8.1 数据库设计之三范式的介绍"></a>8.1 数据库设计之三范式的介绍</h4><p>范式: 对设计数据库提出的一些规范，目前有迹可寻的共有8种范式，一般遵守3范式即可。</p><ul><li>第一范式（1NF）: 强调的是列的原子性，即列不能够再分成其他几列。</li><li>第二范式（2NF）: 满足 1NF，另外包含两部分内容，一是表必须有一个主键；二是非主键字段 必须完全依赖于主键，而不能只依赖于主键的一部分。</li><li>第三范式（3NF）: 满足 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。</li></ul><h4 id="8-2-E-R模型的介绍"><a href="#8-2-E-R模型的介绍" class="headerlink" title="8.2 E-R模型的介绍"></a>8.2 E-R模型的介绍</h4><ul><li>E-R模型由 实体、属性、实体之间的关系构成，主要用来描述数据库中表结构。</li><li>开发流程是先画出E-R模型，然后根据三范式设计数据库中的表结构</li></ul><p>E-R模型即实体-关系模型，E-R模型就是描述数据库存储数据的结构模型。</p><p><strong>E-R模型的使用场景:</strong></p><ol><li>对于大型公司开发项目，我们需要根据产品经理的设计，我们先使用建模工具, 如:power designer，db desinger等这些软件来画出实体-关系模型(E-R模型)</li><li>然后根据三范式设计数据库表结构</li></ol><p><strong>E-R模型的效果图:</strong><br><img src="https://img-blog.csdnimg.cn/20200826135957115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxODEyNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="E-R模型的效果图"></p><p><strong>说明:</strong></p><ul><li>实体: 用矩形表示，并标注实体名称</li><li>属性: 用椭圆表示，并标注属性名称，</li><li>关系: 用菱形表示，并标注关系名称<ul><li>一对一</li><li>一对多</li><li>多对多</li></ul></li></ul><p><strong>一对多的关系:</strong></p><p><strong>说明:</strong></p><ul><li>关系也是一种数据，需要通过一个字段存储在表中</li><li>1对1关系，在表A或表B中创建一个字段，存储另一个表的主键值</li></ul><p><strong>一对多的关系:</strong></p><p><strong>说明:</strong></p><ul><li>1对多关系，在多的一方表(学生表)中创建一个字段，存储班级表的主键值</li></ul><p><strong>多对多的关系:</strong></p><p><strong>说明:</strong></p><ul><li>多对多关系，新建一张表C，这个表只有两个字段，一个用于存储A的主键值，一个用于存储B的主键值</li></ul><h3 id="9-外键SQL语句的编写"><a href="#9-外键SQL语句的编写" class="headerlink" title="9.外键SQL语句的编写"></a>9.外键SQL语句的编写</h3><ul><li>添加外键约束: alter table 从表 add foreign key(外键字段) references 主表(主键字段);</li><li>删除外键约束: alter table 表名 drop foreign key 外键名;</li></ul><h4 id="9-1-外键约束作用"><a href="#9-1-外键约束作用" class="headerlink" title="9.1 外键约束作用"></a>9.1 外键约束作用</h4><p>外键约束:对外键字段的值进行更新和插入时会和引用表中字段的数据进行验证，数据如果不合法则更新和插入会失败，保证数据的有效性</p><h4 id="9-2-对于已经存在的字段添加外键约束"><a href="#9-2-对于已经存在的字段添加外键约束" class="headerlink" title="9.2 对于已经存在的字段添加外键约束"></a>9.2 对于已经存在的字段添加外键约束</h4><pre><code class="sql">-- 为cls_id字段添加外键约束alter table students add foreign key(cls_id) references classes(id);</code></pre><h4 id="9-3-在创建数据表时设置外键约束"><a href="#9-3-在创建数据表时设置外键约束" class="headerlink" title="9.3 在创建数据表时设置外键约束"></a>9.3 在创建数据表时设置外键约束</h4><pre><code class="sql">-- 创建学校表create table school(    id int not null primary key auto_increment,     name varchar(10));-- 创建老师表create table teacher(    id int not null primary key auto_increment,     name varchar(10),     s_id int not null,     foreign key(s_id) references school(id));</code></pre><h4 id="9-4-删除外键约束"><a href="#9-4-删除外键约束" class="headerlink" title="9.4 删除外键约束"></a>9.4 删除外键约束</h4><pre><code class="sql">-- 需要先获取外键约束名称,该名称系统会自动生成,可以通过查看表创建语句来获取名称show create table teacher;-- 获取名称之后就可以根据名称来删除外键约束alter table teacher drop foreign key 外键名;</code></pre><h3 id="10-演练-分组和聚合函数的组合使用"><a href="#10-演练-分组和聚合函数的组合使用" class="headerlink" title="10.演练-分组和聚合函数的组合使用"></a>10.演练-分组和聚合函数的组合使用</h3><h4 id="10-1-数据准备"><a href="#10-1-数据准备" class="headerlink" title="10.1 数据准备"></a>10.1 数据准备</h4><pre><code class="sql">-- 创建 &quot;京东&quot; 数据库create database jing_dong charset=utf8;-- 使用 &quot;京东&quot; 数据库use jing_dong;-- 创建一个商品goods数据表create table goods(    id int unsigned primary key auto_increment not null,    name varchar(150) not null,    cate_name varchar(40) not null,    brand_name varchar(40) not null,    price decimal(10,3) not null default 0,    is_show bit not null default 1,    is_saleoff bit not null default 0);-- 向goods表中插入数据insert into goods values(0,&#39;r510vc 15.6英寸笔记本&#39;,&#39;笔记本&#39;,&#39;华硕&#39;,&#39;3399&#39;,default,default); insert into goods values(0,&#39;y400n 14.0英寸笔记本电脑&#39;,&#39;笔记本&#39;,&#39;联想&#39;,&#39;4999&#39;,default,default);insert into goods values(0,&#39;g150th 15.6英寸游戏本&#39;,&#39;游戏本&#39;,&#39;雷神&#39;,&#39;8499&#39;,default,default); insert into goods values(0,&#39;x550cc 15.6英寸笔记本&#39;,&#39;笔记本&#39;,&#39;华硕&#39;,&#39;2799&#39;,default,default); insert into goods values(0,&#39;x240 超极本&#39;,&#39;超级本&#39;,&#39;联想&#39;,&#39;4880&#39;,default,default); insert into goods values(0,&#39;u330p 13.3英寸超极本&#39;,&#39;超级本&#39;,&#39;联想&#39;,&#39;4299&#39;,default,default); insert into goods values(0,&#39;svp13226scb 触控超极本&#39;,&#39;超级本&#39;,&#39;索尼&#39;,&#39;7999&#39;,default,default); insert into goods values(0,&#39;ipad mini 7.9英寸平板电脑&#39;,&#39;平板电脑&#39;,&#39;苹果&#39;,&#39;1998&#39;,default,default);insert into goods values(0,&#39;ipad air 9.7英寸平板电脑&#39;,&#39;平板电脑&#39;,&#39;苹果&#39;,&#39;3388&#39;,default,default); insert into goods values(0,&#39;ipad mini 配备 retina 显示屏&#39;,&#39;平板电脑&#39;,&#39;苹果&#39;,&#39;2788&#39;,default,default); insert into goods values(0,&#39;ideacentre c340 20英寸一体电脑 &#39;,&#39;台式机&#39;,&#39;联想&#39;,&#39;3499&#39;,default,default); insert into goods values(0,&#39;vostro 3800-r1206 台式电脑&#39;,&#39;台式机&#39;,&#39;戴尔&#39;,&#39;2899&#39;,default,default); insert into goods values(0,&#39;imac me086ch/a 21.5英寸一体电脑&#39;,&#39;台式机&#39;,&#39;苹果&#39;,&#39;9188&#39;,default,default); insert into goods values(0,&#39;at7-7414lp 台式电脑 linux ）&#39;,&#39;台式机&#39;,&#39;宏碁&#39;,&#39;3699&#39;,default,default); insert into goods values(0,&#39;z220sff f4f06pa工作站&#39;,&#39;服务器/工作站&#39;,&#39;惠普&#39;,&#39;4288&#39;,default,default); insert into goods values(0,&#39;poweredge ii服务器&#39;,&#39;服务器/工作站&#39;,&#39;戴尔&#39;,&#39;5388&#39;,default,default); insert into goods values(0,&#39;mac pro专业级台式电脑&#39;,&#39;服务器/工作站&#39;,&#39;苹果&#39;,&#39;28888&#39;,default,default); insert into goods values(0,&#39;hmz-t3w 头戴显示设备&#39;,&#39;笔记本配件&#39;,&#39;索尼&#39;,&#39;6999&#39;,default,default); insert into goods values(0,&#39;商务双肩背包&#39;,&#39;笔记本配件&#39;,&#39;索尼&#39;,&#39;99&#39;,default,default); insert into goods values(0,&#39;x3250 m4机架式服务器&#39;,&#39;服务器/工作站&#39;,&#39;ibm&#39;,&#39;6888&#39;,default,default); insert into goods values(0,&#39;商务双肩背包&#39;,&#39;笔记本配件&#39;,&#39;索尼&#39;,&#39;99&#39;,default,default);</code></pre><p><strong>表结构说明:</strong></p><ul><li>id 表示主键 自增</li><li>name 表示商品名称</li><li>cate_name 表示分类名称</li><li>brand_name 表示品牌名称</li><li>price 表示价格</li><li>is_show 表示是否显示</li><li>is_saleoff 表示是否售完</li></ul><h4 id="10-2-SQL语句演练"><a href="#10-2-SQL语句演练" class="headerlink" title="10.2 SQL语句演练"></a>10.2 SQL语句演练</h4><ol><li><p>查询类型cate_name为 ‘超级本’ 的商品名称、价格</p><pre><code class="sql"> select name,price from goods where cate_name = &#39;超级本&#39;;</code></pre></li><li><p>显示商品的分类</p><pre><code class="sql"> select cate_name from goods group by cate_name;</code></pre></li><li><p>求所有电脑产品的平均价格,并且保留两位小数</p><pre><code class="sql"> select round(avg(price),2) as avg_price from goods;</code></pre></li><li><p>显示每种商品的平均价格</p><pre><code class="sql"> select cate_name,avg(price) from goods group by cate_name;</code></pre></li><li><p>查询每种类型的商品中 最贵、最便宜、平均价、数量</p><pre><code class="sql"> select cate_name,max(price),min(price),avg(price),count(*)  from goods group by cate_name;</code></pre></li><li><p>查询所有价格大于平均价格的商品，并且按价格降序排序</p><pre><code class="sql"> select id,name,price from goods  where price &gt; (select round(avg(price),2) as avg_price from goods)  order by price desc;</code></pre></li></ol><h2 id="三、MySQL数据库的高级使用"><a href="#三、MySQL数据库的高级使用" class="headerlink" title="三、MySQL数据库的高级使用"></a>三、MySQL数据库的高级使用</h2><h3 id="1-将查询结果插入到其它表中"><a href="#1-将查询结果插入到其它表中" class="headerlink" title="1.将查询结果插入到其它表中"></a>1.将查询结果插入到其它表中</h3><h4 id="1-1-思考"><a href="#1-1-思考" class="headerlink" title="1.1 思考"></a>1.1 思考</h4><p>目前只有一个goods表，我们想要增加一个商品分类信息，比如：移动设备这个分类信息，只通过goods表无法完成商品分类的添加，那么如何实现添加商品分类信息的操作?</p><p><strong>答案:</strong></p><ol><li>创建一个商品分类表，把goods表中的商品分类信息添加到该表中。</li><li>将goods表中的分类名称更改成商品分类表中对应的分类id</li></ol><h4 id="2-2-创建商品分类表"><a href="#2-2-创建商品分类表" class="headerlink" title="2.2 创建商品分类表"></a>2.2 创建商品分类表</h4><pre><code class="sql">-- 创建商品分类表create table good_cates(    id int not null primary key auto_increment,     name varchar(50) not null);</code></pre><h4 id="1-3-把goods表中的商品分类添加到商品分类表"><a href="#1-3-把goods表中的商品分类添加到商品分类表" class="headerlink" title="1.3 把goods表中的商品分类添加到商品分类表"></a>1.3 把goods表中的商品分类添加到商品分类表</h4><pre><code class="sql">-- 查询goods表中商品的分类信息select cate_name from goods group by cate_name;-- 将查询结果插入到good_cates表中insert into good_cates(name) select cate_name from goods group by cate_name;-- 添加移动设备分类信息insert into good_cates(name) values(&#39;移动设备&#39;);</code></pre><p><strong>说明:</strong></p><ul><li>insert into .. select .. 表示: 把查询结果插入到指定表中，也就是表复制。</li></ul><h4 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h4><ul><li>想要完成表复制可以使用: insert into .. select .. SQL语句</li></ul><h3 id="2-使用连接更新表中某个字段数据"><a href="#2-使用连接更新表中某个字段数据" class="headerlink" title="2.使用连接更新表中某个字段数据"></a>2.使用连接更新表中某个字段数据</h3><h4 id="2-1-更新goods表中的商品分类信息"><a href="#2-1-更新goods表中的商品分类信息" class="headerlink" title="2.1 更新goods表中的商品分类信息"></a>2.1 更新goods表中的商品分类信息</h4><p>上一节课我们已经创建了一个商品分类表(good_cates)，并完成了商品分类信息的插入，现在需要更新goods表中的商品分类信息，把商品分类名称改成商量分类id。</p><p>接下来我们实现第二步操作:</p><ul><li><strong>将goods表中的分类名称更改成商品分类表中对应的分类id</strong></li></ul><pre><code class="sql">-- 查看goods表中的商品分类名称对应的商品分类idselect * from goods inner join good_cates on goods.cate_name = good_cates.name;-- 把该语句中from 后的语句理解为一张虚表  update goods g inner join good_cates gc on g.cate_name=gc.name set g.cate_name=gc.id;</code></pre><h4 id="2-2-小结"><a href="#2-2-小结" class="headerlink" title="2.2 小结"></a>2.2 小结</h4><ul><li>连接更新表中数据使用: update .. join .. 语句</li></ul><h3 id="3-创建表并给某个字段添加数据"><a href="#3-创建表并给某个字段添加数据" class="headerlink" title="3.创建表并给某个字段添加数据"></a>3.创建表并给某个字段添加数据</h3><h4 id="3-1-思考"><a href="#3-1-思考" class="headerlink" title="3.1 思考"></a>3.1 思考</h4><p>前面我们完成了商品分类表(good_cates)的创建和商品分类信息的添加以及把商品表(goods)中的商品分类名称改成了对应的商品分类id，假如我们想要添加一个品牌，比如：双飞燕这个品牌信息，只通过goods表无法完成品牌信息的添加，那么如何实现添加品牌信息的操作?</p><p><strong>答案:</strong></p><ol><li>创建一个品牌表，把goods表中的品牌信息添加到该表中。</li><li>将goods表中的品牌名称更改成品牌表中对应的品牌id</li></ol><h4 id="3-2-创建品牌表"><a href="#3-2-创建品牌表" class="headerlink" title="3.2 创建品牌表"></a>3.2 创建品牌表</h4><pre><code class="sql">-- 查询品牌信息 select brand_name from goods group by brand_name;-- 通过create table ...select来创建数据表并且同时插入数据-- 创建商品分类表，注意: 需要对brand_name 用as起别名，否则name字段就没有值create table good_brands (     id int unsigned primary key auto_increment,     name varchar(40) not null) select brand_name as name from goods group by brand_name;</code></pre><p><strong>说明:</strong></p><ul><li>create table .. select 列名 .. 表示创建表并插入数据</li></ul><h4 id="3-3-更新goods表中的品牌信息"><a href="#3-3-更新goods表中的品牌信息" class="headerlink" title="3.3 更新goods表中的品牌信息"></a>3.3 更新goods表中的品牌信息</h4><pre><code class="sql">-- 将goods表中的品牌名称更改成品牌表中对应的品牌idupdate goods as g inner join good_brands gb on g.brand_name = gb.name set g.brand_name = gb.id;</code></pre><h4 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h4><ul><li>创建表并给字段插入数据使用: create table .. select 语句</li></ul><h3 id="4-修改goods表结构"><a href="#4-修改goods表结构" class="headerlink" title="4.修改goods表结构"></a>4.修改goods表结构</h3><h4 id="4-1-修改goods表结构"><a href="#4-1-修改goods表结构" class="headerlink" title="4.1 修改goods表结构"></a>4.1 修改goods表结构</h4><p>目前我们已经把good表中的商品分类和品牌信息已经更改成了商品分类id和品牌id，接下来需要把 cate_name 和 brand_name 字段分别改成 cate_id和 brand_id 字段，类型都改成int类型</p><pre><code class="sql">-- 查看表结构desc goods;-- 通过alter table语句修改表结构alter table goods change cate_name cate_id int not null, change brand_name brand_id int not null;</code></pre><p><strong>说明:</strong></p><ul><li>alert table 可以同时修改多个字段信息</li></ul><h4 id="4-2-小结"><a href="#4-2-小结" class="headerlink" title="4.2 小结"></a>4.2 小结</h4><ul><li>修改表结构可以使用: alter table 语句，多个修改字段之间使用逗号分隔</li></ul><h3 id="5-事务"><a href="#5-事务" class="headerlink" title="5.事务"></a>5.事务</h3><h4 id="5-1-事务的介绍"><a href="#5-1-事务的介绍" class="headerlink" title="5.1 事务的介绍"></a>5.1 事务的介绍</h4><p>事务就是用户定义的一系列执行SQL语句的操作, 这些操作要么完全地执行，要么完全地都不执行， 它是一个不可分割的工作执行单元。</p><p><strong>事务的使用场景:</strong></p><p>在日常生活中，有时我们需要进行银行转账，这个银行转账操作背后就是需要执行多个SQL语句，假如这些SQL执行到一半突然停电了，那么就会导致这个功能只完成了一半，这种情况是不允许出现，要想解决这个问题就需要通过事务来完成。</p><h4 id="5-2-事务的四大特性"><a href="#5-2-事务的四大特性" class="headerlink" title="5.2 事务的四大特性"></a>5.2 事务的四大特性</h4><ul><li>原子性(Atomicity)</li><li>一致性(Consistency)</li><li>隔离性(Isolation)</li><li>持久性(Durability)</li></ul><p><strong>原子性:</strong></p><p>一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性</p><p><strong>一致性:</strong></p><p>数据库总是从一个一致性的状态转换到另一个一致性的状态。（在前面的例子中，一致性确保了，即使在转账过程中系统崩溃，支票账户中也不会损失200美元，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。）</p><p><strong>隔离性:</strong></p><p>通常来说，一个事务所做的修改操作在提交事务之前，对于其他事务来说是不可见的。（在前面的例子中，当执行完第三条语句、第四条语句还未开始时，此时有另外的一个账户汇总程序开始运行，则其看到支票帐户的余额并没有被减去200美元。）</p><p><strong>持久性:</strong></p><p>一旦事务提交，则其所做的修改会永久保存到数据库。</p><p><strong>说明:</strong></p><p>事务能够保证数据的完整性和一致性，让用户的操作更加安全。</p><h4 id="5-3-事务的使用"><a href="#5-3-事务的使用" class="headerlink" title="5.3 事务的使用"></a>5.3 事务的使用</h4><p>在使用事务之前，先要确保表的存储引擎是 InnoDB 类型, 只有这个类型才可以使用事务，MySQL数据库中表的存储引擎默认是 InnoDB 类型。</p><p><strong>表的存储引擎说明:</strong></p><p>表的存储引擎就是提供存储数据一种机制，不同表的存储引擎提供不同的存储机制。</p><pre><code class="sql">-- 查看MySQL数据库支持的表的存储引擎show engines;</code></pre><p><strong>说明:</strong></p><ul><li>常用的表的存储引擎是 InnoDB 和 MyISAM</li><li>InnoDB 是支持事务的</li><li>MyISAM 不支持事务，优势是访问速度快，对事务没有要求或者以select、insert为主的都可以使用该存储引擎来创建表</li></ul><p><strong>查看goods表的创表语句:</strong></p><pre><code class="sql">-- 选择数据库use jing_dong;-- 查看goods表show create table goods;mysql root@(none):jing_dong&gt; show create table goods;+-------+--------------------------------------------------------+| Table | Create Table                                           |+-------+--------------------------------------------------------+| goods | CREATE TABLE `goods` (                                 ||       |   `id` int(10) unsigned NOT NULL AUTO_INCREMENT,       ||       |   `name` varchar(150) NOT NULL,                        ||       |   `cate_id` int(10) unsigned NOT NULL,                 ||       |   `brand_id` int(10) unsigned NOT NULL,                ||       |   `price` decimal(10,3) NOT NULL DEFAULT &#39;0.000&#39;,      ||       |   `is_show` bit(1) NOT NULL DEFAULT b&#39;1&#39;,              ||       |   `is_saleoff` bit(1) NOT NULL DEFAULT b&#39;0&#39;,           ||       |   PRIMARY KEY (`id`)                                   ||       | ) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=utf8 |+-------+--------------------------------------------------------+</code></pre><p><strong>说明:</strong></p><ul><li>通过创表语句可以得知，goods表的存储引擎是InnoDB。</li><li>修改表的存储引擎使用: alter table 表名 engine = 引擎类型;<ul><li>比如: alter table students engine = ‘MyISAM’;</li></ul></li></ul><p><strong>开启事务:</strong></p><pre><code class="sql">begin;或者start transaction;</code></pre><p><strong>说明:</strong></p><ul><li><p><strong>开启事务后执行修改命令，变更数据会保存到MySQL服务端的缓存文件中，而不维护到物理表中</strong></p></li><li><p><strong>MySQL数据库默认采用自动提交(autocommit)模式，如果没有显示的开启一个事务,那么每条sql语句都会被当作一个事务执行提交的操作</strong></p></li><li><p>当设置autocommit=0就是取消了自动提交事务模式，直到显示的执行commit和rollback表示该事务结束。</p><ul><li>set autocommit = 0 表示取消自动提交事务模式，需要手动执行commit完成事务的提交</li></ul><pre><code class="sql">set autocommit = 0;insert into students(name) values(&#39;刘三峰&#39;);-- 需要执行手动提交，数据才会真正添加到表中, 验证的话需要重新打开一个连接窗口查看表的数据信息，因为是临时关闭自动提交模式commit-- 重新打开一个终端窗口，连接MySQL数据库服务端mysql -uroot -p-- 然后查询数据,如果上个窗口执行了commit，这个窗口才能看到数据select * from students;</code></pre><p><strong>提交事务:</strong></p><p>将本地缓存文件中的数据提交到物理表中，完成数据的更新。</p><pre><code class="sql">commit;</code></pre><p><strong>回滚事务:</strong></p><p>放弃本地缓存文件中的缓存数据, 表示回到开始事务前的状态</p><pre><code>rollback;</code></pre><p><strong>事务演练的SQL语句:</strong></p><pre><code class="sql">begin;insert into students(name) values(&#39;李白&#39;);-- 查询数据，此时有新增的数据, 注意: 如果这里后续没有执行提交事务操作，那么数据是没有真正的更新到物理表中select * from students;-- 只有这里提交事务，才把数据真正插入到物理表中commit;-- 新打开一个终端，重新连接MySQL数据库，查询students表,这时没有显示新增的数据，说明之前的事务没有提交，这就是事务的隔离性-- 一个事务所做的修改操作在提交事务之前，对于其他事务来说是不可见的select * from students;</code></pre></li></ul><h4 id="5-4-小结"><a href="#5-4-小结" class="headerlink" title="5.4 小结"></a>5.4 小结</h4><ol><li>事务的特性:<ul><li>原子性: 强调事务中的多个操作时一个整体</li><li>一致性: 强调数据库中不会保存不一致状态</li><li>隔离性: 强调数据库中事务之间相互不可见</li><li>持久性: 强调数据库能永久保存数据，一旦提交就不可撤销</li></ul></li><li><strong>MySQL数据库默认采用自动提交(autocommit)模式</strong>, 也就是说修改数据(insert、update、delete)的操作会自动的触发事务,完成事务的提交或者回滚</li><li>开启事务使用 begin 或者 start transaction;</li><li>回滚事务使用 rollback;</li><li>pymysql 里面的 conn.commit() 操作就是提交事务</li><li>pymysql 里面的 conn.rollback() 操作就是回滚事务</li></ol><h3 id="6-索引"><a href="#6-索引" class="headerlink" title="6.索引"></a>6.索引</h3><h4 id="6-1-索引的介绍"><a href="#6-1-索引的介绍" class="headerlink" title="6.1 索引的介绍"></a>6.1 索引的介绍</h4><p>索引在MySQL中也叫做“键”，它是一个特殊的文件，它保存着数据表里所有记录的位置信息，更通俗的来说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。</p><p><strong>应用场景:</strong></p><p>当数据库中数据量很大时，查找数据会变得很慢，我们就可以通过索引来提高数据库的查询效率。</p><h4 id="6-2-索引的使用"><a href="#6-2-索引的使用" class="headerlink" title="6.2 索引的使用"></a>6.2 索引的使用</h4><p><strong>查看表中已有索引:</strong></p><pre><code class="sql">show index from 表名;</code></pre><p><strong>说明:</strong></p><ul><li>主键列会自动创建索引</li></ul><p><strong>索引的创建:</strong></p><pre><code class="sql">-- 创建索引的语法格式-- alter table 表名 add index 索引名[可选](列名, ..)-- 给name字段添加索引alter table classes add index my_name (name);</code></pre><p><strong>说明:</strong></p><ul><li>索引名不指定，默认使用字段名</li></ul><p><strong>索引的删除:</strong></p><pre><code class="sql">-- 删除索引的语法格式-- alter table 表名 drop index 索引名-- 如果不知道索引名，可以查看创表sql语句show create table classes;alter table classes drop index my_name;</code></pre><h4 id="6-3-案例-验证索引查询性能"><a href="#6-3-案例-验证索引查询性能" class="headerlink" title="6.3 案例-验证索引查询性能"></a>6.3 案例-验证索引查询性能</h4><p><strong>创建测试表testindex:</strong></p><pre><code class="sql">create table test_index(title varchar(10));</code></pre><p><strong>向表中插入十万条数据:</strong></p><pre><code class="py">from pymysql import connectdef main():    # 创建Connection连接    conn = connect(host=&#39;localhost&#39;,port=3306,database=&#39;python&#39;,user=&#39;root&#39;,password=&#39;mysql&#39;,charset=&#39;utf8&#39;)    # 获得Cursor对象    cursor = conn.cursor()    # 插入10万次数据    for i in range(100000):        cursor.execute(&quot;insert into test_index values(&#39;ha-%d&#39;)&quot; % i)    # 提交数据    conn.commit()if __name__ == &quot;__main__&quot;:    main()</code></pre><p><strong>验证索引性能操作：</strong></p><pre><code class="sql">-- 开启运行时间监测：set profiling=1;-- 查找第1万条数据ha-99999select * from test_index where title=&#39;ha-99999&#39;;-- 查看执行的时间：show profiles;-- 给title字段创建索引：alter table test_index add index (title);-- 再次执行查询语句select * from test_index where title=&#39;ha-99999&#39;;-- 再次查看执行的时间show profiles;</code></pre><h4 id="6-4-联合索引"><a href="#6-4-联合索引" class="headerlink" title="6.4 联合索引"></a>6.4 联合索引</h4><p>联合索引又叫复合索引，即一个索引覆盖表中两个或者多个字段，一般用在多个字段一起查询的时候。</p><pre><code class="sql">-- 创建teacher表create table teacher(    id int not null primary key auto_increment,    name varchar(10),    age int);-- 创建联合索引alter table teacher add index (name,age);</code></pre><p><strong>联合索引的好处:</strong></p><ul><li>减少磁盘空间开销，因为每创建一个索引，其实就是创建了一个索引文件，那么会增加磁盘空间的开销。</li></ul><h4 id="6-5-联合索引的最左原则"><a href="#6-5-联合索引的最左原则" class="headerlink" title="6.5 联合索引的最左原则"></a>6.5 联合索引的最左原则</h4><p>在使用联合索引的时候，我们要遵守一个最左原则,即index(name,age)支持 name 、name 和 age 组合查询,而不支持单独 age 查询，因为没有用到创建的联合索引。</p><p><strong>最左原则示例:</strong></p><pre><code class="sql">-- 下面的查询使用到了联合索引select * from stu where name=&#39;张三&#39; -- 这里使用了联合索引的name部分select * from stu where name=&#39;李四&#39; and age=10 -- 这里完整的使用联合索引，包括 name 和 age 部分 -- 下面的查询没有使用到联合索引select * from stu where age=10 -- 因为联合索引里面没有这个组合，只有 name | name age 这两种组合</code></pre><p><strong>说明:</strong></p><ul><li>在使用联合索引的查询数据时候一定要保证联合索引的最左侧字段出现在查询条件里面，否则联合索引失效</li></ul><h4 id="6-6-MySQL中索引的优点和缺点和使用原则"><a href="#6-6-MySQL中索引的优点和缺点和使用原则" class="headerlink" title="6.6 MySQL中索引的优点和缺点和使用原则"></a>6.6 MySQL中索引的优点和缺点和使用原则</h4><ul><li>优点：<ol><li>加快数据的查询速度</li></ol></li><li>缺点：<ol><li>创建索引会耗费时间和占用磁盘空间，并且随着数据量的增加所耗费的时间也会增加</li></ol></li><li>使用原则：<ol><li>通过优缺点对比，不是索引越多越好，而是需要自己合理的使用。</li><li>对经常更新的表就避免对其进行过多索引的创建，对经常用于查询的字段应该创建索引，</li><li>数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果。</li><li>在一字段上相同值比较多不要建立索引，比如在学生表的”性别”字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可是建立索引。</li></ol></li></ul><h4 id="6-7-小结"><a href="#6-7-小结" class="headerlink" title="6.7 小结"></a>6.7 小结</h4><ul><li>索引是加快数据库的查询速度的一种手段</li><li>创建索引使用: alter table 表名 add index 索引名[可选] (字段名, xxx);</li><li>删除索引使用: alter table 表名 drop index 索引名;</li></ul><h3 id="7-PyMySQL的使用"><a href="#7-PyMySQL的使用" class="headerlink" title="7.PyMySQL的使用"></a>7.PyMySQL的使用</h3><h4 id="7-1-思考"><a href="#7-1-思考" class="headerlink" title="7.1 思考"></a>7.1 思考</h4><p>如何实现将100000条数据插入到MySQL数据库?</p><p><strong>答案:</strong></p><p>如果使用之前学习的MySQL客户端来完成这个操作，那么这个工作量无疑是巨大的，我们可以通过使用程序代码的方式去连接MySQL数据库，然后对MySQL数据库进行增删改查的方式，实现10000条数据的插入，像这样使用代码的方式操作数据库就称为数据库编程。</p><h4 id="7-2-Python程序操作MySQL数据库"><a href="#7-2-Python程序操作MySQL数据库" class="headerlink" title="7.2 Python程序操作MySQL数据库"></a>7.2 Python程序操作MySQL数据库</h4><p><strong>安装pymysql第三方包:</strong></p><pre><code class="bash">sudo pip3 install pymysql</code></pre><p><strong>说明:</strong></p><ul><li>安装命令使用 sudo pip3 install 第三方包名</li><li>卸载命令使用 sudo pip3 uninstall 第三方包</li><li>大家现在使用的虚拟机已经安装了这个第三方包，可以使用： <strong>pip3 show pymysql</strong> 命令查看第三方包的信息</li><li><strong>pip3 list</strong> 查看使用pip命令安装的第三方包列表</li></ul><p><strong>pymysql的使用:</strong></p><ol><li><p>导入 pymysql 包</p><pre><code class="python"> import pymysql</code></pre></li><li><p>创建连接对象</p><p>调用pymysql模块中的connect()函数来创建连接对象,代码如下:</p><pre><code class="py"> conn=connect(参数列表) * 参数host：连接的mysql主机，如果本机是&#39;localhost&#39; * 参数port：连接的mysql主机的端口，默认是3306 * 参数user：连接的用户名 * 参数password：连接的密码 * 参数database：数据库的名称 * 参数charset：通信采用的编码方式，推荐使用utf8</code></pre><p><strong>连接对象操作说明:</strong></p><ul><li>关闭连接 conn.close()</li><li>提交数据 conn.commit()</li><li>撤销数据 conn.rollback()</li></ul></li><li><p>获取游标对象</p><p>获取游标对象的目标就是要执行sql语句，完成对数据库的增、删、改、查操作。代码如下:</p><pre><code class="py"> # 调用连接对象的cursor()方法获取游标对象    cur =conn.cursor()</code></pre><p><strong>游标操作说明:</strong></p><ul><li>使用游标执行SQL语句: execute(operation [parameters ]) 执行SQL语句，返回受影响的行数，主要用于执行insert、update、delete、select等语句</li><li>获取查询结果集中的一条数据:cur.fetchone()返回一个元组, 如 (1,’张三’)</li><li>获取查询结果集中的所有数据: cur.fetchall()返回一个元组,如((1,’张三’),(2,’李四’))</li><li>关闭游标: cur.close(),表示和数据库操作完成</li></ul></li><li><p>pymysql完成数据的查询操作</p><pre><code class="python">import pymysql# 创建连接对象conn = pymysql.connect(host=&#39;localhost&#39;, port=3306, user=&#39;root&#39;, password=&#39;mysql&#39;,database=&#39;python&#39;, charset=&#39;utf8&#39;)# 获取游标对象cursor = conn.cursor()# 查询 SQL 语句sql = &quot;select * from students;&quot;# 执行 SQL 语句 返回值就是 SQL 语句在执行过程中影响的行数row_count = cursor.execute(sql)print(&quot;SQL 语句执行影响的行数%d&quot; % row_count)# 取出结果集中一行数据,　例如:(1, &#39;张三&#39;)# print(cursor.fetchone())# 取出结果集中的所有数据, 例如:((1, &#39;张三&#39;), (2, &#39;李四&#39;), (3, &#39;王五&#39;))for line in cursor.fetchall():    print(line)# 关闭游标cursor.close()# 关闭连接conn.close()</code></pre></li><li><p>pymysql完成对数据的增删改</p><pre><code class="python">import pymysql# 创建连接对象conn = pymysql.connect(host=&#39;localhost&#39;, port=3306, user=&#39;root&#39;, password=&#39;mysql&#39;,database=&#39;python&#39;, charset=&#39;utf8&#39;)# 获取游标对象cursor = conn.cursor()try:    # 添加 SQL 语句    # sql = &quot;insert into students(name) values(&#39;刘璐&#39;), (&#39;王美丽&#39;);&quot;    # 删除 SQ L语句    # sql = &quot;delete from students where id = 5;&quot;    # 修改 SQL 语句    sql = &quot;update students set name = &#39;王铁蛋&#39; where id = 6;&quot;    # 执行 SQL 语句    row_count = cursor.execute(sql)    print(&quot;SQL 语句执行影响的行数%d&quot; % row_count)    # 提交数据到数据库    conn.commit()except Exception as e:    # 回滚数据， 即撤销刚刚的SQL语句操作    conn.rollback()# 关闭游标cursor.close()# 关闭连接conn.close()</code></pre><p><strong>说明:</strong></p><ul><li>conn.commit() 表示将修改操作提交到数据库</li><li>conn.rollback() 表示回滚数据</li></ul></li><li><p>防止SQL注入</p><p>什么是SQL注入?</p><p>用户提交带有恶意的数据与SQL语句进行字符串方式的拼接，从而影响了SQL语句的语义，最终产生数据泄露的现象。</p><p>如何防止SQL注入?</p><p>SQL语句参数化</p><ul><li>SQL语言中的参数使用%s来占位，此处不是python中的字符串格式化操作</li><li>将SQL语句中%s占位所需要的参数存在一个列表中，把参数列表传递给execute方法中第二个参数</li></ul><p><strong>防止SQL注入的示例代码:</strong></p><pre><code class="python">from pymysql import connectdef main():    find_name = input(&quot;请输入物品名称：&quot;)    # 创建Connection连接    conn = connect(host=&#39;localhost&#39;,port=3306,user=&#39;root&#39;,password=&#39;mysql&#39;,database=&#39;jing_dong&#39;,charset=&#39;utf8&#39;)    # 获得Cursor对象    cs1 = conn.cursor()    # 非安全的方式    # 输入 &#39; or 1 = 1 or &#39;   (单引号也要输入)    # sql = &quot;select * from goods where name=&#39;%s&#39;&quot; % find_name    # print(&quot;&quot;&quot;sql===&gt;%s&lt;====&quot;&quot;&quot; % sql)    # # 执行select语句，并返回受影响的行数：查询所有数据    # count = cs1.execute(sql)    # 安全的方式    # 构造参数列表    params = [find_name]    # 执行select语句，并返回受影响的行数：查询所有数据    count = cs1.execute(&quot;select * from goods where name=%s&quot;, params)    # 注意：    # 如果要是有多个参数，需要进行参数化    # 那么params = [数值1, 数值2....]，此时sql语句中有多个%s即可    # %s 不需要带引号    # 打印受影响的行数    print(count)    # 获取查询的结果    # result = cs1.fetchone()    result = cs1.fetchall()    # 打印查询的结果    print(result)    # 关闭Cursor对象    cs1.close()    # 关闭Connection对象    conn.close()if __name__ == &#39;__main__&#39;:    main()</code></pre><p><strong>说明:</strong></p><ul><li>execute方法中的 %s 占位不需要带引号</li></ul></li></ol><h4 id="7-3-小结-1"><a href="#7-3-小结-1" class="headerlink" title="7.3 小结"></a>7.3 小结</h4><ol><li><p>导包</p><pre><code class="py"> import pymysql</code></pre></li><li><p>创建连接对象</p><pre><code class="py"> pymysql.connect(参数列表)</code></pre></li><li><p>获取游标对象</p><pre><code class="py"> cursor =conn.cursor()</code></pre></li><li><p>执行SQL语句</p><pre><code class="py"> row_count = cursor.execute(sql)</code></pre></li><li><p>获取查询结果集</p><pre><code class="py"> result = cursor.fetchall()</code></pre></li><li><p>将修改操作提交到数据库</p><pre><code class="py"> conn.commit()</code></pre></li><li><p>回滚数据</p><pre><code class="py"> conn.rollback()</code></pre></li><li><p>关闭游标</p><pre><code class="py"> cursor.close()</code></pre></li><li><p>关闭连接</p><pre><code class="py"> conn.close()</code></pre></li></ol><h3 id="8-京东数据库案例练习"><a href="#8-京东数据库案例练习" class="headerlink" title="8.京东数据库案例练习"></a>8.京东数据库案例练习</h3><p>一. 准备数据</p><p>该案例使用前面章节中完成的京东商品数据库.</p><p>二. 程序菜单</p><pre><code class="python">    print(&#39;1. 查询所有商品信息&#39;)    print(&quot;2. 查询所有包含商品的分类&quot;)    print(&quot;3. 添加新商品分类&quot;)    print(&quot;4. 将所有商品价格加1000&quot;)    print(&quot;5. 将所有笔记本的分类改为超级本&quot;)    print(&quot;6. 根据id查询商品信息&quot;)    print(&quot;7. 根据id查询商品信息安全方式&quot;)    print(&quot;8. 退出系统&quot;)</code></pre><p>三. 方法命名</p><pre><code class="python">    # 显示菜单方法    def __print_menu(self):        pass    # 打印结果方法    def __show_query_result(self, result):        pass    # 服务器运行方法,实现主体逻辑    def run(self):        pass    # 1. 查询所有商品信息    def __fetch_all_info(self):        pass   # 2. 查询所有包含商品的分类    def __fetch_cate_of_goods(self):        pass    # 3. 添加商品分类    def __add_new_cate(self):        pass      # 4. 将所有商品价格加1000    def __update_price(self):        pass    # 5. 将所有笔记本的分类改为超级本    def __update_cate(self):        pass    # 6. 根据id查询商品信息    def __fetch_info_with_id(self):        pass    # 7. 根据id查询商品信息安全方式    def __fetch_info_with_id_safe(self):        pass</code></pre><p>四. 代码实现</p><ol><li><p>判断当前是否是主程序入口</p><pre><code class="python"> if __name__ == &#39;__main__&#39;:     main()</code></pre></li><li><p>实现主函数</p><pre><code class="python"> def main():     # 创建服务器对象,并传入相应参数     jd = JDServer(&#39;jd&#39;, &#39;root&#39;, &#39;123123&#39;)     # 启动服务器     jd.run()</code></pre></li><li><p>实现 JD 类</p><pre><code class="python"> import pymysql class JDServer(object): &quot;&quot;&quot;JD 类，提供商品查询服务&quot;&quot;&quot; # 将数据库连接操作放到初化方法中，对象创建时，自动连接数据库 def __init__(self, target_db, username, password):     # 连接数据库     self.db_connect = pymysql.Connect(host=&#39;localhost&#39;,port=3306,database=target_db, user=username, passwd=password, charset=&#39;utf8&#39;) # 将数据库关闭操作放到 __del__方法中，当对象销毁时，自动关闭数据库 def __del__(self):     # 关闭数据库     self.db_connect.close()</code></pre></li><li><p>实现 run 方法 因为需要重复选择，所以要用死循环</p><pre><code class="python"> # 服务器运行方法,实现主体逻辑,通过判断输入选择相应的功能函数 def run(self):     while True:         self.__print_menu()         select_id = input(&#39;请输入功能ID:&#39;)         if select_id == &#39;1&#39;:             self.__fetch_all_info()         elif select_id == &#39;2&#39;:             self.__fetch_cate_of_goods()         elif select_id == &#39;3&#39;:             self.__add_new_cate()         elif select_id == &#39;4&#39;:             self.__update_price()         elif select_id == &#39;5&#39;:             self.__update_cate()         elif select_id == &#39;6&#39;:             self.__fetch_info_with_id()         elif select_id == &#39;7&#39;:             self.__fetch_info_with_id_safe()         elif select_id == &#39;8&#39;:             break         else:             print(&#39;输入功能不正确,请重新输入&#39;)</code></pre></li><li><p>实现一个显示方法，用来输出结果</p><pre><code class="python"> # 用来显示结果的方法，私有，对外不可见 def __show_query_result(self, result):     for item in result:         print(item)</code></pre></li><li><p>实现查询所有商品信息</p><pre><code class="python"> # 1. 查询所有商品信息 def __fetch_all_info(self):     cur = self.db_connect.cursor()     sql_str = &#39;&#39;&#39;select * from goods&#39;&#39;&#39;     cur.execute(sql_str)     result = cur.fetchall()     self.__show_query_result(result)     cur.close()</code></pre></li><li><p>查询所有包含商品的分类</p><pre><code class="python"> # 2. 查询所有包含商品的分类 def __fetch_cate_of_goods(self):     cur = self.db_connect.cursor()     sql_str = &#39;&#39;&#39;select distinct good_cates.name from goods inner join good_cates on goods.cate_id = good_cates.id;&#39;&#39;&#39;     # sql_str = &#39;&#39;&#39; select name from good_cates where id in (select distinct cate_id from goods); &#39;&#39;&#39;     cur.execute(sql_str)     result = cur.fetchall()     self.__show_query_result(result)     cur.close()</code></pre></li><li><p>添加商品分类</p><pre><code class="python"> # 3. 添加商品分类 def __add_new_cate(self):     new_cate = input(&#39;请输入一个新商品分类:&#39;)     sql_str = &#39;&#39;&#39; insert into good_cates(name) values(&quot;%s&quot;) &#39;&#39;&#39; % new_cate     cur = self.db_connect.cursor()     cur.execute(sql_str)     self.db_connect.commit()     cur.close()</code></pre></li><li><p>将所有商品价格加1000</p><pre><code class="python"> # 4. 将所有商品价格加1000 def __update_price(self):     cur = self.db_connect.cursor()     sql_str = &#39;&#39;&#39; update goods set price = price + 1000&#39;&#39;&#39;     cur.execute(sql_str)     self.db_connect.commit()     cur.close()</code></pre></li><li><p>将所有笔记本的分类改为超级本</p><pre><code class="python"># 5. 将所有笔记本的分类改为超级本def __update_cate(self):    cur = self.db_connect.cursor()    sql_str = &#39;&#39;&#39;update goods set cate_id = (select id from good_cates where name = &#39;超级本&#39;) where name like &#39;%笔记本%&#39;;&#39;&#39;&#39;    cur.execute(sql_str)    self.db_connect.commit()    cur.close()</code></pre></li><li><p>根据id 查找商品,会产生SQL注入问题</p><pre><code class="python"># 6. 根据id查询商品信息def __fetch_info_with_id(self):    s_id = input(&#39;请输入一个商品ID:&#39;)    sql_str = &#39;&#39;&#39; select * from goods where id = %s &#39;&#39;&#39; % s_id    print(sql_str)    cur = self.db_connect.cursor()    cur.execute(sql_str)    result = cur.fetchall()    self.__show_query_result(result)    cur.close()</code></pre></li><li><p>根据id查询商品信息安全方式,案例防注入</p><pre><code class="python"># 7. 根据id查询商品信息安全方式def __fetch_info_with_id_safe(self):    s_id = input(&#39;请输入一个商品ID:&#39;)    sql_str = &#39;&#39;&#39; select * from goods where id = %s &#39;&#39;&#39;    print(sql_str)    cur = self.db_connect.cursor()    cur.execute(sql_str, (s_id,))    result = cur.fetchall()    self.__show_query_result(result)    cur.close() self.__show_query_result(result)    cur.close()</code></pre></li><li><p>查询所有包含商品的分类</p><pre><code class="python"> # 2. 查询所有包含商品的分类 def __fetch_cate_of_goods(self):     cur = self.db_connect.cursor()     sql_str = &#39;&#39;&#39;select distinct good_cates.name from goods inner join good_cates on goods.cate_id = good_cates.id;&#39;&#39;&#39;     # sql_str = &#39;&#39;&#39; select name from good_cates where id in (select distinct cate_id from goods); &#39;&#39;&#39;     cur.execute(sql_str)     result = cur.fetchall()     self.__show_query_result(result)     cur.close()</code></pre></li><li><p>添加商品分类</p><pre><code class="python"> # 3. 添加商品分类 def __add_new_cate(self):     new_cate = input(&#39;请输入一个新商品分类:&#39;)     sql_str = &#39;&#39;&#39; insert into good_cates(name) values(&quot;%s&quot;) &#39;&#39;&#39; % new_cate     cur = self.db_connect.cursor()     cur.execute(sql_str)     self.db_connect.commit()     cur.close()</code></pre></li><li><p>将所有商品价格加1000</p><pre><code class="python"> # 4. 将所有商品价格加1000 def __update_price(self):     cur = self.db_connect.cursor()     sql_str = &#39;&#39;&#39; update goods set price = price + 1000&#39;&#39;&#39;     cur.execute(sql_str)     self.db_connect.commit()     cur.close()</code></pre></li><li><p>将所有笔记本的分类改为超级本</p><pre><code class="python"># 5. 将所有笔记本的分类改为超级本def __update_cate(self):    cur = self.db_connect.cursor()    sql_str = &#39;&#39;&#39;update goods set cate_id = (select id from good_cates where name = &#39;超级本&#39;) where name like &#39;%笔记本%&#39;;&#39;&#39;&#39;    cur.execute(sql_str)    self.db_connect.commit()    cur.close()</code></pre></li><li><p>根据id 查找商品,会产生SQL注入问题</p><pre><code class="python"># 6. 根据id查询商品信息def __fetch_info_with_id(self):    s_id = input(&#39;请输入一个商品ID:&#39;)    sql_str = &#39;&#39;&#39; select * from goods where id = %s &#39;&#39;&#39; % s_id    print(sql_str)    cur = self.db_connect.cursor()    cur.execute(sql_str)    result = cur.fetchall()    self.__show_query_result(result)    cur.close()</code></pre></li><li><p>根据id查询商品信息安全方式,案例防注入</p><pre><code class="python"># 7. 根据id查询商品信息安全方式def __fetch_info_with_id_safe(self):    s_id = input(&#39;请输入一个商品ID:&#39;)    sql_str = &#39;&#39;&#39; select * from goods where id = %s &#39;&#39;&#39;    print(sql_str)    cur = self.db_connect.cursor()    cur.execute(sql_str, (s_id,))    result = cur.fetchall()    self.__show_query_result(result)    cur.close()</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySQL数据库&quot;&gt;&lt;a href=&quot;#MySQL数据库&quot; class=&quot;headerlink&quot; title=&quot;MySQL数据库&quot;&gt;&lt;/a&gt;MySQL数据库&lt;/h1&gt;&lt;h2 id=&quot;一、MySQL数据库的基本使用&quot;&gt;&lt;a href=&quot;#一、MySQL数据库的基本使用&quot; class=&quot;headerlink&quot; title=&quot;一、MySQL数据库的基本使用&quot;&gt;&lt;/a&gt;一、MySQL数据库的基本使用&lt;/h2&gt;&lt;h3 id=&quot;1-数据库&quot;&gt;&lt;a href=&quot;#1-数据库&quot; class=&quot;headerlink&quot; title=&quot;1.数据库&quot;&gt;&lt;/a&gt;1.数据库&lt;/h3&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://caijinbo.work/categories/python/"/>
    
    
      <category term="python" scheme="https://caijinbo.work/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python高级06-JavaScript</title>
    <link href="https://caijinbo.work/2020/08/21/2020-08-22-python%E9%AB%98%E7%BA%A706-JavaScript/"/>
    <id>https://caijinbo.work/2020/08/21/2020-08-22-python%E9%AB%98%E7%BA%A706-JavaScript/</id>
    <published>2020-08-21T16:00:00.000Z</published>
    <updated>2020-11-23T10:13:39.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="一、JavaScript的介绍"><a href="#一、JavaScript的介绍" class="headerlink" title="一、JavaScript的介绍"></a>一、JavaScript的介绍</h2><h3 id="1-JavaScript的定义"><a href="#1-JavaScript的定义" class="headerlink" title="1. JavaScript的定义"></a>1. JavaScript的定义</h3><a id="more"></a><p>JavaScript是运行在浏览器端的脚本语言, 是由浏览器解释执行的, 简称js.</p><p>它能够让网页和用户有交互功能, 增加良好的用户体验效果。</p><h4 id="前端开发三大块"><a href="#前端开发三大块" class="headerlink" title="前端开发三大块"></a>前端开发三大块</h4><p>1、HTML：负责网页结构</p><p>2、CSS：负责网页样式</p><p>3、JavaScript：负责网页行为， 比如:网页与用户的交互效果</p><h2 id="二、JavaScript的使用方式"><a href="#二、JavaScript的使用方式" class="headerlink" title="二、JavaScript的使用方式"></a>二、JavaScript的使用方式</h2><h3 id="1-行内式（主要用于事件）"><a href="#1-行内式（主要用于事件）" class="headerlink" title="1. 行内式（主要用于事件）"></a>1. 行内式（主要用于事件）</h3><pre><code class="html">&lt;input type=&quot;button&quot; name=&quot;&quot; onclick=&quot;alert(&#39;ok！&#39;);&quot;&gt;</code></pre><h3 id="2-内嵌式"><a href="#2-内嵌式" class="headerlink" title="2. 内嵌式"></a>2. 内嵌式</h3><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;            alert(&#39;ok！&#39;);&lt;/script&gt;</code></pre><h3 id="3-外链式"><a href="#3-外链式" class="headerlink" title="3. 外链式"></a>3. 外链式</h3><pre><code class="html">&lt;script type=&quot;text/javascript&quot; src=&quot;js/index.js&quot;&gt;&lt;/script&gt;</code></pre><h2 id="三、变量和数据类型"><a href="#三、变量和数据类型" class="headerlink" title="三、变量和数据类型"></a>三、变量和数据类型</h2><h3 id="1-定义变量"><a href="#1-定义变量" class="headerlink" title="1. 定义变量"></a>1. 定义变量</h3><p>JavaScript 是一种弱类型语言，也就是说不需要指定变量的类型，JavaScript的变量类型由它的值来决定， 定义变量需要用关键字 ‘var’, 一条JavaScript语句应该以“;”结尾</p><p><strong>定义变量的语法格式:</strong></p><p>var 变量名 = 值;</p><pre><code class="javascript"> var iNum = 123; var sTr = &#39;asd&#39;; //同时定义多个变量可以用&quot;,&quot;隔开，公用一个‘var’关键字 var iNum = 45,sTr=&#39;qwe&#39;,sCount=&#39;68&#39;;</code></pre><h3 id="2-JavaScript注释"><a href="#2-JavaScript注释" class="headerlink" title="2. JavaScript注释"></a>2. JavaScript注释</h3><p>JavaScript的注释分为单行注释(//注释内容)和多行注释(/<em>多行注释</em>/)</p><pre><code class="javascript">&lt;script type=&quot;text/javascript&quot;&gt;    // 单行注释var iNum = 123;/*      多行注释    1、...    2、...*/var sTr = &#39;abc123&#39;;&lt;/script&gt;</code></pre><h3 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3. 数据类型"></a>3. 数据类型</h3><p>js中有六种数据类型，包括五种基本数据类型和一种复杂数据类型(object)。</p><p>5种基本数据类型：<br>1、number 数字类型<br>2、string 字符串类型<br>3、boolean 布尔类型 true 或 false<br>4、undefined undefined类型，变量声明未初始化，它的值就是undefined<br>5、null null类型，表示空对象，如果定义的变量将来准备保存对象，可以将变量初始化为null,在页面上获取不到对象，返回的值就是null</p><p>1种复合类型：<br>1、object 后面学习的<strong>JavaScript对象</strong>属于复合类型</p><p>js中有六种数据类型，分别是:</p><ul><li>number</li><li>string</li><li>boolean</li><li>undefined</li><li>null</li><li>object</li></ul><pre><code class="js">//1.1 数字 numbervar iOne = 10.1;//1.2 字符串 stringvar sStr = &#39;1234&#39;;//1.3 布尔 boolean; var bIsTrue = false;//1.4 未定义 undefinedvar unData;//1.5 null 表示空对象var nullData = null;//1.6 object 表示对象类型var oObj = {   name:&quot;隔壁老王&quot;,   age:88}// 获取变量的类型var type = typeof(oObj);alert(type);// 获取对象的name属性alert(oObj.name);</code></pre><h3 id="4-变量命名规范"><a href="#4-变量命名规范" class="headerlink" title="4. 变量命名规范"></a>4. 变量命名规范</h3><p>1、区分大小写<br>2、第一个字符必须是字母、下划线（_）或者美元符号（$）<br>3、其他字符可以是字母、下划线、美元符或数字</p><h3 id="5-匈牙利命名风格"><a href="#5-匈牙利命名风格" class="headerlink" title="5. 匈牙利命名风格"></a>5. 匈牙利命名风格</h3><p>对象o Object 比如：oDiv<br>数组a Array 比如：aItems<br>字符串s String 比如：sUserName<br>整数i Integer 比如：iItemCount<br>布尔值b Boolean 比如：bIsComplete<br>浮点数f Float 比如：fPrice<br>函数fn Function 比如：fnHandler</p><h2 id="四、函数定义和调用"><a href="#四、函数定义和调用" class="headerlink" title="四、函数定义和调用"></a>四、函数定义和调用</h2><h3 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1. 函数定义"></a>1. 函数定义</h3><p>函数就是可以<strong>重复使用的代码块</strong>, 使用关键字 <strong>function</strong> 定义函数。</p><pre><code class="javascript">&lt;script type=&quot;text/javascript&quot;&gt;    // 函数定义    function fnAlert(){        alert(&#39;hello!&#39;);    }&lt;/script&gt;</code></pre><h3 id="2-函数调用"><a href="#2-函数调用" class="headerlink" title="2. 函数调用"></a>2. 函数调用</h3><p>函数调用就是<strong>函数名加小括号</strong>，比如:函数名(参数[参数可选])</p><pre><code class="javascript">&lt;script type=&quot;text/javascript&quot;&gt;    // 函数定义    function fnAlert(){        alert(&#39;hello!&#39;);    }    // 函数调用    fnAlert();&lt;/script&gt;</code></pre><h3 id="3-定义有参数有返回值的函数"><a href="#3-定义有参数有返回值的函数" class="headerlink" title="3. 定义有参数有返回值的函数"></a>3. 定义有参数有返回值的函数</h3><p>定义函数时，函数如果有参数，<strong>参数放到小括号里面</strong>，函数如果有返回值，返回值通过 <strong>return</strong> 关键字来返回</p><pre><code class="javascript">&lt;script type=&quot;text/javascript&quot;&gt;function fnAdd(iNum01,iNum02){    var iRs = iNum01 + iNum02;    return iRs;    alert(&#39;here!&#39;);}var iCount = fnAdd(3,4);alert(iCount);  //弹出7&lt;/script&gt;</code></pre><p><strong>函数中’return’关键字的作用:</strong><br>1、返回函数中的值<br>2、执行完return函数执行结束</p><h2 id="五、变量作用域"><a href="#五、变量作用域" class="headerlink" title="五、变量作用域"></a>五、变量作用域</h2><h3 id="1-变量作用域的介绍"><a href="#1-变量作用域的介绍" class="headerlink" title="1. 变量作用域的介绍"></a>1. 变量作用域的介绍</h3><p>变量作用域就是变量的使用范围，变量分为:</p><ul><li>局部变量</li><li>全局变量</li></ul><h3 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="2. 局部变量"></a>2. 局部变量</h3><p>局部变量就是在函数内使用的变量，只能在函数内部使用。</p><pre><code class="javascript">&lt;script type=&quot;text/javascript&quot;&gt;    function myalert()    {        // 定义局部变量        var b = 23;        alert(b);    }    myalert(); // 弹出23    alert(b);  // 函数外使用出错&lt;/script&gt;</code></pre><h3 id="3-全局变量"><a href="#3-全局变量" class="headerlink" title="3. 全局变量"></a>3. 全局变量</h3><p>全局变量就是在函数外定义的变量，可以在不同函数内使用。</p><pre><code class="javascript">&lt;script type=&quot;text/javascript&quot;&gt;    // 定义全局变量    var a = 12;    function myalert()    {        // 修改全局变量        a++;    }    myalert();    alert(a);  // 弹出13    &lt;/script&gt;</code></pre><h2 id="六、条件语句"><a href="#六、条件语句" class="headerlink" title="六、条件语句"></a>六、条件语句</h2><h3 id="1-条件语句的介绍"><a href="#1-条件语句的介绍" class="headerlink" title="1. 条件语句的介绍"></a>1. 条件语句的介绍</h3><p>条件语句就是通过条件来控制程序的走向</p><h3 id="2-条件语句语法"><a href="#2-条件语句语法" class="headerlink" title="2. 条件语句语法"></a>2. 条件语句语法</h3><ol><li>if 语句 - 只有当指定条件为 true 时，使用该语句来执行代码</li><li>if…else 语句 - 当条件为 true 时执行代码，当条件为 false 时执行其他代码</li><li>if…else if….else 语句 - 使用该语句来判断多条件，执行条件成立的语句</li></ol><h3 id="3-比较运算符"><a href="#3-比较运算符" class="headerlink" title="3. 比较运算符"></a>3. 比较运算符</h3><p>假如 x = 5, 查看比较后的结果:</p><table><thead><tr><th align="left">比较运算符</th><th align="left">描述</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">==</td><td align="left">等于</td><td align="left">x == 8 为 false</td></tr><tr><td align="left">===</td><td align="left">全等(值和类型)</td><td align="left">x === 5 为 true; x === “5” 为 false</td></tr><tr><td align="left">!=</td><td align="left">不等于</td><td align="left">x != 8 为 true</td></tr><tr><td align="left">&gt;</td><td align="left">大于</td><td align="left">x &gt; 8 为 false</td></tr><tr><td align="left">&lt;</td><td align="left">小于</td><td align="left">x &lt; 8 为 true</td></tr><tr><td align="left">&gt;=</td><td align="left">大于或等于</td><td align="left">x &gt;= 8 为 false</td></tr><tr><td align="left">&lt;=</td><td align="left">小于或等于</td><td align="left">x &lt;= 8 为 true</td></tr></tbody></table><p><strong>比较运算符示例代码:</strong></p><pre><code class="js">var iNum01 = 12;var sNum01 = &#39;12&#39;;if(iNum01==12){    alert(&#39;相等！&#39;);}else{    alert(&#39;不相等！&#39;)}// &quot;==&quot; 符号默认会将符号两边的变量转换成数字再进行对比，这个叫做隐式转换if(sNum01==12){    alert(&#39;相等！&#39;);}else{    alert(&#39;不相等！&#39;)}// &quot;===&quot; 符号不会转换符号两边的数据类型if(sNum01===12){    alert(&#39;相等！&#39;);}else{    alert(&#39;不相等！&#39;)}// 多条件判断var sFruit = &quot;苹果&quot;;if (sFruit == &quot;苹果&quot;) {    alert(&quot;您选择的水果是苹果&quot;);} else if (sFruit == &quot;鸭梨&quot;) {    alert(&quot;您选择的水果是鸭梨&quot;);} else {    alert(&quot;对不起，您选择的水果不存在!&quot;)}</code></pre><h3 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4. 逻辑运算符"></a>4. 逻辑运算符</h3><p>假如 x=6, y=3, 查看比较后的结果:</p><table><thead><tr><th align="left">比较运算符</th><th align="left">描述</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">&amp;&amp;</td><td align="left">and</td><td align="left">(x &lt; 10 &amp;&amp; y &gt; 1) 为 true</td></tr><tr><td align="left">||</td><td align="left">or</td><td align="left">(x==5 || y==5) 为 false</td></tr><tr><td align="left">!</td><td align="left">not</td><td align="left">!(x==y) 为 true</td></tr></tbody></table><p><strong>逻辑运算符示例代码:</strong></p><pre><code class="js">var x = 6;var y = 3;if(x &lt; 10 &amp;&amp; y &gt; 1){    alert(&#39;都大于&#39;);}else{    alert(&#39;至少有一个不大于&#39;);}if(x &gt; 5 || y &gt; 7 ){    alert(&#39;至少有一个大于&#39;);}else{    alert(&#39;都不大于&#39;);}if(!(x == y)){    alert(&#39;等于&#39;)}else{    alert(&#39;不等于&#39;)}</code></pre><h2 id="七、获取标签元素"><a href="#七、获取标签元素" class="headerlink" title="七、获取标签元素"></a>七、获取标签元素</h2><h3 id="1-获取标签元素"><a href="#1-获取标签元素" class="headerlink" title="1. 获取标签元素"></a>1. 获取标签元素</h3><p>可以使用<strong>内置对象 document</strong> 上的 <strong>getElementById 方法</strong>来获取页面上设置了id属性的标签元素，获取到的是一个html对象，然后将它赋值给一个变量，比如：</p><pre><code class="js">&lt;script type=&quot;text/javascript&quot;&gt;    var oDiv = document.getElementById(&#39;div1&#39;);    alert(oDiv);&lt;/script&gt;&lt;div id=&quot;div1&quot;&gt;这是一个div元素&lt;/div&gt;</code></pre><p><strong>说明:</strong><br>上面的代码，如果把javascript写在元素的上面，就会出错，因为页面上从上往下加载执行的，javascript去页面上获取元素div1的时候，元素div1还没有加载。</p><p><strong>解决方法有两种:</strong></p><p>第一种方法：将javascript放到页面最下边</p><pre><code class="js">&lt;div id=&quot;div1&quot;&gt;这是一个div元素&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var oDiv = document.getElementById(&#39;div1&#39;);    alert(oDiv);&lt;/script&gt;</code></pre><p>第二种方法：设置页面加载完成执行的函数，在执行函数里面获取标签元素。</p><pre><code class="js">&lt;script type=&quot;text/javascript&quot;&gt;    window.onload = function(){        var oDiv = document.getElementById(&#39;div1&#39;);    }&lt;/script&gt;</code></pre><p><strong>说明:</strong><br>onload是页面所有元素加载完成的事件，给onload设置函数时，当事件触发就会执行设置的函数。</p><h2 id="八、操作标签元素属性"><a href="#八、操作标签元素属性" class="headerlink" title="八、操作标签元素属性"></a>八、操作标签元素属性</h2><h3 id="1-属性的操作"><a href="#1-属性的操作" class="headerlink" title="1. 属性的操作"></a>1. 属性的操作</h3><p>首先获取的页面标签元素，然后就可以对页面标签元素的属性进行操作，属性的操作包括:</p><ul><li>属性的读取</li><li>属性的设置</li></ul><p><strong>属性名在js中的写法</strong></p><ol><li>html的属性和js里面属性大多数写法一样，但是“class” 属性写成 “className”</li><li>“style” 属性里面的属性，有横杠的改成驼峰式，比如：“font-size”，改成”style.fontSize”</li></ol><pre><code class="html">&lt;style&gt;    .sty01{        font-size:20px;        color:red;    }    .sty02{        font-size:30px;        color:pink;        text-decoration:none;    }&lt;/style&gt;&lt;script type=&quot;text/javascript&quot;&gt;    window.onload = function(){        var oInput = document.getElementById(&#39;input1&#39;);        var oA = document.getElementById(&#39;link1&#39;);        // 读取属性值        var sValue = oInput.value;        var sType = oInput.type;        var sName = oInput.name;        var sLinks = oA.href;        // 操作class属性,需要写成“className”        oA.className = &#39;sty02&#39;;        // 写(设置)属性        oA.style.color = &#39;red&#39;;        oA.style.fontSize = sValue;    }&lt;/script&gt;&lt;input type=&quot;text&quot; name=&quot;setsize&quot; id=&quot;input1&quot; value=&quot;20px&quot;&gt;&lt;a href=&quot;#&quot; id=&quot;link01&quot; class=&quot;sty01&quot;&gt;这是一个链接&lt;/a&gt;</code></pre><h3 id="2-innerHTML"><a href="#2-innerHTML" class="headerlink" title="2. innerHTML"></a>2. innerHTML</h3><p>innerHTML可以读取或者设置标签包裹的内容</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;    window.onload = function(){        var oDiv = document.getElementById(&#39;div1&#39;);        //读取        var sTxt = oDiv.innerHTML;        alert(sTxt);        //写入        oDiv.innerHTML = &#39;&lt;a href=&quot;http://www.itcast.cn&quot;&gt;传智播客&lt;a/&gt;&#39;;    }&lt;/script&gt;&lt;div id=&quot;div1&quot;&gt;这是一个div元素&lt;/div&gt;</code></pre><h2 id="九、数组及操作方法"><a href="#九、数组及操作方法" class="headerlink" title="九、数组及操作方法"></a>九、数组及操作方法</h2><h3 id="1-数组的介绍"><a href="#1-数组的介绍" class="headerlink" title="1. 数组的介绍"></a>1. 数组的介绍</h3><p>数组就是一组数据的集合，javascript 中，数组里面的数据可以是不同类型的数据，好比 python 里面的列表。</p><ul><li>数组的定义使用一对中括号</li><li>获取数组的长度使用length属性</li><li>从数组最后添加元素使用push方法</li><li>从数组最后删除元素使用pop方法</li><li>根据下标添加和删除元素使用splice方法</li></ul><h3 id="2-数组的定义"><a href="#2-数组的定义" class="headerlink" title="2. 数组的定义"></a>2. 数组的定义</h3><pre><code class="js">// 实例化对象方式创建var aList = new Array(1,2,3);// 字面量方式创建，推荐使用var aList2 = [1,2,3,&#39;asd&#39;];</code></pre><h3 id="3-多维数组"><a href="#3-多维数组" class="headerlink" title="3. 多维数组"></a>3. 多维数组</h3><p>多维数组指的是数组的成员也是数组，把这样的数组叫做多维数组。</p><pre><code class="js">var aList = [[1,2,3],[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]];</code></pre><h3 id="4-数组的操作"><a href="#4-数组的操作" class="headerlink" title="4. 数组的操作"></a>4. 数组的操作</h3><p>1、 获取数组的长度</p><pre><code class="js">var aList = [1,2,3,4];alert(aList.length); // 弹出4</code></pre><p>2、 根据下标取值</p><pre><code class="js">var aList = [1,2,3,4];alert(aList[0]); // 弹出1</code></pre><p>3、 从数组最后添加和删除数据</p><pre><code class="js">var aList = [1,2,3,4];aList.push(5);alert(aList); //弹出1,2,3,4,5aList.pop();alert(aList); // 弹出1,2,3,4</code></pre><p>4、根据下标添加和删除元素</p><p>arr.splice(start,num,element1,…..,elementN)</p><p>参数解析：</p><ol><li>start：必需，开始删除的索引。</li><li>num：可选，删除数组元素的个数。</li><li>elementN：可选，在start索引位置要插入的新元素。</li></ol><p>此方法会删除从start索引开始的num个元素，并将elementN参数插入到start索引位置。</p><pre><code class="js">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];colors.splice(0,1);  //删除第一项alert(colors);  //green,bluecolors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;);  //从第一个索引位置插入两项数据alert(colors);  //green,yellow,organge,bluecolors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;);  //删除一项，插入两项数据alert(colors);  //green,red,purple,orange,blue</code></pre><h2 id="十、循环语句"><a href="#十、循环语句" class="headerlink" title="十、循环语句"></a>十、循环语句</h2><h3 id="1-循环语句的介绍"><a href="#1-循环语句的介绍" class="headerlink" title="1. 循环语句的介绍"></a>1. 循环语句的介绍</h3><p>循环语句就是让一部分代码重复执行，javascript中常用的循环语句有:</p><ul><li>for</li><li>while</li><li>do-while</li></ul><h3 id="2-for循环"><a href="#2-for循环" class="headerlink" title="2. for循环"></a>2. for循环</h3><pre><code class="js">var array = [1, 4, 5];for(var index = 0; index &lt; array.length; index++){    var result = array[index];    alert(result);}</code></pre><h3 id="3-while循环"><a href="#3-while循环" class="headerlink" title="3. while循环"></a>3. while循环</h3><pre><code class="js">var array = [1, 4, 5];        var index = 0;while (index &lt; array.length) {    var result = array[index];    alert(result);    index++;}</code></pre><p><strong>说明:</strong></p><p>当条件成立的时候, while语句会循环执行</p><h3 id="4-do-while循环"><a href="#4-do-while循环" class="headerlink" title="4. do-while循环"></a>4. do-while循环</h3><pre><code class="js">var array = [1, 4, 5];var index = 0;do {    var result = array[index];    alert(result);    index++;} while (index &lt; array.length);</code></pre><p><strong>说明:</strong></p><p>当条件不成立的时候do语句也会执行一次</p><h2 id="十一、字符串拼接"><a href="#十一、字符串拼接" class="headerlink" title="十一、字符串拼接"></a>十一、字符串拼接</h2><h3 id="1、字符串拼接"><a href="#1、字符串拼接" class="headerlink" title="1、字符串拼接"></a>1、字符串拼接</h3><p>字符串拼接使用: <strong>“+”</strong> 运算符</p><pre><code class="js">var iNum1 = 10;var fNum2 = 11.1;var sStr = &#39;abc&#39;;result = iNum1 + fNum2;alert(result); // 弹出21.1result = fNum2 + sStr;alert(result); // 弹出11.1abc</code></pre><p><strong>说明</strong></p><p>数字和字符串拼接会自动进行类型转换(隐式类型转换)，把数字类型转成字符串类型进行拼接</p><h2 id="十二、定时器"><a href="#十二、定时器" class="headerlink" title="十二、定时器"></a>十二、定时器</h2><h3 id="1-定时器的介绍"><a href="#1-定时器的介绍" class="headerlink" title="1. 定时器的介绍"></a>1. 定时器的介绍</h3><p>定时器就是在一段特定的时间后执行某段程序代码。</p><ul><li>定时器的创建<ul><li>只执行一次函数的定时器, 对应的代码是setTimeout函数</li><li>反复执行函数的定时器, 对应的代码是setInterval函数</li></ul></li><li>清除定时器<ul><li>清除只执行一次函数的定时器, 对应的代码是clearTimeout函数</li><li>清除清除反复执行的定时器, 对应的代码是clearInterval函数</li></ul></li></ul><h3 id="2-定时器的使用："><a href="#2-定时器的使用：" class="headerlink" title="2. 定时器的使用："></a>2. 定时器的使用：</h3><p>js 定时器有两种创建方式：</p><ol><li>setTimeout(func[, delay, param1, param2, …]) ：以指定的时间间隔（以毫秒计）调用一次函数的定时器</li><li>setInterval(func[, delay, param1, param2, …]) ：以指定的时间间隔（以毫秒计）重复调用一个函数的定时器</li></ol><p><strong>setTimeout函数的参数说明:</strong></p><ul><li>第一个参数 func , 表示定时器要执行的函数名</li><li>第二个参数 delay, 表示时间间隔，默认是0，单位是毫秒</li><li>第三个参数 param1, 表示定时器执行函数的第一个参数，一次类推传入多个执行函数对应的参数。</li></ul><pre><code class="js">&lt;script&gt;     function hello(){         alert(&#39;hello&#39;);     }     // 执行一次函数的定时器    setTimeout(hello, 500);&lt;/script&gt;</code></pre><p><strong>setInterval函数的参数说明:</strong></p><ul><li>第一个参数 func , 表示定时器要执行的函数名</li><li>第二个参数 delay, 表示时间间隔，默认是0，单位是毫秒</li><li>第三个参数 param1, 表示定时器执行函数的第一个参数，一次类推传入多个执行函数对应的参数。</li></ul><pre><code class="js">&lt;script&gt;     function hello(){         alert(&#39;hello&#39;);     }     // 重复执行函数的定时器    setInterval(hello, 1000);&lt;/script&gt;</code></pre><h3 id="2-清除定时器"><a href="#2-清除定时器" class="headerlink" title="2. 清除定时器"></a>2. 清除定时器</h3><p>js 清除定时器分别是:</p><ul><li>clearTimeout(timeoutID) 清除只执行一次的定时器(setTimeout函数)</li><li>clearInterval(timeoutID) 清除反复执行的定时器(setInterval函数)</li></ul><p><strong>clearTimeout函数的参数说明:</strong></p><ul><li>timeoutID 为调用 setTimeout 函数时所获得的返回值，使用该返回标识符作为参数，可以取消该 setTimeout 所设定的定时执行操作。</li></ul><pre><code class="js">&lt;script&gt;    function hello(){        alert(&#39;hello&#39;);        // 清除只执行一次的定时器        clearTimeout(t1)    }    // 执行一次函数的定时器    t1 = setTimeout(hello, 500);&lt;/script&gt;</code></pre><p><strong>clearInterval函数的参数说明:</strong></p><ul><li>timeoutID 为调用 setInterval 函数时所获得的返回值，使用该返回标识符作为参数，可以取消该 setInterval 所设定的定时执行操作。</li></ul><pre><code class="js">&lt;script&gt;     function hello(){         alert(&#39;hello&#39;);     }     // 重复执行函数的定时器    var t1 = setInterval(hello, 1000);    function stop(){        // 清除反复执行的定时器        clearInterval(t1);     }  &lt;/script&gt; &lt;input type=&quot;button&quot; value=&quot;停止&quot; onclick=&quot;stop();&quot;&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JavaScript&quot;&gt;&lt;a href=&quot;#JavaScript&quot; class=&quot;headerlink&quot; title=&quot;JavaScript&quot;&gt;&lt;/a&gt;JavaScript&lt;/h1&gt;&lt;h2 id=&quot;一、JavaScript的介绍&quot;&gt;&lt;a href=&quot;#一、JavaScript的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、JavaScript的介绍&quot;&gt;&lt;/a&gt;一、JavaScript的介绍&lt;/h2&gt;&lt;h3 id=&quot;1-JavaScript的定义&quot;&gt;&lt;a href=&quot;#1-JavaScript的定义&quot; class=&quot;headerlink&quot; title=&quot;1. JavaScript的定义&quot;&gt;&lt;/a&gt;1. JavaScript的定义&lt;/h3&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://caijinbo.work/categories/python/"/>
    
    
      <category term="python" scheme="https://caijinbo.work/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python高级05-HTML+CSS基础</title>
    <link href="https://caijinbo.work/2020/08/21/2020-08-22-python%E9%AB%98%E7%BA%A705-HTML+CSS%E5%9F%BA%E7%A1%80/"/>
    <id>https://caijinbo.work/2020/08/21/2020-08-22-python%E9%AB%98%E7%BA%A705-HTML+CSS%E5%9F%BA%E7%A1%80/</id>
    <published>2020-08-21T16:00:00.000Z</published>
    <updated>2020-11-23T10:13:35.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML-CSS基础"><a href="#HTML-CSS基础" class="headerlink" title="HTML+CSS基础"></a>HTML+CSS基础</h1><h2 id="一、html-的介绍"><a href="#一、html-的介绍" class="headerlink" title="一、html 的介绍"></a>一、html 的介绍</h2><h3 id="1-html的定义"><a href="#1-html的定义" class="headerlink" title="1. html的定义"></a>1. html的定义</h3><a id="more"></a><p>HTML 的全称为：HyperText Mark-up Language, 指的是超文本标记语言。 标记：就是标签, <code>&lt;标签名称&gt; &lt;/标签名称&gt;</code>, 比如: <code>&lt;html&gt;&lt;/html&gt;、&lt;h1&gt;&lt;/h1&gt;</code> 等，标签大多数都是成对出现的。</p><p>所谓超文本，有两层含义:</p><ol><li>因为网页中还可以图片、视频、音频等内容(超越文本限制)</li><li>它还可以在网页中跳转到另一个网页，与世界各地主机的网页链接(超链接文本)</li></ol><h3 id="2-html的作用"><a href="#2-html的作用" class="headerlink" title="2. html的作用"></a>2. html的作用</h3><p>html是用来开发网页的，它是开发网页的语言。</p><h2 id="二、html-的基本结构"><a href="#二、html-的基本结构" class="headerlink" title="二、html 的基本结构"></a>二、html 的基本结构</h2><h3 id="1-结构代码"><a href="#1-结构代码" class="headerlink" title="1. 结构代码"></a>1. 结构代码</h3><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;                    &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;网页标题&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;          网页显示内容    &lt;/body&gt;&lt;/html&gt;</code></pre><ol><li>第一行<code>&lt;!DOCTYPE html&gt;</code>是文档声明, 用来指定页面所使用的html的版本, 这里声明的是一个html5的文档。</li><li><code>&lt;html&gt;...&lt;/html&gt;</code>标签是开发人员在告诉浏览器，整个网页是从<code>&lt;html&gt;</code>这里开始的，到<code>&lt;/html&gt;</code>结束,也就是html文档的开始和结束标签。</li><li><code>&lt;head&gt;...&lt;/head&gt;</code>标签用于定义文档的头部,是负责对网页进行设置标题、编码格式以及引入css和js文件的。</li><li><code>&lt;body&gt;...&lt;/body&gt;</code>标签是编写网页上显示的内容。</li></ol><h3 id="2-浏览网页文件"><a href="#2-浏览网页文件" class="headerlink" title="2. 浏览网页文件"></a>2. 浏览网页文件</h3><p>网页文件的后缀是<strong>.html</strong>或者<strong>.htm</strong>, <strong>一个html文件就是一个网页</strong>，html文件用编辑器打开显示的是文本，可以用文本的方式编辑它，如果用浏览器打开，浏览器会按照标签描述内容将文件渲染成网页。</p><p>目前常用的编辑网页工具有vscode+chrome。</p><h2 id="三、初始常用的-html-标签"><a href="#三、初始常用的-html-标签" class="headerlink" title="三、初始常用的 html 标签"></a>三、初始常用的 html 标签</h2><h3 id="1-常用的-html-标签"><a href="#1-常用的-html-标签" class="headerlink" title="1. 常用的 html 标签"></a>1. 常用的 html 标签</h3><pre><code class="html">&lt;!-- 1、成对出现的标签：--&gt;&lt;h1&gt;h1标题&lt;/h1&gt;&lt;div&gt;这是一个div标签&lt;/div&gt;&lt;p&gt;这个一个段落标签&lt;/p&gt;&lt;!-- 2、单个出现的标签： --&gt;&lt;br&gt;&lt;img src=&quot;images/pic.jpg&quot; alt=&quot;图片&quot;&gt;&lt;hr&gt;&lt;!-- 3、带属性的标签，如src、alt 和 href等都是属性 --&gt;&lt;img src=&quot;images/pic.jpg&quot; alt=&quot;图片&quot;&gt;&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度网&lt;/a&gt;&lt;!-- 4、标签的嵌套 --&gt;&lt;div&gt;    &lt;img src=&quot;images/pic.jpg&quot; alt=&quot;图片&quot;&gt;    &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度网&lt;/a&gt;&lt;/div&gt;</code></pre><p><strong>提示:</strong></p><ol><li>标签不区分大小写，但是推荐使用小写。</li><li>根据标签的书写形式，标签分为双标签(闭合标签)和单标签(空标签)<br>2.1 双标签是指由开始标签和结束标签组成的一对标签，这种标签允许嵌套和承载内容，比如: div标签<br>2.2 单标签是一个标签组成，没有标签内容， 比如: img标签</li></ol><h2 id="四、资源路径"><a href="#四、资源路径" class="headerlink" title="四、资源路径"></a>四、资源路径</h2><h3 id="1-相对路径"><a href="#1-相对路径" class="headerlink" title="1. 相对路径"></a>1. 相对路径</h3><blockquote><p>从当前操作 html 的文档所在目录算起的路径叫做相对路径</p></blockquote><p><strong>示例代码:</strong></p><pre><code class="html">&lt;!-- 相对路径方式1 --&gt;&lt;img src=&quot;./images/logo.png&quot;&gt;&lt;!-- 相对路径方式2 --&gt;&lt;img src=&quot;images/logo.png&quot;&gt;</code></pre><h3 id="2-绝对路径"><a href="#2-绝对路径" class="headerlink" title="2. 绝对路径"></a>2. 绝对路径</h3><blockquote><p>从根目录算起的路径叫做绝对路径，Windows 的根目录是指定的盘符，mac OS 和Linux 是/</p></blockquote><p><strong>示例代码:</strong></p><pre><code class="html">&lt;!-- 绝对路径 --&gt;&lt;img src=&quot;/Users/apple/Desktop/demo/hello/images/logo.png&quot;&gt;&lt;img src=&quot;C:\demo\images\001.jpg&quot;&gt;</code></pre><p><strong>提示:</strong></p><p>一般都会使用相对路径，绝对路径的操作在其它电脑上打开会有可能出现资源文件找不到的问题</p><h2 id="五、列表标签"><a href="#五、列表标签" class="headerlink" title="五、列表标签"></a>五、列表标签</h2><h3 id="1-列表标签的种类"><a href="#1-列表标签的种类" class="headerlink" title="1. 列表标签的种类"></a>1. 列表标签的种类</h3><ul><li>无序列表标签(ul标签)</li><li>有序列表标签(ol标签)</li></ul><h3 id="2-无序列表"><a href="#2-无序列表" class="headerlink" title="2. 无序列表"></a>2. 无序列表</h3><pre><code class="html">&lt;!-- ul标签定义无序列表 --&gt;&lt;ul&gt;    &lt;!-- li标签定义列表项目 --&gt;    &lt;li&gt;列表标题一&lt;/li&gt;    &lt;li&gt;列表标题二&lt;/li&gt;    &lt;li&gt;列表标题三&lt;/li&gt;&lt;/ul&gt;</code></pre><h3 id="3-有序列表"><a href="#3-有序列表" class="headerlink" title="3. 有序列表"></a>3. 有序列表</h3><pre><code class="html">&lt;!-- ol标签定义有序列表 --&gt;&lt;ol&gt;    &lt;!-- li标签定义列表项目 --&gt;    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;列表标题一&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;列表标题二&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;列表标题三&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;</code></pre><h2 id="六、表格标签"><a href="#六、表格标签" class="headerlink" title="六、表格标签"></a>六、表格标签</h2><h3 id="1-表格的结构"><a href="#1-表格的结构" class="headerlink" title="1. 表格的结构"></a>1. 表格的结构</h3><blockquote><p>表格是由行和列组成，好比一个excel文件</p></blockquote><h3 id="2-表格标签"><a href="#2-表格标签" class="headerlink" title="2. 表格标签"></a>2. 表格标签</h3><ul><li><table>标签：表示一个表格</li></ul><p><strong>示例代码:</strong></p><pre><code class="html">&lt;table&gt;    &lt;tr&gt;        &lt;th&gt;姓名&lt;/th&gt;        &lt;th&gt;年龄&lt;/th&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;张三&lt;/td&gt;        &lt;td&gt;18&lt;/td&gt;     &lt;/tr&gt;&lt;/table&gt;</code></pre><p><strong>表格边线合并:</strong></p><p>border-collapse 设置表格的边线合并，如：border-collapse:collapse;</p><h2 id="七、表单标签"><a href="#七、表单标签" class="headerlink" title="七、表单标签"></a>七、表单标签</h2><h3 id="1-表单的介绍"><a href="#1-表单的介绍" class="headerlink" title="1. 表单的介绍"></a>1. 表单的介绍</h3><blockquote><p>表单用于搜集不同类型的用户输入(用户输入的数据)，然后可以把用户数据提交到web服务器 。</p><ul><li>表单标签是<code>&lt;form&gt;</code>标签</li><li>常用的表单元素标签有: <code>&lt;label&gt;</code>、<code>&lt;input&gt;</code>、 <code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code> 等标签</li></ul></blockquote><h3 id="2-表单相关标签的使用"><a href="#2-表单相关标签的使用" class="headerlink" title="2. 表单相关标签的使用"></a>2. 表单相关标签的使用</h3><ol><li><code>&lt;form&gt;</code>标签 表示表单标签，定义整体的表单区域</li><li><code>&lt;label&gt;</code>标签 表示表单元素的文字标注标签，定义文字标注</li><li><code>&lt;input&gt;</code>标签 表示表单元素的用户输入标签，定义不同类型的用户输入数据方式<ul><li>type属性<ul><li>type=”text” 定义单行文本输入框</li><li>type=”password” 定义密码输入框</li><li>type=”radio” 定义单选框</li><li>type=”checkbox” 定义复选框</li><li>type=”file” 定义上传文件</li><li>type=”submit” 定义提交按钮</li><li>type=”reset” 定义重置按钮</li><li>type=”button” 定义一个普通按钮</li></ul></li></ul></li><li><code>&lt;textarea&gt;</code>标签 表示表单元素的多行文本输入框标签 定义多行文本输入框</li><li><code>&lt;select&gt;</code>标签 表示表单元素的下拉列表标签 定义下拉列表<ul><li><code>&lt;option&gt;</code>标签 与<code>&lt;select&gt;</code>标签配合，定义下拉列表中的选项</li></ul></li></ol><p><strong>示例代码:</strong></p><pre><code class="html">&lt;form&gt;    &lt;p&gt;        &lt;label&gt;姓名：&lt;/label&gt;&lt;input type=&quot;text&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;密码：&lt;/label&gt;&lt;input type=&quot;password&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;性别：&lt;/label&gt;        &lt;input type=&quot;radio&quot;&gt; 男        &lt;input type=&quot;radio&quot;&gt; 女    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;爱好：&lt;/label&gt;        &lt;input type=&quot;checkbox&quot;&gt; 唱歌        &lt;input type=&quot;checkbox&quot;&gt; 跑步        &lt;input type=&quot;checkbox&quot;&gt; 游泳    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;照片：&lt;/label&gt;        &lt;input type=&quot;file&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;个人描述：&lt;/label&gt;        &lt;textarea&gt;&lt;/textarea&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;籍贯：&lt;/label&gt;        &lt;select&gt;            &lt;option&gt;北京&lt;/option&gt;            &lt;option&gt;上海&lt;/option&gt;            &lt;option&gt;广州&lt;/option&gt;            &lt;option&gt;深圳&lt;/option&gt;        &lt;/select&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;        &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt;    &lt;/p&gt;&lt;/form&gt;</code></pre><h2 id="八、表单提交"><a href="#八、表单提交" class="headerlink" title="八、表单提交"></a>八、表单提交</h2><h3 id="1-表单属性设置"><a href="#1-表单属性设置" class="headerlink" title="1. 表单属性设置"></a>1. 表单属性设置</h3><p><code>&lt;form&gt;</code>标签 表示表单标签，定义整体的表单区域</p><ul><li>action属性 设置表单数据提交地址</li><li>method属性 设置表单提交的方式，一般有“GET”方式和“POST”方式, 不区分大小写</li></ul><h3 id="2-表单元素属性设置"><a href="#2-表单元素属性设置" class="headerlink" title="2. 表单元素属性设置"></a>2. 表单元素属性设置</h3><ul><li>name属性 设置表单元素的名称，该名称是提交数据时的参数名</li><li>value属性 设置表单元素的值，该值是提交数据时参数名所对应的值</li></ul><h3 id="3-示例代码"><a href="#3-示例代码" class="headerlink" title="3. 示例代码"></a>3. 示例代码</h3><pre><code class="html"> &lt;form action=&quot;https://www.baidu.com&quot; method=&quot;GET&quot;&gt;    &lt;p&gt;        &lt;label&gt;姓名：&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;11&quot; /&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;密码：&lt;/label&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;性别：&lt;/label&gt;        &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; /&gt; 男        &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; /&gt; 女    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;爱好：&lt;/label&gt;        &lt;input type=&quot;checkbox&quot; name=&quot;like&quot; value=&quot;sing&quot; /&gt; 唱歌        &lt;input type=&quot;checkbox&quot; name=&quot;like&quot; value=&quot;run&quot; /&gt; 跑步        &lt;input type=&quot;checkbox&quot; name=&quot;like&quot; value=&quot;swiming&quot; /&gt; 游泳    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;照片：&lt;/label&gt;        &lt;input type=&quot;file&quot; name=&quot;person_pic&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;个人描述：&lt;/label&gt;        &lt;textarea name=&quot;about&quot;&gt;&lt;/textarea&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;籍贯：&lt;/label&gt;        &lt;select name=&quot;site&quot;&gt;            &lt;option value=&quot;0&quot;&gt;北京&lt;/option&gt;            &lt;option value=&quot;1&quot;&gt;上海&lt;/option&gt;            &lt;option value=&quot;2&quot;&gt;广州&lt;/option&gt;            &lt;option value=&quot;3&quot;&gt;深圳&lt;/option&gt;        &lt;/select&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;input type=&quot;submit&quot; name=&quot;&quot; value=&quot;提交&quot;&gt;        &lt;input type=&quot;reset&quot; name=&quot;&quot; value=&quot;重置&quot;&gt;    &lt;/p&gt;&lt;/form&gt;</code></pre><h2 id="九、css-的介绍"><a href="#九、css-的介绍" class="headerlink" title="九、css 的介绍"></a>九、css 的介绍</h2><h3 id="1-css-的定义"><a href="#1-css-的定义" class="headerlink" title="1. css 的定义"></a>1. css 的定义</h3><blockquote><p>css(Cascading Style Sheet)层叠样式表，它是用来美化页面的一种语言。</p></blockquote><h3 id="2-css-的作用"><a href="#2-css-的作用" class="headerlink" title="2. css 的作用"></a>2. css 的作用</h3><ol><li>美化界面, 比如: 设置标签文字大小、颜色、字体加粗等样式。</li><li>控制页面布局, 比如: 设置浮动、定位等样式。</li></ol><h3 id="3-css-的基本语法"><a href="#3-css-的基本语法" class="headerlink" title="3. css 的基本语法"></a>3. css 的基本语法</h3><p>选择器{</p><p>样式规则</p><p>}</p><p>样式规则：</p><p>属性名1：属性值1;</p><p>属性名2：属性值2;</p><p>属性名3：属性值3;</p><p>…</p><p>选择器:<strong>是用来选择标签的，选出来以后给标签加样式。</strong></p><p><strong>代码示例:</strong></p><pre><code class="html">div{     width:100px;     height:100px;     background:gold; }</code></pre><p><strong>说明</strong></p><p>css 是由两个主要的部分构成：<strong>选择器和一条或多条样式规则</strong>，注意:<strong>样式规则需要放到大括号里面。</strong></p><h2 id="十、css-的引入方式"><a href="#十、css-的引入方式" class="headerlink" title="十、css 的引入方式"></a>十、css 的引入方式</h2><p><strong>css的三种引入方式</strong></p><ol><li><p>行内式</p></li><li><p>内嵌式（内部样式）</p></li><li><p>外链式</p><p>说明：</p><p>外链式是在公司开发的时候会使用，最能体现 div+css 的标签内容与显示样式分离的思想， 也最易改版维护，代码看起来也是最美观的一种。</p></li></ol><h3 id="1-行内式"><a href="#1-行内式" class="headerlink" title="1. 行内式"></a>1. 行内式</h3><blockquote><p>直接在标签的 style 属性中添加 css 样式</p></blockquote><p><strong>示例代码:</strong></p><pre><code class="html">&lt;div style=&quot;width:100px; height:100px; background:red &quot;&gt;hello&lt;/div&gt;</code></pre><p>优点：方便、直观。 缺点：缺乏可重用性。</p><h3 id="2-内嵌式（内部样式）"><a href="#2-内嵌式（内部样式）" class="headerlink" title="2. 内嵌式（内部样式）"></a>2. 内嵌式（内部样式）</h3><blockquote><p>在<code>&lt;head&gt;</code>标签内加入<code>&lt;style&gt;</code>标签，在<code>&lt;style&gt;</code>标签中编写css代码。</p></blockquote><p><strong>示例代码:</strong></p><pre><code class="html">&lt;head&gt;   &lt;style type=&quot;text/css&quot;&gt;      h3{         color:red;      }   &lt;/style&gt;&lt;/head&gt;</code></pre><p>优点：在同一个页面内部便于复用和维护。 缺点：在多个页面之间的可重用性不够高。</p><h3 id="3-外链式"><a href="#3-外链式" class="headerlink" title="3. 外链式"></a>3. 外链式</h3><blockquote><p>将css代码写在一个单独的.css文件中，在<code>&lt;head&gt;</code>标签中使用<code>&lt;link&gt;</code>标签直接引入该文件到页面中。</p></blockquote><p><strong>示例代码:</strong></p><pre><code class="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/main.css&quot;&gt;</code></pre><p>优点：使得css样式与html页面分离，便于整个页面系统的规划和维护，可重用性高。 缺点：css代码由于分离到单独的css文件，容易出现css代码过于集中，若维护不当则极容易造成混乱。</p><h3 id="4-css引入方式选择"><a href="#4-css引入方式选择" class="headerlink" title="4. css引入方式选择"></a>4. css引入方式选择</h3><ol><li>行内式几乎不用</li><li>内嵌式在学习css样式的阶段使用</li><li>外链式在公司开发的阶段使用，可以对 css 样式和 html 页面分别进行开发。</li></ol><h2 id="十一、css-选择器"><a href="#十一、css-选择器" class="headerlink" title="十一、css 选择器"></a>十一、css 选择器</h2><h3 id="1-css-选择器的定义"><a href="#1-css-选择器的定义" class="headerlink" title="1. css 选择器的定义"></a>1. css 选择器的定义</h3><p>css 选择器是用来选择标签的，选出来以后给标签加样式。</p><h3 id="2-css-选择器的种类"><a href="#2-css-选择器的种类" class="headerlink" title="2. css 选择器的种类"></a>2. css 选择器的种类</h3><ol><li>标签选择器</li><li>类选择器</li><li>层级选择器(后代选择器)</li><li>id选择器</li><li>组选择器</li><li>伪类选择器</li></ol><h3 id="3-标签选择器"><a href="#3-标签选择器" class="headerlink" title="3. 标签选择器"></a>3. 标签选择器</h3><p>根据标签来选择标签，<strong>以标签开头</strong>，此种选择器影响范围大，一般用来做一些通用设置。</p><p><strong>示例代码</strong></p><pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;    p{        color: red;    }&lt;/style&gt;&lt;div&gt;hello&lt;/div&gt;&lt;p&gt;hello&lt;/p&gt;</code></pre><h3 id="4-类选择器"><a href="#4-类选择器" class="headerlink" title="4. 类选择器"></a>4. 类选择器</h3><p>根据类名来选择标签，<strong>以 . 开头</strong>, 一个类选择器可应用于多个标签上，一个标签上也可以使用多个类选择器，多个类选择器需要使用空格分割，应用灵活，可复用，是css中应用最多的一种选择器。</p><p><strong>示例代码</strong></p><pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;    .blue{color:blue}    .big{font-size:20px}    .box{width:100px;height:100px;background:gold} &lt;/style&gt;&lt;div class=&quot;blue&quot;&gt;这是一个div&lt;/div&gt;&lt;h3 class=&quot;blue big box&quot;&gt;这是一个标题&lt;/h3&gt;&lt;p class=&quot;blue box&quot;&gt;这是一个段落&lt;/p&gt;</code></pre><h3 id="5-层级选择器-后代选择器"><a href="#5-层级选择器-后代选择器" class="headerlink" title="5. 层级选择器(后代选择器)"></a>5. 层级选择器(后代选择器)</h3><p>根据层级关系选择后代标签，<strong>以选择器1 选择器2开头</strong>，主要应用在标签嵌套的结构中，减少命名。</p><p><strong>示例代码</strong></p><pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;    div p{        color: red;    }    .con{width:300px;height:80px;background:green}    .con span{color:red}    .con .pink{color:pink}    .con .gold{color:gold}    &lt;/style&gt;&lt;div&gt;    &lt;p&gt;hello&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;con&quot;&gt;    &lt;span&gt;哈哈&lt;/span&gt;    &lt;a href=&quot;#&quot; class=&quot;pink&quot;&gt;百度&lt;/a&gt;    &lt;a href=&quot;#&quot; class=&quot;gold&quot;&gt;谷歌&lt;/a&gt;&lt;/div&gt;&lt;span&gt;你好&lt;/span&gt;&lt;a href=&quot;#&quot; class=&quot;pink&quot;&gt;新浪&lt;/a&gt;</code></pre><p><strong>注意点: 这个层级关系不一定是父子关系，也有可能是祖孙关系，只要有后代关系都适用于这个层级选择器</strong></p><h3 id="6-id选择器"><a href="#6-id选择器" class="headerlink" title="6. id选择器"></a>6. id选择器</h3><p>根据id选择标签，以#开头, 元素的id名称不能重复，所以id选择器只能对应于页面上一个元素，不能复用，id名一般给程序使用，所以不推荐使用id作为选择器。</p><p><strong>示例代码</strong></p><pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;    #box{color:red} &lt;/style&gt;&lt;p id=&quot;box&quot;&gt;这是一个段落标签&lt;/p&gt;   &lt;!-- 对应以上一条样式，其它元素不允许应用此样式 --&gt;&lt;p&gt;这是第二个段落标签&lt;/p&gt; &lt;!-- 无法应用以上样式，每个标签只能有唯一的id名 --&gt;&lt;p&gt;这是第三个段落标签&lt;/p&gt; &lt;!-- 无法应用以上样式，每个标签只能有唯一的id名  --&gt;</code></pre><p><strong>注意点: 虽然给其它标签设置id=“box”也可以设置样式，但是不推荐这样做，因为id是唯一的，以后js通过id只能获取一个唯一的标签对象。</strong></p><h3 id="7-组选择器"><a href="#7-组选择器" class="headerlink" title="7. 组选择器"></a>7. 组选择器</h3><p>根据组合的选择器选择不同的标签，<strong>以 , 分割开</strong>, 如果有公共的样式设置，可以使用组选择器。</p><p><strong>示例代码</strong></p><pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;    .box1,.box2,.box3{width:100px;height:100px}    .box1{background:red}    .box2{background:pink}    .box2{background:gold}&lt;/style&gt;&lt;div class=&quot;box1&quot;&gt;这是第一个div&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;这是第二个div&lt;/div&gt;&lt;div class=&quot;box3&quot;&gt;这是第三个div&lt;/div&gt;</code></pre><h3 id="8-伪类选择器"><a href="#8-伪类选择器" class="headerlink" title="8. 伪类选择器"></a>8. 伪类选择器</h3><p>用于向选择器添加特殊的效果, <strong>以 : 分割开</strong>, 当用户和网站交互的时候改变显示效果可以使用伪类选择器</p><p><strong>示例代码</strong></p><pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;    .box1{width:100px;height:100px;background:gold;}    .box1:hover{width:300px;}&lt;/style&gt;&lt;div class=&quot;box1&quot;&gt;这是第一个div&lt;/div&gt;</code></pre><h2 id="十二、css-属性"><a href="#十二、css-属性" class="headerlink" title="十二、css 属性"></a>十二、css 属性</h2><h3 id="1-布局常用样式属性"><a href="#1-布局常用样式属性" class="headerlink" title="1. 布局常用样式属性"></a>1. 布局常用样式属性</h3><ul><li>width 设置元素(标签)的宽度，如：width:100px;</li><li>height 设置元素(标签)的高度，如：height:200px;</li><li>background 设置元素背景色或者背景图片，如：background:gold; 设置元素的背景色, background: url(images/logo.png); 设置元素的背景图片。</li><li>border 设置元素四周的边框，如：border:1px solid black; 设置元素四周边框是1像素宽的黑色实线</li><li>以上也可以拆分成四个边的写法，分别设置四个边的：</li><li>border-top 设置顶边边框，如：border-top:10px solid red;</li><li>border-left 设置左边边框，如：border-left:10px solid blue;</li><li>border-right 设置右边边框，如：border-right:10px solid green;</li><li>border-bottom 设置底边边框，如：border-bottom:10px solid pink;</li></ul><h3 id="2-文本常用样式属性"><a href="#2-文本常用样式属性" class="headerlink" title="2. 文本常用样式属性"></a>2. 文本常用样式属性</h3><ul><li>color 设置文字的颜色，如： color:red;</li><li>font-size 设置文字的大小，如：font-size:12px;</li><li>font-family 设置文字的字体，如：font-family:’微软雅黑’;为了避免中文字不兼容，一般写成：font-family:’Microsoft Yahei’;</li><li>font-weight 设置文字是否加粗，如：font-weight:bold; 设置加粗 font-weight:normal 设置不加粗</li><li>line-height 设置文字的行高，如：line-height:24px; 表示文字高度加上文字上下的间距是24px，也就是每一行占有的高度是24px</li><li>text-decoration 设置文字的下划线，如：text-decoration:none; 将文字下划线去掉</li><li>text-align 设置文字水平对齐方式，如text-align:center 设置文字水平居中</li><li>text-indent 设置文字首行缩进，如：text-indent:24px; 设置文字首行缩进24px</li></ul><h3 id="3-布局常用样式属性示例代码"><a href="#3-布局常用样式属性示例代码" class="headerlink" title="3. 布局常用样式属性示例代码"></a>3. 布局常用样式属性示例代码</h3><pre><code class="html">&lt;style&gt;    .box1{        width: 200px;         height: 200px;         background:yellow;         border: 1px solid black;    }    .box2{        /* 这里是注释内容 */        /* 设置宽度 */        width: 100px;        /* 设置高度 */        height: 100px;        /* 设置背景色 */        background: red;        /* 设置四边边框 */        /* border: 10px solid black; */        border-top: 10px solid black;        border-left: 10px solid black;        border-right: 10px solid black;        border-bottom: 10px solid black;        /* 设置内边距， 内容到边框的距离，如果设置四边是上右下左 */        /* padding: 10px;   */        padding-left: 10px;        padding-top: 10px;        /* 设置外边距，设置元素边框到外界元素边框的距离 */        margin: 10px;        /* margin-top: 10px;        margin-left: 10px; */        float: left;    }    .box3{        width: 48px;         height: 48px;         background:pink;         border: 1px solid black;        float: left;    }&lt;/style&gt;&lt;div class=&quot;box1&quot;&gt;    &lt;div class=&quot;box2&quot;&gt;        padding 设置元素包含的内容和元素边框的距离    &lt;/div&gt;    &lt;div class=&quot;box3&quot;&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><h3 id="4-文本常用样式属性示例"><a href="#4-文本常用样式属性示例" class="headerlink" title="4. 文本常用样式属性示例"></a>4. 文本常用样式属性示例</h3><pre><code class="html">&lt;style&gt;    p{       /* 设置字体大小  浏览器默认是 16px */       font-size:20px;       /* 设置字体 */       font-family: &quot;Microsoft YaHei&quot;;        /* 设置字体加粗 */       font-weight: bold;       /* 设置字体颜色 */       color: red;       /* 增加掉下划线 */       text-decoration: underline;       /* 设置行高  */       line-height: 100px;       /* 设置背景色 */       background: green;       /* 设置文字居中 */       /* text-align: center; */       text-indent: 40px;    }    a{        /* 去掉下划线 */        text-decoration: none;    }&lt;/style&gt;&lt;a href=&quot;#&quot;&gt;连接标签&lt;/a&gt;&lt;p&gt;    你好，世界!&lt;/p&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTML-CSS基础&quot;&gt;&lt;a href=&quot;#HTML-CSS基础&quot; class=&quot;headerlink&quot; title=&quot;HTML+CSS基础&quot;&gt;&lt;/a&gt;HTML+CSS基础&lt;/h1&gt;&lt;h2 id=&quot;一、html-的介绍&quot;&gt;&lt;a href=&quot;#一、html-的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、html 的介绍&quot;&gt;&lt;/a&gt;一、html 的介绍&lt;/h2&gt;&lt;h3 id=&quot;1-html的定义&quot;&gt;&lt;a href=&quot;#1-html的定义&quot; class=&quot;headerlink&quot; title=&quot;1. html的定义&quot;&gt;&lt;/a&gt;1. html的定义&lt;/h3&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://caijinbo.work/categories/python/"/>
    
    
      <category term="python" scheme="https://caijinbo.work/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python高级03-网络编程</title>
    <link href="https://caijinbo.work/2020/08/21/2020-08-10-python%E9%AB%98%E7%BA%A703-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://caijinbo.work/2020/08/21/2020-08-10-python%E9%AB%98%E7%BA%A703-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2020-08-21T16:00:00.000Z</published>
    <updated>2020-11-23T10:13:29.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="一-IP地址的介绍"><a href="#一-IP地址的介绍" class="headerlink" title="一. IP地址的介绍"></a>一. IP地址的介绍</h2><h3 id="1-IP-地址的概念"><a href="#1-IP-地址的概念" class="headerlink" title="1. IP 地址的概念"></a>1. IP 地址的概念</h3><a id="more"></a><p>IP地址（Internet Protocol Address）是指互联网协议地址，又译为网际协议地址。</p><p>IP地址是<a href="https://baike.baidu.com/item/IP协议" target="_blank" rel="noopener">IP协议</a>提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p><p>IP 地址就是<strong>标识网络中设备的一个地址</strong>，好比现实生活中的家庭地址。</p><p><strong>说明:</strong></p><ul><li>IP 地址分为两类： <strong>IPv4</strong> 和 <strong>IPv6</strong></li><li>IPv4 是目前使用的ip地址</li><li>IPv6 是未来使用的ip地址</li><li>IPv4 是由点分十进制组成</li><li>IPv6 是由冒号十六进制组成</li></ul><h3 id="2-IP-地址的作用"><a href="#2-IP-地址的作用" class="headerlink" title="2. IP 地址的作用"></a>2. IP 地址的作用</h3><p>IP 地址的作用是<strong>标识网络中唯一的一台设备的</strong>，也就是说通过IP地址能够找到网络中某台设备。</p><h3 id="3-查看-IP-地址"><a href="#3-查看-IP-地址" class="headerlink" title="3. 查看 IP 地址"></a>3. 查看 IP 地址</h3><ul><li>Linux 和 mac OS 使用 <strong>ifconfig</strong> 这个命令</li><li>Windows 使用 <strong>ipconfig</strong> 这个命令</li></ul><p>说明:</p><ul><li>127.0.0.1表示本机地址，提示：如果和自己的电脑通信就可以使用该地址。</li><li>127.0.0.1该地址对应的域名是<strong>localhost</strong>，<strong>域名是 ip 地址的别名</strong>，通过域名能解析出一个对应的ip地址。</li></ul><h3 id="4-检查网络是否正常"><a href="#4-检查网络是否正常" class="headerlink" title="4. 检查网络是否正常"></a>4. 检查网络是否正常</h3><ul><li>检查网络是否正常使用 ping 命令</li></ul><p><strong>说明:</strong></p><ul><li>ping <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 检查是否能上公网</li><li>ping 当前局域网的ip地址 检查是否在同一个局域网内</li><li>ping 127.0.0.1 检查本地网卡是否正常</li></ul><h2 id="二-端口和端口号的介绍"><a href="#二-端口和端口号的介绍" class="headerlink" title="二. 端口和端口号的介绍"></a>二. 端口和端口号的介绍</h2><h3 id="1-什么是端口"><a href="#1-什么是端口" class="headerlink" title="1. 什么是端口"></a>1. 什么是端口</h3><p><strong>每运行一个网络程序都会有一个端口，想要给对应的程序发送数据，找到对应的端口即可。</strong></p><p><strong>端口是传输数据的通道</strong>，好比教室的门，<strong>是数据传输必经之路</strong>。</p><p>那么如何准确的找到对应的端口呢?</p><p><strong>其实，每一个端口都会有一个对应的端口号，好比每个教室的门都有一个门牌号，想要找到端口通过端口号即可。</strong></p><h3 id="2-什么是端口号"><a href="#2-什么是端口号" class="headerlink" title="2. 什么是端口号"></a>2. 什么是端口号</h3><p>操作系统为了统一管理这么多端口，<strong>就对端口进行了编号</strong>，这就是端口号，<strong>端口号其实就是一个数字</strong>，好比我们现实生活中的门牌号，端口号可以标识唯一的一个端口。</p><p>端口号有65536个。</p><p><strong>知名端口号:</strong></p><p>知名端口号是指<strong>众所周知的端口号，范围从0到1023。</strong></p><ul><li>这些端口号一般固定分配给一些服务，比如21端口分配给FTP(文件传输协议)服务，25端口分配给SMTP（简单邮件传输协议）服务，80端口分配给HTTP服务。</li></ul><p><strong>动态端口号:</strong></p><p>一般程序员<strong>开发应用程序使用端口号称为动态端口号, 范围是从1024到65535。</strong></p><ul><li>如果程序员开发的程序没有设置端口号，操作系统会在动态端口号这个范围内随机生成一个给开发的应用程序使用。</li><li>当运行一个程序默认会有一个端口号，当这个程序退出时，所占用的这个端口号就会被释放。</li></ul><h2 id="三-TCP的介绍"><a href="#三-TCP的介绍" class="headerlink" title="三. TCP的介绍"></a>三. TCP的介绍</h2><h3 id="1-TCP-的概念"><a href="#1-TCP-的概念" class="headerlink" title="1. TCP 的概念"></a>1. TCP 的概念</h3><p>TCP 的英文全拼(Transmission Control Protocol)简称<strong>传输控制协议</strong>，它是一种<strong>面向连接的、可靠的、基于字节流的传输层通信协议</strong>。</p><p><strong>TCP 通信步骤:</strong></p><ol><li>创建连接</li><li>传输数据</li><li>关闭连接</li></ol><p><strong>说明:</strong></p><p>TCP 通信模型相当于生活中的’打电话‘，在通信开始之前，一定要先建立好连接，才能发送数据，通信结束要关闭连接。</p><h3 id="2-TCP-的特点"><a href="#2-TCP-的特点" class="headerlink" title="2. TCP 的特点"></a>2. TCP 的特点</h3><ol><li>面向连接<ul><li>通信双方必须先建立好连接才能进行数据的传输，数据传输完成后，双方必须断开此连接，以释放系统资源。</li></ul></li><li>可靠传输<ul><li>TCP 采用发送应答机制</li><li>超时重传</li><li>错误校验</li><li>流量控制和阻塞管理</li></ul></li></ol><h2 id="四-socket的介绍"><a href="#四-socket的介绍" class="headerlink" title="四. socket的介绍"></a>四. socket的介绍</h2><h3 id="1-socket-的概念"><a href="#1-socket-的概念" class="headerlink" title="1. socket 的概念"></a>1. socket 的概念</h3><p>socket (简称 套接字) 是<strong>进程之间通信一个工具</strong>，好比现实生活中的<strong>插座</strong>，所有的家用电器要想工作都是基于插座进行，<strong>进程之间想要进行网络通信需要基于这个 socket</strong>。</p><h3 id="2-socket-的作用"><a href="#2-socket-的作用" class="headerlink" title="2. socket 的作用"></a>2. socket 的作用</h3><p>负责<strong>进程之间的网络数据传输</strong>，好比数据的搬运工。</p><h3 id="3-socket-使用场景"><a href="#3-socket-使用场景" class="headerlink" title="3. socket 使用场景"></a>3. socket 使用场景</h3><p>不夸张的说，只要跟<strong>网络相关的应用程序或者软件都使用到了 socket</strong> 。</p><h2 id="五-TCP网络应用程序开发流程"><a href="#五-TCP网络应用程序开发流程" class="headerlink" title="五. TCP网络应用程序开发流程"></a>五. TCP网络应用程序开发流程</h2><h3 id="1-TCP-网络应用程序开发流程的介绍"><a href="#1-TCP-网络应用程序开发流程的介绍" class="headerlink" title="1. TCP 网络应用程序开发流程的介绍"></a>1. TCP 网络应用程序开发流程的介绍</h3><p>TCP 网络应用程序开发分为:</p><ul><li>TCP 客户端程序开发</li><li>TCP 服务端程序开发</li></ul><p><strong>说明:</strong></p><p>客户端程序是指运行在<strong>用户设备上的程序</strong> 服务端程序是指运行在<strong>服务器设备上的程序</strong>，专门为客户端提供数据服务。</p><ol><li><strong>主动发起建立连接请求的</strong>是客户端程序</li><li><strong>等待接受连接请求的</strong>是服务端程序</li></ol><h3 id="2-TCP-客户端程序开发流程的介绍"><a href="#2-TCP-客户端程序开发流程的介绍" class="headerlink" title="2. TCP 客户端程序开发流程的介绍"></a>2. TCP 客户端程序开发流程的介绍</h3><ol><li>创建客户端套接字对象</li><li>和服务端套接字建立连接</li><li>发送数据</li><li>接收数据</li><li>关闭客户端套接字</li></ol><h3 id="3-TCP-服务端程序开发流程的介绍"><a href="#3-TCP-服务端程序开发流程的介绍" class="headerlink" title="3. TCP 服务端程序开发流程的介绍"></a>3. TCP 服务端程序开发流程的介绍</h3><ol><li>创建服务端端套接字对象</li><li>绑定端口号</li><li>设置监听</li><li>等待接受客户端的连接请求</li><li>接收数据</li><li>发送数据</li><li>关闭套接字</li></ol><h2 id="六-TCP客户端程序开发"><a href="#六-TCP客户端程序开发" class="headerlink" title="六. TCP客户端程序开发"></a>六. TCP客户端程序开发</h2><h3 id="1-开发-TCP-客户端程序开发步骤回顾"><a href="#1-开发-TCP-客户端程序开发步骤回顾" class="headerlink" title="1. 开发 TCP 客户端程序开发步骤回顾"></a>1. 开发 TCP 客户端程序开发步骤回顾</h3><ol><li>创建客户端套接字对象</li><li>和服务端套接字建立连接</li><li>发送数据</li><li>接收数据</li><li>关闭客户端套接字</li></ol><h3 id="2-socket-类的介绍"><a href="#2-socket-类的介绍" class="headerlink" title="2. socket 类的介绍"></a>2. socket 类的介绍</h3><p>导入 socket 模块<br><strong>import socket</strong></p><p>创建客户端 socket 对象<br><strong>socket.socket(AddressFamily, Type)</strong></p><p><strong>参数说明:</strong></p><ul><li>AddressFamily 表示IP地址类型, 分为IPv4和IPv6</li><li>Type 表示传输协议类型</li></ul><p><strong>方法说明:</strong></p><ul><li>connect((host, port)) 表示和服务端套接字建立连接, host是服务器ip地址，port是应用程序的端口号</li><li>send(data) 表示发送数据，data是二进制数据</li><li>recv(buffersize) 表示接收数据, buffersize是每次接收数据的长度</li></ul><h3 id="3-TCP-客户端程序开发示例代码"><a href="#3-TCP-客户端程序开发示例代码" class="headerlink" title="3. TCP 客户端程序开发示例代码"></a>3. TCP 客户端程序开发示例代码</h3><pre><code class="python">import socketif __name__ == &#39;__main__&#39;:    # 创建tcp客户端套接字    # 1. AF_INET：表示ipv4    # 2. SOCK_STREAM: tcp传输协议    tcp_client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # 和服务端应用程序建立连接    tcp_client_socket.connect((&quot;192.168.131.62&quot;, 8080))    # 代码执行到此，说明连接建立成功    # 准备发送的数据    send_data = &quot;你好服务端，我是客户端!&quot;.encode(&quot;utf-8&quot;)    # 发送数据    tcp_client_socket.send(send_data)    # 接收数据, 这次接收的数据最大字节数是1024    recv_data = tcp_client_socket.recv(1024)    # 返回的直接是服务端程序发送的二进制数据    print(recv_data)    # 对数据进行解码    recv_content = recv_data.decode(&quot;utf-8&quot;)    print(&quot;接收服务端的数据为:&quot;, recv_content)    # 关闭套接字    tcp_client_socket.close()</code></pre><p><strong>执行结果:</strong></p><pre><code class="py">b&#39;hello&#39;接收服务端的数据为: hello</code></pre><p><strong>说明</strong></p><ol><li>str.encode(编码格式) 表示把字符串编码成为二进制</li><li>data.decode(编码格式) 表示把二进制解码成为字符串</li></ol><h2 id="七-TCP服务端程序开发"><a href="#七-TCP服务端程序开发" class="headerlink" title="七. TCP服务端程序开发"></a>七. TCP服务端程序开发</h2><h3 id="1-开发-TCP-服务端程序开发步骤回顾"><a href="#1-开发-TCP-服务端程序开发步骤回顾" class="headerlink" title="1. 开发 TCP 服务端程序开发步骤回顾"></a>1. 开发 TCP 服务端程序开发步骤回顾</h3><ol><li>创建服务端端套接字对象</li><li>绑定端口号</li><li>设置监听</li><li>等待接受客户端的连接请求</li><li>接收数据</li><li>发送数据</li><li>关闭套接字</li></ol><h3 id="2-socket-类的介绍-1"><a href="#2-socket-类的介绍-1" class="headerlink" title="2. socket 类的介绍"></a>2. socket 类的介绍</h3><p>导入 socket 模块<br><strong>import socket</strong></p><p>创建服务端 socket 对象<br><strong>socket.socket(AddressFamily, Type)</strong></p><p><strong>参数说明:</strong></p><ul><li>AddressFamily 表示IP地址类型, 分为IPv4和IPv6</li><li>Type 表示传输协议类型</li></ul><p><strong>方法说明:</strong></p><ul><li>bind((host, port)) 表示绑定端口号, host 是 ip 地址，port 是端口号，ip 地址一般不指定，表示本机的任何一个ip地址都可以。</li><li>listen (backlog) 表示设置监听，backlog参数表示最大等待建立连接的个数。</li><li>accept() 表示等待接受客户端的连接请求</li><li>send(data) 表示发送数据，data 是二进制数据</li><li>recv(buffersize) 表示接收数据, buffersize 是每次接收数据的长度</li></ul><h3 id="3-TCP-服务端程序开发示例代码"><a href="#3-TCP-服务端程序开发示例代码" class="headerlink" title="3. TCP 服务端程序开发示例代码"></a>3. TCP 服务端程序开发示例代码</h3><pre><code class="python">import socketif __name__ == &#39;__main__&#39;:    # 创建tcp服务端套接字    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # 设置端口号复用，让程序退出端口号立即释放    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)     # 给程序绑定端口号    tcp_server_socket.bind((&quot;&quot;, 8080))    # 设置监听    # 128:最大等待建立连接的个数， 提示： 目前是单任务的服务端，同一时刻只能服务与一个客户端，后续使用多任务能够让服务端同时服务与多个客户端，    # 不需要让客户端进行等待建立连接    # listen后的这个套接字只负责接收客户端连接请求，不能收发消息，收发消息使用返回的这个新套接字来完成    tcp_server_socket.listen(128)    # 等待客户端建立连接的请求, 只有客户端和服务端建立连接成功代码才会解阻塞，代码才能继续往下执行    # 1. 专门和客户端通信的套接字： service_client_socket    # 2. 客户端的ip地址和端口号： ip_port    service_client_socket, ip_port = tcp_server_socket.accept()    # 代码执行到此说明连接建立成功    print(&quot;客户端的ip地址和端口号:&quot;, ip_port)    # 接收客户端发送的数据, 这次接收数据的最大字节数是1024    recv_data = service_client_socket.recv(1024)    # 获取数据的长度    recv_data_length = len(recv_data)    print(&quot;接收数据的长度为:&quot;, recv_data_length)    # 对二进制数据进行解码    recv_content = recv_data.decode(&quot;utf-8&quot;)    print(&quot;接收客户端的数据为:&quot;, recv_content)    # 准备发送的数据    send_data = &quot;ok, 问题正在处理中...&quot;.encode(&quot;utf-8&quot;)    # 发送数据给客户端    service_client_socket.send(send_data)    # 关闭服务与客户端的套接字， 终止和客户端通信的服务    service_client_socket.close()    # 关闭服务端的套接字, 终止和客户端提供建立连接请求的服务    tcp_server_socket.close()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">客户端的ip地址和端口号: (&#39;172.16.47.209&#39;, 52472)接收数据的长度为: 5接收客户端的数据为: hello</code></pre><p><strong>说明:</strong></p><p>当客户端和服务端建立连接后，<strong>服务端程序退出后端口号不会立即释放，需要等待大概1-2分钟。</strong></p><p>解决办法有两种:</p><ol><li>更换服务端端口号</li><li>设置端口号复用(推荐大家使用)，也就是说让服务端程序退出后端口号立即释放。</li></ol><p>设置端口号复用的代码如下:</p><pre><code class="py"># 参数1: 表示当前套接字# 参数2: 设置端口号复用选项# 参数3: 设置端口号复用选项对应的值tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)</code></pre><h2 id="八-TCP网络应用程序的注意点"><a href="#八-TCP网络应用程序的注意点" class="headerlink" title="八. TCP网络应用程序的注意点"></a>八. TCP网络应用程序的注意点</h2><h3 id="1-TCP网络应用程序的注意点介绍"><a href="#1-TCP网络应用程序的注意点介绍" class="headerlink" title="1. TCP网络应用程序的注意点介绍"></a>1. TCP网络应用程序的注意点介绍</h3><ol><li>当 TCP 客户端程序想要和 TCP 服务端程序进行通信的时候必须要先<strong>建立连接</strong></li><li>TCP 客户端程序一般不需要绑定端口号，因为客户端是主动发起建立连接的。</li><li><strong>TCP 服务端程序必须绑定端口号</strong>，否则客户端找不到这个 TCP 服务端程序。</li><li>listen 后的套接字是被动套接字，<strong>只负责接收新的客户端的连接请求，不能收发消息。</strong></li><li>当 TCP 客户端程序和 TCP 服务端程序连接成功后， TCP 服务器端程序会产生一个<strong>新的套接字</strong>，收发客户端消息使用该套接字。</li><li><strong>关闭 accept 返回的套接字意味着和这个客户端已经通信完毕</strong>。</li><li><strong>关闭 listen 后的套接字意味着服务端的套接字关闭了，会导致新的客户端不能连接服务端，但是之前已经接成功的客户端还能正常通信。</strong></li><li><strong>当客户端的套接字调用 close 后，服务器端的 recv 会解阻塞，返回的数据长度为0</strong>，服务端可以通过返回数据的长度来判断客户端是否已经下线，反之<strong>服务端关闭套接字，客户端的 recv 也会解阻塞，返回的数据长度也为0</strong>。</li></ol><h2 id="九-案例-多任务版TCP服务程序"><a href="#九-案例-多任务版TCP服务程序" class="headerlink" title="九. 案例-多任务版TCP服务程序"></a>九. 案例-多任务版TCP服务程序</h2><h3 id="1-需求"><a href="#1-需求" class="headerlink" title="1. 需求"></a>1. 需求</h3><p>目前我们开发的TCP服务端程序只能服务于一个客户端，如何开发一个多任务版的TCP服务端程序能够服务于多个客户端呢?</p><p>完成多任务，可以使用<strong>线程</strong>，比进程更加节省内存资源。</p><h3 id="2-具体实现步骤"><a href="#2-具体实现步骤" class="headerlink" title="2. 具体实现步骤"></a>2. 具体实现步骤</h3><ol><li>编写一个TCP服务端程序，循环等待接受客户端的连接请求</li><li>当客户端和服务端建立连接成功，创建子线程，使用子线程专门处理客户端的请求，防止主线程阻塞</li><li>把创建的子线程设置成为守护主线程，防止主线程无法退出。</li></ol><h3 id="3-多任务版TCP服务端程序的示例代码"><a href="#3-多任务版TCP服务端程序的示例代码" class="headerlink" title="3. 多任务版TCP服务端程序的示例代码:"></a>3. 多任务版TCP服务端程序的示例代码:</h3><pre><code class="python">import socketimport threading# 处理客户端的请求操作def handle_client_request(service_client_socket, ip_port):    # 循环接收客户端发送的数据    while True:        # 接收客户端发送的数据        recv_data = service_client_socket.recv(1024)        # 容器类型判断是否有数据可以直接使用if语句进行判断，如果容器类型里面有数据表示条件成立，否则条件失败        # 容器类型: 列表、字典、元组、字符串、set、range、二进制数据        if recv_data:            print(recv_data.decode(&quot;utf-8&quot;), ip_port)            # 回复            service_client_socket.send(&quot;ok，问题正在处理中...&quot;.encode(&quot;utf-8&quot;))        else:            print(&quot;客户端下线了:&quot;, ip_port)            break    # 终止和客户端进行通信    service_client_socket.close()if __name__ == &#39;__main__&#39;:    # 创建tcp服务端套接字    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # 设置端口号复用，让程序退出端口号立即释放    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)    # 绑定端口号    tcp_server_socket.bind((&quot;&quot;, 8080))    # 设置监听, listen后的套接字是被动套接字，只负责接收客户端的连接请求    tcp_server_socket.listen(128)    # 循环等待接收客户端的连接请求    while True:        # 等待接收客户端的连接请求        service_client_socket, ip_port = tcp_server_socket.accept()        print(&quot;客户端连接成功:&quot;, ip_port)        # 当客户端和服务端建立连接成功以后，需要创建一个子线程，不同子线程负责接收不同客户端的消息        sub_thread = threading.Thread(target=handle_client_request, args=(service_client_socket, ip_port))        # 设置守护主线程        sub_thread.setDaemon(True)        # 启动子线程        sub_thread.start()    # tcp服务端套接字可以不需要关闭，因为服务端程序需要一直运行    # tcp_server_socket.close()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">客户端连接成功: (&#39;172.16.47.209&#39;, 51528)客户端连接成功: (&#39;172.16.47.209&#39;, 51714)hello1 (&#39;172.16.47.209&#39;, 51528)hello2 (&#39;172.16.47.209&#39;, 51714)</code></pre><h2 id="十-socket的send和recv原理剖析"><a href="#十-socket的send和recv原理剖析" class="headerlink" title="十. socket的send和recv原理剖析"></a>十. socket的send和recv原理剖析</h2><h3 id="1-认识TCP-socket的发送和接收缓冲区"><a href="#1-认识TCP-socket的发送和接收缓冲区" class="headerlink" title="1. 认识TCP socket的发送和接收缓冲区"></a>1. 认识TCP socket的发送和接收缓冲区</h3><p>当创建一个TCP socket对象的时候会有一个<strong>发送缓冲区</strong>和一个<strong>接收缓冲区</strong>，<strong>这个发送和接收缓冲区指的就是内存中的一片空间。</strong></p><h3 id="2-send原理剖析"><a href="#2-send原理剖析" class="headerlink" title="2. send原理剖析"></a>2. send原理剖析</h3><p>send是不是直接把数据发给服务端?</p><p>不是，要想发数据，必须得<strong>通过网卡发送数据</strong>，应用程序是无法直接通过网卡发送数据的，它需要调用操作系统接口，也就是说，应用程序把发送的数据先写入到<strong>发送缓冲区</strong>(内存中的一片空间)，再<strong>由操作系统控制网卡把发送缓冲区的数据发送给服务端网卡</strong> 。</p><h3 id="3-recv原理剖析"><a href="#3-recv原理剖析" class="headerlink" title="3. recv原理剖析"></a>3. recv原理剖析</h3><p>recv是不是直接从客户端接收数据?</p><p>不是，<strong>应用软件是无法直接通过网卡接收数据的</strong>，它需要调用操作系统接口，<strong>由操作系统通过网卡接收数据</strong>，把接收的数据<strong>写入到接收缓冲区</strong>(内存中的一片空间），应用程序<strong>再从接收缓存区获取客户端发送的数据</strong>。</p><p><strong>说明:</strong></p><ul><li>发送数据是发送到发送缓冲区</li><li>接收数据是从接收缓冲区 获取</li></ul><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><p>不管是recv还是send都不是直接接收到对方的数据和发送数据到对方，<strong>发送数据会写入到发送缓冲区，接收数据是从接收缓冲区来读取，发送数据和接收数据最终是由操作系统控制网卡来完成。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;网络编程&quot;&gt;&lt;a href=&quot;#网络编程&quot; class=&quot;headerlink&quot; title=&quot;网络编程&quot;&gt;&lt;/a&gt;网络编程&lt;/h1&gt;&lt;h2 id=&quot;一-IP地址的介绍&quot;&gt;&lt;a href=&quot;#一-IP地址的介绍&quot; class=&quot;headerlink&quot; title=&quot;一. IP地址的介绍&quot;&gt;&lt;/a&gt;一. IP地址的介绍&lt;/h2&gt;&lt;h3 id=&quot;1-IP-地址的概念&quot;&gt;&lt;a href=&quot;#1-IP-地址的概念&quot; class=&quot;headerlink&quot; title=&quot;1. IP 地址的概念&quot;&gt;&lt;/a&gt;1. IP 地址的概念&lt;/h3&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://caijinbo.work/categories/python/"/>
    
    
      <category term="python" scheme="https://caijinbo.work/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python高级08-MySQL数据库</title>
    <link href="https://caijinbo.work/2020/08/21/2020-08-22-python%E9%AB%98%E7%BA%A708-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://caijinbo.work/2020/08/21/2020-08-22-python%E9%AB%98%E7%BA%A708-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2020-08-21T16:00:00.000Z</published>
    <updated>2020-11-23T10:13:44.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h1><h2 id="一、MySQL数据库的基本使用"><a href="#一、MySQL数据库的基本使用" class="headerlink" title="一、MySQL数据库的基本使用"></a>一、MySQL数据库的基本使用</h2><h3 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1.数据库"></a>1.数据库</h3><a id="more"></a><h4 id="1-1-数据库的介绍"><a href="#1-1-数据库的介绍" class="headerlink" title="1.1 数据库的介绍"></a>1.1 数据库的介绍</h4><p>数据库就是<strong>存储和管理数据的仓库</strong>，数据按照一定的格式进行存储，用户可以对数据库中的数据进行增加、修改、删除、查询等操作。</p><h4 id="1-2-数据库的分类"><a href="#1-2-数据库的分类" class="headerlink" title="1.2 数据库的分类"></a>1.2 数据库的分类</h4><ul><li>关系型数据库</li><li>非关系型数据库</li></ul><p><strong>关系型数据库:</strong></p><p>是指采用了关系模型来组织数据的数据库，简单来说，<strong>关系模型指的就是二维表格模型</strong>，好比Excel文件中的表格，强调使用表格的方式存储数据。</p><p><strong>关系型数据库中核心元素</strong></p><ul><li>数据行</li><li>数据列</li><li>数据表</li><li>数据库(数据表的集合)</li></ul><p><strong>常用的关系型数据库:</strong></p><ul><li>Oracle</li><li>Microsoft SQL Server</li><li>MySQL</li><li>SQLite</li></ul><p><strong>非关系型数据库:</strong></p><p>非关系型数据库，又被称为NoSQL（Not Only SQL )，意为不仅仅是SQL，对NoSQL 最普遍的定义是“非关联型的”，强调 Key-Value 的方式存储数据。</p><p><strong>常用的非关系型数据库:</strong></p><ul><li>MongoDB</li><li>Redis</li></ul><h4 id="1-3-数据库的作用"><a href="#1-3-数据库的作用" class="headerlink" title="1.3 数据库的作用"></a>1.3 数据库的作用</h4><p>数据库的作用就是存储和管理数据的，比如: 我们在京东网站上的浏览的商品列表数据，这些数据都会存储在数据库。</p><h4 id="1-4-数据库的特点"><a href="#1-4-数据库的特点" class="headerlink" title="1.4 数据库的特点"></a>1.4 数据库的特点</h4><ol><li>持久化存储</li><li>读写速度极高</li><li>保证数据的有效性</li></ol><h3 id="2-关系型数据库管理系统"><a href="#2-关系型数据库管理系统" class="headerlink" title="2.关系型数据库管理系统"></a>2.关系型数据库管理系统</h3><h4 id="2-1-关系型数据库管理系统的介绍"><a href="#2-1-关系型数据库管理系统的介绍" class="headerlink" title="2.1 关系型数据库管理系统的介绍"></a>2.1 关系型数据库管理系统的介绍</h4><p>数据库管理系统（英语全拼：Relational Database Management System，简称RDBMS）是<strong>为管理关系型数据库而设计的软件系统，如果大家想要使用关系型数据库就需要安装数据库管理系统，其实就是一个应用软件</strong>。</p><p><strong>关系型数据库管理系统可以分为:</strong></p><ul><li>关系型数据库服务端软件</li><li>关系型数据库客户端软件</li></ul><p><strong>关系型数据库服务端软件:</strong></p><p>主要负责管理不同的数据库，而每个数据库里面会有一系列数据文件，数据文件是用来存储数据的, 其实数据库就是一系列数据文件的集合。</p><p><strong>关系型数据库客户端软件:</strong></p><p>主要负责和关系型数据库服务端软件进行通信, 向服务端传输数据或者从服务端获取数据.</p><p><strong>说明:</strong></p><ol><li>用户操作关系型数据库客户端，实现数据库相关操作。</li><li>关系数据库客户端借助网络使用SQL语言和关系型数据库服务端进行数据通信</li><li>关系型数据库服务端管理着不同的数据库，每个数据库会有一系列的数据文件，数据都保存在数据文件里面，每个数据库可以理解成是一个文件夹。</li><li>数据库客户端和数据库服务器想要通信需要使用SQL。</li></ol><h4 id="2-2-SQL的介绍"><a href="#2-2-SQL的介绍" class="headerlink" title="2.2 SQL的介绍"></a>2.2 SQL的介绍</h4><p>SQL(Structured Query Language)是结构化查询语言，是一种用来操作RDBMS的数据库的语言。也就是说通过 SQL 可以操作 oracle,sql server,mysql,sqlite 等关系型的数据库。</p><p>SQL的作用是实现数据库客户端和数据库服务端之间的通信，SQL就是通信的桥梁。</p><p><strong>SQL语言主要分为：</strong></p><ul><li><strong>DQL：数据查询语言，用于对数据进行查询，如select</strong></li><li><strong>DML：数据操作语言，对数据进行增加、修改、删除，如insert、update、delete</strong></li><li>TPL：事务处理语言，对事务进行处理，包括begin transaction、commit、rollback</li><li>DCL：数据控制语言，进行授权与权限回收，如grant、revoke</li><li>DDL：数据定义语言，进行数据库、表的管理等，如create、drop</li></ul><p><strong>说明:</strong></p><ul><li>对于程序员来讲，重点是数据的增、删、改、查，必须熟练编写DQL、DML，能够编写DDL完成数据库、表的操作，其它操作如TPL、DCL了解即可.</li><li>SQL语言不区分大小写</li></ul><p>​    </p><h3 id="3-MySQL数据库"><a href="#3-MySQL数据库" class="headerlink" title="3.MySQL数据库"></a>3.MySQL数据库</h3><h4 id="3-1-MySQL数据库的介绍"><a href="#3-1-MySQL数据库的介绍" class="headerlink" title="3.1 MySQL数据库的介绍"></a>3.1 MySQL数据库的介绍</h4><p>MySQL是一个关系型数据库管理系统，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件，它是由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品，MySQL 是最流行的关系型数据库管理系统中的一个。</p><p><strong>MySQL的特点:</strong></p><ol><li>MySQL是开源的，所以你不需要支付额外的费用。</li><li>MySQL支持大型的数据库。可以处理拥有上千万条记录的大型数据库。</li><li>MySQL使用标准的SQL数据语言形式。</li><li>MySQL可以安装在不同的操作系统，并且提供多种编程语言的操作接口。这些编程语言包括C、C++、Python、Java、Ruby等等。</li></ol><h4 id="3-2-MySQL数据库的安装"><a href="#3-2-MySQL数据库的安装" class="headerlink" title="3.2 MySQL数据库的安装"></a>3.2 MySQL数据库的安装</h4><ul><li>MySQL数据库服务端软件的安装</li><li>MySQL数据库客户端软件的安装</li></ul><p><strong>MySQL数据库服务端软件的安装:</strong></p><p>在Ubuntu中打开终端，输入下面的命令:</p><pre><code class="bash">sudo apt install mysql-server mysql-client</code></pre><p>manjaro安装mysql：</p><pre><code class="bash">sudo pacman -S mysql</code></pre><p>centos 安装mysql </p><pre><code class="bash">yum install mysql mysql-devel -y</code></pre><p><strong>查看MySQL服务状态:</strong></p><pre><code class="bash">sudo service mysql status</code></pre><p><strong>停止MySQL服务:</strong></p><pre><code class="bash">sudo service mysql stop</code></pre><p><strong>启动MySQL服务:</strong></p><pre><code class="bash">sudo service mysql start</code></pre><p><strong>重启MySQL服务:</strong></p><pre><code class="bash">sudo service mysql restart</code></pre><p><strong>MySQL配置文件的介绍:</strong>（ubutnu）</p><p>配置文件路径为: /etc/mysql/mysql.conf.d/mysqld.cnf</p><p><strong>主要配置信息说明:</strong></p><pre><code class="bash">port表示端口号，默认为3306bind-address表示服务器绑定的ip，默认为127.0.0.1datadir表示数据库保存路径，默认为/var/lib/mysqllog_error表示错误日志，默认为/var/log/mysql/error.log</code></pre><p><strong>MySQL数据库客户端软件的安装:</strong></p><p>客户端是程序员或者dba使用的软件，通过socket方式与服务端程序通信。</p><p>常用的MySQL数据库客户端软件有</p><ol><li>图形化界面客户端Navicat</li><li>命令行客户端mysql</li></ol><p><strong>mysql命令的使用帮助:</strong></p><pre><code class="bash">mysql --help</code></pre><p><strong>MySQL客户端的使用:</strong></p><p>MySQL客户端连接MySQL服务端命令</p><pre><code class="bash">mysql -uroot -p</code></pre><p><strong>说明:</strong></p><ul><li>-u: 表示MySQL服务端的用户名</li><li>-p: 表示MySQL服务端的密码</li><li>quit 或者 exit 或者 ctr + d 表示退出</li></ul><h3 id="4-数据类型和约束"><a href="#4-数据类型和约束" class="headerlink" title="4.数据类型和约束"></a>4.数据类型和约束</h3><h4 id="4-1-数据类型"><a href="#4-1-数据类型" class="headerlink" title="4.1 数据类型"></a>4.1 数据类型</h4><p>数据类型是指在创建表的时候为表中字段指定数据类型，只有数据符合类型要求才能存储起来，使用数据类型的原则是:够用就行，尽量使用取值范围小的，而不用大的，这样可以更多的节省存储空间。</p><p><strong>常用数据类型如下:</strong></p><ul><li>整数：int，bit</li><li>小数：decimal</li><li>字符串：varchar,char</li><li>日期时间: date, time, datetime</li><li>枚举类型(enum)</li></ul><p><strong>数据类型说明:</strong></p><ul><li>decimal表示浮点数，如 decimal(5, 2) 表示共存5位数，小数占 2 位.</li><li>char表示固定长度的字符串，如char(3)，如果填充’ab’时会补一个空格为’ab ‘，3表示字符数</li><li>varchar表示可变长度的字符串，如varchar(3)，填充’ab’时就会存储’ab’，3表示字符数</li><li>对于图片、音频、视频等文件，不存储在数据库中，而是上传到某个服务器上，然后在表中存储这个文件的保存路径.</li><li>字符串 text 表示存储大文本，当字符大于 4000 时推荐使用, 比如技术博客.</li></ul><h4 id="4-2-数据约束"><a href="#4-2-数据约束" class="headerlink" title="4.2 数据约束"></a>4.2 数据约束</h4><p>约束是指数据在数据类型限定的基础上额外增加的要求.</p><p><strong>常见的约束如下:</strong></p><ul><li>主键 primary key: 物理上存储的顺序. MySQL 建议所有表的主键字段都叫 id, 类型为 int unsigned.</li><li>非空 not null: 此字段不允许填写空值.</li><li>惟一 unique: 此字段的值不允许重复.</li><li>默认 default: 当不填写字段对应的值会使用默认值，如果填写时以填写为准.</li><li>外键 foreign key: 对关系字段进行约束, 当为关系字段填写值时, 会到关联的表中查询此值是否存在, 如果存在则填写成功, 如果不存在则填写失败并抛出异常.</li></ul><h4 id="4-3-数据类型附录表"><a href="#4-3-数据类型附录表" class="headerlink" title="4.3 数据类型附录表"></a>4.3 数据类型附录表</h4><h5 id="4-3-1-整数类型"><a href="#4-3-1-整数类型" class="headerlink" title="4.3.1 整数类型"></a>4.3.1 整数类型</h5><table><thead><tr><th align="left">类型</th><th align="left">字节大小</th><th align="left">有符号范围(Signed)</th><th align="left">无符号范围(Unsigned)</th></tr></thead><tbody><tr><td align="left">TINYINT</td><td align="left">1</td><td align="left">-128 ~ 127</td><td align="left">0 ~ 255</td></tr><tr><td align="left">SMALLINT</td><td align="left">2</td><td align="left">-32768 ~ 32767</td><td align="left">0 ~ 65535</td></tr><tr><td align="left">MEDIUMINT</td><td align="left">3</td><td align="left">-8388608 ~ 8388607</td><td align="left">0 ~ 16777215</td></tr><tr><td align="left">INT/INTEGER</td><td align="left">4</td><td align="left">-2147483648 ~2147483647</td><td align="left">0 ~ 4294967295</td></tr><tr><td align="left">BIGINT</td><td align="left">8</td><td align="left">-9223372036854775808 ~ 9223372036854775807</td><td align="left">0 ~ 18446744073709551615</td></tr></tbody></table><h5 id="4-3-2-字符串"><a href="#4-3-2-字符串" class="headerlink" title="4.3.2 字符串"></a>4.3.2 字符串</h5><table><thead><tr><th align="left">类型</th><th align="left">说明</th><th align="left">使用场景</th></tr></thead><tbody><tr><td align="left">CHAR</td><td align="left">固定长度，小型数据</td><td align="left">身份证号、手机号、电话、密码</td></tr><tr><td align="left">VARCHAR</td><td align="left">可变长度，小型数据</td><td align="left">姓名、地址、品牌、型号</td></tr><tr><td align="left">TEXT</td><td align="left">可变长度，字符个数大于 4000</td><td align="left">存储小型文章或者新闻</td></tr><tr><td align="left">LONGTEXT</td><td align="left">可变长度， 极大型文本数据</td><td align="left">存储极大型文本数据</td></tr></tbody></table><h5 id="4-3-3-时间类型"><a href="#4-3-3-时间类型" class="headerlink" title="4.3.3 时间类型"></a>4.3.3 时间类型</h5><table><thead><tr><th align="left">类型</th><th align="left">字节大小</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">DATE</td><td align="left">4</td><td align="left">‘2020-01-01’</td></tr><tr><td align="left">TIME</td><td align="left">3</td><td align="left">‘12:29:59’</td></tr><tr><td align="left">DATETIME</td><td align="left">8</td><td align="left">‘2020-01-01 12:29:59’</td></tr><tr><td align="left">YEAR</td><td align="left">1</td><td align="left">‘2017’</td></tr><tr><td align="left">TIMESTAMP</td><td align="left">4</td><td align="left">‘1970-01-01 00:00:01’ UTC ~ ‘2038-01-01 00:00:01’ UTC</td></tr></tbody></table><h5 id="4-3-4-小结"><a href="#4-3-4-小结" class="headerlink" title="4.3.4 小结"></a>4.3.4 小结</h5><ul><li>常用的数据类型:<ul><li>整数：int，bit</li><li>小数：decimal</li><li>字符串：varchar,char</li><li>日期时间: date, time, datetime</li><li>枚举类型(enum)</li></ul></li><li>常见的约束:<ul><li>主键约束 primary key</li><li>非空约束 not null</li><li>惟一约束 unique</li><li>默认约束 default</li><li>外键约束 foreign key</li></ul></li><li>数据类型和约束保证了表中数据的准确性和完整性</li></ul><h3 id="5-命令行客户端MySQL的使用"><a href="#5-命令行客户端MySQL的使用" class="headerlink" title="5.命令行客户端MySQL的使用"></a>5.命令行客户端MySQL的使用</h3><h4 id="5-1-登录和登出数据库"><a href="#5-1-登录和登出数据库" class="headerlink" title="5.1 登录和登出数据库"></a>5.1 登录和登出数据库</h4><p><strong>登录数据库:</strong></p><p>输入下面命令:</p><pre><code class="bash">mysql -uroot -p</code></pre><p><strong>说明:</strong></p><ul><li>-u 后面是登录的用户名</li><li>-p 后面是登录密码, 如果不填写, 回车之后会提示输入密码</li></ul><p><strong>登录成功后, 输入如下命令查看效果：</strong></p><pre><code class="sql"># 显示当前时间select now();</code></pre><p><strong>登出(退出)数据库:</strong></p><pre><code class="sql">quit 或 exit 或 ctrl + d</code></pre><h4 id="5-2-数据库操作的SQL语句"><a href="#5-2-数据库操作的SQL语句" class="headerlink" title="5.2 数据库操作的SQL语句"></a>5.2 数据库操作的SQL语句</h4><ol><li><p>查看所有数据库</p><pre><code class="sql">show databases;</code></pre></li><li><p>创建数据库</p><pre><code class="sql">create database 数据库名 charset=utf8;例：create database python charset=utf8;</code></pre></li><li><p>使用数据库</p><pre><code class="sql">use 数据库名;</code></pre></li><li><p>查看当前使用的数据库</p><pre><code class="sql">select database();</code></pre></li><li><p>删除数据库-慎重</p><pre><code class="sql">drop database 数据库名;例：drop database python;</code></pre></li></ol><h4 id="5-3-表结构操作的SQL语句"><a href="#5-3-表结构操作的SQL语句" class="headerlink" title="5.3 表结构操作的SQL语句"></a>5.3 表结构操作的SQL语句</h4><ol><li><p>查看当前数据库中所有表</p><pre><code class="sql">show tables;</code></pre></li><li><p>创建表</p><pre><code class="sql">create table students( id int unsigned primary key auto_increment not null, name varchar(20) not null, age tinyint unsigned default 0, height decimal(5,2), gender enum(&#39;男&#39;,&#39;女&#39;,&#39;人妖&#39;,&#39;保密&#39;) default &#39;保密&#39;);</code></pre><p><strong>说明:</strong></p><pre><code class="sql">create table 表名(字段名称 数据类型  可选的约束条件,column1 datatype contrai,...);</code></pre></li><li><p>修改表-添加字段</p><pre><code class="sql">alter table 表名 add 列名 类型 约束;例：alter table students add birthday datetime;</code></pre></li><li><p>修改表-修改字段类型</p><pre><code class="sql">alter table 表名 modify 列名 类型 约束;例：alter table students modify birthday date not null;</code></pre><p><strong>说明:</strong></p><ul><li>modify: 只能修改字段类型或者约束，不能修改字段名</li></ul></li><li><p>修改表-修改字段名和字段类型</p><pre><code class="sql">alter table 表名 change 原名 新名 类型及约束;例：alter table students change birthday birth datetime not null;</code></pre><p><strong>说明:</strong></p><ul><li>change: 既能对字段重命名又能修改字段类型还能修改约束</li></ul></li><li><p>修改表-删除字段</p><pre><code class="sql">alter table 表名 drop 列名;例：alter table students drop birthday;</code></pre></li><li><p>查看创表SQL语句</p><pre><code class="sql">show create table 表名;例：show create table students;</code></pre></li><li><p>查看创库SQL语句</p><pre><code class="sql">show create database 数据库名;例：show create database mytest;</code></pre></li><li><p>删除表</p><pre><code class="sql">drop table 表名;例：drop table students;</code></pre></li></ol><h4 id="5-4-表数据操作的SQL语句"><a href="#5-4-表数据操作的SQL语句" class="headerlink" title="5.4 表数据操作的SQL语句"></a>5.4 表数据操作的SQL语句</h4><ol><li><p>查询数据</p><pre><code class="sql">-- 1. 查询所有列select * from 表名;例：select * from students;-- 2. 查询指定列select 列1,列2,... from 表名;例：select id,name from students;</code></pre></li><li><p>添加数据</p><pre><code class="sql">-- 1. 全列插入：值的顺序与表结构字段的顺序完全一一对应insert into 表名 values (...)例:insert into students values(0, &#39;xx&#39;, default, default, &#39;男&#39;);-- 2. 部分列插入：值的顺序与给出的列顺序对应insert into 表名 (列1,...) values(值1,...)例:insert into students(name, age) values(&#39;王二小&#39;, 15);-- 3. 全列多行插入insert into 表名 values(...),(...)...;例:insert into students values(0, &#39;张飞&#39;, 55, 1.75, &#39;男&#39;),(0, &#39;关羽&#39;, 58, 1.85, &#39;男&#39;);-- 4. 部分列多行插入insert into 表名(列1,...) values(值1,...),(值1,...)...;例：insert into students(name, height) values(&#39;刘备&#39;, 1.75),(&#39;曹操&#39;, 1.6);</code></pre><p><strong>说明:</strong></p><ul><li>主键列是自动增长，但是在全列插入时需要占位，通常使用空值(0或者null或者default)</li><li>在全列插入时，如果字段列有默认值可以使用 default 来占位，插入后的数据就是之前设置的默认值</li></ul></li><li><p>修改数据</p><pre><code class="sql">update 表名 set 列1=值1,列2=值2... where 条件例：update students set age = 18, gender = &#39;女&#39; where id = 6;</code></pre></li><li><p>删除数据</p><pre><code class="sql">delete from 表名 where 条件例：delete from students where id=5;</code></pre><p>问题:</p><p>上面的操作称之为物理删除，一旦删除就不容易恢复，我们可以使用逻辑删除的方式来解决这个问题。</p><pre><code class="sql">-- 添加删除表示字段，0表示未删除 1表示删除alter table students add isdelete bit default 0;-- 逻辑删除数据update students set isdelete = 1 where id = 8;</code></pre><p><strong>说明:</strong></p><ul><li>逻辑删除，本质就是修改操作</li></ul></li></ol><h3 id="6-as和distinct关键字"><a href="#6-as和distinct关键字" class="headerlink" title="6.as和distinct关键字"></a>6.as和distinct关键字</h3><h4 id="6-1-as关键字"><a href="#6-1-as关键字" class="headerlink" title="6.1 as关键字"></a>6.1 as关键字</h4><p>在使用SQL语句显示结果的时候，往往在屏幕显示的字段名并不具备良好的可读性，此时可以使用 as 给字段起一个别名。</p><ol><li><p>使用 as 给字段起别名</p><pre><code class="sql">select id as 序号, name as 名字, gender as 性别 from students;</code></pre></li><li><p>可以通过 as 给表起别名</p><pre><code class="sql">-- 如果是单表查询 可以省略表名select id, name, gender from students;-- 表名.字段名select students.id,students.name,students.gender from students;-- 可以通过 as 给表起别名 select s.id,s.name,s.gender from students as s;</code></pre></li></ol><h4 id="6-2-distinct关键字"><a href="#6-2-distinct关键字" class="headerlink" title="6.2 distinct关键字"></a>6.2 distinct关键字</h4><p>distinct可以去除重复数据行。</p><pre><code class="sql">select distinct 列1,... from 表名;例： 查询班级中学生的性别select name, gender from students;-- 看到了很多重复数据 想要对其中重复数据行进行去重操作可以使用 distinctselect distinct name, gender from students;</code></pre><h3 id="7-where条件查询"><a href="#7-where条件查询" class="headerlink" title="7.where条件查询"></a>7.where条件查询</h3><h4 id="7-1-where条件查询的介绍"><a href="#7-1-where条件查询的介绍" class="headerlink" title="7.1 where条件查询的介绍"></a>7.1 where条件查询的介绍</h4><p>使用where条件查询可以对表中的数据进行筛选，条件成立的记录会出现在结果集中。</p><p><strong>where语句支持的运算符:</strong></p><ol><li>比较运算符</li><li>逻辑运算符</li><li>模糊查询</li><li>范围查询</li><li>空判断</li></ol><p><strong>where条件查询语法格式如下:</strong></p><pre><code class="sql">select * from 表名 where 条件;例：select * from students where id = 1;</code></pre><h4 id="7-2-比较运算符查询"><a href="#7-2-比较运算符查询" class="headerlink" title="7.2 比较运算符查询"></a>7.2 比较运算符查询</h4><ol><li>等于: =</li><li>大于: &gt;</li><li>大于等于: &gt;=</li><li>小于: &lt;</li><li>小于等于: &lt;=</li><li>不等于: != 或 &lt;&gt;</li></ol><p><strong>例1：查询编号大于3的学生:</strong></p><pre><code class="sql">select * from students where id &gt; 3;</code></pre><p><strong>例2：查询编号不大于4的学生:</strong></p><pre><code class="sql">select * from students where id &lt;= 4;</code></pre><p><strong>例3：查询姓名不是“黄蓉”的学生:</strong></p><pre><code class="sql">select * from students where name != &#39;黄蓉&#39;;</code></pre><p><strong>例4：查询没被删除的学生:</strong></p><pre><code class="sql">select * from students where is_delete=0;</code></pre><h4 id="7-3-逻辑运算符查询"><a href="#7-3-逻辑运算符查询" class="headerlink" title="7.3 逻辑运算符查询"></a>7.3 逻辑运算符查询</h4><ol><li>and</li><li>or</li><li>not</li></ol><p><strong>例1：查询编号大于3的女同学:</strong></p><pre><code class="sql">select * from students where id &gt; 3 and gender=0;</code></pre><p><strong>例2：查询编号小于4或没被删除的学生:</strong></p><pre><code class="sql">select * from students where id &lt; 4 or is_delete=0;</code></pre><p><strong>例3：查询年龄不在10岁到15岁之间的学生:</strong></p><pre><code class="sql">select * from students where not (age &gt;= 10 and age &lt;= 15);</code></pre><p><strong>说明:</strong></p><ul><li>多个条件判断想要作为一个整体，可以结合‘()’。</li></ul><h4 id="7-4-模糊查询"><a href="#7-4-模糊查询" class="headerlink" title="7.4 模糊查询"></a>7.4 模糊查询</h4><ol><li>like是模糊查询关键字</li><li>%表示任意多个任意字符</li><li>_表示一个任意字符</li></ol><p><strong>例1：查询姓黄的学生:</strong></p><pre><code class="sql">select * from students where name like &#39;黄%&#39;;</code></pre><p><strong>例2：查询姓黄并且“名”是一个字的学生:</strong></p><pre><code class="sql">select * from students where name like &#39;黄_&#39;;</code></pre><p><strong>例3：查询姓黄或叫靖的学生:</strong></p><pre><code class="sql">select * from students where name like &#39;黄%&#39; or name like &#39;%靖&#39;;</code></pre><h4 id="7-5-范围查询"><a href="#7-5-范围查询" class="headerlink" title="7.5 范围查询"></a>7.5 范围查询</h4><ol><li>between .. and .. 表示在一个连续的范围内查询</li><li>in 表示在一个非连续的范围内查询</li></ol><p><strong>例1：查询编号为3至8的学生:</strong></p><pre><code class="sql">select * from students where id between 3 and 8;</code></pre><p><strong>例2：查询编号不是3至8的男生:</strong></p><pre><code>select * from students where (not id between 3 and 8) and gender=&#39;男&#39;;</code></pre><h4 id="7-6-空判断查询"><a href="#7-6-空判断查询" class="headerlink" title="7.6 空判断查询"></a>7.6 空判断查询</h4><ol><li>判断为空使用: is null</li><li>判断非空使用: is not null</li></ol><p><strong>例1：查询没有填写身高的学生:</strong></p><pre><code class="sql">select * from students where height is null;</code></pre><p><strong>注意:</strong></p><ol><li>不能使用 where height = null 判断为空</li><li>不能使用 where height != null 判断非空</li><li>null 不等于 ‘’ 空字符串</li></ol><h3 id="8-排序"><a href="#8-排序" class="headerlink" title="8.排序"></a>8.排序</h3><h4 id="8-1-排序查询语法"><a href="#8-1-排序查询语法" class="headerlink" title="8.1 排序查询语法"></a>8.1 排序查询语法</h4><p>排序查询语法：</p><pre><code class="sql">select * from 表名 order by 列1 asc|desc [,列2 asc|desc,...]</code></pre><p><strong>语法说明:</strong></p><ol><li>先按照列1进行排序，如果列1的值相同时，则按照 列2 排序，以此类推</li><li>asc从小到大排列，即升序</li><li>desc从大到小排序，即降序</li><li>默认按照列值从小到大排序（即asc关键字）</li></ol><p><strong>例1：查询未删除男生信息，按学号降序:</strong></p><pre><code class="sql">select * from students where gender=1 and is_delete=0 order by id desc;</code></pre><p><strong>例2：显示所有的学生信息，先按照年龄从大–&gt;小排序，当年龄相同时 按照身高从高–&gt;矮排序:</strong></p><pre><code class="sql">select * from students  order by age desc,height desc;</code></pre><p>小结：</p><ol><li>排序使用 order by 关键字</li><li>asc 表示升序</li><li>desc 表示降序</li></ol><h3 id="9-分页查询"><a href="#9-分页查询" class="headerlink" title="9.分页查询"></a>9.分页查询</h3><h4 id="9-1-分页查询的介绍"><a href="#9-1-分页查询的介绍" class="headerlink" title="9.1 分页查询的介绍"></a>9.1 分页查询的介绍</h4><p>当我们在京东购物，浏览商品列表的时候，由于数据特别多，一页显示不完，一页一页的进行显示，这就是分页查询</p><h4 id="9-2-分页查询的语法"><a href="#9-2-分页查询的语法" class="headerlink" title="9.2 分页查询的语法"></a>9.2 分页查询的语法</h4><pre><code class="sql">select * from 表名 limit start,count</code></pre><p><strong>说明:</strong></p><ol><li>limit是分页查询关键字</li><li>start表示开始行索引，默认是0</li><li>count表示查询条数</li></ol><p><strong>例1：查询前3行男生信息:</strong></p><pre><code class="sql">select * from students where gender=1 limit 0,3;简写select * from students where gender=1 limit 3;</code></pre><h4 id="9-3-分页查询案例"><a href="#9-3-分页查询案例" class="headerlink" title="9.3 分页查询案例"></a>9.3 分页查询案例</h4><p>已知每页显示m条数据，求第n页显示的数据</p><p>提示: 关键是求每页的开始行索引</p><p><strong>查询学生表，获取第n页数据的SQL语句:</strong></p><pre><code class="sql">select * from students limit (n-1)*m,m</code></pre><h2 id="二、MySQL数据库的条件查询"><a href="#二、MySQL数据库的条件查询" class="headerlink" title="二、MySQL数据库的条件查询"></a>二、MySQL数据库的条件查询</h2><h3 id="1-聚合函数"><a href="#1-聚合函数" class="headerlink" title="1.聚合函数"></a>1.聚合函数</h3><h4 id="1-1-聚合函数的介绍"><a href="#1-1-聚合函数的介绍" class="headerlink" title="1.1 聚合函数的介绍"></a>1.1 聚合函数的介绍</h4><p>聚合函数又叫组函数，通常是对表中的数据进行统计和计算，一般结合分组(group by)来使用，用于统计和计算分组数据。</p><p><strong>常用的聚合函数:</strong></p><ol><li>count(col): 表示求指定列的总行数</li><li>max(col): 表示求指定列的最大值</li><li>min(col): 表示求指定列的最小值</li><li>sum(col): 表示求指定列的和</li><li>avg(col): 表示求指定列的平均值</li></ol><h4 id="1-2-求总行数"><a href="#1-2-求总行数" class="headerlink" title="1.2 求总行数"></a>1.2 求总行数</h4><pre><code class="sql">-- 返回非NULL数据的总行数.select count(height) from students; -- 返回总行数，包含null值记录;select count(*) from students;</code></pre><h4 id="1-3-求最大值"><a href="#1-3-求最大值" class="headerlink" title="1.3 求最大值"></a>1.3 求最大值</h4><pre><code class="sql">-- 查询女生的编号最大值select max(id) from students where gender = 2;</code></pre><h4 id="1-4-求最小值"><a href="#1-4-求最小值" class="headerlink" title="1.4 求最小值"></a>1.4 求最小值</h4><pre><code class="sql">-- 查询未删除的学生最小编号select min(id) from students where is_delete = 0;</code></pre><h4 id="1-5-求和"><a href="#1-5-求和" class="headerlink" title="1.5 求和"></a>1.5 求和</h4><pre><code class="sql">-- 查询男生的总身高select sum(height) from students where gender = 1;-- 平均身高select sum(height) / count(*) from students where gender = 1;</code></pre><h4 id="1-6-求平均值"><a href="#1-6-求平均值" class="headerlink" title="1.6 求平均值"></a>1.6 求平均值</h4><pre><code class="sql">-- 求男生的平均身高, 聚合函数不统计null值，平均身高有误select avg(height) from students where gender = 1;-- 求男生的平均身高, 包含身高是null的select avg(ifnull(height,0)) from students where gender = 1;</code></pre><p><strong>说明</strong></p><ul><li>ifnull函数: 表示判断指定字段的值是否为null，如果为空使用自己提供的值。</li></ul><h4 id="1-7-聚合函数的特点"><a href="#1-7-聚合函数的特点" class="headerlink" title="1.7 聚合函数的特点"></a>1.7 聚合函数的特点</h4><ul><li>聚合函数默认忽略字段为null的记录 要想列值为null的记录也参与计算，必须使用ifnull函数对null值做替换。</li></ul><h3 id="2-分组查询"><a href="#2-分组查询" class="headerlink" title="2. 分组查询"></a>2. 分组查询</h3><ul><li>group by 根据指定的一个或者多个字段对数据进行分组</li><li>group_concat(字段名)函数是统计每个分组指定字段的信息集合</li><li>聚合函数在和 group by 结合使用时, 聚合函数统计和计算的是每个分组的数据</li><li>having 是对分组数据进行条件过滤</li><li>with rollup在最后记录后面新增一行，显示select查询时聚合函数的统计和计算结果</li></ul><h4 id="2-1-分组查询介绍"><a href="#2-1-分组查询介绍" class="headerlink" title="2.1 分组查询介绍"></a>2.1 分组查询介绍</h4><p>分组查询就是将查询结果按照指定字段进行分组，字段中数据相等的分为一组。</p><p><strong>分组查询基本的语法格式如下：</strong></p><p>GROUP BY 列名 [HAVING 条件表达式] [WITH ROLLUP]</p><p><strong>说明:</strong></p><ul><li>列名: 是指按照指定字段的值进行分组。</li><li>HAVING 条件表达式: 用来过滤分组后的数据。</li><li>WITH ROLLUP：在所有记录的最后加上一条记录，显示select查询时聚合函数的统计和计算结果</li></ul><h4 id="2-2-group-by的使用"><a href="#2-2-group-by的使用" class="headerlink" title="2.2 group by的使用"></a>2.2 group by的使用</h4><p>group by可用于单个字段分组，也可用于多个字段分组</p><pre><code class="sql">-- 根据gender字段来分组select gender from students group by gender;-- 根据name和gender字段进行分组select name, gender from students group by name, gender;</code></pre><h4 id="2-3-group-by-group-concat-的使用"><a href="#2-3-group-by-group-concat-的使用" class="headerlink" title="2.3 group by + group_concat()的使用"></a>2.3 group by + group_concat()的使用</h4><p>group_concat(字段名): 统计每个分组指定字段的信息集合，每个信息之间使用逗号进行分割</p><pre><code class="sql">-- 根据gender字段进行分组， 查询gender字段和分组的name字段信息select gender,group_concat(name) from students group by gender;</code></pre><h4 id="2-4-group-by-聚合函数的使用"><a href="#2-4-group-by-聚合函数的使用" class="headerlink" title="2.4 group by + 聚合函数的使用"></a>2.4 group by + 聚合函数的使用</h4><pre><code class="sql">-- 统计不同性别的人的平均年龄select gender,avg(age) from students group by gender;-- 统计不同性别的人的个数select gender,count(*) from students group by gender;</code></pre><h4 id="2-5-group-by-having的使用"><a href="#2-5-group-by-having的使用" class="headerlink" title="2.5 group by + having的使用"></a>2.5 group by + having的使用</h4><p>having作用和where类似都是过滤数据的，但having是过滤分组数据的，只能用于group by</p><pre><code class="sql">-- 根据gender字段进行分组，统计分组条数大于2的select gender,count(*) from students group by gender having count(*)&gt;2;</code></pre><h4 id="2-6-group-by-with-rollup的使用"><a href="#2-6-group-by-with-rollup的使用" class="headerlink" title="2.6 group by + with rollup的使用"></a>2.6 group by + with rollup的使用</h4><p>with rollup的作用是：在最后记录后面新增一行，显示select查询时聚合函数的统计和计算结果</p><pre><code class="sql">-- 根据gender字段进行分组，汇总总人数select gender,count(*) from students group by gender with rollup;-- 根据gender字段进行分组，汇总所有人的年龄select gender,group_concat(age) from students group by gender with rollup;</code></pre><h3 id="3-连接查询-内连接"><a href="#3-连接查询-内连接" class="headerlink" title="3.连接查询-内连接"></a>3.连接查询-内连接</h3><ul><li>内连接使用inner join .. on .., on 表示两个表的连接查询条件</li><li>内连接根据连接查询条件取出两个表的 “交集”</li></ul><h4 id="3-1-连接查询的介绍"><a href="#3-1-连接查询的介绍" class="headerlink" title="3.1 连接查询的介绍"></a>3.1 连接查询的介绍</h4><p>连接查询可以实现多个表的查询，当查询的字段数据来自不同的表就可以使用连接查询来完成。</p><p>连接查询可以分为:</p><ol><li>内连接查询</li><li>左连接查询</li><li>右连接查询</li><li>自连接查询</li></ol><h4 id="3-2-内连接查询"><a href="#3-2-内连接查询" class="headerlink" title="3.2 内连接查询"></a>3.2 内连接查询</h4><p>查询两个表中符合条件的共有记录</p><p><strong>内连接查询效果图:</strong></p><p><img src="E:%5Ccaijinbo_posts%5Cpicture%5C%E5%86%85%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2.png" alt="内连接查询"></p><p><strong>内连接查询语法格式:</strong></p><pre><code class="sql">select 字段 from 表1 inner join 表2 on 表1.字段1 = 表2.字段2</code></pre><p><strong>说明:</strong></p><ul><li>inner join 就是内连接查询关键字</li><li>on 就是连接查询条件</li></ul><p><strong>例1：使用内连接查询学生表与班级表:</strong></p><pre><code class="sql">select * from students as s inner join classes as c on s.cls_id = c.id;</code></pre><h3 id="4-连接查询-左连接"><a href="#4-连接查询-左连接" class="headerlink" title="4.连接查询-左连接"></a>4.连接查询-左连接</h3><ul><li>左连接使用left join .. on .., on 表示两个表的连接查询条件</li><li>左连接以左表为主根据条件查询右表数据，右表数据不存在使用null值填充。</li></ul><h4 id="4-1-左连接查询"><a href="#4-1-左连接查询" class="headerlink" title="4.1 左连接查询"></a>4.1 左连接查询</h4><p>以左表为主根据条件查询右表数据，如果根据条件查询右表数据不存在使用null值填充</p><p><strong>左连接查询效果图:</strong></p><p><img src="E:%5Ccaijinbo_posts%5Cpicture/%E5%B7%A6%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2.png" alt="内连接查询"></p><p><strong>左连接查询语法格式:</strong></p><pre><code class="sql">select 字段 from 表1 left join 表2 on 表1.字段1 = 表2.字段2</code></pre><p><strong>说明:</strong></p><ul><li>left join 就是左连接查询关键字</li><li>on 就是连接查询条件</li><li>表1 是左表</li><li>表2 是右表</li></ul><p><strong>例1：使用左连接查询学生表与班级表:</strong></p><pre><code class="sql">select * from students as s left join classes as c on s.cls_id = c.id;</code></pre><h3 id="5-连接查询-右连接"><a href="#5-连接查询-右连接" class="headerlink" title="5.连接查询-右连接"></a>5.连接查询-右连接</h3><ul><li>右连接使用right join .. on .., on 表示两个表的连接查询条件</li><li>右连接以右表为主根据条件查询左表数据，左表数据不存在使用null值填充。</li></ul><h4 id="5-1-右连接查询"><a href="#5-1-右连接查询" class="headerlink" title="5.1 右连接查询"></a>5.1 右连接查询</h4><p>以右表为主根据条件查询左表数据，如果根据条件查询左表数据不存在使用null值填充</p><p><strong>右连接查询效果图:</strong></p><p><img src="E:%5Ccaijinbo_posts%5Cpicture/%E5%8F%B3%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2.png" alt="内连接查询"></p><p><strong>右连接查询语法格式:</strong></p><pre><code class="sql">select 字段 from 表1 right join 表2 on 表1.字段1 = 表2.字段2</code></pre><p><strong>说明:</strong></p><ul><li>right join 就是右连接查询关键字</li><li>on 就是连接查询条件</li><li>表1 是左表</li><li>表2 是右表</li></ul><p><strong>例1：使用右连接查询学生表与班级表:</strong></p><pre><code class="sql">select * from students as s right join classes as c on s.cls_id = c.id;</code></pre><h3 id="6-连接查询-自连接"><a href="#6-连接查询-自连接" class="headerlink" title="6.连接查询-自连接"></a>6.连接查询-自连接</h3><ul><li>自连接查询就是把一张表模拟成左右两张表，然后进行连表查询。</li><li>自连接就是一种特殊的连接方式，连接的表还是本身这张表</li></ul><h4 id="6-1-自连接查询"><a href="#6-1-自连接查询" class="headerlink" title="6.1 自连接查询"></a>6.1 自连接查询</h4><p>左表和右表是同一个表，根据连接查询条件查询两个表中的数据。</p><p><strong>自连接查询的用法:</strong></p><pre><code class="sql">select c.title, c.pid, p.id, p.title from areas as c inner join areas as p on c.pid = p.id where p.title = &#39;目标&#39;;</code></pre><p><strong>说明:</strong></p><ul><li><strong>自连接查询必须对表起别名</strong></li></ul><p><strong>这个直连接没有配图说明，可能会难以理解</strong></p><h3 id="7-子查询"><a href="#7-子查询" class="headerlink" title="7.子查询"></a>7.子查询</h3><h4 id="7-1-子查询的介绍"><a href="#7-1-子查询的介绍" class="headerlink" title="7.1 子查询的介绍"></a>7.1 子查询的介绍</h4><p>在一个 select 语句中,嵌入了另外一个 select 语句, 那么被嵌入的 select 语句称之为子查询语句，外部那个select语句则称为主查询.</p><p><strong>主查询和子查询的关系:</strong></p><ol><li>子查询是嵌入到主查询中</li><li>子查询是辅助主查询的,要么充当条件,要么充当数据源</li><li>子查询是可以独立存在的语句,是一条完整的 select 语句</li></ol><h4 id="7-2-子查询的使用"><a href="#7-2-子查询的使用" class="headerlink" title="7.2 子查询的使用"></a>7.2 子查询的使用</h4><p><strong>例1. 查询大于平均年龄的学生:</strong></p><pre><code class="sql">select * from students where age &gt; (select avg(age) from students);</code></pre><p><strong>例2. 查询学生在班的所有班级名字:</strong></p><pre><code class="sql">select name from classes where id in (select cls_id from students where cls_id is not null);</code></pre><p><strong>例3. 查找年龄最大,身高最高的学生:</strong></p><pre><code class="sql">select * from students where (age, height) =  (select max(age), max(height) from students);</code></pre><h4 id="7-3-小结"><a href="#7-3-小结" class="headerlink" title="7.3 小结"></a>7.3 小结</h4><ul><li>子查询是一个完整的SQL语句，子查询被嵌入到一对小括号里面</li></ul><h3 id="8-数据库设计之三范式"><a href="#8-数据库设计之三范式" class="headerlink" title="8.数据库设计之三范式"></a>8.数据库设计之三范式</h3><h4 id="8-1-数据库设计之三范式的介绍"><a href="#8-1-数据库设计之三范式的介绍" class="headerlink" title="8.1 数据库设计之三范式的介绍"></a>8.1 数据库设计之三范式的介绍</h4><p>范式: 对设计数据库提出的一些规范，目前有迹可寻的共有8种范式，一般遵守3范式即可。</p><ul><li>第一范式（1NF）: 强调的是列的原子性，即列不能够再分成其他几列。</li><li>第二范式（2NF）: 满足 1NF，另外包含两部分内容，一是表必须有一个主键；二是非主键字段 必须完全依赖于主键，而不能只依赖于主键的一部分。</li><li>第三范式（3NF）: 满足 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。</li></ul><h4 id="8-2-E-R模型的介绍"><a href="#8-2-E-R模型的介绍" class="headerlink" title="8.2 E-R模型的介绍"></a>8.2 E-R模型的介绍</h4><ul><li>E-R模型由 实体、属性、实体之间的关系构成，主要用来描述数据库中表结构。</li><li>开发流程是先画出E-R模型，然后根据三范式设计数据库中的表结构</li></ul><p>E-R模型即实体-关系模型，E-R模型就是描述数据库存储数据的结构模型。</p><p><strong>E-R模型的使用场景:</strong></p><ol><li>对于大型公司开发项目，我们需要根据产品经理的设计，我们先使用建模工具, 如:power designer，db desinger等这些软件来画出实体-关系模型(E-R模型)</li><li>然后根据三范式设计数据库表结构</li></ol><p><strong>E-R模型的效果图:</strong></p><p><img src="E:%5Ccaijinbo_posts%5Cpicture/E-R%E6%A8%A1%E5%9E%8B%E5%9B%BE.png" alt="E-R模型图"></p><p><strong>说明:</strong></p><ul><li>实体: 用矩形表示，并标注实体名称</li><li>属性: 用椭圆表示，并标注属性名称，</li><li>关系: 用菱形表示，并标注关系名称<ul><li>一对一</li><li>一对多</li><li>多对多</li></ul></li></ul><p><strong>一对多的关系:</strong></p><p><strong>说明:</strong></p><ul><li>关系也是一种数据，需要通过一个字段存储在表中</li><li>1对1关系，在表A或表B中创建一个字段，存储另一个表的主键值</li></ul><p><strong>一对多的关系:</strong></p><p><strong>说明:</strong></p><ul><li>1对多关系，在多的一方表(学生表)中创建一个字段，存储班级表的主键值</li></ul><p><strong>多对多的关系:</strong></p><p><strong>说明:</strong></p><ul><li>多对多关系，新建一张表C，这个表只有两个字段，一个用于存储A的主键值，一个用于存储B的主键值</li></ul><h3 id="9-外键SQL语句的编写"><a href="#9-外键SQL语句的编写" class="headerlink" title="9.外键SQL语句的编写"></a>9.外键SQL语句的编写</h3><ul><li>添加外键约束: alter table 从表 add foreign key(外键字段) references 主表(主键字段);</li><li>删除外键约束: alter table 表名 drop foreign key 外键名;</li></ul><h4 id="9-1-外键约束作用"><a href="#9-1-外键约束作用" class="headerlink" title="9.1 外键约束作用"></a>9.1 外键约束作用</h4><p>外键约束:对外键字段的值进行更新和插入时会和引用表中字段的数据进行验证，数据如果不合法则更新和插入会失败，保证数据的有效性</p><h4 id="9-2-对于已经存在的字段添加外键约束"><a href="#9-2-对于已经存在的字段添加外键约束" class="headerlink" title="9.2 对于已经存在的字段添加外键约束"></a>9.2 对于已经存在的字段添加外键约束</h4><pre><code class="sql">-- 为cls_id字段添加外键约束alter table students add foreign key(cls_id) references classes(id);</code></pre><h4 id="9-3-在创建数据表时设置外键约束"><a href="#9-3-在创建数据表时设置外键约束" class="headerlink" title="9.3 在创建数据表时设置外键约束"></a>9.3 在创建数据表时设置外键约束</h4><pre><code class="sql">-- 创建学校表create table school(    id int not null primary key auto_increment,     name varchar(10));-- 创建老师表create table teacher(    id int not null primary key auto_increment,     name varchar(10),     s_id int not null,     foreign key(s_id) references school(id));</code></pre><h4 id="9-4-删除外键约束"><a href="#9-4-删除外键约束" class="headerlink" title="9.4 删除外键约束"></a>9.4 删除外键约束</h4><pre><code class="sql">-- 需要先获取外键约束名称,该名称系统会自动生成,可以通过查看表创建语句来获取名称show create table teacher;-- 获取名称之后就可以根据名称来删除外键约束alter table teacher drop foreign key 外键名;</code></pre><h3 id="10-演练-分组和聚合函数的组合使用"><a href="#10-演练-分组和聚合函数的组合使用" class="headerlink" title="10.演练-分组和聚合函数的组合使用"></a>10.演练-分组和聚合函数的组合使用</h3><h4 id="10-1-数据准备"><a href="#10-1-数据准备" class="headerlink" title="10.1 数据准备"></a>10.1 数据准备</h4><pre><code class="sql">-- 创建 &quot;京东&quot; 数据库create database jing_dong charset=utf8;-- 使用 &quot;京东&quot; 数据库use jing_dong;-- 创建一个商品goods数据表create table goods(    id int unsigned primary key auto_increment not null,    name varchar(150) not null,    cate_name varchar(40) not null,    brand_name varchar(40) not null,    price decimal(10,3) not null default 0,    is_show bit not null default 1,    is_saleoff bit not null default 0);-- 向goods表中插入数据insert into goods values(0,&#39;r510vc 15.6英寸笔记本&#39;,&#39;笔记本&#39;,&#39;华硕&#39;,&#39;3399&#39;,default,default); insert into goods values(0,&#39;y400n 14.0英寸笔记本电脑&#39;,&#39;笔记本&#39;,&#39;联想&#39;,&#39;4999&#39;,default,default);insert into goods values(0,&#39;g150th 15.6英寸游戏本&#39;,&#39;游戏本&#39;,&#39;雷神&#39;,&#39;8499&#39;,default,default); insert into goods values(0,&#39;x550cc 15.6英寸笔记本&#39;,&#39;笔记本&#39;,&#39;华硕&#39;,&#39;2799&#39;,default,default); insert into goods values(0,&#39;x240 超极本&#39;,&#39;超级本&#39;,&#39;联想&#39;,&#39;4880&#39;,default,default); insert into goods values(0,&#39;u330p 13.3英寸超极本&#39;,&#39;超级本&#39;,&#39;联想&#39;,&#39;4299&#39;,default,default); insert into goods values(0,&#39;svp13226scb 触控超极本&#39;,&#39;超级本&#39;,&#39;索尼&#39;,&#39;7999&#39;,default,default); insert into goods values(0,&#39;ipad mini 7.9英寸平板电脑&#39;,&#39;平板电脑&#39;,&#39;苹果&#39;,&#39;1998&#39;,default,default);insert into goods values(0,&#39;ipad air 9.7英寸平板电脑&#39;,&#39;平板电脑&#39;,&#39;苹果&#39;,&#39;3388&#39;,default,default); insert into goods values(0,&#39;ipad mini 配备 retina 显示屏&#39;,&#39;平板电脑&#39;,&#39;苹果&#39;,&#39;2788&#39;,default,default); insert into goods values(0,&#39;ideacentre c340 20英寸一体电脑 &#39;,&#39;台式机&#39;,&#39;联想&#39;,&#39;3499&#39;,default,default); insert into goods values(0,&#39;vostro 3800-r1206 台式电脑&#39;,&#39;台式机&#39;,&#39;戴尔&#39;,&#39;2899&#39;,default,default); insert into goods values(0,&#39;imac me086ch/a 21.5英寸一体电脑&#39;,&#39;台式机&#39;,&#39;苹果&#39;,&#39;9188&#39;,default,default); insert into goods values(0,&#39;at7-7414lp 台式电脑 linux ）&#39;,&#39;台式机&#39;,&#39;宏碁&#39;,&#39;3699&#39;,default,default); insert into goods values(0,&#39;z220sff f4f06pa工作站&#39;,&#39;服务器/工作站&#39;,&#39;惠普&#39;,&#39;4288&#39;,default,default); insert into goods values(0,&#39;poweredge ii服务器&#39;,&#39;服务器/工作站&#39;,&#39;戴尔&#39;,&#39;5388&#39;,default,default); insert into goods values(0,&#39;mac pro专业级台式电脑&#39;,&#39;服务器/工作站&#39;,&#39;苹果&#39;,&#39;28888&#39;,default,default); insert into goods values(0,&#39;hmz-t3w 头戴显示设备&#39;,&#39;笔记本配件&#39;,&#39;索尼&#39;,&#39;6999&#39;,default,default); insert into goods values(0,&#39;商务双肩背包&#39;,&#39;笔记本配件&#39;,&#39;索尼&#39;,&#39;99&#39;,default,default); insert into goods values(0,&#39;x3250 m4机架式服务器&#39;,&#39;服务器/工作站&#39;,&#39;ibm&#39;,&#39;6888&#39;,default,default); insert into goods values(0,&#39;商务双肩背包&#39;,&#39;笔记本配件&#39;,&#39;索尼&#39;,&#39;99&#39;,default,default);</code></pre><p><strong>表结构说明:</strong></p><ul><li>id 表示主键 自增</li><li>name 表示商品名称</li><li>cate_name 表示分类名称</li><li>brand_name 表示品牌名称</li><li>price 表示价格</li><li>is_show 表示是否显示</li><li>is_saleoff 表示是否售完</li></ul><h4 id="10-2-SQL语句演练"><a href="#10-2-SQL语句演练" class="headerlink" title="10.2 SQL语句演练"></a>10.2 SQL语句演练</h4><ol><li><p>查询类型cate_name为 ‘超级本’ 的商品名称、价格</p><pre><code class="sql"> select name,price from goods where cate_name = &#39;超级本&#39;;</code></pre></li><li><p>显示商品的分类</p><pre><code class="sql"> select cate_name from goods group by cate_name;</code></pre></li><li><p>求所有电脑产品的平均价格,并且保留两位小数</p><pre><code class="sql"> select round(avg(price),2) as avg_price from goods;</code></pre></li><li><p>显示每种商品的平均价格</p><pre><code class="sql"> select cate_name,avg(price) from goods group by cate_name;</code></pre></li><li><p>查询每种类型的商品中 最贵、最便宜、平均价、数量</p><pre><code class="sql"> select cate_name,max(price),min(price),avg(price),count(*)  from goods group by cate_name;</code></pre></li><li><p>查询所有价格大于平均价格的商品，并且按价格降序排序</p><pre><code class="sql"> select id,name,price from goods  where price &gt; (select round(avg(price),2) as avg_price from goods)  order by price desc;</code></pre></li></ol><h2 id="三、MySQL数据库的高级使用"><a href="#三、MySQL数据库的高级使用" class="headerlink" title="三、MySQL数据库的高级使用"></a>三、MySQL数据库的高级使用</h2><h3 id="1-将查询结果插入到其它表中"><a href="#1-将查询结果插入到其它表中" class="headerlink" title="1.将查询结果插入到其它表中"></a>1.将查询结果插入到其它表中</h3><h4 id="1-1-思考"><a href="#1-1-思考" class="headerlink" title="1.1 思考"></a>1.1 思考</h4><p>目前只有一个goods表，我们想要增加一个商品分类信息，比如：移动设备这个分类信息，只通过goods表无法完成商品分类的添加，那么如何实现添加商品分类信息的操作?</p><p><strong>答案:</strong></p><ol><li>创建一个商品分类表，把goods表中的商品分类信息添加到该表中。</li><li>将goods表中的分类名称更改成商品分类表中对应的分类id</li></ol><h4 id="2-2-创建商品分类表"><a href="#2-2-创建商品分类表" class="headerlink" title="2.2 创建商品分类表"></a>2.2 创建商品分类表</h4><pre><code class="sql">-- 创建商品分类表create table good_cates(    id int not null primary key auto_increment,     name varchar(50) not null);</code></pre><h4 id="1-3-把goods表中的商品分类添加到商品分类表"><a href="#1-3-把goods表中的商品分类添加到商品分类表" class="headerlink" title="1.3 把goods表中的商品分类添加到商品分类表"></a>1.3 把goods表中的商品分类添加到商品分类表</h4><pre><code class="sql">-- 查询goods表中商品的分类信息select cate_name from goods group by cate_name;-- 将查询结果插入到good_cates表中insert into good_cates(name) select cate_name from goods group by cate_name;-- 添加移动设备分类信息insert into good_cates(name) values(&#39;移动设备&#39;);</code></pre><p><strong>说明:</strong></p><ul><li>insert into .. select .. 表示: 把查询结果插入到指定表中，也就是表复制。</li></ul><h4 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h4><ul><li>想要完成表复制可以使用: insert into .. select .. SQL语句</li></ul><h3 id="2-使用连接更新表中某个字段数据"><a href="#2-使用连接更新表中某个字段数据" class="headerlink" title="2.使用连接更新表中某个字段数据"></a>2.使用连接更新表中某个字段数据</h3><h4 id="2-1-更新goods表中的商品分类信息"><a href="#2-1-更新goods表中的商品分类信息" class="headerlink" title="2.1 更新goods表中的商品分类信息"></a>2.1 更新goods表中的商品分类信息</h4><p>上一节课我们已经创建了一个商品分类表(good_cates)，并完成了商品分类信息的插入，现在需要更新goods表中的商品分类信息，把商品分类名称改成商量分类id。</p><p>接下来我们实现第二步操作:</p><ul><li><strong>将goods表中的分类名称更改成商品分类表中对应的分类id</strong></li></ul><pre><code class="sql">-- 查看goods表中的商品分类名称对应的商品分类idselect * from goods inner join good_cates on goods.cate_name = good_cates.name;-- 把该语句中from 后的语句理解为一张虚表  update goods g inner join good_cates gc on g.cate_name=gc.name set g.cate_name=gc.id;</code></pre><h4 id="2-2-小结"><a href="#2-2-小结" class="headerlink" title="2.2 小结"></a>2.2 小结</h4><ul><li>连接更新表中数据使用: update .. join .. 语句</li></ul><h3 id="3-创建表并给某个字段添加数据"><a href="#3-创建表并给某个字段添加数据" class="headerlink" title="3.创建表并给某个字段添加数据"></a>3.创建表并给某个字段添加数据</h3><h4 id="3-1-思考"><a href="#3-1-思考" class="headerlink" title="3.1 思考"></a>3.1 思考</h4><p>前面我们完成了商品分类表(good_cates)的创建和商品分类信息的添加以及把商品表(goods)中的商品分类名称改成了对应的商品分类id，假如我们想要添加一个品牌，比如：双飞燕这个品牌信息，只通过goods表无法完成品牌信息的添加，那么如何实现添加品牌信息的操作?</p><p><strong>答案:</strong></p><ol><li>创建一个品牌表，把goods表中的品牌信息添加到该表中。</li><li>将goods表中的品牌名称更改成品牌表中对应的品牌id</li></ol><h4 id="3-2-创建品牌表"><a href="#3-2-创建品牌表" class="headerlink" title="3.2 创建品牌表"></a>3.2 创建品牌表</h4><pre><code class="sql">-- 查询品牌信息 select brand_name from goods group by brand_name;-- 通过create table ...select来创建数据表并且同时插入数据-- 创建商品分类表，注意: 需要对brand_name 用as起别名，否则name字段就没有值create table good_brands (     id int unsigned primary key auto_increment,     name varchar(40) not null) select brand_name as name from goods group by brand_name;</code></pre><p><strong>说明:</strong></p><ul><li>create table .. select 列名 .. 表示创建表并插入数据</li></ul><h4 id="3-3-更新goods表中的品牌信息"><a href="#3-3-更新goods表中的品牌信息" class="headerlink" title="3.3 更新goods表中的品牌信息"></a>3.3 更新goods表中的品牌信息</h4><pre><code class="sql">-- 将goods表中的品牌名称更改成品牌表中对应的品牌idupdate goods as g inner join good_brands gb on g.brand_name = gb.name set g.brand_name = gb.id;</code></pre><h4 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h4><ul><li>创建表并给字段插入数据使用: create table .. select 语句</li></ul><h3 id="4-修改goods表结构"><a href="#4-修改goods表结构" class="headerlink" title="4.修改goods表结构"></a>4.修改goods表结构</h3><h4 id="4-1-修改goods表结构"><a href="#4-1-修改goods表结构" class="headerlink" title="4.1 修改goods表结构"></a>4.1 修改goods表结构</h4><p>目前我们已经把good表中的商品分类和品牌信息已经更改成了商品分类id和品牌id，接下来需要把 cate_name 和 brand_name 字段分别改成 cate_id和 brand_id 字段，类型都改成int类型</p><pre><code class="sql">-- 查看表结构desc goods;-- 通过alter table语句修改表结构alter table goods change cate_name cate_id int not null, change brand_name brand_id int not null;</code></pre><p><strong>说明:</strong></p><ul><li>alert table 可以同时修改多个字段信息</li></ul><h4 id="4-2-小结"><a href="#4-2-小结" class="headerlink" title="4.2 小结"></a>4.2 小结</h4><ul><li>修改表结构可以使用: alter table 语句，多个修改字段之间使用逗号分隔</li></ul><h3 id="5-事务"><a href="#5-事务" class="headerlink" title="5.事务"></a>5.事务</h3><h4 id="5-1-事务的介绍"><a href="#5-1-事务的介绍" class="headerlink" title="5.1 事务的介绍"></a>5.1 事务的介绍</h4><p>事务就是用户定义的一系列执行SQL语句的操作, 这些操作要么完全地执行，要么完全地都不执行， 它是一个不可分割的工作执行单元。</p><p><strong>事务的使用场景:</strong></p><p>在日常生活中，有时我们需要进行银行转账，这个银行转账操作背后就是需要执行多个SQL语句，假如这些SQL执行到一半突然停电了，那么就会导致这个功能只完成了一半，这种情况是不允许出现，要想解决这个问题就需要通过事务来完成。</p><h4 id="5-2-事务的四大特性"><a href="#5-2-事务的四大特性" class="headerlink" title="5.2 事务的四大特性"></a>5.2 事务的四大特性</h4><ul><li>原子性(Atomicity)</li><li>一致性(Consistency)</li><li>隔离性(Isolation)</li><li>持久性(Durability)</li></ul><p><strong>原子性:</strong></p><p>一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性</p><p><strong>一致性:</strong></p><p>数据库总是从一个一致性的状态转换到另一个一致性的状态。（在前面的例子中，一致性确保了，即使在转账过程中系统崩溃，支票账户中也不会损失200美元，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。）</p><p><strong>隔离性:</strong></p><p>通常来说，一个事务所做的修改操作在提交事务之前，对于其他事务来说是不可见的。（在前面的例子中，当执行完第三条语句、第四条语句还未开始时，此时有另外的一个账户汇总程序开始运行，则其看到支票帐户的余额并没有被减去200美元。）</p><p><strong>持久性:</strong></p><p>一旦事务提交，则其所做的修改会永久保存到数据库。</p><p><strong>说明:</strong></p><p>事务能够保证数据的完整性和一致性，让用户的操作更加安全。</p><h4 id="5-3-事务的使用"><a href="#5-3-事务的使用" class="headerlink" title="5.3 事务的使用"></a>5.3 事务的使用</h4><p>在使用事务之前，先要确保表的存储引擎是 InnoDB 类型, 只有这个类型才可以使用事务，MySQL数据库中表的存储引擎默认是 InnoDB 类型。</p><p><strong>表的存储引擎说明:</strong></p><p>表的存储引擎就是提供存储数据一种机制，不同表的存储引擎提供不同的存储机制。</p><pre><code class="sql">-- 查看MySQL数据库支持的表的存储引擎show engines;</code></pre><p><strong>说明:</strong></p><ul><li>常用的表的存储引擎是 InnoDB 和 MyISAM</li><li>InnoDB 是支持事务的</li><li>MyISAM 不支持事务，优势是访问速度快，对事务没有要求或者以select、insert为主的都可以使用该存储引擎来创建表</li></ul><p><strong>查看goods表的创表语句:</strong></p><pre><code class="sql">-- 选择数据库use jing_dong;-- 查看goods表show create table goods;mysql root@(none):jing_dong&gt; show create table goods;+-------+--------------------------------------------------------+| Table | Create Table                                           |+-------+--------------------------------------------------------+| goods | CREATE TABLE `goods` (                                 ||       |   `id` int(10) unsigned NOT NULL AUTO_INCREMENT,       ||       |   `name` varchar(150) NOT NULL,                        ||       |   `cate_id` int(10) unsigned NOT NULL,                 ||       |   `brand_id` int(10) unsigned NOT NULL,                ||       |   `price` decimal(10,3) NOT NULL DEFAULT &#39;0.000&#39;,      ||       |   `is_show` bit(1) NOT NULL DEFAULT b&#39;1&#39;,              ||       |   `is_saleoff` bit(1) NOT NULL DEFAULT b&#39;0&#39;,           ||       |   PRIMARY KEY (`id`)                                   ||       | ) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=utf8 |+-------+--------------------------------------------------------+</code></pre><p><strong>说明:</strong></p><ul><li>通过创表语句可以得知，goods表的存储引擎是InnoDB。</li><li>修改表的存储引擎使用: alter table 表名 engine = 引擎类型;<ul><li>比如: alter table students engine = ‘MyISAM’;</li></ul></li></ul><p><strong>开启事务:</strong></p><pre><code class="sql">begin;或者start transaction;</code></pre><p><strong>说明:</strong></p><ul><li><p><strong>开启事务后执行修改命令，变更数据会保存到MySQL服务端的缓存文件中，而不维护到物理表中</strong></p></li><li><p><strong>MySQL数据库默认采用自动提交(autocommit)模式，如果没有显示的开启一个事务,那么每条sql语句都会被当作一个事务执行提交的操作</strong></p></li><li><p>当设置autocommit=0就是取消了自动提交事务模式，直到显示的执行commit和rollback表示该事务结束。</p><ul><li>set autocommit = 0 表示取消自动提交事务模式，需要手动执行commit完成事务的提交</li></ul><pre><code class="sql">set autocommit = 0;insert into students(name) values(&#39;刘三峰&#39;);-- 需要执行手动提交，数据才会真正添加到表中, 验证的话需要重新打开一个连接窗口查看表的数据信息，因为是临时关闭自动提交模式commit-- 重新打开一个终端窗口，连接MySQL数据库服务端mysql -uroot -p-- 然后查询数据,如果上个窗口执行了commit，这个窗口才能看到数据select * from students;</code></pre><p><strong>提交事务:</strong></p><p>将本地缓存文件中的数据提交到物理表中，完成数据的更新。</p><pre><code class="sql">commit;</code></pre><p><strong>回滚事务:</strong></p><p>放弃本地缓存文件中的缓存数据, 表示回到开始事务前的状态</p><pre><code>rollback;</code></pre><p><strong>事务演练的SQL语句:</strong></p><pre><code class="sql">begin;insert into students(name) values(&#39;李白&#39;);-- 查询数据，此时有新增的数据, 注意: 如果这里后续没有执行提交事务操作，那么数据是没有真正的更新到物理表中select * from students;-- 只有这里提交事务，才把数据真正插入到物理表中commit;-- 新打开一个终端，重新连接MySQL数据库，查询students表,这时没有显示新增的数据，说明之前的事务没有提交，这就是事务的隔离性-- 一个事务所做的修改操作在提交事务之前，对于其他事务来说是不可见的select * from students;</code></pre></li></ul><h4 id="5-4-小结"><a href="#5-4-小结" class="headerlink" title="5.4 小结"></a>5.4 小结</h4><ol><li>事务的特性:<ul><li>原子性: 强调事务中的多个操作时一个整体</li><li>一致性: 强调数据库中不会保存不一致状态</li><li>隔离性: 强调数据库中事务之间相互不可见</li><li>持久性: 强调数据库能永久保存数据，一旦提交就不可撤销</li></ul></li><li><strong>MySQL数据库默认采用自动提交(autocommit)模式</strong>, 也就是说修改数据(insert、update、delete)的操作会自动的触发事务,完成事务的提交或者回滚</li><li>开启事务使用 begin 或者 start transaction;</li><li>回滚事务使用 rollback;</li><li>pymysql 里面的 conn.commit() 操作就是提交事务</li><li>pymysql 里面的 conn.rollback() 操作就是回滚事务</li></ol><h3 id="6-索引"><a href="#6-索引" class="headerlink" title="6.索引"></a>6.索引</h3><h4 id="6-1-索引的介绍"><a href="#6-1-索引的介绍" class="headerlink" title="6.1 索引的介绍"></a>6.1 索引的介绍</h4><p>索引在MySQL中也叫做“键”，它是一个特殊的文件，它保存着数据表里所有记录的位置信息，更通俗的来说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。</p><p><strong>应用场景:</strong></p><p>当数据库中数据量很大时，查找数据会变得很慢，我们就可以通过索引来提高数据库的查询效率。</p><h4 id="6-2-索引的使用"><a href="#6-2-索引的使用" class="headerlink" title="6.2 索引的使用"></a>6.2 索引的使用</h4><p><strong>查看表中已有索引:</strong></p><pre><code class="sql">show index from 表名;</code></pre><p><strong>说明:</strong></p><ul><li>主键列会自动创建索引</li></ul><p><strong>索引的创建:</strong></p><pre><code class="sql">-- 创建索引的语法格式-- alter table 表名 add index 索引名[可选](列名, ..)-- 给name字段添加索引alter table classes add index my_name (name);</code></pre><p><strong>说明:</strong></p><ul><li>索引名不指定，默认使用字段名</li></ul><p><strong>索引的删除:</strong></p><pre><code class="sql">-- 删除索引的语法格式-- alter table 表名 drop index 索引名-- 如果不知道索引名，可以查看创表sql语句show create table classes;alter table classes drop index my_name;</code></pre><h4 id="6-3-案例-验证索引查询性能"><a href="#6-3-案例-验证索引查询性能" class="headerlink" title="6.3 案例-验证索引查询性能"></a>6.3 案例-验证索引查询性能</h4><p><strong>创建测试表testindex:</strong></p><pre><code class="sql">create table test_index(title varchar(10));</code></pre><p><strong>向表中插入十万条数据:</strong></p><pre><code class="py">from pymysql import connectdef main():    # 创建Connection连接    conn = connect(host=&#39;localhost&#39;,port=3306,database=&#39;python&#39;,user=&#39;root&#39;,password=&#39;mysql&#39;,charset=&#39;utf8&#39;)    # 获得Cursor对象    cursor = conn.cursor()    # 插入10万次数据    for i in range(100000):        cursor.execute(&quot;insert into test_index values(&#39;ha-%d&#39;)&quot; % i)    # 提交数据    conn.commit()if __name__ == &quot;__main__&quot;:    main()</code></pre><p><strong>验证索引性能操作：</strong></p><pre><code class="sql">-- 开启运行时间监测：set profiling=1;-- 查找第1万条数据ha-99999select * from test_index where title=&#39;ha-99999&#39;;-- 查看执行的时间：show profiles;-- 给title字段创建索引：alter table test_index add index (title);-- 再次执行查询语句select * from test_index where title=&#39;ha-99999&#39;;-- 再次查看执行的时间show profiles;</code></pre><h4 id="6-4-联合索引"><a href="#6-4-联合索引" class="headerlink" title="6.4 联合索引"></a>6.4 联合索引</h4><p>联合索引又叫复合索引，即一个索引覆盖表中两个或者多个字段，一般用在多个字段一起查询的时候。</p><pre><code class="sql">-- 创建teacher表create table teacher(    id int not null primary key auto_increment,    name varchar(10),    age int);-- 创建联合索引alter table teacher add index (name,age);</code></pre><p><strong>联合索引的好处:</strong></p><ul><li>减少磁盘空间开销，因为每创建一个索引，其实就是创建了一个索引文件，那么会增加磁盘空间的开销。</li></ul><h4 id="6-5-联合索引的最左原则"><a href="#6-5-联合索引的最左原则" class="headerlink" title="6.5 联合索引的最左原则"></a>6.5 联合索引的最左原则</h4><p>在使用联合索引的时候，我们要遵守一个最左原则,即index(name,age)支持 name 、name 和 age 组合查询,而不支持单独 age 查询，因为没有用到创建的联合索引。</p><p><strong>最左原则示例:</strong></p><pre><code class="sql">-- 下面的查询使用到了联合索引select * from stu where name=&#39;张三&#39; -- 这里使用了联合索引的name部分select * from stu where name=&#39;李四&#39; and age=10 -- 这里完整的使用联合索引，包括 name 和 age 部分 -- 下面的查询没有使用到联合索引select * from stu where age=10 -- 因为联合索引里面没有这个组合，只有 name | name age 这两种组合</code></pre><p><strong>说明:</strong></p><ul><li>在使用联合索引的查询数据时候一定要保证联合索引的最左侧字段出现在查询条件里面，否则联合索引失效</li></ul><h4 id="6-6-MySQL中索引的优点和缺点和使用原则"><a href="#6-6-MySQL中索引的优点和缺点和使用原则" class="headerlink" title="6.6 MySQL中索引的优点和缺点和使用原则"></a>6.6 MySQL中索引的优点和缺点和使用原则</h4><ul><li>优点：<ol><li>加快数据的查询速度</li></ol></li><li>缺点：<ol><li>创建索引会耗费时间和占用磁盘空间，并且随着数据量的增加所耗费的时间也会增加</li></ol></li><li>使用原则：<ol><li>通过优缺点对比，不是索引越多越好，而是需要自己合理的使用。</li><li>对经常更新的表就避免对其进行过多索引的创建，对经常用于查询的字段应该创建索引，</li><li>数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果。</li><li>在一字段上相同值比较多不要建立索引，比如在学生表的”性别”字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可是建立索引。</li></ol></li></ul><h4 id="6-7-小结"><a href="#6-7-小结" class="headerlink" title="6.7 小结"></a>6.7 小结</h4><ul><li>索引是加快数据库的查询速度的一种手段</li><li>创建索引使用: alter table 表名 add index 索引名[可选] (字段名, xxx);</li><li>删除索引使用: alter table 表名 drop index 索引名;</li></ul><h3 id="7-PyMySQL的使用"><a href="#7-PyMySQL的使用" class="headerlink" title="7.PyMySQL的使用"></a>7.PyMySQL的使用</h3><h4 id="7-1-思考"><a href="#7-1-思考" class="headerlink" title="7.1 思考"></a>7.1 思考</h4><p>如何实现将100000条数据插入到MySQL数据库?</p><p><strong>答案:</strong></p><p>如果使用之前学习的MySQL客户端来完成这个操作，那么这个工作量无疑是巨大的，我们可以通过使用程序代码的方式去连接MySQL数据库，然后对MySQL数据库进行增删改查的方式，实现10000条数据的插入，像这样使用代码的方式操作数据库就称为数据库编程。</p><h4 id="7-2-Python程序操作MySQL数据库"><a href="#7-2-Python程序操作MySQL数据库" class="headerlink" title="7.2 Python程序操作MySQL数据库"></a>7.2 Python程序操作MySQL数据库</h4><p><strong>安装pymysql第三方包:</strong></p><pre><code class="bash">sudo pip3 install pymysql</code></pre><p><strong>说明:</strong></p><ul><li>安装命令使用 sudo pip3 install 第三方包名</li><li>卸载命令使用 sudo pip3 uninstall 第三方包</li><li>大家现在使用的虚拟机已经安装了这个第三方包，可以使用： <strong>pip3 show pymysql</strong> 命令查看第三方包的信息</li><li><strong>pip3 list</strong> 查看使用pip命令安装的第三方包列表</li></ul><p><strong>pymysql的使用:</strong></p><ol><li><p>导入 pymysql 包</p><pre><code class="python"> import pymysql</code></pre></li><li><p>创建连接对象</p><p>调用pymysql模块中的connect()函数来创建连接对象,代码如下:</p><pre><code class="py"> conn=connect(参数列表) * 参数host：连接的mysql主机，如果本机是&#39;localhost&#39; * 参数port：连接的mysql主机的端口，默认是3306 * 参数user：连接的用户名 * 参数password：连接的密码 * 参数database：数据库的名称 * 参数charset：通信采用的编码方式，推荐使用utf8</code></pre><p><strong>连接对象操作说明:</strong></p><ul><li>关闭连接 conn.close()</li><li>提交数据 conn.commit()</li><li>撤销数据 conn.rollback()</li></ul></li><li><p>获取游标对象</p><p>获取游标对象的目标就是要执行sql语句，完成对数据库的增、删、改、查操作。代码如下:</p><pre><code class="py"> # 调用连接对象的cursor()方法获取游标对象    cur =conn.cursor()</code></pre><p><strong>游标操作说明:</strong></p><ul><li>使用游标执行SQL语句: execute(operation [parameters ]) 执行SQL语句，返回受影响的行数，主要用于执行insert、update、delete、select等语句</li><li>获取查询结果集中的一条数据:cur.fetchone()返回一个元组, 如 (1,’张三’)</li><li>获取查询结果集中的所有数据: cur.fetchall()返回一个元组,如((1,’张三’),(2,’李四’))</li><li>关闭游标: cur.close(),表示和数据库操作完成</li></ul></li><li><p>pymysql完成数据的查询操作</p><pre><code class="python">import pymysql# 创建连接对象conn = pymysql.connect(host=&#39;localhost&#39;, port=3306, user=&#39;root&#39;, password=&#39;mysql&#39;,database=&#39;python&#39;, charset=&#39;utf8&#39;)# 获取游标对象cursor = conn.cursor()# 查询 SQL 语句sql = &quot;select * from students;&quot;# 执行 SQL 语句 返回值就是 SQL 语句在执行过程中影响的行数row_count = cursor.execute(sql)print(&quot;SQL 语句执行影响的行数%d&quot; % row_count)# 取出结果集中一行数据,　例如:(1, &#39;张三&#39;)# print(cursor.fetchone())# 取出结果集中的所有数据, 例如:((1, &#39;张三&#39;), (2, &#39;李四&#39;), (3, &#39;王五&#39;))for line in cursor.fetchall():    print(line)# 关闭游标cursor.close()# 关闭连接conn.close()</code></pre></li><li><p>pymysql完成对数据的增删改</p><pre><code class="python">import pymysql# 创建连接对象conn = pymysql.connect(host=&#39;localhost&#39;, port=3306, user=&#39;root&#39;, password=&#39;mysql&#39;,database=&#39;python&#39;, charset=&#39;utf8&#39;)# 获取游标对象cursor = conn.cursor()try:    # 添加 SQL 语句    # sql = &quot;insert into students(name) values(&#39;刘璐&#39;), (&#39;王美丽&#39;);&quot;    # 删除 SQ L语句    # sql = &quot;delete from students where id = 5;&quot;    # 修改 SQL 语句    sql = &quot;update students set name = &#39;王铁蛋&#39; where id = 6;&quot;    # 执行 SQL 语句    row_count = cursor.execute(sql)    print(&quot;SQL 语句执行影响的行数%d&quot; % row_count)    # 提交数据到数据库    conn.commit()except Exception as e:    # 回滚数据， 即撤销刚刚的SQL语句操作    conn.rollback()# 关闭游标cursor.close()# 关闭连接conn.close()</code></pre><p><strong>说明:</strong></p><ul><li>conn.commit() 表示将修改操作提交到数据库</li><li>conn.rollback() 表示回滚数据</li></ul></li><li><p>防止SQL注入</p><p>什么是SQL注入?</p><p>用户提交带有恶意的数据与SQL语句进行字符串方式的拼接，从而影响了SQL语句的语义，最终产生数据泄露的现象。</p><p>如何防止SQL注入?</p><p>SQL语句参数化</p><ul><li>SQL语言中的参数使用%s来占位，此处不是python中的字符串格式化操作</li><li>将SQL语句中%s占位所需要的参数存在一个列表中，把参数列表传递给execute方法中第二个参数</li></ul><p><strong>防止SQL注入的示例代码:</strong></p><pre><code class="python">from pymysql import connectdef main():    find_name = input(&quot;请输入物品名称：&quot;)    # 创建Connection连接    conn = connect(host=&#39;localhost&#39;,port=3306,user=&#39;root&#39;,password=&#39;mysql&#39;,database=&#39;jing_dong&#39;,charset=&#39;utf8&#39;)    # 获得Cursor对象    cs1 = conn.cursor()    # 非安全的方式    # 输入 &#39; or 1 = 1 or &#39;   (单引号也要输入)    # sql = &quot;select * from goods where name=&#39;%s&#39;&quot; % find_name    # print(&quot;&quot;&quot;sql===&gt;%s&lt;====&quot;&quot;&quot; % sql)    # # 执行select语句，并返回受影响的行数：查询所有数据    # count = cs1.execute(sql)    # 安全的方式    # 构造参数列表    params = [find_name]    # 执行select语句，并返回受影响的行数：查询所有数据    count = cs1.execute(&quot;select * from goods where name=%s&quot;, params)    # 注意：    # 如果要是有多个参数，需要进行参数化    # 那么params = [数值1, 数值2....]，此时sql语句中有多个%s即可    # %s 不需要带引号    # 打印受影响的行数    print(count)    # 获取查询的结果    # result = cs1.fetchone()    result = cs1.fetchall()    # 打印查询的结果    print(result)    # 关闭Cursor对象    cs1.close()    # 关闭Connection对象    conn.close()if __name__ == &#39;__main__&#39;:    main()</code></pre><p><strong>说明:</strong></p><ul><li>execute方法中的 %s 占位不需要带引号</li></ul></li></ol><h4 id="7-3-小结-1"><a href="#7-3-小结-1" class="headerlink" title="7.3 小结"></a>7.3 小结</h4><ol><li><p>导包</p><pre><code class="py"> import pymysql</code></pre></li><li><p>创建连接对象</p><pre><code class="py"> pymysql.connect(参数列表)</code></pre></li><li><p>获取游标对象</p><pre><code class="py"> cursor =conn.cursor()</code></pre></li><li><p>执行SQL语句</p><pre><code class="py"> row_count = cursor.execute(sql)</code></pre></li><li><p>获取查询结果集</p><pre><code class="py"> result = cursor.fetchall()</code></pre></li><li><p>将修改操作提交到数据库</p><pre><code class="py"> conn.commit()</code></pre></li><li><p>回滚数据</p><pre><code class="py"> conn.rollback()</code></pre></li><li><p>关闭游标</p><pre><code class="py"> cursor.close()</code></pre></li><li><p>关闭连接</p><pre><code class="py"> conn.close()</code></pre></li></ol><h3 id="8-京东数据库案例练习"><a href="#8-京东数据库案例练习" class="headerlink" title="8.京东数据库案例练习"></a>8.京东数据库案例练习</h3><p>一. 准备数据</p><p>该案例使用前面章节中完成的京东商品数据库.</p><p>二. 程序菜单</p><pre><code class="python">    print(&#39;1. 查询所有商品信息&#39;)    print(&quot;2. 查询所有包含商品的分类&quot;)    print(&quot;3. 添加新商品分类&quot;)    print(&quot;4. 将所有商品价格加1000&quot;)    print(&quot;5. 将所有笔记本的分类改为超级本&quot;)    print(&quot;6. 根据id查询商品信息&quot;)    print(&quot;7. 根据id查询商品信息安全方式&quot;)    print(&quot;8. 退出系统&quot;)</code></pre><p>三. 方法命名</p><pre><code class="python">    # 显示菜单方法    def __print_menu(self):        pass    # 打印结果方法    def __show_query_result(self, result):        pass    # 服务器运行方法,实现主体逻辑    def run(self):        pass    # 1. 查询所有商品信息    def __fetch_all_info(self):        pass   # 2. 查询所有包含商品的分类    def __fetch_cate_of_goods(self):        pass    # 3. 添加商品分类    def __add_new_cate(self):        pass      # 4. 将所有商品价格加1000    def __update_price(self):        pass    # 5. 将所有笔记本的分类改为超级本    def __update_cate(self):        pass    # 6. 根据id查询商品信息    def __fetch_info_with_id(self):        pass    # 7. 根据id查询商品信息安全方式    def __fetch_info_with_id_safe(self):        pass</code></pre><p>四. 代码实现</p><ol><li><p>判断当前是否是主程序入口</p><pre><code class="python"> if __name__ == &#39;__main__&#39;:     main()</code></pre></li><li><p>实现主函数</p><pre><code class="python"> def main():     # 创建服务器对象,并传入相应参数     jd = JDServer(&#39;jd&#39;, &#39;root&#39;, &#39;123123&#39;)     # 启动服务器     jd.run()</code></pre></li><li><p>实现 JD 类</p><pre><code class="python"> import pymysql class JDServer(object): &quot;&quot;&quot;JD 类，提供商品查询服务&quot;&quot;&quot; # 将数据库连接操作放到初化方法中，对象创建时，自动连接数据库 def __init__(self, target_db, username, password):     # 连接数据库     self.db_connect = pymysql.Connect(host=&#39;localhost&#39;,port=3306,database=target_db, user=username, passwd=password, charset=&#39;utf8&#39;) # 将数据库关闭操作放到 __del__方法中，当对象销毁时，自动关闭数据库 def __del__(self):     # 关闭数据库     self.db_connect.close()</code></pre></li><li><p>实现 run 方法 因为需要重复选择，所以要用死循环</p><pre><code class="python"> # 服务器运行方法,实现主体逻辑,通过判断输入选择相应的功能函数 def run(self):     while True:         self.__print_menu()         select_id = input(&#39;请输入功能ID:&#39;)         if select_id == &#39;1&#39;:             self.__fetch_all_info()         elif select_id == &#39;2&#39;:             self.__fetch_cate_of_goods()         elif select_id == &#39;3&#39;:             self.__add_new_cate()         elif select_id == &#39;4&#39;:             self.__update_price()         elif select_id == &#39;5&#39;:             self.__update_cate()         elif select_id == &#39;6&#39;:             self.__fetch_info_with_id()         elif select_id == &#39;7&#39;:             self.__fetch_info_with_id_safe()         elif select_id == &#39;8&#39;:             break         else:             print(&#39;输入功能不正确,请重新输入&#39;)</code></pre></li><li><p>实现一个显示方法，用来输出结果</p><pre><code class="python"> # 用来显示结果的方法，私有，对外不可见 def __show_query_result(self, result):     for item in result:         print(item)</code></pre></li><li><p>实现查询所有商品信息</p><pre><code class="python"> # 1. 查询所有商品信息 def __fetch_all_info(self):     cur = self.db_connect.cursor()     sql_str = &#39;&#39;&#39;select * from goods&#39;&#39;&#39;     cur.execute(sql_str)     result = cur.fetchall()     self.__show_query_result(result)     cur.close()</code></pre></li><li><p>查询所有包含商品的分类</p><pre><code class="python"> # 2. 查询所有包含商品的分类 def __fetch_cate_of_goods(self):     cur = self.db_connect.cursor()     sql_str = &#39;&#39;&#39;select distinct good_cates.name from goods inner join good_cates on goods.cate_id = good_cates.id;&#39;&#39;&#39;     # sql_str = &#39;&#39;&#39; select name from good_cates where id in (select distinct cate_id from goods); &#39;&#39;&#39;     cur.execute(sql_str)     result = cur.fetchall()     self.__show_query_result(result)     cur.close()</code></pre></li><li><p>添加商品分类</p><pre><code class="python"> # 3. 添加商品分类 def __add_new_cate(self):     new_cate = input(&#39;请输入一个新商品分类:&#39;)     sql_str = &#39;&#39;&#39; insert into good_cates(name) values(&quot;%s&quot;) &#39;&#39;&#39; % new_cate     cur = self.db_connect.cursor()     cur.execute(sql_str)     self.db_connect.commit()     cur.close()</code></pre></li><li><p>将所有商品价格加1000</p><pre><code class="python"> # 4. 将所有商品价格加1000 def __update_price(self):     cur = self.db_connect.cursor()     sql_str = &#39;&#39;&#39; update goods set price = price + 1000&#39;&#39;&#39;     cur.execute(sql_str)     self.db_connect.commit()     cur.close()</code></pre></li><li><p>将所有笔记本的分类改为超级本</p><pre><code class="python"># 5. 将所有笔记本的分类改为超级本def __update_cate(self):    cur = self.db_connect.cursor()    sql_str = &#39;&#39;&#39;update goods set cate_id = (select id from good_cates where name = &#39;超级本&#39;) where name like &#39;%笔记本%&#39;;&#39;&#39;&#39;    cur.execute(sql_str)    self.db_connect.commit()    cur.close()</code></pre></li><li><p>根据id 查找商品,会产生SQL注入问题</p><pre><code class="python"># 6. 根据id查询商品信息def __fetch_info_with_id(self):    s_id = input(&#39;请输入一个商品ID:&#39;)    sql_str = &#39;&#39;&#39; select * from goods where id = %s &#39;&#39;&#39; % s_id    print(sql_str)    cur = self.db_connect.cursor()    cur.execute(sql_str)    result = cur.fetchall()    self.__show_query_result(result)    cur.close()</code></pre></li><li><p>根据id查询商品信息安全方式,案例防注入</p><pre><code class="python"># 7. 根据id查询商品信息安全方式def __fetch_info_with_id_safe(self):    s_id = input(&#39;请输入一个商品ID:&#39;)    sql_str = &#39;&#39;&#39; select * from goods where id = %s &#39;&#39;&#39;    print(sql_str)    cur = self.db_connect.cursor()    cur.execute(sql_str, (s_id,))    result = cur.fetchall()    self.__show_query_result(result)    cur.close()</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySQL数据库&quot;&gt;&lt;a href=&quot;#MySQL数据库&quot; class=&quot;headerlink&quot; title=&quot;MySQL数据库&quot;&gt;&lt;/a&gt;MySQL数据库&lt;/h1&gt;&lt;h2 id=&quot;一、MySQL数据库的基本使用&quot;&gt;&lt;a href=&quot;#一、MySQL数据库的基本使用&quot; class=&quot;headerlink&quot; title=&quot;一、MySQL数据库的基本使用&quot;&gt;&lt;/a&gt;一、MySQL数据库的基本使用&lt;/h2&gt;&lt;h3 id=&quot;1-数据库&quot;&gt;&lt;a href=&quot;#1-数据库&quot; class=&quot;headerlink&quot; title=&quot;1.数据库&quot;&gt;&lt;/a&gt;1.数据库&lt;/h3&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://caijinbo.work/categories/python/"/>
    
    
      <category term="python" scheme="https://caijinbo.work/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python高级04-HTTP协议和静态WEB服务器</title>
    <link href="https://caijinbo.work/2020/08/21/2020-08-22-python%E9%AB%98%E7%BA%A704-HTTP%E5%8D%8F%E8%AE%AE%E5%92%8C%E9%9D%99%E6%80%81WEB%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://caijinbo.work/2020/08/21/2020-08-22-python%E9%AB%98%E7%BA%A704-HTTP%E5%8D%8F%E8%AE%AE%E5%92%8C%E9%9D%99%E6%80%81WEB%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-08-21T16:00:00.000Z</published>
    <updated>2020-11-23T10:13:31.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP协议和静态WEB服务器"><a href="#HTTP协议和静态WEB服务器" class="headerlink" title="HTTP协议和静态WEB服务器"></a>HTTP协议和静态WEB服务器</h1><h2 id="一、HTTP-协议"><a href="#一、HTTP-协议" class="headerlink" title="一、HTTP 协议"></a>一、HTTP 协议</h2><h3 id="1-HTTP-协议的介绍"><a href="#1-HTTP-协议的介绍" class="headerlink" title="1. HTTP 协议的介绍"></a>1. HTTP 协议的介绍</h3><a id="more"></a><p>HTTP 协议的全称是(HyperText Transfer Protocol)，翻译过来就是<strong>超文本传输协议</strong>。</p><p>超文本是超级文本的缩写，是指超越文本限制或者超链接，比如:图片、音乐、视频、超链接等等都属于超文本。</p><p>HTTP 协议的制作者是<strong>蒂姆·伯纳斯-李</strong>，1991年设计出来的，<strong>HTTP 协议设计之前目的是传输网页数据的，现在允许传输任意类型的数据</strong>。</p><p><strong>传输 HTTP 协议格式的数据是基于 TCP 传输协议的，发送数据之前需要先建立连接。</strong></p><h3 id="2-HTTP-协议的作用"><a href="#2-HTTP-协议的作用" class="headerlink" title="2. HTTP 协议的作用"></a>2. HTTP 协议的作用</h3><p>它<strong>规定了浏览器和 Web 服务器通信数据的格式，也就是说浏览器和web服务器通信需要使用http协议</strong>。</p><h3 id="3-浏览器访问web服务器的通信过程"><a href="#3-浏览器访问web服务器的通信过程" class="headerlink" title="3. 浏览器访问web服务器的通信过程"></a>3. 浏览器访问web服务器的通信过程</h3><p>第1步：浏览器客户端通过DNS（域名解析服务器）将目标网站域名（例如<a href="http://www.baidu.com)解析成IP地址(39.156.69.79)" target="_blank" rel="noopener">www.baidu.com)解析成IP地址(39.156.69.79)</a> &gt;&gt;&gt;获取到目标ip</p><p>第2步：浏览器客户端与web服务器程序默认80端口号建立连接</p><p>第3步：浏览器向web服务器发送http请求数据</p><p>第4步：web服务器收到请求后根据请求向服务器主机获取资源</p><p>第5步：服务器主机将资源返回给web服务器</p><p>第6步：web服务器向浏览器返回http响应数据</p><h2 id="二、URL"><a href="#二、URL" class="headerlink" title="二、URL"></a>二、URL</h2><h3 id="1-URL的概念"><a href="#1-URL的概念" class="headerlink" title="1. URL的概念"></a>1. URL的概念</h3><p>URL的英文全拼是(Uniform Resoure Locator),表达的意思是统一资源定位符，通俗理解就是网络资源地址，也就是我们常说的网址。</p><h3 id="2-URL的组成"><a href="#2-URL的组成" class="headerlink" title="2. URL的组成"></a>2. URL的组成</h3><p><strong>URL的样子:</strong></p><p><a href="https://news.163.com/18/1122/10/E178J2O4000189FH.html" target="_blank" rel="noopener">https://news.163.com/18/1122/10/E178J2O4000189FH.html</a></p><p><strong>URL的组成部分:</strong></p><ol><li><strong>协议部分</strong>: https://、http://、ftp://</li><li><strong>域名部分</strong>: news.163.com</li><li><strong>资源路径部分</strong>: /18/1122/10/E178J2O4000189FH.html</li></ol><p><strong>域名:</strong></p><p>域名就是<strong>IP地址的别名</strong>，它是用点进行分割使用英文字母和数字组成的名字，<strong>使用域名目的就是方便的记住某台主机IP地址</strong>。</p><p><strong>URL的扩展:</strong></p><p><a href="https://news.163.com/hello.html?page=1&amp;count=10" target="_blank" rel="noopener">https://news.163.com/hello.html?page=1&amp;count=10</a></p><ul><li><strong>查询参数部分</strong>: ?page=1&amp;count=10</li></ul><p><strong>参数说明:</strong></p><ul><li>? 后面的 page 表示第一个参数，后面的参数都使用 &amp; 进行连接</li></ul><h2 id="三、查看HTTP协议的通信过程"><a href="#三、查看HTTP协议的通信过程" class="headerlink" title="三、查看HTTP协议的通信过程"></a>三、查看HTTP协议的通信过程</h2><h3 id="1-谷歌浏览器开发者工具的使用"><a href="#1-谷歌浏览器开发者工具的使用" class="headerlink" title="1. 谷歌浏览器开发者工具的使用"></a>1. 谷歌浏览器开发者工具的使用</h3><p>首先需要安装Google Chrome浏览器，然后Windows和Linux平台按<strong>F12</strong>调出开发者工具, mac OS选择 视图 -&gt; 开发者 -&gt; 开发者工具或者直接使用 <strong>alt+command+i</strong> 这个快捷键，还有一个多平台通用的操作就是在<strong>网页右击选择检查</strong>。</p><p><strong>开发者工具的标签选项说明:</strong></p><ul><li>元素（Elements）：用于查看或修改HTML标签</li><li>控制台（Console）：执行js代码</li><li>源代码（Sources）：查看静态资源文件，断点调试JS代码</li><li>网络（Network）：查看http协议的通信过程</li></ul><p><strong>开发者工具的使用说明:</strong></p><ol><li>点击Network标签选项</li><li>在浏览器的地址栏输入百度的网址，就能看到请求百度首页的http的通信过程</li><li><strong>这里的每项记录都是请求+响应的一次过程</strong></li></ol><h2 id="四、HTTP-请求报文"><a href="#四、HTTP-请求报文" class="headerlink" title="四、HTTP 请求报文"></a>四、HTTP 请求报文</h2><h3 id="1-HTTP-请求报文介绍"><a href="#1-HTTP-请求报文介绍" class="headerlink" title="1. HTTP 请求报文介绍"></a>1. HTTP 请求报文介绍</h3><p><strong>HTTP最常见的请求报文有两种:</strong></p><ol><li>GET 方式的请求报文</li><li>POST 方式的请求报文</li></ol><p><strong>说明:</strong></p><ul><li>GET: 获取web服务器数据</li><li>POST: 向web服务器提交数据</li></ul><h3 id="2-HTTP-GET-请求报文分析"><a href="#2-HTTP-GET-请求报文分析" class="headerlink" title="2. HTTP GET 请求报文分析"></a>2. HTTP GET 请求报文分析</h3><p><strong>GET 请求报文说明:</strong></p><pre><code class="http">---- 请求行 ----GET / HTTP/1.1  # GET请求方式 请求资源路径 HTTP协议版本---- 请求头 -----Host: www.itcast.cn  # 服务器的主机地址和端口号,默认是80Connection: keep-alive # 和服务端保持长连接Upgrade-Insecure-Requests: 1 # 让浏览器升级不安全请求，使用https请求User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36  # 用户代理，也就是客户端的名称Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 # 可接受的数据类型Accept-Encoding: gzip, deflate # 可接受的压缩格式Accept-Language: zh-CN,zh;q=0.9 #可接受的语言Cookie: pgv_pvi=1246921728; # 登录用户的身份标识---- 空行 ----</code></pre><p><strong>GET 请求原始报文说明:</strong></p><pre><code class="http">GET / HTTP/1.1\r\nHost: www.itcast.cn\r\n  Connection: keep-alive\r\nUpgrade-Insecure-Requests: 1\r\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\r\nAccept-Encoding: gzip, deflate\r\nAccept-Language: zh-CN,zh;q=0.9\r\nCookie: pgv_pvi=1246921728; \r\n\r\n  (请求头信息后面还有一个单独的’\r\n’不能省略)</code></pre><p><strong>说明：</strong></p><ul><li>每项数据之间使用:<strong>\r\n</strong></li></ul><p><strong>POST 请求报文说明:</strong></p><pre><code class="http">---- 请求行 ----POST /xmweb?host=mail.itcast.cn&amp;_t=1542884567319 HTTP/1.1 # POST请求方式 请求资源路径 HTTP协议版本---- 请求头 ----Host: mail.itcast.cn # 服务器的主机地址和端口号,默认是80Connection: keep-alive # 和服务端保持长连接Content-Type: application/x-www-form-urlencoded  # 告诉服务端请求的数据类型User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36 # 客户端的名称---- 空行 -------- 请求体 ----username=hello&amp;pass=hello # 请求参数</code></pre><p><strong>POST 请求原始报文说明:</strong></p><pre><code class="http">POST /xmweb?host=mail.itcast.cn&amp;_t=1542884567319 HTTP/1.1\r\nHost: mail.itcast.cn\r\nConnection: keep-alive\r\nContent-Type: application/x-www-form-urlencoded\r\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36\r\n\r\n(请求头信息后面还有一个单独的’\r\n’不能省略)username=hello&amp;pass=hello</code></pre><p><strong>说明：</strong></p><ul><li>每项数据之间使用:<strong>\r\n</strong></li></ul><h2 id="五、HTTP响应报文"><a href="#五、HTTP响应报文" class="headerlink" title="五、HTTP响应报文"></a>五、HTTP响应报文</h2><h3 id="1-HTTP响应报文分析"><a href="#1-HTTP响应报文分析" class="headerlink" title="1. HTTP响应报文分析"></a>1. HTTP响应报文分析</h3><p>一个HTTP响应报文是由<strong>响应行、响应头、空行和响应体</strong>4个部分组成。</p><p>响应行是由三部分组成：<strong>HTTP协议版本 状态码 状态描述</strong>，最常见的状态码是200</p><p><strong>响应报文说明:</strong></p><pre><code class="http">--- 响应行/状态行 ---HTTP/1.1 200 OK # HTTP协议版本 状态码 状态描述--- 响应头 ---Server: Tengine # 服务器名称Content-Type: text/html; charset=UTF-8 # 内容类型Transfer-Encoding: chunked # 发送给客户端内容不确定内容长度，发送结束的标记是0\r\n, Content-Length表示服务端确定发送给客户端的内容大小，但是二者只能用其一。Connection: keep-alive # 和客户端保持长连接Date: Fri, 23 Nov 2018 02:01:05 GMT # 服务端的响应时间--- 空行 ------ 响应体 ---&lt;!DOCTYPE html&gt;&lt;html lang=“en”&gt; …&lt;/html&gt; # 响应给客户端的数据</code></pre><p><strong>原始响应报文说明:</strong></p><pre><code class="http">HTTP/1.1 200 OK\r\nServer: Tengine\r\nContent-Type: text/html; charset=UTF-8\r\nTransfer-Encoding: chunked\r\nConnection: keep-alive\r\nDate: Fri, 23 Nov 2018 02:01:05 GMT\r\n\r\n(响应头信息后面还有一个单独的’\r\n’不能省略)&lt;!DOCTYPE html&gt;&lt;html lang=“en”&gt; …&lt;/html&gt;</code></pre><p><strong>说明:</strong></p><p>每项数据之间使用:<strong>\r\n</strong></p><h3 id="2-HTTP-状态码介绍"><a href="#2-HTTP-状态码介绍" class="headerlink" title="2. HTTP 状态码介绍"></a>2. HTTP 状态码介绍</h3><p>HTTP 状态码是<strong>用于表示web服务器响应状态的3位数字代码</strong>。</p><table><thead><tr><th align="left">状态码</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">200</td><td align="left">请求成功</td></tr><tr><td align="left">307</td><td align="left">重定向</td></tr><tr><td align="left">400</td><td align="left">错误的请求，请求地址或者参数有误</td></tr><tr><td align="left">404</td><td align="left">请求资源在服务器不存在</td></tr><tr><td align="left">500</td><td align="left">服务器内部源代码出现错误</td></tr></tbody></table><h2 id="六、搭建Python自带静态Web服务器"><a href="#六、搭建Python自带静态Web服务器" class="headerlink" title="六、搭建Python自带静态Web服务器"></a>六、搭建Python自带静态Web服务器</h2><h3 id="1-静态Web服务器是什么？"><a href="#1-静态Web服务器是什么？" class="headerlink" title="1. 静态Web服务器是什么？"></a>1. 静态Web服务器是什么？</h3><p>可以<strong>为发出请求的浏览器提供静态文档的程序</strong>。</p><p>平时我们浏览百度新闻数据的时候，<strong>每天的新闻数据都会发生变化，那访问的这个页面就是动态的</strong>，而我们开发的是<strong>静态的，页面的数据不会发生变化</strong>。</p><h3 id="2-如何搭建Python自带的静态Web服务器"><a href="#2-如何搭建Python自带的静态Web服务器" class="headerlink" title="2. 如何搭建Python自带的静态Web服务器"></a>2. 如何搭建Python自带的静态Web服务器</h3><p>搭建Python自带的静态Web服务器使用 <strong>python3 -m http.server 端口号</strong></p><pre><code class="bash">ubuntu@python:~$ python3 -m http.server 8080Serving HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/) ...</code></pre><p><strong>-m选项说明:</strong></p><p>-m表示<strong>运行包里面的模块</strong>，执行这个命令的时候，需要进入你<strong>自己指定静态文件的目录</strong>，然后通过浏览器就能访问对应的 html文件了，这样一个静态的web服务器就搭建好了。</p><h3 id="3-访问搭建的静态Web服务器"><a href="#3-访问搭建的静态Web服务器" class="headerlink" title="3. 访问搭建的静态Web服务器"></a>3. 访问搭建的静态Web服务器</h3><p>在浏览器上输入127.0.0.1:8080</p><h3 id="4-查看浏览器和搭建的静态Web服务器的通信过程"><a href="#4-查看浏览器和搭建的静态Web服务器的通信过程" class="headerlink" title="4. 查看浏览器和搭建的静态Web服务器的通信过程"></a>4. 查看浏览器和搭建的静态Web服务器的通信过程</h3><p>在浏览器上按F12键或者右键选择检查打开调试控制台</p><p>选择Network或者网络</p><p>刷新一下就可以看到通信过程了</p><h2 id="七、静态Web服务器-返回固定页面数据"><a href="#七、静态Web服务器-返回固定页面数据" class="headerlink" title="七、静态Web服务器-返回固定页面数据"></a>七、静态Web服务器-返回固定页面数据</h2><h3 id="1-开发自己的静态Web服务器"><a href="#1-开发自己的静态Web服务器" class="headerlink" title="1. 开发自己的静态Web服务器"></a>1. 开发自己的静态Web服务器</h3><p><strong>实现步骤:</strong></p><ol><li>编写一个TCP服务端程序</li><li>获取浏览器发送的http请求报文数据</li><li>读取固定页面数据，把页面数据组装成HTTP响应报文数据发送给浏览器。</li><li>HTTP响应报文数据发送完成以后，关闭服务于客户端的套接字。</li></ol><h3 id="2-静态Web服务器-返回固定页面数据的示例代码"><a href="#2-静态Web服务器-返回固定页面数据的示例代码" class="headerlink" title="2. 静态Web服务器-返回固定页面数据的示例代码"></a>2. 静态Web服务器-返回固定页面数据的示例代码</h3><pre><code class="python">import socketif __name__ == &#39;__main__&#39;:    # 创建tcp服务端套接字    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # 设置端口号复用, 程序退出端口立即释放    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)    # 绑定端口号    tcp_server_socket.bind((&quot;&quot;, 9000))    # 设置监听    tcp_server_socket.listen(128)    while True:        # 等待接受客户端的连接请求        new_socket, ip_port = tcp_server_socket.accept()        # 代码执行到此，说明连接建立成功        recv_client_data = new_socket.recv(4096)        # 对二进制数据进行解码        recv_client_content = recv_client_data.decode(&quot;utf-8&quot;)        print(recv_client_content)        with open(&quot;static/index.html&quot;, &quot;rb&quot;) as file:            # 读取文件数据            file_data = file.read()        # 响应行        response_line = &quot;HTTP/1.1 200 OK\r\n&quot;        # 响应头        response_header = &quot;Server: PWS1.0\r\n&quot;        # 响应体        response_body = file_data        # 拼接响应报文        response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body        # 发送数据        new_socket.send(response_data)        # 关闭服务与客户端的套接字        new_socket.close()</code></pre><h2 id="八、静态Web服务器-返回指定页面数据"><a href="#八、静态Web服务器-返回指定页面数据" class="headerlink" title="八、静态Web服务器-返回指定页面数据"></a>八、静态Web服务器-返回指定页面数据</h2><h3 id="1-静态Web服务器的问题"><a href="#1-静态Web服务器的问题" class="headerlink" title="1. 静态Web服务器的问题"></a>1. 静态Web服务器的问题</h3><p>目前的Web服务器，不管用户访问什么页面，返回的都是固定页面的数据，接下来需要根据用户的请求返回指定页面的数据</p><p><strong>返回指定页面数据的实现步骤:</strong></p><ol><li>获取用户请求资源的路径</li><li>根据请求资源的路径，读取指定文件的数据</li><li>组装指定文件数据的响应报文，发送给浏览器</li><li>判断请求的文件在服务端不存在，组装404状态的响应报文，发送给浏览器</li></ol><h3 id="2-静态Web服务器-返回指定页面数据的示例代码"><a href="#2-静态Web服务器-返回指定页面数据的示例代码" class="headerlink" title="2. 静态Web服务器-返回指定页面数据的示例代码"></a>2. 静态Web服务器-返回指定页面数据的示例代码</h3><pre><code class="python">import socketdef main():    # 创建tcp服务端套接字    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # 设置端口号复用, 程序退出端口立即释放    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)    # 绑定端口号    tcp_server_socket.bind((&quot;&quot;, 9000))    # 设置监听    tcp_server_socket.listen(128)    while True:        # 等待接受客户端的连接请求        new_socket, ip_port = tcp_server_socket.accept()        # 代码执行到此，说明连接建立成功        recv_client_data = new_socket.recv(4096)        if len(recv_client_data) == 0:            print(&quot;关闭浏览器了&quot;)            new_socket.close()            return        # 对二进制数据进行解码        recv_client_content = recv_client_data.decode(&quot;utf-8&quot;)        print(recv_client_content)        # 根据指定字符串进行分割， 最大分割次数指定2        request_list = recv_client_content.split(&quot; &quot;, maxsplit=2)        # 获取请求资源路径        request_path = request_list[1]        print(request_path)        # 判断请求的是否是根目录，如果条件成立，指定首页数据返回        if request_path == &quot;/&quot;:            request_path = &quot;/index.html&quot;        try:            # 动态打开指定文件            with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file:                # 读取文件数据                file_data = file.read()        except Exception as e:            # 请求资源不存在，返回404数据            # 响应行            response_line = &quot;HTTP/1.1 404 Not Found\r\n&quot;            # 响应头            response_header = &quot;Server: PWS1.0\r\n&quot;            with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file:                file_data = file.read()            # 响应体            response_body = file_data            # 拼接响应报文            response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body            # 发送数据            new_socket.send(response_data)        else:            # 响应行            response_line = &quot;HTTP/1.1 200 OK\r\n&quot;            # 响应头            response_header = &quot;Server: PWS1.0\r\n&quot;            # 响应体            response_body = file_data            # 拼接响应报文            response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body            # 发送数据            new_socket.send(response_data)        finally:            # 关闭服务与客户端的套接字            new_socket.close()if __name__ == &#39;__main__&#39;:    main()</code></pre><h2 id="九、静态Web服务器-多任务版"><a href="#九、静态Web服务器-多任务版" class="headerlink" title="九、静态Web服务器-多任务版"></a>九、静态Web服务器-多任务版</h2><h3 id="1-静态Web服务器的问题-1"><a href="#1-静态Web服务器的问题-1" class="headerlink" title="1. 静态Web服务器的问题"></a>1. 静态Web服务器的问题</h3><p>目前的Web服务器，不能支持多用户同时访问，只能一个一个的处理客户端的请求，那么如何开发多任务版的web服务器同时处理 多个客户端的请求?</p><p>可以使用<strong>多线程</strong>，比进程更加节省内存资源。</p><p><strong>多任务版web服务器程序的实现步骤:</strong></p><ol><li>当客户端和服务端建立连接成功，创建子线程，使用子线程专门处理客户端的请求，防止主线程阻塞。</li><li>把创建的子线程设置成为守护主线程，防止主线程无法退出。</li></ol><h3 id="2-静态Web服务器-多任务版的示例代码"><a href="#2-静态Web服务器-多任务版的示例代码" class="headerlink" title="2. 静态Web服务器-多任务版的示例代码"></a>2. 静态Web服务器-多任务版的示例代码</h3><pre><code class="python">import socketimport threading# 处理客户端的请求def handle_client_request(new_socket):    # 代码执行到此，说明连接建立成功    recv_client_data = new_socket.recv(4096)    if len(recv_client_data) == 0:        print(&quot;关闭浏览器了&quot;)        new_socket.close()        return    # 对二进制数据进行解码    recv_client_content = recv_client_data.decode(&quot;utf-8&quot;)    print(recv_client_content)    # 根据指定字符串进行分割， 最大分割次数指定2    request_list = recv_client_content.split(&quot; &quot;, maxsplit=2)    # 获取请求资源路径    request_path = request_list[1]    print(request_path)    # 判断请求的是否是根目录，如果条件成立，指定首页数据返回    if request_path == &quot;/&quot;:        request_path = &quot;/index.html&quot;    try:        # 动态打开指定文件        with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file:            # 读取文件数据            file_data = file.read()    except Exception as e:        # 请求资源不存在，返回404数据        # 响应行        response_line = &quot;HTTP/1.1 404 Not Found\r\n&quot;        # 响应头        response_header = &quot;Server: PWS1.0\r\n&quot;        with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file:            file_data = file.read()        # 响应体        response_body = file_data        # 拼接响应报文        response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body        # 发送数据        new_socket.send(response_data)    else:        # 响应行        response_line = &quot;HTTP/1.1 200 OK\r\n&quot;        # 响应头        response_header = &quot;Server: PWS1.0\r\n&quot;        # 响应体        response_body = file_data        # 拼接响应报文        response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body        # 发送数据        new_socket.send(response_data)    finally:        # 关闭服务与客户端的套接字        new_socket.close()# 程序入口函数def main():    # 创建tcp服务端套接字    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # 设置端口号复用, 程序退出端口立即释放    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)    # 绑定端口号    tcp_server_socket.bind((&quot;&quot;, 9000))    # 设置监听    tcp_server_socket.listen(128)    while True:        # 等待接受客户端的连接请求        new_socket, ip_port = tcp_server_socket.accept()        print(ip_port)        # 当客户端和服务器建立连接程，创建子线程        sub_thread = threading.Thread(target=handle_client_request, args=(new_socket,))        # 设置守护主线程        sub_thread.setDaemon(True)        # 启动子线程执行对应的任务        sub_thread.start()if __name__ == &#39;__main__&#39;:    main()</code></pre><h2 id="十、静态Web服务器-面向对象开发"><a href="#十、静态Web服务器-面向对象开发" class="headerlink" title="十、静态Web服务器-面向对象开发"></a>十、静态Web服务器-面向对象开发</h2><h3 id="1-以面向对象的方式开发静态Web服务器"><a href="#1-以面向对象的方式开发静态Web服务器" class="headerlink" title="1. 以面向对象的方式开发静态Web服务器"></a>1. 以面向对象的方式开发静态Web服务器</h3><p><strong>实现步骤:</strong></p><ol><li>把提供服务的Web服务器抽象成一个类(HTTPWebServer)</li><li>提供Web服务器的初始化方法，在初始化方法里面创建socket对象</li><li>提供一个开启Web服务器的方法，让Web服务器处理客户端请求操作。</li></ol><h3 id="2-静态Web服务器-面向对象开发的示例代码"><a href="#2-静态Web服务器-面向对象开发的示例代码" class="headerlink" title="2. 静态Web服务器-面向对象开发的示例代码"></a>2. 静态Web服务器-面向对象开发的示例代码</h3><pre><code class="python">import socketimport threading# 定义web服务器类class HttpWebServer(object):    def __init__(self):        # 创建tcp服务端套接字        tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        # 设置端口号复用, 程序退出端口立即释放        tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)        # 绑定端口号        tcp_server_socket.bind((&quot;&quot;, 9000))        # 设置监听        tcp_server_socket.listen(128)        # 保存创建成功的服务器套接字        self.tcp_server_socket = tcp_server_socket    # 处理客户端的请求    @staticmethod    def handle_client_request(new_socket):        # 代码执行到此，说明连接建立成功        recv_client_data = new_socket.recv(4096)        if len(recv_client_data) == 0:            print(&quot;关闭浏览器了&quot;)            new_socket.close()            return        # 对二进制数据进行解码        recv_client_content = recv_client_data.decode(&quot;utf-8&quot;)        print(recv_client_content)        # 根据指定字符串进行分割， 最大分割次数指定2        request_list = recv_client_content.split(&quot; &quot;, maxsplit=2)        # 获取请求资源路径        request_path = request_list[1]        print(request_path)        # 判断请求的是否是根目录，如果条件成立，指定首页数据返回        if request_path == &quot;/&quot;:            request_path = &quot;/index.html&quot;        try:            # 动态打开指定文件            with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file:                # 读取文件数据                file_data = file.read()        except Exception as e:            # 请求资源不存在，返回404数据            # 响应行            response_line = &quot;HTTP/1.1 404 Not Found\r\n&quot;            # 响应头            response_header = &quot;Server: PWS1.0\r\n&quot;            with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file:                file_data = file.read()            # 响应体            response_body = file_data            # 拼接响应报文            response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body            # 发送数据            new_socket.send(response_data)        else:            # 响应行            response_line = &quot;HTTP/1.1 200 OK\r\n&quot;            # 响应头            response_header = &quot;Server: PWS1.0\r\n&quot;            # 响应体            response_body = file_data            # 拼接响应报文            response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body            # 发送数据            new_socket.send(response_data)        finally:            # 关闭服务与客户端的套接字            new_socket.close()    # 启动web服务器进行工作    def start(self):        while True:            # 等待接受客户端的连接请求            new_socket, ip_port = self.tcp_server_socket.accept()            # 当客户端和服务器建立连接程，创建子线程            sub_thread = threading.Thread(target=self.handle_client_request, args=(new_socket,))            # 设置守护主线程            sub_thread.setDaemon(True)            # 启动子线程执行对应的任务            sub_thread.start()# 程序入口函数def main():    # 创建web服务器对象    web_server = HttpWebServer()    # 启动web服务器进行工作    web_server.start()if __name__ == &#39;__main__&#39;:    main()</code></pre><h2 id="十一、静态Web服务器-命令行启动动态绑定端口号"><a href="#十一、静态Web服务器-命令行启动动态绑定端口号" class="headerlink" title="十一、静态Web服务器-命令行启动动态绑定端口号"></a>十一、静态Web服务器-命令行启动动态绑定端口号</h2><h3 id="1-开发命令行启动动态绑定端口号的静态web服务器"><a href="#1-开发命令行启动动态绑定端口号的静态web服务器" class="headerlink" title="1. 开发命令行启动动态绑定端口号的静态web服务器"></a>1. 开发命令行启动动态绑定端口号的静态web服务器</h3><p><strong>实现步骤:</strong></p><ol><li>获取执行python程序的终端命令行参数</li><li>判断参数的类型，设置端口号必须是整型</li><li>给Web服务器类的初始化方法添加一个端口号参数，用于绑定端口号</li></ol><h3 id="2-静态Web服务器-命令行启动动态绑定端口号的示例代码"><a href="#2-静态Web服务器-命令行启动动态绑定端口号的示例代码" class="headerlink" title="2. 静态Web服务器-命令行启动动态绑定端口号的示例代码"></a>2. 静态Web服务器-命令行启动动态绑定端口号的示例代码</h3><pre><code class="python">import socketimport threadingimport sys# 定义web服务器类class HttpWebServer(object):    def __init__(self, port):        # 创建tcp服务端套接字        tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        # 设置端口号复用, 程序退出端口立即释放        tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)        # 绑定端口号        tcp_server_socket.bind((&quot;&quot;, port))        # 设置监听        tcp_server_socket.listen(128)        # 保存创建成功的服务器套接字        self.tcp_server_socket = tcp_server_socket    # 处理客户端的请求    @staticmethod    def handle_client_request(new_socket):        # 代码执行到此，说明连接建立成功        recv_client_data = new_socket.recv(4096)        if len(recv_client_data) == 0:            print(&quot;关闭浏览器了&quot;)            new_socket.close()            return        # 对二进制数据进行解码        recv_client_content = recv_client_data.decode(&quot;utf-8&quot;)        print(recv_client_content)        # 根据指定字符串进行分割， 最大分割次数指定2        request_list = recv_client_content.split(&quot; &quot;, maxsplit=2)        # 获取请求资源路径        request_path = request_list[1]        print(request_path)        # 判断请求的是否是根目录，如果条件成立，指定首页数据返回        if request_path == &quot;/&quot;:            request_path = &quot;/index.html&quot;        try:            # 动态打开指定文件            with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file:                # 读取文件数据                file_data = file.read()        except Exception as e:            # 请求资源不存在，返回404数据            # 响应行            response_line = &quot;HTTP/1.1 404 Not Found\r\n&quot;            # 响应头            response_header = &quot;Server: PWS1.0\r\n&quot;            with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file:                file_data = file.read()            # 响应体            response_body = file_data            # 拼接响应报文            response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body            # 发送数据            new_socket.send(response_data)        else:            # 响应行            response_line = &quot;HTTP/1.1 200 OK\r\n&quot;            # 响应头            response_header = &quot;Server: PWS1.0\r\n&quot;            # 响应体            response_body = file_data            # 拼接响应报文            response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body            # 发送数据            new_socket.send(response_data)        finally:            # 关闭服务与客户端的套接字            new_socket.close()    # 启动web服务器进行工作    def start(self):        while True:            # 等待接受客户端的连接请求            new_socket, ip_port = self.tcp_server_socket.accept()            # 当客户端和服务器建立连接程，创建子线程            sub_thread = threading.Thread(target=self.handle_client_request, args=(new_socket,))            # 设置守护主线程            sub_thread.setDaemon(True)            # 启动子线程执行对应的任务            sub_thread.start()# 程序入口函数def main():    print(sys.argv)    # 判断命令行参数是否等于2,    if len(sys.argv) != 2:        print(&quot;执行命令如下: python3 xxx.py 8000&quot;)        return    # 判断字符串是否都是数字组成    if not sys.argv[1].isdigit():        print(&quot;执行命令如下: python3 xxx.py 8000&quot;)        return    # 获取终端命令行参数    port = int(sys.argv[1])    # 创建web服务器对象    web_server = HttpWebServer(port)    # 启动web服务器进行工作    web_server.start()if __name__ == &#39;__main__&#39;:    main()</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTTP协议和静态WEB服务器&quot;&gt;&lt;a href=&quot;#HTTP协议和静态WEB服务器&quot; class=&quot;headerlink&quot; title=&quot;HTTP协议和静态WEB服务器&quot;&gt;&lt;/a&gt;HTTP协议和静态WEB服务器&lt;/h1&gt;&lt;h2 id=&quot;一、HTTP-协议&quot;&gt;&lt;a href=&quot;#一、HTTP-协议&quot; class=&quot;headerlink&quot; title=&quot;一、HTTP 协议&quot;&gt;&lt;/a&gt;一、HTTP 协议&lt;/h2&gt;&lt;h3 id=&quot;1-HTTP-协议的介绍&quot;&gt;&lt;a href=&quot;#1-HTTP-协议的介绍&quot; class=&quot;headerlink&quot; title=&quot;1. HTTP 协议的介绍&quot;&gt;&lt;/a&gt;1. HTTP 协议的介绍&lt;/h3&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://caijinbo.work/categories/python/"/>
    
    
      <category term="python" scheme="https://caijinbo.work/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python高级07-jQuery</title>
    <link href="https://caijinbo.work/2020/08/21/2020-08-22-python%E9%AB%98%E7%BA%A707-jQuery/"/>
    <id>https://caijinbo.work/2020/08/21/2020-08-22-python%E9%AB%98%E7%BA%A707-jQuery/</id>
    <published>2020-08-21T16:00:00.000Z</published>
    <updated>2020-11-23T10:13:41.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><h2 id="一、jQuery的介绍"><a href="#一、jQuery的介绍" class="headerlink" title="一、jQuery的介绍"></a>一、jQuery的介绍</h2><h3 id="1-jQuery的定义"><a href="#1-jQuery的定义" class="headerlink" title="1. jQuery的定义"></a>1. jQuery的定义</h3><a id="more"></a><p>jQuery是对JavaScript的封装，它是免费、开源的JavaScript函数库，jQuery 极大地简化了 JavaScript 编程。</p><p>jQuery官网：<a href="https://jquery.com/" target="_blank" rel="noopener">https://jquery.com/</a></p><h3 id="2-jQuery的作用"><a href="#2-jQuery的作用" class="headerlink" title="2. jQuery的作用"></a>2. jQuery的作用</h3><p>jQuery和JavaScript它们的作用一样，都是负责网页行为操作，增加网页和用户的交互效果的，只不过jQuery简化了JavaScript编程，jQuery实现交互效果更简单。</p><h3 id="3-jQuery的优点"><a href="#3-jQuery的优点" class="headerlink" title="3. jQuery的优点"></a>3. jQuery的优点</h3><ul><li>jQuery兼容了现在主流的浏览器，增加了程序员的开发效率。</li><li>jQuery简化了 JavaScript 编程，代码编写更加简单。</li></ul><h2 id="二、jQuery的用法"><a href="#二、jQuery的用法" class="headerlink" title="二、jQuery的用法"></a>二、jQuery的用法</h2><h3 id="1-jQuery的引入"><a href="#1-jQuery的引入" class="headerlink" title="1. jQuery的引入"></a>1. jQuery的引入</h3><pre><code class="js">&lt;script src=&quot;js/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;</code></pre><p>jQuery入口函数有两种写法:</p><pre><code class="js">  // 完整写法  $(document).ready(function(){       ...  });  // 简化写法  $(function(){       ...  });</code></pre><h3 id="2-jQuery的入口函数"><a href="#2-jQuery的入口函数" class="headerlink" title="2. jQuery的入口函数"></a>2. jQuery的入口函数</h3><p>我们知道使用js获取标签元素，需要页面加载完成以后再获取，我们通过给onload事件属性设置了一个函数来获取标签元素，而jquery提供了<strong>ready函数</strong>来解决这个问题，保证获取标签元素没有问题，<strong>它的速度比原生的 window.onload 更快</strong>。</p><p><strong>入口函数示例代码:</strong></p><pre><code class="js">&lt;script src=&quot;js/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    window.onload = function(){        var oDiv = document.getElementById(&#39;div01&#39;);        alert(&#39;原生就是获取的div：&#39; + oDiv);    };    $(document).ready(function(){        var $div = $(&#39;#div01&#39;);        alert(&#39;jquery获取的div：&#39; + $div);    });&lt;/script&gt;&lt;div id=&quot;div01&quot;&gt;这是一个div&lt;/div&gt;</code></pre><p><strong>入口函数的简写示例代码:</strong></p><pre><code class="js">&lt;script src=&quot;js/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    window.onload = function(){        var oDiv = document.getElementById(&#39;div01&#39;);        alert(&#39;原生就是获取的div：&#39; + oDiv);    };    /*    $(document).ready(function(){        var $div = $(&#39;#div01&#39;);        alert(&#39;jquery获取的div：&#39; + $div);    });    */    // 上面ready的写法可以简写成下面的形式：    $(function(){        var $div = $(&#39;#div01&#39;);        alert(&#39;jquery获取的div：&#39; + $div);    }); &lt;/script&gt;&lt;div id=&quot;div01&quot;&gt;这是一个div&lt;/div&gt;</code></pre><h2 id="三、jQuery选择器"><a href="#三、jQuery选择器" class="headerlink" title="三、jQuery选择器"></a>三、jQuery选择器</h2><h3 id="1-jQuery选择器的介绍"><a href="#1-jQuery选择器的介绍" class="headerlink" title="1. jQuery选择器的介绍"></a>1. jQuery选择器的介绍</h3><p>jquery选择器就是快速选择标签元素，获取标签的，选择规则和css样式一样。</p><p>jquery给标签设置样式使用css方法</p><h3 id="2-jQuery选择器的种类"><a href="#2-jQuery选择器的种类" class="headerlink" title="2. jQuery选择器的种类"></a>2. jQuery选择器的种类</h3><ol><li>标签选择器</li><li>类选择器</li><li>id选择器</li><li>层级选择器</li><li>属性选择器</li></ol><ul><li>jQuery选择器就是选择标签的</li><li>标签选择器是<strong>根据标签名来选择标签</strong></li><li>类选择器是<strong>根据类名来选择标签</strong></li><li>id选择器是<strong>根据id来选择标签</strong></li><li>层级选择器是<strong>根据层级关系来选择标签</strong></li><li>属性选择器是<strong>根据属性名来选择标签</strong></li></ul><p><strong>示例代码:</strong></p><pre><code class="js">$(&#39;#myId&#39;) //选择id为myId的标签$(&#39;.myClass&#39;) // 选择class为myClass的标签$(&#39;li&#39;) //选择所有的li标签$(&#39;#ul1 li span&#39;) //选择id为ul1标签下的所有li标签下的span标签$(&#39;input[name=first]&#39;) // 选择name属性等于first的input标签</code></pre><p><strong>说明:</strong><br>可以使用length属性来判断标签是否选择成功, 如果length大于0表示选择成功，否则选择失败。</p><pre><code class="js">$(function(){    result = $(&quot;div&quot;).length;    alert(result);});</code></pre><h2 id="四、选择集过滤"><a href="#四、选择集过滤" class="headerlink" title="四、选择集过滤"></a>四、选择集过滤</h2><h3 id="1-选择集过滤的介绍"><a href="#1-选择集过滤的介绍" class="headerlink" title="1. 选择集过滤的介绍"></a>1. 选择集过滤的介绍</h3><p>选择集过滤就是在选择标签的集合里面过滤自己需要的标签</p><ul><li>选择集过滤可以使用has方法和eq方法来完成</li></ul><h3 id="2-选择集过滤的操作"><a href="#2-选择集过滤的操作" class="headerlink" title="2. 选择集过滤的操作"></a>2. 选择集过滤的操作</h3><ul><li>has(选择器名称)方法，表示选取包含指定选择器的标签</li><li>eq(索引)方法，表示选取指定索引的标签</li></ul><p><strong>has方法的示例代码:</strong></p><pre><code class="js">&lt;script&gt;    $(function(){        //  has方法的使用        var $div = $(&quot;div&quot;).has(&quot;#mytext&quot;);        //  设置样式        $div.css({&quot;background&quot;:&quot;red&quot;});    });&lt;/script&gt;&lt;div&gt;    这是第一个div    &lt;input type=&quot;text&quot; id=&quot;mytext&quot;&gt;&lt;/div&gt;&lt;div&gt;    这是第二个div    &lt;input type=&quot;text&quot;&gt;    &lt;input type=&quot;button&quot;&gt;&lt;/div&gt;</code></pre><p><strong>eq方法的示例代码:</strong></p><pre><code class="js">&lt;script&gt;    $(function(){        //  has方法的使用        var $div = $(&quot;div&quot;).has(&quot;#mytext&quot;);        //  设置样式        $div.css({&quot;background&quot;:&quot;red&quot;});        //  eq方法的使用        var $div = $(&quot;div&quot;).eq(1);        //  设置样式        $div.css({&quot;background&quot;:&quot;yellow&quot;});    });&lt;/script&gt;&lt;div&gt;    这是第一个div    &lt;input type=&quot;text&quot; id=&quot;mytext&quot;&gt;&lt;/div&gt;&lt;div&gt;    这是第二个div    &lt;input type=&quot;text&quot;&gt;    &lt;input type=&quot;button&quot;&gt;&lt;/div&gt;</code></pre><h2 id="五、选择集转移"><a href="#五、选择集转移" class="headerlink" title="五、选择集转移"></a>五、选择集转移</h2><h3 id="1-选择集转移介绍"><a href="#1-选择集转移介绍" class="headerlink" title="1. 选择集转移介绍"></a>1. 选择集转移介绍</h3><p>选择集转移就是以选择的标签为参照，然后获取转移后的标签</p><ul><li>prev() 表示获取上一个同级元素</li><li>prevAll() 表示获取上面所有同级元素</li><li>next() 表示获取下一个同级元素</li><li>nextAll() 表示获取下面所有同级元素</li><li>parent() 表示获取父元素</li><li>children() 表示获取所有的子元素</li><li>siblings() 表示获取其它同级元素</li><li>find(“选择器名称”) 表示获取指定选择器的元素</li></ul><h3 id="2-选择集转移操作"><a href="#2-选择集转移操作" class="headerlink" title="2. 选择集转移操作"></a>2. 选择集转移操作</h3><ul><li>$(‘#box’).prev(); 表示选择id是box元素的上一个的同级元素</li><li>$(‘#box’).prevAll(); 表示选择id是box元素的上面所有的同级元素</li><li>$(‘#box’).next(); 表示选择id是box元素的下一个的同级元素</li><li>$(‘#box’).nextAll(); 表示选择id是box元素的下面所有的同级元素</li><li>$(‘#box’).parent(); 表示选择id是box元素的父元素</li><li>$(‘#box’).children(); 表示选择id是box元素的所有子元素</li><li>$(‘#box’).siblings(); 表示选择id是box元素的其它同级元素</li><li>$(‘#box’).find(‘.myClass’); 表示选择id是box元素的class等于myClass的元素</li></ul><p><strong>选择集转移的示例代码:</strong></p><pre><code class="js">&lt;script&gt;    $(function(){        var $div = $(&#39;#div01&#39;);        $div.prev().css({&#39;color&#39;:&#39;red&#39;});        $div.prevAll().css({&#39;text-indent&#39;:50});        $div.next().css({&#39;color&#39;:&#39;blue&#39;});        $div.nextAll().css({&#39;text-indent&#39;:80});        $div.siblings().css({&#39;text-decoration&#39;:&#39;underline&#39;})        $div.parent().css({&#39;background&#39;:&#39;gray&#39;});        $div.children().css({&#39;color&#39;:&#39;red&#39;});        $div.find(&#39;.sp02&#39;).css({&#39;font-size&#39;:30});    });  &lt;/script&gt;&lt;div&gt;    &lt;h2&gt;这是第一个h2标签&lt;/h2&gt;    &lt;p&gt;这是第一个段落&lt;/p&gt;    &lt;div id=&quot;div01&quot;&gt;这是一个&lt;span&gt;div&lt;/span&gt;&lt;span class=&quot;sp02&quot;&gt;第二个span&lt;/span&gt;&lt;/div&gt;    &lt;h2&gt;这是第二个h2标签&lt;/h2&gt;    &lt;p&gt;这是第二个段落&lt;/p&gt;</code></pre><h2 id="六、获取和设置元素内容"><a href="#六、获取和设置元素内容" class="headerlink" title="六、获取和设置元素内容"></a>六、获取和设置元素内容</h2><h3 id="1-html方法的使用"><a href="#1-html方法的使用" class="headerlink" title="1. html方法的使用"></a>1. html方法的使用</h3><ul><li><p>获取和设置元素的内容使用: html方法</p></li><li><p>给指定元素追加html内容使用: append方法</p></li></ul><p>jquery中的html方法可以获取和设置标签的html内容</p><p><strong>示例代码:</strong></p><pre><code class="js">&lt;script&gt;    $(function(){        var $div = $(&quot;#div1&quot;);        //  获取标签的html内容        var result = $div.html();        alert(result);        //  设置标签的html内容，之前的内容会清除        $div.html(&quot;&lt;span style=&#39;color:red&#39;&gt;你好&lt;/span&gt;&quot;);        //  追加html内容        $div.append(&quot;&lt;span style=&#39;color:red&#39;&gt;你好&lt;/span&gt;&quot;);    });&lt;/script&gt;&lt;div id=&quot;div1&quot;&gt;    &lt;p&gt;hello&lt;/p&gt;&lt;/div&gt;</code></pre><p><strong>说明:</strong></p><p>给指定标签追加html内容使用<strong>append方法</strong></p><h2 id="七、获取和设置元素属性"><a href="#七、获取和设置元素属性" class="headerlink" title="七、获取和设置元素属性"></a>七、获取和设置元素属性</h2><h3 id="1-prop方法的使用"><a href="#1-prop方法的使用" class="headerlink" title="1. prop方法的使用"></a>1. prop方法的使用</h3><p>之前使用css方法可以给标签设置样式属性，那么设置标签的其它属性可以使用prop方法了。</p><ul><li>获取和设置元素属性的操作可以通过prop方法来完成</li><li>获取和设置元素的value属性可以通过val方法来完成，更加简单和方便</li></ul><p><strong>示例代码:</strong></p><pre><code class="js">&lt;style&gt;    .a01{        color:red;    }&lt;/style&gt;&lt;script&gt;    $(function(){        var $a = $(&quot;#link01&quot;);        var $input = $(&#39;#input01&#39;)        // 获取元素属性        var sId = $a.prop(&quot;id&quot;);        alert(sId);        // 设置元素属性        $a.prop({&quot;href&quot;:&quot;http://www.baidu.com&quot;,&quot;title&quot;:&#39;这是去到百度的链接&#39;,&quot;class&quot;:&quot;a01&quot;});        //  获取value属性        // var sValue = $input.prop(&quot;value&quot;);        // alert(sValue);        // 获取value属性使用val()方法的简写方式        var sValue = $input.val();        alert(sValue);        // 设置value值        $input.val(&quot;222222&quot;);    })&lt;/script&gt;&lt;a id=&quot;link01&quot;&gt;这是一个链接&lt;/a&gt;&lt;input type=&quot;text&quot; id=&quot;input01&quot; value=&quot;111111&quot;&gt;</code></pre><p><strong>说明:</strong> 获取value属性和设置value属性还可以通过<strong>val方法</strong>来完成。</p><h2 id="八、jQuery事件"><a href="#八、jQuery事件" class="headerlink" title="八、jQuery事件"></a>八、jQuery事件</h2><h3 id="1-常用事件"><a href="#1-常用事件" class="headerlink" title="1. 常用事件"></a>1. 常用事件</h3><ul><li>click() 鼠标单击</li><li>blur() 元素失去焦点</li><li>focus() 元素获得焦点</li><li>mouseover() 鼠标进入（进入子元素也触发）</li><li>mouseout() 鼠标离开（离开子元素也触发）</li><li>ready() DOM加载完成</li></ul><p><strong>示例代码:</strong></p><pre><code class="js">&lt;script&gt;    $(function(){        var $li = $(&#39;.list li&#39;);        var $button = $(&#39;#button1&#39;)        var $text = $(&quot;#text1&quot;);        var $div = $(&quot;#div1&quot;)        //  鼠标点击        $li.click(function(){                         // this指的是当前发生事件的对象，但是它是一个原生js对象            // this.style.background = &#39;red&#39;;            // $(this) 指的是当前发生事件的jquery对象            $(this).css({&#39;background&#39;:&#39;gold&#39;});            // 获取jquery对象的索引值,通过index() 方法            alert($(this).index());        });        //  一般和按钮配合使用        $button.click(function(){            alert($text.val());        });        //  获取焦点        $text.focus(function(){            $(this).css({&#39;background&#39;:&#39;red&#39;});        });        //  失去焦点        $text.blur(function(){            $(this).css({&#39;background&#39;:&#39;white&#39;});        });        //  鼠标进入        $div.mouseover(function(){            $(this).css({&#39;background&#39;:&#39;gold&#39;});        });        //  鼠标离开        $div.mouseout(function() {            $(this).css({&#39;background&#39;:&#39;white&#39;});        });    });&lt;/script&gt;&lt;div id=&quot;div1&quot;&gt;    &lt;ul class=&quot;list&quot;&gt;        &lt;li&gt;列表文字&lt;/li&gt;        &lt;li&gt;列表文字&lt;/li&gt;        &lt;li&gt;列表文字&lt;/li&gt;    &lt;/ul&gt;    &lt;input type=&quot;text&quot; id=&quot;text1&quot;&gt;    &lt;input type=&quot;button&quot; id=&quot;button1&quot; value=&quot;点击&quot;&gt;&lt;/div&gt;</code></pre><p><strong>说明:</strong></p><ul><li>this指的是当前发生事件的对象，但是它是一个原生js对象</li><li>$(this) 指的是当前发生事件的jquery对象</li></ul><h2 id="九、事件代理"><a href="#九、事件代理" class="headerlink" title="九、事件代理"></a>九、事件代理</h2><h3 id="1-事件代理介绍"><a href="#1-事件代理介绍" class="headerlink" title="1. 事件代理介绍"></a>1. 事件代理介绍</h3><p>事件代理就是利用事件冒泡的原理(事件冒泡就是事件会向它的父级一级一级传递),把事件加到父级上，通过判断事件来源，执行相应的子元素的操作，<strong>事件代理首先可以极大减少事件绑定次数，提高性能；其次可以让新加入的子元素也可以拥有相同的操作</strong>。</p><ul><li>事件代理就是使用父元素来代理子元素的事件，好处是减少事件的绑定次数，提高性能。</li><li>使用场景当多个相同的子元素绑定同一个事件，可以使用事件代理。</li><li>事件代理使用是使用delegate方法来完成</li></ul><p><strong>事件冒泡代码:</strong></p><pre><code class="js"> &lt;script&gt;    $(function(){        var $div1 = $(&#39;#div1&#39;);        var $div2 = $(&#39;#div2&#39;);        $div1.click(function(){            alert($(this).html());        });         $div2.click(function(){            alert($(this).html());        });     });&lt;/script&gt; &lt;div id=&quot;div1&quot; style=&quot;width:200px; height:200px; background: red;&quot;&gt;    &lt;div id=&quot;div2&quot; style=&quot;width:100px; height:100px;background: yellow;&quot;&gt;        哈哈    &lt;/div&gt;&lt;/div&gt;</code></pre><p><strong>说明:</strong></p><p>当点击子元素div，它的点击事件会向它父元素传递，也会触发了父元素的点击事件，这就是事件冒泡。</p><h3 id="2-事件代理的使用"><a href="#2-事件代理的使用" class="headerlink" title="2. 事件代理的使用"></a>2. 事件代理的使用</h3><p><strong>一般绑定事件的写法:</strong></p><pre><code class="js">$(function(){    $ali = $(&#39;#list li&#39;);    $ali.click(function() {        $(this).css({background:&#39;red&#39;});    });})&lt;ul id=&quot;list&quot;&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;2&lt;/li&gt;    &lt;li&gt;3&lt;/li&gt;    &lt;li&gt;4&lt;/li&gt;    &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt;</code></pre><p><strong>事件代理的写法</strong></p><pre><code class="js">$(function(){    $list = $(&#39;#list&#39;);    // 父元素ul 来代理 子元素li的点击事件    $list.delegate(&#39;li&#39;, &#39;click&#39;, function() {        // $(this)表示当前点击的子元素对象        $(this).css({background:&#39;red&#39;});    });})&lt;ul id=&quot;list&quot;&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;2&lt;/li&gt;    &lt;li&gt;3&lt;/li&gt;    &lt;li&gt;4&lt;/li&gt;    &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt;</code></pre><p><strong>delegate方法参数说明:</strong></p><p>delegate(childSelector,event,function)</p><ul><li>childSelector: 子元素的选择器</li><li>event: 事件名称，比如: ‘click’</li><li>function: 当事件触发执行的函数</li></ul><h2 id="十、JavaScript对象"><a href="#十、JavaScript对象" class="headerlink" title="十、JavaScript对象"></a>十、JavaScript对象</h2><h3 id="1-JavaScript对象的介绍"><a href="#1-JavaScript对象的介绍" class="headerlink" title="1. JavaScript对象的介绍"></a>1. JavaScript对象的介绍</h3><p>JavaScript 中的所有事物都是对象：字符串、数值、数组、函数等都可以认为是对象，此外，JavaScript 允许自定义对象，对象可以拥有属性和方法。</p><p>创建自定义javascript对象有两种方式:</p><ul><li>Object</li><li>字面量</li></ul><h3 id="2-JavaScript创建对象操作"><a href="#2-JavaScript创建对象操作" class="headerlink" title="2. JavaScript创建对象操作"></a>2. JavaScript创建对象操作</h3><p>创建自定义javascript对象有两种方式:</p><ul><li>通过顶级Object类型来实例化一个对象</li><li>通过对象字面量创建一个对象</li></ul><p><strong>Object类创建对象的示例代码:</strong></p><pre><code class="js">&lt;script&gt;    var person = new Object();    // 添加属性：    person.name = &#39;tom&#39;;    person.age = &#39;25&#39;;    // 添加方法：    person.sayName = function(){        alert(this.name);    }    // 调用属性和方法：    alert(person.age);    person.sayName();&lt;/script&gt;</code></pre><p><strong>对象字面量创建对象的示例代码:</strong></p><pre><code class="js">&lt;script&gt;    var person2 = {        name:&#39;Rose&#39;,        age: 18,        sayName:function(){            alert(&#39;My name is&#39; + this.name);        }    }    // 调用属性和方法：    alert(person2.age);    person2.sayName();&lt;/script&gt;</code></pre><p><strong>说明:</strong></p><p>调用属性和方法的操作都是通过点语法的方式来完成，对象的创建推荐使用字面量方式，因为更加简单。</p><h2 id="十一、json"><a href="#十一、json" class="headerlink" title="十一、json"></a>十一、json</h2><h3 id="1-json的介绍"><a href="#1-json的介绍" class="headerlink" title="1. json的介绍"></a>1. json的介绍</h3><p>json是 JavaScript Object Notation 的首字母缩写，翻译过来就是javascript对象表示法，这里说的json就是<strong>类似于javascript对象的字符串</strong>，它同时是一种<strong>数据格式</strong>，目前这种数据格式比较流行，逐渐替换掉了传统的xml数据格式。</p><ul><li>json就是一个javascript对象表示法，json本质上是一个字符串。</li><li>json有两种格式：1. 对象格式, 2. 数组格式</li></ul><h3 id="2-json的格式"><a href="#2-json的格式" class="headerlink" title="2. json的格式"></a>2. json的格式</h3><p>json有两种格式：</p><ol><li>对象格式</li><li>数组格式</li></ol><p><strong>对象格式:</strong></p><p>对象格式的json数据，使用一对大括号({})，大括号里面放入key:value形式的键值对，多个键值对使用逗号分隔。</p><p><strong>对象格式的json数据:</strong></p><pre><code class="json">{    &quot;name&quot;:&quot;tom&quot;,    &quot;age&quot;:18}</code></pre><p><strong>格式说明:</strong></p><p>json中的(key)属性名称和字符串值需要用<strong>双引号</strong>引起来，用单引号或者不用引号会导致读取数据错误。</p><p><strong>数组格式:</strong></p><p>数组格式的json数据，使用一对中括号([])，中括号里面的数据使用逗号分隔。</p><p><strong>数组格式的json数据:</strong></p><pre><code class="json">[&quot;tom&quot;,18,&quot;programmer&quot;]</code></pre><p><strong>实际开发的json格式比较复杂,例如:</strong></p><pre><code class="json">{    &quot;name&quot;:&quot;jack&quot;,    &quot;age&quot;:29,    &quot;hobby&quot;:[&quot;reading&quot;,&quot;travel&quot;,&quot;photography&quot;]    &quot;school&quot;:{        &quot;name&quot;:&quot;Merrimack College&quot;,        &quot;location&quot;:&quot;North Andover, MA&quot;    }}</code></pre><h3 id="3-json数据转换成JavaScript对象"><a href="#3-json数据转换成JavaScript对象" class="headerlink" title="3. json数据转换成JavaScript对象"></a>3. json数据转换成JavaScript对象</h3><p><strong>json本质上是字符串</strong>，如果在js中操作json数据，可以将json字符串转化为JavaScript对象。</p><p><strong>示例代码:</strong></p><pre><code class="json">var sJson = &#39;{&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:18}&#39;;var oPerson = JSON.parse(sJson);// 操作属性alert(oPerson.name);alert(oPerson.age);</code></pre><h2 id="十二、ajax"><a href="#十二、ajax" class="headerlink" title="十二、ajax"></a>十二、ajax</h2><h3 id="1-ajax的介绍"><a href="#1-ajax的介绍" class="headerlink" title="1. ajax的介绍"></a>1. ajax的介绍</h3><p>ajax 是 Asynchronous JavaScript and XML的简写，ajax一个前后台配合的技术，它可以<strong>让 javascript 发送异步的 http 请求，与后台通信进行数据的获取</strong>，ajax 最大的优点是<strong>实现局部刷新</strong>，ajax可以发送http请求，当获取到后台数据的时候更新页面显示数据实现局部刷新，在这里大家只需要记住，<strong>当前端页面想和后台服务器进行数据交互就可以使用ajax了。</strong></p><p>这里提示一下大家, <strong>在html页面使用ajax需要在web服务器环境下运行, 一般向自己的web服务器发送ajax请求。</strong></p><ul><li>ajax 是发送http请求获取后台服务器数据的技术</li><li>ajax的简写方式可以使用$.get和$.post方法来完成</li></ul><h3 id="2-ajax的使用"><a href="#2-ajax的使用" class="headerlink" title="2. ajax的使用"></a>2. ajax的使用</h3><p>jquery将它封装成了一个方法$.ajax()，我们可以直接用这个方法来执行ajax请求。</p><p><strong>示例代码:</strong></p><pre><code class="js">&lt;script&gt;    $.ajax({    // 1.url 请求地址    url:&#39;http://t.weather.sojson.com/api/weather/city/101010100&#39;,    // 2.type 请求方式，默认是&#39;GET&#39;，常用的还有&#39;POST&#39;    type:&#39;GET&#39;,    // 3.dataType 设置返回的数据格式，常用的是&#39;json&#39;格式    dataType:&#39;JSON&#39;,    // 4.data 设置发送给服务器的数据, 没有参数不需要设置    // 5.success 设置请求成功后的回调函数    success:function (response) {        console.log(response);        },    // 6.error 设置请求失败后的回调函数    error:function () {        alert(&quot;请求失败,请稍后再试!&quot;);    },    // 7.async 设置是否异步，默认值是&#39;true&#39;，表示异步，一般不用写    async:true});&lt;/script&gt;</code></pre><p><strong>ajax方法的参数说明:</strong></p><ol><li>url 请求地址</li><li>type 请求方式，默认是’GET’，常用的还有’POST’</li><li>dataType 设置返回的数据格式，常用的是’json’格式</li><li>data 设置发送给服务器的数据，没有参数不需要设置</li><li>success 设置请求成功后的回调函数</li><li>error 设置请求失败后的回调函数</li><li>async 设置是否异步，默认值是’true’，表示异步，一般不用写</li><li>同步和异步说明<ul><li>同步是一个ajax请求完成另外一个才可以请求，需要等待上一个ajax请求完成，好比线程同步。</li><li>异步是多个ajax同时请求，不需要等待其它ajax请求完成， 好比线程异步。</li></ul></li></ol><p><strong>ajax的简写方式:</strong></p><p>$.ajax按照请求方式可以简写成$.get或者$.post方式</p><p><strong>ajax简写方式的示例代码:</strong></p><pre><code class="js"> &lt;script&gt;    $(function(){        /*         1. url 请求地址         2. data 设置发送给服务器的数据, 没有参数不需要设置         3. success 设置请求成功后的回调函数         4. dataType 设置返回的数据格式，常用的是&#39;json&#39;格式, 默认智能判断数据格式        */         $.get(&quot;http://t.weather.sojson.com/api/weather/city/101010100&quot;, function(dat,status){            console.log(dat);            console.log(status);            alert(dat);        }).error(function(){            alert(&quot;网络异常&quot;);        });        /*         1. url 请求地址         2. data 设置发送给服务器的数据, 没有参数不需要设置         3. success 设置请求成功后的回调函数         4. dataType 设置返回的数据格式，常用的是&#39;json&#39;格式, 默认智能判断数据格式        */         $.post(&quot;test.php&quot;, {&quot;func&quot;: &quot;getNameAndTime&quot;}, function(data){            alert(data.name);             console.log(data.time);         }, &quot;json&quot;).error(function(){            alert(&quot;网络异常&quot;);        });     });&lt;/script&gt;</code></pre><p><strong>$.get和$.post方法的参数说明:</strong></p><p>$.get(url,data,success(data, status, xhr),dataType).error(func)<br>$.post(url,data,success(data, status, xhr),dataType).error(func)</p><ol><li>url 请求地址</li><li>data 设置发送给服务器的数据，没有参数不需要设置</li><li>success 设置请求成功后的回调函数<ul><li>data 请求的结果数据</li><li>status 请求的状态信息, 比如: “success”</li><li>xhr 底层发送http请求XMLHttpRequest对象</li></ul></li><li>dataType 设置返回的数据格式<ul><li>“xml”</li><li>“html”</li><li>“text”</li><li>“json”</li></ul></li><li>error 表示错误异常处理<ul><li>func 错误异常回调函数</li></ul></li></ol><h2 id="十三、Ajax-综合练习"><a href="#十三、Ajax-综合练习" class="headerlink" title="十三、Ajax 综合练习"></a>十三、Ajax 综合练习</h2><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;js/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        function search(){            var search_str = $(&quot;input01&quot;).val();            $.get(&quot;http://ttapi.research.itcast.cn/app/v1_0/search?q=&quot; + search_str,function(response){                console.log(typeof(response),response);                var res_array = response.data.results;                var $ul = $(&quot;#content&quot;);                $ul.html(&quot;&quot;);                for(var i=0;i &lt; res_array.length;i++){                    console.log(res_array[i].title);                    $ul.append(&quot;&lt;li&gt;&quot; + res_array[i].title + &quot;&lt;/li&gt;&quot;);                }            },&quot;JSON&quot;).error(function(){                alert(&quot;请求失败，请稍后再试&quot;)            });        }    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;input type=&quot;text&quot; id=&quot;input01&quot;&gt;    &lt;input type=&quot;button&quot; id=&quot;btn01&quot; value=&quot;搜索&quot; onclick=&quot;search();&quot;&gt;    &lt;ul id=&quot;content&quot;&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;jQuery&quot;&gt;&lt;a href=&quot;#jQuery&quot; class=&quot;headerlink&quot; title=&quot;jQuery&quot;&gt;&lt;/a&gt;jQuery&lt;/h1&gt;&lt;h2 id=&quot;一、jQuery的介绍&quot;&gt;&lt;a href=&quot;#一、jQuery的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、jQuery的介绍&quot;&gt;&lt;/a&gt;一、jQuery的介绍&lt;/h2&gt;&lt;h3 id=&quot;1-jQuery的定义&quot;&gt;&lt;a href=&quot;#1-jQuery的定义&quot; class=&quot;headerlink&quot; title=&quot;1. jQuery的定义&quot;&gt;&lt;/a&gt;1. jQuery的定义&lt;/h3&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://caijinbo.work/categories/python/"/>
    
    
      <category term="python" scheme="https://caijinbo.work/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python高级02-多任务编程</title>
    <link href="https://caijinbo.work/2020/08/05/2020-08-06-python%E9%AB%98%E7%BA%A702-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B/"/>
    <id>https://caijinbo.work/2020/08/05/2020-08-06-python%E9%AB%98%E7%BA%A702-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B/</id>
    <published>2020-08-05T16:00:00.000Z</published>
    <updated>2020-11-23T10:13:28.543Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第2节：多任务编程"><a href="#第2节：多任务编程" class="headerlink" title="第2节：多任务编程"></a>第2节：多任务编程</h3><h4 id="1-多任务介绍"><a href="#1-多任务介绍" class="headerlink" title="1. 多任务介绍"></a>1. 多任务介绍</h4><h5 id="1-1-多任务的概念"><a href="#1-1-多任务的概念" class="headerlink" title="1.1 多任务的概念"></a>1.1 多任务的概念</h5><a id="more"></a><p>多任务是指在<strong>同一时间内</strong>执行<strong>多个任务</strong>，例如: 现在电脑安装的操作系统都是多任务操作系统，可以同时运行着多个软件。</p><h5 id="1-2-多任务的执行方式"><a href="#1-2-多任务的执行方式" class="headerlink" title="1.2 多任务的执行方式"></a>1.2 多任务的执行方式</h5><ul><li>并发</li><li>并行</li></ul><p><strong>并发:</strong></p><p>在一段时间内<strong>交替</strong>去执行任务。</p><p><strong>例如:</strong></p><p>对于单核cpu处理多任务,操作系统轮流<strong>让各个软件交替执行</strong>，假如:软件1执行0.01秒，切换到软件2，软件2执行0.01秒，再切换到软件3，执行0.01秒……这样反复执行下去。表面上看，每个软件都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像这些软件都在同时执行一样，这里需要注意单核cpu是并发的执行多任务的。</p><p><strong>并行:</strong></p><p>对于多核cpu处理多任务，操作系统会给cpu的每个内核安排一个执行的软件，<strong>多个内核是真正的一起执行软件</strong>。这里需要注意<strong>多核cpu是并行的执行多任务，始终有多个软件一起执行</strong>。</p><h4 id="2-进程的使用"><a href="#2-进程的使用" class="headerlink" title="2. 进程的使用"></a>2. 进程的使用</h4><h5 id="2-1-进程的介绍"><a href="#2-1-进程的介绍" class="headerlink" title="2.1 进程的介绍"></a>2.1 进程的介绍</h5><p>在Python程序中，想要实现多任务可以使用进程来完成，进程是实现多任务的一种方式。</p><h5 id="2-2-进程的概念"><a href="#2-2-进程的概念" class="headerlink" title="2.2 进程的概念"></a>2.2 进程的概念</h5><p>一个正在运行的程序或者软件就是一个进程，<strong>它是操作系统进行资源分配的基本单位</strong>，也就是说每启动一个进程，操作系统都会给其分配一定的运行资源(内存资源)保证进程的运行。</p><p>比如:现实生活中的公司可以理解成是一个进程，公司提供办公资源(电脑、办公桌椅等)，真正干活的是员工，员工可以理解成线程。</p><p><strong>注意:</strong></p><p><strong>一个程序运行后至少有一个进程，一个进程默认有一个线程</strong>，进程里面可以创建多个线程，<strong>线程是依附在进程里面的，没有进程就没有线程</strong>。</p><p><strong>说明:</strong></p><p>多进程可以完成多任务，每个进程就好比一家独立的公司，每个公司都各自在运营，每个进程也各自在运行，执行各自的任务。</p><h5 id="2-3-多进程的使用"><a href="#2-3-多进程的使用" class="headerlink" title="2.3 多进程的使用"></a>2.3 多进程的使用</h5><h6 id="2-3-1-导入进程包"><a href="#2-3-1-导入进程包" class="headerlink" title="2.3.1 导入进程包"></a>2.3.1 导入进程包</h6><pre><code class="python">#导入进程包import multiprocessing</code></pre><h6 id="2-3-2-Process进程类的说明"><a href="#2-3-2-Process进程类的说明" class="headerlink" title="2.3.2 Process进程类的说明"></a>2.3.2 Process进程类的说明</h6><p><strong>Process([group [, target [, name [, args [, kwargs]]]]])</strong></p><ul><li>group：指定进程组，目前只能使用None</li><li>target：执行的目标任务名</li><li>name：进程名字</li><li>args：以元组方式给执行任务传参</li><li>kwargs：以字典方式给执行任务传参</li></ul><p><strong>Process创建的实例对象的常用方法:</strong></p><ul><li>start()：启动子进程实例（创建子进程）</li><li>join()：等待子进程执行结束</li><li>terminate()：不管任务是否完成，立即终止子进程</li></ul><p><strong>Process创建的实例对象的常用属性:</strong></p><p>name：当前进程的别名，默认为Process-N，N为从1开始递增的整数</p><h6 id="2-3-3-多进程完成多任务的代码"><a href="#2-3-3-多进程完成多任务的代码" class="headerlink" title="2.3.3 多进程完成多任务的代码"></a>2.3.3 多进程完成多任务的代码</h6><pre><code class="python">import multiprocessingimport time# 跳舞任务def dance():    for i in range(5):        print(&quot;跳舞中...&quot;)        time.sleep(0.2)# 唱歌任务def sing():    for i in range(5):        print(&quot;唱歌中...&quot;)        time.sleep(0.2)if __name__ == &#39;__main__&#39;:    # 创建跳舞的子进程    # group: 表示进程组，目前只能使用None    # target: 表示执行的目标任务名(函数名、方法名)    # name: 进程名称, 默认是Process-1, .....    dance_process = multiprocessing.Process(target=dance, name=&quot;process1&quot;)    sing_process = multiprocessing.Process(target=sing)    # 启动子进程执行对应的任务    dance_process.start()    sing_process.start()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">唱歌中...跳舞中...唱歌中...跳舞中...唱歌中...跳舞中...唱歌中...跳舞中...唱歌中...跳舞中...</code></pre><h5 id="2-4-获取进程编号"><a href="#2-4-获取进程编号" class="headerlink" title="2.4 获取进程编号"></a>2.4 获取进程编号</h5><h6 id="2-4-1-获取进程编号的目的"><a href="#2-4-1-获取进程编号的目的" class="headerlink" title="2.4.1 获取进程编号的目的"></a>2.4.1 获取进程编号的目的</h6><p><strong>获取进程编号的目的是验证主进程和子进程的关系，可以得知子进程是由那个主进程创建出来的。</strong></p><p>获取进程编号的两种操作</p><ul><li>获取当前进程编号</li><li>获取当前父进程编号</li></ul><h6 id="2-4-2-获取当前进程编号"><a href="#2-4-2-获取当前进程编号" class="headerlink" title="2.4.2 获取当前进程编号"></a>2.4.2 获取当前进程编号</h6><p><strong>os.getpid()</strong> 表示获取当前进程编号</p><p><strong>示例代码:</strong></p><pre><code class="python">import multiprocessingimport timeimport os# 跳舞任务def dance():    # 获取当前进程的编号    print(&quot;dance:&quot;, os.getpid())    # 获取当前进程    print(&quot;dance:&quot;, multiprocessing.current_process())    for i in range(5):        print(&quot;跳舞中...&quot;)        time.sleep(0.2)        # 扩展:根据进程编号杀死指定进程        os.kill(os.getpid(), 9)# 唱歌任务def sing():    # 获取当前进程的编号    print(&quot;sing:&quot;, os.getpid())    # 获取当前进程    print(&quot;sing:&quot;, multiprocessing.current_process())    for i in range(5):        print(&quot;唱歌中...&quot;)        time.sleep(0.2)if __name__ == &#39;__main__&#39;:    # 获取当前进程的编号    print(&quot;main:&quot;, os.getpid())    # 获取当前进程    print(&quot;main:&quot;, multiprocessing.current_process())    # 创建跳舞的子进程    # group: 表示进程组，目前只能使用None    # target: 表示执行的目标任务名(函数名、方法名)    # name: 进程名称, 默认是Process-1, .....    dance_process = multiprocessing.Process(target=dance, name=&quot;process1&quot;)    sing_process = multiprocessing.Process(target=sing)    # 启动子进程执行对应的任务    dance_process.start()    sing_process.start()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">main: 70763main: &lt;_MainProcess(MainProcess, started)&gt;dance: 70768dance: &lt;Process(myprocess1, started)&gt;跳舞中...sing: 70769sing: &lt;Process(Process-2, started)&gt;唱歌中...唱歌中...唱歌中...唱歌中...唱歌中...</code></pre><h6 id="2-4-3-获取当前父进程编号"><a href="#2-4-3-获取当前父进程编号" class="headerlink" title="2.4.3 获取当前父进程编号"></a>2.4.3 获取当前父进程编号</h6><p><strong>os.getppid()</strong> 表示获取当前父进程编号</p><p><strong>示例代码:</strong></p><pre><code class="python">import multiprocessingimport timeimport os# 跳舞任务def dance():    # 获取当前进程的编号    print(&quot;dance:&quot;, os.getpid())    # 获取当前进程    print(&quot;dance:&quot;, multiprocessing.current_process())    # 获取父进程的编号    print(&quot;dance的父进程编号:&quot;, os.getppid())    for i in range(5):        print(&quot;跳舞中...&quot;)        time.sleep(0.2)        # 扩展:根据进程编号杀死指定进程        os.kill(os.getpid(), 9)# 唱歌任务def sing():    # 获取当前进程的编号    print(&quot;sing:&quot;, os.getpid())    # 获取当前进程    print(&quot;sing:&quot;, multiprocessing.current_process())    # 获取父进程的编号    print(&quot;sing的父进程编号:&quot;, os.getppid())    for i in range(5):        print(&quot;唱歌中...&quot;)        time.sleep(0.2)if __name__ == &#39;__main__&#39;:    # 获取当前进程的编号    print(&quot;main:&quot;, os.getpid())    # 获取当前进程    print(&quot;main:&quot;, multiprocessing.current_process())    # 创建跳舞的子进程    # group: 表示进程组，目前只能使用None    # target: 表示执行的目标任务名(函数名、方法名)    # name: 进程名称, 默认是Process-1, .....    dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;)    sing_process = multiprocessing.Process(target=sing)    # 启动子进程执行对应的任务    dance_process.start()    sing_process.start()main: 70860main: &lt;_MainProcess(MainProcess, started)&gt;dance: 70861dance: &lt;Process(myprocess1, started)&gt;dance的父进程编号: 70860跳舞中...sing: 70862sing: &lt;Process(Process-2, started)&gt;sing的父进程编号: 70860唱歌中...唱歌中...唱歌中...唱歌中...唱歌中...</code></pre><h5 id="2-5-进程执行带有参数的任务"><a href="#2-5-进程执行带有参数的任务" class="headerlink" title="2.5 进程执行带有参数的任务"></a>2.5 进程执行带有参数的任务</h5><h6 id="2-5-1-进程执行带有参数的任务的介绍"><a href="#2-5-1-进程执行带有参数的任务的介绍" class="headerlink" title="2.5.1 进程执行带有参数的任务的介绍"></a>2.5.1 进程执行带有参数的任务的介绍</h6><p>前面我们使用进程执行的任务是没有参数的，假如我们使用进程执行的任务带有参数，如何给函数传参呢?</p><p>Process类执行任务并给任务传参数有两种方式:</p><ul><li>args 表示以元组的方式给执行任务传参</li><li>kwargs 表示以字典方式给执行任务传参</li></ul><h6 id="2-5-2-args参数的使用"><a href="#2-5-2-args参数的使用" class="headerlink" title="2.5.2 args参数的使用"></a>2.5.2 args参数的使用</h6><p><strong>示例代码:</strong></p><pre><code class="python">import multiprocessingimport time# 带有参数的任务def task(count):    for i in range(count):        print(&quot;任务执行中..&quot;)        time.sleep(0.2)    else:        print(&quot;任务执行完成&quot;)if __name__ == &#39;__main__&#39;:    # 创建子进程    # args: 以元组的方式给任务传入参数    sub_process = multiprocessing.Process(target=task, args=(5,))    sub_process.start()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">任务执行中..任务执行中..任务执行中..任务执行中..任务执行中..任务执行完成</code></pre><h6 id="2-5-3-kwargs参数的使用"><a href="#2-5-3-kwargs参数的使用" class="headerlink" title="2.5.3 kwargs参数的使用"></a>2.5.3 kwargs参数的使用</h6><p><strong>示例代码:</strong></p><pre><code class="python">import multiprocessingimport time# 带有参数的任务def task(count):    for i in range(count):        print(&quot;任务执行中..&quot;)        time.sleep(0.2)    else:        print(&quot;任务执行完成&quot;)if __name__ == &#39;__main__&#39;:    # 创建子进程    # kwargs: 表示以字典方式传入参数    sub_process = multiprocessing.Process(target=task, kwargs={&quot;count&quot;: 3})    sub_process.start()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">任务执行中..任务执行中..任务执行中..任务执行完成</code></pre><h5 id="2-6-进程的注意点"><a href="#2-6-进程的注意点" class="headerlink" title="2.6 进程的注意点"></a>2.6 进程的注意点</h5><h6 id="2-6-1-进程的注意点介绍"><a href="#2-6-1-进程的注意点介绍" class="headerlink" title="2.6.1 进程的注意点介绍"></a>2.6.1 进程的注意点介绍</h6><ol><li>进程之间不共享全局变量</li><li>主进程会等待所有的子进程执行结束再结束</li></ol><h6 id="2-6-2-进程之间不共享全局变量"><a href="#2-6-2-进程之间不共享全局变量" class="headerlink" title="2.6.2 进程之间不共享全局变量"></a>2.6.2 进程之间不共享全局变量</h6><pre><code class="python">import multiprocessingimport time# 定义全局变量g_list = list()# 添加数据的任务def add_data():    for i in range(5):        g_list.append(i)        print(&quot;add:&quot;, i)        time.sleep(0.2)    # 代码执行到此，说明数据添加完成    print(&quot;add_data:&quot;, g_list)def read_data():    print(&quot;read_data&quot;, g_list)if __name__ == &#39;__main__&#39;:    # 创建添加数据的子进程    add_data_process = multiprocessing.Process(target=add_data)    # 创建读取数据的子进程    read_data_process = multiprocessing.Process(target=read_data)    # 启动子进程执行对应的任务    add_data_process.start()    # 主进程等待添加数据的子进程执行完成以后程序再继续往下执行，读取数据    add_data_process.join()    read_data_process.start()    print(&quot;main:&quot;, g_list)    # 总结: 多进程之间不共享全局变量</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">add: 0add: 1add: 2add: 3add: 4add_data: [0, 1, 2, 3, 4]main: []read_data []</code></pre><h6 id="2-6-3-进程之间不共享全局变量的小结"><a href="#2-6-3-进程之间不共享全局变量的小结" class="headerlink" title="2.6.3 进程之间不共享全局变量的小结"></a>2.6.3 进程之间不共享全局变量的小结</h6><ul><li>创建子进程会对主进程资源进行拷贝，也就是说子进程是主进程的一个副本，好比是一对双胞胎，之所以进程之间不共享全局变量，是因为操作的不是同一个进程里面的全局变量，只不过不同进程里面的全局变量名字相同而已。</li></ul><h6 id="2-6-4-主进程会等待所有的子进程执行结束再结束"><a href="#2-6-4-主进程会等待所有的子进程执行结束再结束" class="headerlink" title="2.6.4 主进程会等待所有的子进程执行结束再结束"></a>2.6.4 主进程会等待所有的子进程执行结束再结束</h6><p>假如我们现在创建一个子进程，这个子进程执行完大概需要2秒钟，现在让主进程执行0.5秒钟就退出程序，查看一下执行结果，示例代码如下:</p><pre><code class="python">import multiprocessingimport time# 定义进程所需要执行的任务def task():    for i in range(10):        print(&quot;任务执行中...&quot;)        time.sleep(0.2)if __name__ == &#39;__main__&#39;:    # 创建子进程    sub_process = multiprocessing.Process(target=task)    sub_process.start()    # 主进程延时0.5秒钟    time.sleep(0.5)    print(&quot;over&quot;)    exit()    # 总结： 主进程会等待所有的子进程执行完成以后程序再退出</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">任务执行中...任务执行中...任务执行中...over任务执行中...任务执行中...任务执行中...任务执行中...任务执行中...任务执行中...任务执行中...</code></pre><p><strong>说明:</strong></p><p>通过上面代码的执行结果，我们可以得知: <strong>主进程会等待所有的子进程执行结束再结束</strong></p><p>假如我们就让主进程执行0.5秒钟，子进程就销毁不再执行，那怎么办呢?</p><ul><li>我们可以设置<strong>守护主进程</strong> 或者 在主进程退出之前 <strong>让子进程销毁</strong></li></ul><p><strong>守护主进程:</strong></p><ul><li>守护主进程就是主进程退出子进程销毁不再执行</li></ul><p><strong>子进程销毁:</strong></p><ul><li>子进程执行结束</li></ul><p><strong>保证主进程正常退出的示例代码:</strong></p><pre><code class="python">import multiprocessingimport time# 定义进程所需要执行的任务def task():    for i in range(10):        print(&quot;任务执行中...&quot;)        time.sleep(0.2)if __name__ == &#39;__main__&#39;:    # 创建子进程    sub_process = multiprocessing.Process(target=task)    # 设置守护主进程，主进程退出子进程直接销毁，子进程的生命周期依赖与主进程    # sub_process.daemon = True    sub_process.start()    time.sleep(0.5)    print(&quot;over&quot;)    # 让子进程销毁    sub_process.terminate()    exit()    # 总结： 主进程会等待所有的子进程执行完成以后程序再退出    # 如果想要主进程退出子进程销毁，可以设置守护主进程或者在主进程退出之前让子进程销毁</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">任务执行中...任务执行中...任务执行中...over</code></pre><h6 id="2-6-5-主进程会等待所有的子进程执行结束再结束的小结"><a href="#2-6-5-主进程会等待所有的子进程执行结束再结束的小结" class="headerlink" title="2.6.5 主进程会等待所有的子进程执行结束再结束的小结"></a>2.6.5 主进程会等待所有的子进程执行结束再结束的小结</h6><ul><li>为了保证子进程能够正常的运行，主进程会等所有的子进程执行完成以后再销毁，设置守护主进程的目的是<strong>主进程退出子进程销毁，不让主进程再等待子进程去执行</strong>。</li><li>设置守护主进程方式： <strong>子进程对象.daemon = True</strong></li><li>销毁子进程方式： <strong>子进程对象.terminate()</strong></li></ul><h4 id="3-线程的使用"><a href="#3-线程的使用" class="headerlink" title="3. 线程的使用"></a>3. 线程的使用</h4><h5 id="3-1-线程的介绍"><a href="#3-1-线程的介绍" class="headerlink" title="3.1 线程的介绍"></a>3.1 线程的介绍</h5><p>在Python中，想要实现多任务除了使用进程，还可以使用线程来完成，线程是实现多任务的另外一种方式。</p><h5 id="3-2-线程的概念"><a href="#3-2-线程的概念" class="headerlink" title="3.2 线程的概念"></a>3.2 线程的概念</h5><p>线程是进程中执行代码的一个分支，每个执行分支（线程）要想工作执行代码需要cpu进行调度 ，也就是说线程是cpu调度的基本单位，每个进程至少都有一个线程，而这个线程就是我们通常说的主线程。</p><h5 id="3-3-线程的作用"><a href="#3-3-线程的作用" class="headerlink" title="3.3 线程的作用"></a>3.3 线程的作用</h5><p>多线程可以完成多任务</p><h5 id="3-4-多线程的使用"><a href="#3-4-多线程的使用" class="headerlink" title="3.4 多线程的使用"></a>3.4 多线程的使用</h5><h6 id="3-4-1-导入线程模块"><a href="#3-4-1-导入线程模块" class="headerlink" title="3.4.1 导入线程模块"></a>3.4.1 导入线程模块</h6><pre><code class="python">#导入线程模块import threading</code></pre><h6 id="3-4-2-线程类Thread参数说明"><a href="#3-4-2-线程类Thread参数说明" class="headerlink" title="3.4.2 线程类Thread参数说明"></a>3.4.2 线程类Thread参数说明</h6><p>Thread([group [, target [, name [, args [, kwargs]]]]])</p><ul><li>group: 线程组，目前只能使用None</li><li>target: 执行的目标任务名</li><li>args: 以元组的方式给执行任务传参</li><li>kwargs: 以字典方式给执行任务传参</li><li>name: 线程名，一般不用设置</li></ul><h6 id="3-4-3-启动线程"><a href="#3-4-3-启动线程" class="headerlink" title="3.4.3 启动线程"></a>3.4.3 启动线程</h6><p>启动线程使用start方法</p><h6 id="3-4-4-多线程完成多任务的代码"><a href="#3-4-4-多线程完成多任务的代码" class="headerlink" title="3.4.4 多线程完成多任务的代码"></a>3.4.4 多线程完成多任务的代码</h6><pre><code class="python">import threadingimport time# 唱歌任务def sing():    # 扩展： 获取当前线程    # print(&quot;sing当前执行的线程为：&quot;, threading.current_thread())    for i in range(3):        print(&quot;正在唱歌...%d&quot; % i)        time.sleep(1)# 跳舞任务def dance():    # 扩展： 获取当前线程    # print(&quot;dance当前执行的线程为：&quot;, threading.current_thread())    for i in range(3):        print(&quot;正在跳舞...%d&quot; % i)        time.sleep(1)if __name__ == &#39;__main__&#39;:    # 扩展： 获取当前线程    # print(&quot;当前执行的线程为：&quot;, threading.current_thread())    # 创建唱歌的线程    # target： 线程执行的函数名    sing_thread = threading.Thread(target=sing)    # 创建跳舞的线程    dance_thread = threading.Thread(target=dance)    # 开启线程    sing_thread.start()    dance_thread.start()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">正在唱歌...0正在跳舞...0正在唱歌...1正在跳舞...1正在唱歌...2正在跳舞...2</code></pre><h5 id="3-5-线程执行带有参数的任务"><a href="#3-5-线程执行带有参数的任务" class="headerlink" title="3.5 线程执行带有参数的任务"></a>3.5 线程执行带有参数的任务</h5><h6 id="3-5-1-线程执行带有参数的任务的介绍"><a href="#3-5-1-线程执行带有参数的任务的介绍" class="headerlink" title="3.5.1 线程执行带有参数的任务的介绍"></a>3.5.1 线程执行带有参数的任务的介绍</h6><p>前面我们使用线程执行的任务是没有参数的，假如我们使用线程执行的任务带有参数，如何给函数传参呢?</p><p>Thread类执行任务并给任务传参数有两种方式:</p><ul><li>args 表示以元组的方式给执行任务传参</li><li>kwargs 表示以字典方式给执行任务传参</li></ul><h6 id="3-5-2-args参数的使用"><a href="#3-5-2-args参数的使用" class="headerlink" title="3.5.2 args参数的使用"></a>3.5.2 args参数的使用</h6><p><strong>示例代码:</strong></p><pre><code class="python">import threadingimport time# 带有参数的任务def task(count):    for i in range(count):        print(&quot;任务执行中..&quot;)        time.sleep(0.2)    else:        print(&quot;任务执行完成&quot;)if __name__ == &#39;__main__&#39;:    # 创建子线程    # args: 以元组的方式给任务传入参数    sub_thread = threading.Thread(target=task, args=(5,))    sub_thread.start()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">任务执行中..任务执行中..任务执行中..任务执行中..任务执行中..任务执行完成</code></pre><h6 id="3-5-3-kwargs参数的使用"><a href="#3-5-3-kwargs参数的使用" class="headerlink" title="3.5.3 kwargs参数的使用"></a>3.5.3 kwargs参数的使用</h6><p><strong>示例代码:</strong></p><pre><code class="python">import threadingimport time# 带有参数的任务def task(count):    for i in range(count):        print(&quot;任务执行中..&quot;)        time.sleep(0.2)    else:        print(&quot;任务执行完成&quot;)if __name__ == &#39;__main__&#39;:    # 创建子线程    # kwargs: 表示以字典方式传入参数    sub_thread = threading.Thread(target=task, kwargs={&quot;count&quot;: 3})    sub_thread.start()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">任务执行中..任务执行中..任务执行中..任务执行完成</code></pre><h5 id="3-6-线程的注意点"><a href="#3-6-线程的注意点" class="headerlink" title="3.6 线程的注意点"></a>3.6 线程的注意点</h5><h6 id="3-6-1-线程的注意点介绍"><a href="#3-6-1-线程的注意点介绍" class="headerlink" title="3.6.1 线程的注意点介绍"></a>3.6.1 线程的注意点介绍</h6><ol><li>线程之间执行是无序的</li><li>主线程会等待所有的子线程执行结束再结束</li><li>线程之间共享全局变量</li><li>线程之间共享全局变量数据出现错误问题</li></ol><h6 id="3-6-2-线程之间执行是无序的"><a href="#3-6-2-线程之间执行是无序的" class="headerlink" title="3.6.2 线程之间执行是无序的"></a>3.6.2 线程之间执行是无序的</h6><pre><code class="python">import threadingimport timedef task():    time.sleep(1)    print(&quot;当前线程:&quot;, threading.current_thread().name)if __name__ == &#39;__main__&#39;:   for _ in range(5):       sub_thread = threading.Thread(target=task)       sub_thread.start()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">当前线程: Thread-1当前线程: Thread-2当前线程: Thread-4当前线程: Thread-5当前线程: Thread-3</code></pre><p><strong>说明:</strong></p><ul><li>线程之间执行是无序的，它是由cpu调度决定的 ，cpu调度哪个线程，哪个线程就先执行，没有调度的线程不能执行。</li><li>进程之间执行也是无序的，它是由操作系统调度决定的，操作系统调度哪个进程，哪个进程就先执行，没有调度的进程不能执行。</li></ul><h6 id="3-6-3-主线程会等待所有的子线程执行结束再结束"><a href="#3-6-3-主线程会等待所有的子线程执行结束再结束" class="headerlink" title="3.6.3 主线程会等待所有的子线程执行结束再结束"></a>3.6.3 主线程会等待所有的子线程执行结束再结束</h6><p>假如我们现在创建一个子线程，这个子线程执行完大概需要2.5秒钟，现在让主线程执行1秒钟就退出程序，查看一下执行结果，示例代码如下:</p><pre><code class="python">import threadingimport time# 测试主线程是否会等待子线程执行完成以后程序再退出def show_info():    for i in range(5):        print(&quot;test:&quot;, i)        time.sleep(0.5)if __name__ == &#39;__main__&#39;:    sub_thread = threading.Thread(target=show_info)    sub_thread.start()    # 主线程延时1秒    time.sleep(1)    print(&quot;over&quot;)</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">test: 0test: 1overtest: 2test: 3test: 4</code></pre><p><strong>说明:</strong></p><p>通过上面代码的执行结果，我们可以得知: <strong>主线程会等待所有的子线程执行结束再结束</strong></p><p>假如我们就让主线程执行1秒钟，子线程就销毁不再执行，那怎么办呢?</p><ul><li>我们可以设置<strong>守护主线程</strong></li></ul><p><strong>守护主线程:</strong></p><ul><li>守护主线程就是主线程退出子线程销毁不再执行</li></ul><p><strong>设置守护主线程有两种方式：</strong></p><ol><li>threading.Thread(target=show_info, daemon=True)</li><li>线程对象.setDaemon(True)</li></ol><p><strong>设置守护主线程的示例代码:</strong></p><pre><code class="python">import threadingimport time# 测试主线程是否会等待子线程执行完成以后程序再退出def show_info():    for i in range(5):        print(&quot;test:&quot;, i)        time.sleep(0.5)if __name__ == &#39;__main__&#39;:    # 创建子线程守护主线程     # daemon=True 守护主线程    # 守护主线程方式1    sub_thread = threading.Thread(target=show_info, daemon=True)    # 设置成为守护主线程，主线程退出后子线程直接销毁不再执行子线程的代码    # 守护主线程方式2    # sub_thread.setDaemon(True)    sub_thread.start()    # 主线程延时1秒    time.sleep(1)    print(&quot;over&quot;)</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">test: 0test: 1over</code></pre><h6 id="3-6-4-线程之间共享全局变量"><a href="#3-6-4-线程之间共享全局变量" class="headerlink" title="3.6.4 线程之间共享全局变量"></a>3.6.4 线程之间共享全局变量</h6><p><strong>需求:</strong></p><ol><li>定义一个列表类型的全局变量</li><li>创建两个子线程分别执行向全局变量添加数据的任务和向全局变量读取数据的任务</li><li>查看线程之间是否共享全局变量数据</li></ol><pre><code class="python">import threadingimport time# 定义全局变量my_list = list()# 写入数据任务def write_data():    for i in range(5):        my_list.append(i)        time.sleep(0.1)    print(&quot;write_data:&quot;, my_list)# 读取数据任务def read_data():    print(&quot;read_data:&quot;, my_list)if __name__ == &#39;__main__&#39;:    # 创建写入数据的线程    write_thread = threading.Thread(target=write_data)    # 创建读取数据的线程    read_thread = threading.Thread(target=read_data)    write_thread.start()    # 延时    # time.sleep(1)    # 主线程等待写入线程执行完成以后代码在继续往下执行    write_thread.join()    print(&quot;开始读取数据啦&quot;)    read_thread.start()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">write_data: [0, 1, 2, 3, 4]开始读取数据啦read_data: [0, 1, 2, 3, 4]</code></pre><h6 id="3-6-5-线程之间共享全局变量数据出现错误问题"><a href="#3-6-5-线程之间共享全局变量数据出现错误问题" class="headerlink" title="3.6.5 线程之间共享全局变量数据出现错误问题"></a>3.6.5 线程之间共享全局变量数据出现错误问题</h6><p><strong>需求:</strong></p><ol><li>定义两个函数，实现循环100万次，每循环一次给全局变量加1</li><li>创建两个子线程执行对应的两个函数，查看计算后的结果</li></ol><pre><code class="python">import threading# 定义全局变量g_num = 0# 循环一次给全局变量加1def sum_num1():    for i in range(1000000):        global g_num        g_num += 1    print(&quot;sum1:&quot;, g_num)# 循环一次给全局变量加1def sum_num2():    for i in range(1000000):        global g_num        g_num += 1    print(&quot;sum2:&quot;, g_num)if __name__ == &#39;__main__&#39;:    # 创建两个线程    first_thread = threading.Thread(target=sum_num1)    second_thread = threading.Thread(target=sum_num2)    # 启动线程    first_thread.start()    # 启动线程    second_thread.start()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">sum1: 1210949sum2: 1496035</code></pre><p><strong>注意点:</strong></p><p><strong>多线程同时对全局变量操作数据发生了错误</strong></p><p><strong>错误分析:</strong></p><p>两个线程first_thread和second_thread都要对全局变量g_num(默认是0)进行加1运算，但是由于是多线程同时操作，有可能出现下面情况：</p><ol><li>在g_num=0时，first_thread取得g_num=0。此时系统把first_thread调度为”sleeping”状态，把second_thread转换为”running”状态，t2也获得g_num=0</li><li>然后second_thread对得到的值进行加1并赋给g_num，使得g_num=1</li><li>然后系统又把second_thread调度为”sleeping”，把first_thread转为”running”。线程t1又把它之前得到的0加1后赋值给g_num。</li><li>这样导致虽然first_thread和first_thread都对g_num加1，但结果仍然是g_num=1</li></ol><p><strong>全局变量数据错误的解决办法:</strong></p><p>线程同步: 保证同一时刻只能有一个线程去操作全局变量 同步: 就是协同步调，按预定的先后次序进行运行。如:你说完，我再说, 好比现实生活中的对讲机</p><p>线程同步的方式:</p><ol><li><strong>线程等待(join)</strong></li><li><strong>互斥锁</strong></li></ol><h4 id="4-线程同步与互斥锁"><a href="#4-线程同步与互斥锁" class="headerlink" title="4. 线程同步与互斥锁"></a>4. 线程同步与互斥锁</h4><h5 id="4-1线程同步"><a href="#4-1线程同步" class="headerlink" title="4.1线程同步:"></a>4.1线程同步:</h5><p>线程同步: 保证同一时刻只能有一个线程去操作全局变量 同步: 就是协同步调，按预定的先后次序进行运行。如:你说完，我再说, 好比现实生活中的对讲机</p><p><strong>线程等待的示例代码:</strong></p><pre><code class="python">import threading# 定义全局变量g_num = 0# 循环1000000次每次给全局变量加1def sum_num1():    for i in range(1000000):        global g_num        g_num += 1    print(&quot;sum1:&quot;, g_num)# 循环1000000次每次给全局变量加1def sum_num2():    for i in range(1000000):        global g_num        g_num += 1    print(&quot;sum2:&quot;, g_num)if __name__ == &#39;__main__&#39;:    # 创建两个线程    first_thread = threading.Thread(target=sum_num1)    second_thread = threading.Thread(target=sum_num2)    # 启动线程    first_thread.start()    # 主线程等待第一个线程执行完成以后代码再继续执行，让其执行第二个线程    # 线程同步： 一个任务执行完成以后另外一个任务才能执行，同一个时刻只有一个任务在执行    first_thread.join()    # 启动线程    second_thread.start()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">sum1: 1000000sum2: 2000000</code></pre><h5 id="4-2-互斥锁的概念"><a href="#4-2-互斥锁的概念" class="headerlink" title="4.2 互斥锁的概念"></a>4.2 互斥锁的概念</h5><p>互斥锁: 对共享数据进行锁定，保证同一时刻只能有一个线程去操作。</p><p>注意:</p><ul><li>互斥锁是<strong>多个线程一起去抢</strong>，抢到锁的线程先执行，没有抢到锁的线程需要等待，等互斥锁使用完释放后，其它等待的线程再去抢这个锁。</li></ul><h5 id="4-3-互斥锁的使用"><a href="#4-3-互斥锁的使用" class="headerlink" title="4.3 互斥锁的使用"></a>4.3 互斥锁的使用</h5><p>threading模块中定义了Lock变量，这个变量本质上是一个函数，通过调用这个函数可以获取一把互斥锁。</p><p><strong>互斥锁使用步骤:</strong></p><pre><code class="python"># 创建锁mutex = threading.Lock()# 上锁mutex.acquire()...这里编写代码能保证同一时刻只能有一个线程去操作, 对共享数据进行锁定...# 释放锁mutex.release()</code></pre><p><strong>注意点:</strong></p><ul><li><strong>acquire和release方法之间的代码同一时刻只能有一个线程去操作</strong></li><li><strong>如果在调用acquire方法的时候 其他线程已经使用了这个互斥锁，那么此时acquire方法会堵塞，直到这个互斥锁释放后才能再次上锁。</strong></li></ul><h5 id="4-4-使用互斥锁完成2个线程对同一个全局变量各加100万次的操作"><a href="#4-4-使用互斥锁完成2个线程对同一个全局变量各加100万次的操作" class="headerlink" title="4.4 使用互斥锁完成2个线程对同一个全局变量各加100万次的操作"></a>4.4 使用互斥锁完成2个线程对同一个全局变量各加100万次的操作</h5><pre><code class="python">import threading# 定义全局变量g_num = 0# 创建全局互斥锁lock = threading.Lock()# 循环一次给全局变量加1def sum_num1():    # 上锁    lock.acquire()    for i in range(1000000):        global g_num        g_num += 1    print(&quot;sum1:&quot;, g_num)    # 释放锁    lock.release()# 循环一次给全局变量加1def sum_num2():    # 上锁    lock.acquire()    for i in range(1000000):        global g_num        g_num += 1    print(&quot;sum2:&quot;, g_num)    # 释放锁    lock.release()if __name__ == &#39;__main__&#39;:    # 创建两个线程    first_thread = threading.Thread(target=sum_num1)    second_thread = threading.Thread(target=sum_num2)    # 启动线程    first_thread.start()    second_thread.start()    # 提示：加上互斥锁，那个线程抢到这个锁我们决定不了，那线程抢到锁那个线程先执行，没有抢到的线程需要等待    # 加上互斥锁多任务瞬间变成单任务，性能会下降，也就是说同一时刻只能有一个线程去执行</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">sum1: 1000000sum2: 2000000</code></pre><p><strong>说明:</strong></p><p>通过执行结果可以地址<strong>互斥锁能够保证多个线程访问共享数据不会出现数据错误问题</strong></p><h4 id="5-死锁介绍"><a href="#5-死锁介绍" class="headerlink" title="5. 死锁介绍"></a>5. 死锁介绍</h4><h5 id="5-1-死锁的概念"><a href="#5-1-死锁的概念" class="headerlink" title="5.1 死锁的概念"></a>5.1 死锁的概念</h5><p>死锁: 一直等待对方释放锁的情景就是死锁</p><p><strong>说明:</strong></p><p>现实社会中，男女双方一直等待对方先道歉的这种行为就好比是死锁。</p><p><strong>死锁的结果</strong></p><ul><li>会造成应用程序的停止响应，不能再处理其它任务了。</li></ul><h5 id="5-2-死锁示例"><a href="#5-2-死锁示例" class="headerlink" title="5.2 死锁示例"></a>5.2 死锁示例</h5><p><strong>需求:</strong></p><p>根据下标在列表中取值, 保证同一时刻只能有一个线程去取值</p><pre><code class="python">import threadingimport time# 创建互斥锁lock = threading.Lock()# 根据下标去取值， 保证同一时刻只能有一个线程去取值def get_value(index):    # 上锁    lock.acquire()    print(threading.current_thread())    my_list = [3,6,8,1]    # 判断下标释放越界    if index &gt;= len(my_list):        print(&quot;下标越界:&quot;, index)        return    value = my_list[index]    print(value)    time.sleep(0.2)    # 释放锁    lock.release()if __name__ == &#39;__main__&#39;:    # 模拟大量线程去执行取值操作    for i in range(30):        sub_thread = threading.Thread(target=get_value, args=(i,))        sub_thread.start()</code></pre><h5 id="5-3-避免死锁"><a href="#5-3-避免死锁" class="headerlink" title="5.3 避免死锁"></a>5.3 避免死锁</h5><ul><li>在合适的地方释放锁</li></ul><pre><code class="python">import threadingimport time# 创建互斥锁lock = threading.Lock()# 根据下标去取值， 保证同一时刻只能有一个线程去取值def get_value(index):    # 上锁    lock.acquire()    print(threading.current_thread())    my_list = [3,6,8,1]    if index &gt;= len(my_list):        print(&quot;下标越界:&quot;, index)        # 当下标越界需要释放锁，让后面的线程还可以取值        lock.release()        return    value = my_list[index]    print(value)    time.sleep(0.2)    # 释放锁    lock.release()if __name__ == &#39;__main__&#39;:    # 模拟大量线程去执行取值操作    for i in range(30):        sub_thread = threading.Thread(target=get_value, args=(i,))        sub_thread.start()</code></pre><h4 id="6-进程和线程的对比"><a href="#6-进程和线程的对比" class="headerlink" title="6.进程和线程的对比"></a>6.进程和线程的对比</h4><h5 id="6-1-进程和线程的对比的三个方向"><a href="#6-1-进程和线程的对比的三个方向" class="headerlink" title="6.1 进程和线程的对比的三个方向"></a>6.1 进程和线程的对比的三个方向</h5><ol><li>关系对比</li><li>区别对比</li><li>优缺点对比</li></ol><h5 id="6-2-关系对比"><a href="#6-2-关系对比" class="headerlink" title="6.2 关系对比"></a>6.2 关系对比</h5><ol><li>线程是依附在进程里面的，没有进程就没有线程。</li><li>一个进程默认提供一条线程，进程可以创建多个线程。</li></ol><h5 id="6-3-区别对比"><a href="#6-3-区别对比" class="headerlink" title="6.3 区别对比"></a>6.3 区别对比</h5><ol><li>进程之间不共享全局变量</li><li>线程之间共享全局变量，但是要注意资源竞争的问题，解决办法: 互斥锁或者线程同步</li><li>创建进程的资源开销要比创建线程的资源开销要大</li><li>进程是操作系统资源分配的基本单位，线程是CPU调度的基本单位</li><li>线程不能够独立执行，必须依存在进程中</li><li>多进程开发比单进程多线程开发稳定性要强</li></ol><h5 id="6-4-优缺点对比"><a href="#6-4-优缺点对比" class="headerlink" title="6.4 优缺点对比"></a>6.4 优缺点对比</h5><ul><li>进程优缺点:<ul><li>优点：可以用多核</li><li>缺点：资源开销大</li></ul></li><li>线程优缺点:<ul><li>优点：资源开销小</li><li>缺点：不能使用多核</li></ul></li></ul><h4 id="7-协程"><a href="#7-协程" class="headerlink" title="7.协程"></a>7.协程</h4><h5 id="7-1-协程是啥"><a href="#7-1-协程是啥" class="headerlink" title="7.1 协程是啥"></a>7.1 协程是啥</h5><p>协程是python个中另外一种实现多任务的方式。</p><p>只不过比线程更小占用更小执行单元（理解为需要的资源）。</p><p>通俗的理解：</p><p>在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行，注意不是通过调用函数的方式做到的，并且切换的次数以及什么时候再切换到原来的函数都由开发者自己确定。</p><h5 id="7-2-协程的优点"><a href="#7-2-协程的优点" class="headerlink" title="7.2 协程的优点"></a>7.2 协程的优点</h5><p>最大的优势就是协程极高的执行效率。因为函数切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p><p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p><h5 id="7-3-gevent"><a href="#7-3-gevent" class="headerlink" title="7.3 gevent"></a>7.3 gevent</h5><p>gevent 是一个第三方库。</p><p>Python中仅提供了对协程的基本支持，但是不完全。而第三方的gevent为Python提供了比较完善的协程支持。</p><p>其原理是当一个任务函数遇到IO(指的是input output 输入输出，比如网络、文件操作等)操作时，比如访问网络，就自动切换到其他的任务函数执行，等到IO操作完成，再在适当的时候切换回来继续执行。</p><p>由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有任务函数在运行，而不是等待IO,得以实现多任务,提高程序执行效率。</p><h5 id="7-4-安装"><a href="#7-4-安装" class="headerlink" title="7.4 安装"></a>7.4 安装</h5><pre><code class="python">pip3 install gevent</code></pre><h5 id="7-5-gevent的使用"><a href="#7-5-gevent的使用" class="headerlink" title="7.5 gevent的使用"></a>7.5 gevent的使用</h5><pre><code class="python">import geventdef f(n):    for i in range(n):        print(gevent.getcurrent(), i)g1 = gevent.spawn(f, 5)g2 = gevent.spawn(f, 5)g3 = gevent.spawn(f, 5)g1.join()g2.join()g3.join()</code></pre><p>运行结果</p><pre><code class="python">&lt;Greenlet at 0x10e49f550: f(5)&gt; 0&lt;Greenlet at 0x10e49f550: f(5)&gt; 1&lt;Greenlet at 0x10e49f550: f(5)&gt; 2&lt;Greenlet at 0x10e49f550: f(5)&gt; 3&lt;Greenlet at 0x10e49f550: f(5)&gt; 4&lt;Greenlet at 0x10e49f910: f(5)&gt; 0&lt;Greenlet at 0x10e49f910: f(5)&gt; 1&lt;Greenlet at 0x10e49f910: f(5)&gt; 2&lt;Greenlet at 0x10e49f910: f(5)&gt; 3&lt;Greenlet at 0x10e49f910: f(5)&gt; 4&lt;Greenlet at 0x10e49f4b0: f(5)&gt; 0&lt;Greenlet at 0x10e49f4b0: f(5)&gt; 1&lt;Greenlet at 0x10e49f4b0: f(5)&gt; 2&lt;Greenlet at 0x10e49f4b0: f(5)&gt; 3&lt;Greenlet at 0x10e49f4b0: f(5)&gt; 4</code></pre><p>可以看到，3个greenlet是依次运行而不是交替运行</p><h5 id="7-6-gevent切换执行"><a href="#7-6-gevent切换执行" class="headerlink" title="7.6 gevent切换执行"></a>7.6 gevent切换执行</h5><pre><code class="python">import geventdef f(n):    for i in range(n):        print(gevent.getcurrent(), i)        #用来模拟一个耗时操作，注意不是time模块中的sleep        gevent.sleep(1)g1 = gevent.spawn(f, 5)g2 = gevent.spawn(f, 5)g3 = gevent.spawn(f, 5)g1.join()g2.join()g3.join()</code></pre><p>运行结果</p><pre><code class="python">&lt;Greenlet at 0x7fa70ffa1c30: f(5)&gt; 0&lt;Greenlet at 0x7fa70ffa1870: f(5)&gt; 0&lt;Greenlet at 0x7fa70ffa1eb0: f(5)&gt; 0&lt;Greenlet at 0x7fa70ffa1c30: f(5)&gt; 1&lt;Greenlet at 0x7fa70ffa1870: f(5)&gt; 1&lt;Greenlet at 0x7fa70ffa1eb0: f(5)&gt; 1&lt;Greenlet at 0x7fa70ffa1c30: f(5)&gt; 2&lt;Greenlet at 0x7fa70ffa1870: f(5)&gt; 2&lt;Greenlet at 0x7fa70ffa1eb0: f(5)&gt; 2&lt;Greenlet at 0x7fa70ffa1c30: f(5)&gt; 3&lt;Greenlet at 0x7fa70ffa1870: f(5)&gt; 3&lt;Greenlet at 0x7fa70ffa1eb0: f(5)&gt; 3&lt;Greenlet at 0x7fa70ffa1c30: f(5)&gt; 4&lt;Greenlet at 0x7fa70ffa1870: f(5)&gt; 4&lt;Greenlet at 0x7fa70ffa1eb0: f(5)&gt; 4</code></pre><h5 id="7-7-给程序打补丁"><a href="#7-7-给程序打补丁" class="headerlink" title="7.7 给程序打补丁"></a>7.7 给程序打补丁</h5><pre><code class="python">from gevent import monkeyimport geventimport randomimport timedef coroutine_work(coroutine_name):    for i in range(10):        print(coroutine_name, i)        time.sleep(random.random())gevent.joinall([        gevent.spawn(coroutine_work, &quot;work1&quot;),        gevent.spawn(coroutine_work, &quot;work2&quot;)])</code></pre><p>运行结果</p><pre><code class="python">work1 0work1 1work1 2work1 3work1 4work1 5work1 6work1 7work1 8work1 9work2 0work2 1work2 2work2 3work2 4work2 5work2 6work2 7work2 8work2 9from gevent import monkeyimport geventimport randomimport time# 有耗时操作时需要monkey.patch_all()  # 将程序中用到的耗时操作的代码，换为gevent中自己实现的模块def coroutine_work(coroutine_name):    for i in range(10):        print(coroutine_name, i)        time.sleep(random.random())gevent.joinall([        gevent.spawn(coroutine_work, &quot;work1&quot;),        gevent.spawn(coroutine_work, &quot;work2&quot;)])</code></pre><p>运行结果</p><pre><code class="python">work1 0work2 0work1 1work1 2work1 3work2 1work1 4work2 2work1 5work2 3work1 6work1 7work1 8work2 4work2 5work1 9work2 6work2 7work2 8work2 9</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第2节：多任务编程&quot;&gt;&lt;a href=&quot;#第2节：多任务编程&quot; class=&quot;headerlink&quot; title=&quot;第2节：多任务编程&quot;&gt;&lt;/a&gt;第2节：多任务编程&lt;/h3&gt;&lt;h4 id=&quot;1-多任务介绍&quot;&gt;&lt;a href=&quot;#1-多任务介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 多任务介绍&quot;&gt;&lt;/a&gt;1. 多任务介绍&lt;/h4&gt;&lt;h5 id=&quot;1-1-多任务的概念&quot;&gt;&lt;a href=&quot;#1-1-多任务的概念&quot; class=&quot;headerlink&quot; title=&quot;1.1 多任务的概念&quot;&gt;&lt;/a&gt;1.1 多任务的概念&lt;/h5&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://caijinbo.work/categories/python/"/>
    
    
      <category term="python" scheme="https://caijinbo.work/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python高级01-Linux基本使用</title>
    <link href="https://caijinbo.work/2020/08/04/2020-08-05-python%E9%AB%98%E7%BA%A701-Linux%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://caijinbo.work/2020/08/04/2020-08-05-python%E9%AB%98%E7%BA%A701-Linux%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2020-08-04T16:00:00.000Z</published>
    <updated>2020-11-23T10:13:27.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章：Linux基本使用"><a href="#第一章：Linux基本使用" class="headerlink" title="第一章：Linux基本使用"></a>第一章：Linux基本使用</h2><h3 id="第1节：Linux系统使用"><a href="#第1节：Linux系统使用" class="headerlink" title="第1节：Linux系统使用"></a>第1节：Linux系统使用</h3><h4 id="1-Linux基础命令使用"><a href="#1-Linux基础命令使用" class="headerlink" title="1.Linux基础命令使用"></a>1.Linux基础命令使用</h4><a id="more"></a><h5 id="1-1-查看目录命令的使用"><a href="#1-1-查看目录命令的使用" class="headerlink" title="1.1 查看目录命令的使用"></a>1.1 查看目录命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ls</td><td align="left">查看当前目录信息</td></tr><tr><td align="left">tree</td><td align="left">以树状方式显示目录信息</td></tr></tbody></table><h5 id="1-2-查看当前目录路径"><a href="#1-2-查看当前目录路径" class="headerlink" title="1.2 查看当前目录路径"></a>1.2 查看当前目录路径</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">pwd</td><td align="left">查看当前目录路径</td></tr></tbody></table><h5 id="1-3-清除终端内容"><a href="#1-3-清除终端内容" class="headerlink" title="1.3 清除终端内容"></a>1.3 清除终端内容</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">clear</td><td align="left">清除终端内容</td></tr></tbody></table><h5 id="1-4-切换目录命令的使用"><a href="#1-4-切换目录命令的使用" class="headerlink" title="1.4 切换目录命令的使用"></a>1.4 切换目录命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">cd 目录</td><td align="left">切换到指定目录</td></tr><tr><td align="left">cd ~</td><td align="left">切换到当前用户的主目录</td></tr><tr><td align="left">cd ..</td><td align="left">切换到上一级目录</td></tr><tr><td align="left">cd .</td><td align="left">切换到当前目录</td></tr><tr><td align="left">cd -</td><td align="left">切换到上一次目录</td></tr></tbody></table><p><strong>注意:</strong></p><ul><li>cd命令切换目录时，这个目录必须存在。</li><li>cd 后面不写目录等价于cd ~</li></ul><h5 id="1-5-绝对路径"><a href="#1-5-绝对路径" class="headerlink" title="1.5 绝对路径"></a>1.5 绝对路径</h5><p>从根目录算起的路径叫做绝对路径</p><p><strong>例如:</strong></p><ul><li>/home/python/Desktop</li><li>/usr/bin</li></ul><h5 id="1-6-相对路径"><a href="#1-6-相对路径" class="headerlink" title="1.6 相对路径"></a>1.6 相对路径</h5><p>从当前目录算起的路径叫做相对路径</p><p><strong>例如:</strong></p><ul><li>./test/hello</li><li>../static/images</li></ul><h5 id="1-7-绝对路径和相对路径的使用"><a href="#1-7-绝对路径和相对路径的使用" class="headerlink" title="1.7 绝对路径和相对路径的使用"></a>1.7 绝对路径和相对路径的使用</h5><ol><li>使用绝对路径切换到桌面<br>cd /home/python/Desktop</li><li>在下载目录以相对路径切换到桌面<br>cd Downloads<br>cd ../Desktop</li><li>在桌面使用相对路径切换到上一级目录的上一级目录 cd Desktop cd ../../</li></ol><h5 id="1-8-自动补全"><a href="#1-8-自动补全" class="headerlink" title="1.8 自动补全"></a>1.8 自动补全</h5><ul><li>当敲出 文件或者目录或者命令 的前几个字母之后，按下 tab 键，如果输入的没有歧义，系统会自动补全</li><li>当切换目录或者使用命令的时候，如果不确定当前目录下有那些子目录或者其它命令，可以通过两次tab键查看</li></ul><h5 id="1-9-创建、删除文件及目录命令的使用"><a href="#1-9-创建、删除文件及目录命令的使用" class="headerlink" title="1.9 创建、删除文件及目录命令的使用"></a>1.9 创建、删除文件及目录命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">touch 文件名</td><td align="left">创建指定文件</td></tr><tr><td align="left">mkdir 目录名</td><td align="left">创建目录(文件夹)</td></tr><tr><td align="left">rm 文件名或者目录名</td><td align="left">删除指定文件或者目录</td></tr><tr><td align="left">rmdir 目录名</td><td align="left">删除空目录</td></tr></tbody></table><h5 id="1-10-复制、移动文件及目录命令的使用"><a href="#1-10-复制、移动文件及目录命令的使用" class="headerlink" title="1.10 复制、移动文件及目录命令的使用"></a>1.10 复制、移动文件及目录命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">cp</td><td align="left">拷贝文件、拷贝目录</td></tr><tr><td align="left">mv</td><td align="left">移动文件、移动目录、重命名</td></tr></tbody></table><h5 id="1-11-终端命令格式说明"><a href="#1-11-终端命令格式说明" class="headerlink" title="1.11 终端命令格式说明"></a>1.11 终端命令格式说明</h5><p><strong>command</strong> [-options] [parameter]</p><p><strong>每项信息的说明:</strong></p><ul><li>command：命令名, 比如: ls、pwd</li><li>[-options]：选项，可以有零个、一个或者多个选项，多个选项可以合并，比如使用的 -r 就是选项。</li><li>[parameter]：参数，可以有零个、一个 或者 多个参数， 比如: touch 文件名、mkdir 目录名、cd 目标目录(路径)，这些文件名和目录名都是参数。</li><li>[]：代表可选</li></ul><h5 id="1-12-查看命令帮助方式"><a href="#1-12-查看命令帮助方式" class="headerlink" title="1.12 查看命令帮助方式"></a>1.12 查看命令帮助方式</h5><ul><li>–help 使用说明: 命令 –help</li><li>man 使用说明: man 命令</li></ul><p><strong>man命令的说明:</strong></p><table><thead><tr><th align="left">操作键</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">空格</td><td align="left">显示下一屏信息</td></tr><tr><td align="left">回车</td><td align="left">显示下一行信息</td></tr><tr><td align="left">b</td><td align="left">显示上一屏信息</td></tr><tr><td align="left">f</td><td align="left">显示下一屏信息</td></tr><tr><td align="left">q</td><td align="left">退出</td></tr></tbody></table><h4 id="2-Linux命令选项的使用"><a href="#2-Linux命令选项的使用" class="headerlink" title="2.Linux命令选项的使用"></a>2.Linux命令选项的使用</h4><h5 id="2-1-ls命令选项使用"><a href="#2-1-ls命令选项使用" class="headerlink" title="2.1 ls命令选项使用"></a>2.1 ls命令选项使用</h5><table><thead><tr><th align="left">命令选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-l</td><td align="left">以列表方式显示</td></tr><tr><td align="left">-h</td><td align="left">以大小单位显示，默认是字节</td></tr><tr><td align="left">-a</td><td align="left">显示隐藏文件和隐藏目录</td></tr></tbody></table><h5 id="2-2-mkdir命令选项"><a href="#2-2-mkdir命令选项" class="headerlink" title="2.2 mkdir命令选项"></a>2.2 mkdir命令选项</h5><table><thead><tr><th align="left">命令选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-p</td><td align="left">创建所依赖的文件夹</td></tr></tbody></table><h5 id="2-3-rm命令选项"><a href="#2-3-rm命令选项" class="headerlink" title="2.3 rm命令选项"></a>2.3 rm命令选项</h5><table><thead><tr><th align="left">命令选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-i</td><td align="left">交互式提示</td></tr><tr><td align="left">-r</td><td align="left">递归删除目录及其内容</td></tr><tr><td align="left">-f</td><td align="left">强制删除，忽略不存在的文件，无需提示</td></tr><tr><td align="left">-d</td><td align="left">删除空目录</td></tr></tbody></table><h5 id="2-4-cp命令选项"><a href="#2-4-cp命令选项" class="headerlink" title="2.4 cp命令选项"></a>2.4 cp命令选项</h5><table><thead><tr><th align="left">命令选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-i</td><td align="left">交互式提示</td></tr><tr><td align="left">-r</td><td align="left">递归拷贝目录及其内容</td></tr><tr><td align="left">-v</td><td align="left">显示拷贝后的路径描述</td></tr><tr><td align="left">-a</td><td align="left">保留文件的原有权限</td></tr></tbody></table><h5 id="2-5-mv命令选项"><a href="#2-5-mv命令选项" class="headerlink" title="2.5 mv命令选项"></a>2.5 mv命令选项</h5><table><thead><tr><th align="left">命令选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-i</td><td align="left">交互式提示</td></tr><tr><td align="left">-v</td><td align="left">显示移动后的路径描述</td></tr></tbody></table><h4 id="3-Linux高级命令使用"><a href="#3-Linux高级命令使用" class="headerlink" title="3. Linux高级命令使用"></a>3. Linux高级命令使用</h4><h5 id="3-1-重定向命令的使用"><a href="#3-1-重定向命令的使用" class="headerlink" title="3.1 重定向命令的使用"></a>3.1 重定向命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">&gt;</td><td align="left">如果文件存在会覆盖原有文件内容，相当于文件操作中的‘w’模式</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">如果文件存在会追加写入文件末尾，相当于文件操作中的‘a’ 模式</td></tr></tbody></table><p><strong>说明:</strong></p><p>只要在终端能显示信息的命令都可以使用重定向，比如: tree</p><h5 id="3-2-查看文件内容命令的使用"><a href="#3-2-查看文件内容命令的使用" class="headerlink" title="3.2 查看文件内容命令的使用"></a>3.2 查看文件内容命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">cat</td><td align="left">查看小型文件</td></tr><tr><td align="left">more</td><td align="left">分屏查看大型文件</td></tr></tbody></table><p><strong>说明:</strong></p><ul><li>cat命令结合重定向可以完成多个文件的合并</li><li>gedit 文件编辑命令，可以查看和编辑文件</li></ul><p><strong>more命令的效果图</strong></p><p>当查看内容信息过长无法在一屏上显示时，可以使用 more 命令在终端分屏显示文件内容。</p><p><strong>操作键说明:</strong></p><table><thead><tr><th align="left">操作键</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">空格</td><td align="left">显示下一屏信息</td></tr><tr><td align="left">回车</td><td align="left">显示下一行信息</td></tr><tr><td align="left">b</td><td align="left">显示上一屏信息</td></tr><tr><td align="left">f</td><td align="left">显示下一屏信息</td></tr><tr><td align="left">q</td><td align="left">退出</td></tr></tbody></table><h5 id="3-3-管道-命令的使用"><a href="#3-3-管道-命令的使用" class="headerlink" title="3.3 管道(|)命令的使用"></a>3.3 管道(|)命令的使用</h5><p>管道(|)：一个命令的输出可以通过管道做为另一个命令的输入，可以理解成是一个容器，存放在终端显示的内容。</p><p><strong>说明:</strong></p><p>管道(|)一般结合 more 命令使用，主要是分配查看终端显示内容。</p><h5 id="3-4-链接命令的使用"><a href="#3-4-链接命令的使用" class="headerlink" title="3.4 链接命令的使用"></a>3.4 链接命令的使用</h5><p>链接命令是创建链接文件，链接文件分为:</p><ul><li>软链接</li><li>硬链接</li></ul><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ln -s</td><td align="left">创建软链接</td></tr><tr><td align="left">ln</td><td align="left">创建硬链接</td></tr></tbody></table><h6 id="3-4-1-软链接"><a href="#3-4-1-软链接" class="headerlink" title="3.4.1 软链接"></a>3.4.1 软链接</h6><p>类似于<strong>Windows下的快捷方式</strong>，当一个源文件的目录层级比较深，我们想要方便使用它可以给源文件创建一个软链接。</p><p><strong>注意点:</strong></p><ul><li><strong>如果软链接和源文件不在同一个目录，源文件要使用绝对路径，不能使用相对路径。</strong></li><li><strong>删除源文件则软链接失效</strong></li><li><strong>可以给目录创建软链接</strong></li></ul><h6 id="3-4-2-硬链接"><a href="#3-4-2-硬链接" class="headerlink" title="3.4.2 硬链接"></a>3.4.2 硬链接</h6><p>类似于<strong>源文件的一个别名</strong>，也就是说这两个名字指向的是同一个文件数据。</p><p><strong>注意点:</strong></p><ul><li><strong>创建硬链接使用相对路径和绝对路径都可以</strong></li><li><strong>删除源文件，硬链接还可以访问到数据。</strong></li><li><strong>创建硬链接，硬链接数会加1，删除源文件或者硬链接，硬链接数会减1。</strong></li><li><strong>创建软链接，硬链接数不会加1</strong></li><li><strong>不能给目录创建硬链接</strong></li></ul><p><strong>硬链接数:</strong></p><p><strong>硬链接数就是文件数据被文件名使用的次数, 好比引用计数</strong></p><h5 id="3-5-grep命令的使用"><a href="#3-5-grep命令的使用" class="headerlink" title="3.5 grep命令的使用"></a>3.5 grep命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">grep</td><td align="left">文本搜索</td></tr></tbody></table><h6 id="3-5-1-grep命令选项的使用"><a href="#3-5-1-grep命令选项的使用" class="headerlink" title="3.5.1  grep命令选项的使用"></a>3.5.1  grep命令选项的使用</h6><table><thead><tr><th align="left">命令选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-i</td><td align="left">忽略大小写</td></tr><tr><td align="left">-n</td><td align="left">显示匹配行号</td></tr><tr><td align="left">-v</td><td align="left">显示不包含匹配文本的所有行</td></tr></tbody></table><h6 id="3-5-2-grep命令结合正则表达式的使用"><a href="#3-5-2-grep命令结合正则表达式的使用" class="headerlink" title="3.5.2 grep命令结合正则表达式的使用"></a>3.5.2 grep命令结合正则表达式的使用</h6><table><thead><tr><th align="left">正则表达式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">^</td><td align="left">以指定字符串开头</td></tr><tr><td align="left">$</td><td align="left">以指定字符串结尾</td></tr><tr><td align="left">.</td><td align="left">匹配一个非换行符的字符</td></tr></tbody></table><h5 id="3-6-find命令及选项的使用"><a href="#3-6-find命令及选项的使用" class="headerlink" title="3.6  find命令及选项的使用"></a>3.6  find命令及选项的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">find</td><td align="left">在指定目录下查找文件(包括目录)</td></tr></tbody></table><p><strong>find命令选项:</strong></p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-name</td><td align="left">根据文件名(包括目录名)字查找</td></tr></tbody></table><h6 id="3-6-1-find命令结合通配符的使用"><a href="#3-6-1-find命令结合通配符的使用" class="headerlink" title="3.6.1 find命令结合通配符的使用"></a>3.6.1 find命令结合通配符的使用</h6><p><strong>通配符:</strong></p><p>是一种特殊语句，主要有星号(*)和问号(?)，用来模糊搜索文件</p><table><thead><tr><th align="left">通配符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">代表0个或多个任意字符</td></tr><tr><td align="left">?</td><td align="left">代表任意一个字符</td></tr></tbody></table><p><strong>扩展:</strong></p><p>通配符不仅能结合 <strong>find</strong> 命令使用，还可以结合其它命令使用, 比如: <strong>ls、mv、cp</strong> 等，这里需要注意只有 <strong>find</strong> 命令使用通配符需要加上引号。</p><h5 id="3-7-tar命令及选项的使用"><a href="#3-7-tar命令及选项的使用" class="headerlink" title="3.7 tar命令及选项的使用"></a>3.7 tar命令及选项的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">tar</td><td align="left">压缩和解压缩命令</td></tr></tbody></table><p><strong>tar命令选项:</strong></p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-c</td><td align="left">创建打包文件</td></tr><tr><td align="left">-v</td><td align="left">显示打包或者解包的详细信息</td></tr><tr><td align="left">-f</td><td align="left">指定文件名称, 必须放到所有选项后面</td></tr><tr><td align="left">-z</td><td align="left">压缩或解压缩(.gz)</td></tr><tr><td align="left">-j</td><td align="left">压缩或解压缩(.bz2)</td></tr><tr><td align="left">-x</td><td align="left">解包</td></tr><tr><td align="left">-C</td><td align="left">解压缩到指定目录</td></tr></tbody></table><h5 id="3-8-zip和unzip命令及选项的使用"><a href="#3-8-zip和unzip命令及选项的使用" class="headerlink" title="3.8 zip和unzip命令及选项的使用"></a>3.8 zip和unzip命令及选项的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">zip</td><td align="left">压缩成.zip格式文件</td></tr><tr><td align="left">unzip</td><td align="left">解压缩.zip格式文件</td></tr></tbody></table><p><strong>unzip命令选项:</strong></p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-d</td><td align="left">解压缩到指定目录</td></tr></tbody></table><p><strong>说明:</strong></p><ul><li>压缩文件尽量使用.bz2格式，因为占用空间较少</li><li>使用zip命令压缩的文件占用空间比较多, 当时比较通用，操作更加简单。</li></ul><h5 id="3-9-chmod命令的介绍"><a href="#3-9-chmod命令的介绍" class="headerlink" title="3.9 chmod命令的介绍"></a>3.9 chmod命令的介绍</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">chmod</td><td align="left">修改文件权限</td></tr></tbody></table><p>chmod修改文件权限有两种方式:</p><ul><li>字母法</li><li>数字法</li></ul><h6 id="3-91-chmod-字母法的使用"><a href="#3-91-chmod-字母法的使用" class="headerlink" title="3.91 chmod 字母法的使用"></a>3.91 chmod 字母法的使用</h6><p><strong>角色说明:</strong></p><table><thead><tr><th align="left">角色</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">u</td><td align="left">user, 表示该文件的所有者</td></tr><tr><td align="left">g</td><td align="left">group, 表示用户组</td></tr><tr><td align="left">o</td><td align="left">other, 表示其他用户</td></tr><tr><td align="left">a</td><td align="left">all, 表示所有用户</td></tr></tbody></table><p><strong>权限设置说明:</strong></p><table><thead><tr><th align="left">操作符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">增加权限</td></tr><tr><td align="left">-</td><td align="left">撤销权限</td></tr><tr><td align="left">=</td><td align="left">设置权限</td></tr></tbody></table><p><strong>权限说明:</strong></p><table><thead><tr><th align="left">权限</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">r</td><td align="left">可读</td></tr><tr><td align="left">w</td><td align="left">可写</td></tr><tr><td align="left">x</td><td align="left">可执行</td></tr><tr><td align="left">-</td><td align="left">无任何权限</td></tr></tbody></table><h6 id="3-9-2-chmod-数字法的使用"><a href="#3-9-2-chmod-数字法的使用" class="headerlink" title="3.9.2 chmod 数字法的使用"></a>3.9.2 chmod 数字法的使用</h6><p>数字法就是“rwx” 这些权限也可以用<strong>数字来代替</strong></p><p><strong>权限说明:</strong></p><table><thead><tr><th align="left">权限</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">r</td><td align="left">可读，权限值是4</td></tr><tr><td align="left">w</td><td align="left">可写，权限值是2</td></tr><tr><td align="left">x</td><td align="left">可执行，权限值是1</td></tr><tr><td align="left">-</td><td align="left">无任何权限，权限值是0</td></tr></tbody></table><h5 id="3-10-sudo命令的使用"><a href="#3-10-sudo命令的使用" class="headerlink" title="3.10 sudo命令的使用"></a>3.10 sudo命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">sudo -s</td><td align="left">切换到root用户，获取管理员权限</td></tr><tr><td align="left">sudo</td><td align="left">某个命令的执行需要获取管理员权限可以在执行命令前面加上sudo</td></tr></tbody></table><h5 id="3-11-whoami命令的使用"><a href="#3-11-whoami命令的使用" class="headerlink" title="3.11 whoami命令的使用"></a>3.11 whoami命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">whoami</td><td align="left">查看当前用户</td></tr></tbody></table><h5 id="3-12-exit命令的使用"><a href="#3-12-exit命令的使用" class="headerlink" title="3.12 exit命令的使用"></a>3.12 exit命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">exit</td><td align="left">退出登录用户</td></tr></tbody></table><h5 id="3-13-who命令的使用"><a href="#3-13-who命令的使用" class="headerlink" title="3.13 who命令的使用"></a>3.13 who命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">who</td><td align="left">查看所有的登录用户</td></tr></tbody></table><h5 id="3-14-passwd命令的使用"><a href="#3-14-passwd命令的使用" class="headerlink" title="3.14 passwd命令的使用"></a>3.14 passwd命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">passwd</td><td align="left">修改用户密码，不指定用户默认修改当前登录用户密码</td></tr></tbody></table><h5 id="3-15-which命令的使用"><a href="#3-15-which命令的使用" class="headerlink" title="3.15 which命令的使用"></a>3.15 which命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">which</td><td align="left">查看命令位置</td></tr></tbody></table><h5 id="3-16-关机和重启命令的使用"><a href="#3-16-关机和重启命令的使用" class="headerlink" title="3.16 关机和重启命令的使用"></a>3.16 关机和重启命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">shutdown –h now  或者 poweroff</td><td align="left">立刻关机</td></tr><tr><td align="left">reboot</td><td align="left">重启</td></tr></tbody></table><h5 id="3-17-useradd创建用户"><a href="#3-17-useradd创建用户" class="headerlink" title="3.17 useradd创建用户"></a>3.17 useradd创建用户</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">useradd</td><td align="left">创建(添加)用户</td></tr></tbody></table><p><strong>useradd命令选项:</strong></p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-m</td><td align="left">自动创建用户主目录,主目录的名字就是用户名</td></tr><tr><td align="left">-g</td><td align="left">指定用户所属的用户组，默认不指定会自动创建一个同名的用户组</td></tr></tbody></table><p><strong>说明:</strong></p><ul><li><strong>useradd</strong> 命令的使用需要使用管理员权限，前面需要加上 <strong>sudo</strong></li><li>创建用户如果不指定用户组，默认会自动创建一个同名的用户组</li><li>查看用户是否创建成功，可以查看<strong>/etc/passwd</strong>这个文件</li><li>查看用户组是否创建成功，可以查看<strong>/etc/group</strong>这个文件</li></ul><p><strong>passwd文件中的每项信息说明,以root:x:0:0:root:/root:/bin/bash为例:</strong></p><ul><li>第一个：用户名</li><li>第二个：密码占位符</li><li>第三个：uid, 用户id</li><li>第四个：gid, 用户所在组id</li><li>第五个：用户描述, 可选，</li><li>第六个：用户的主目录所在位置</li><li>第七个：用户所用 shell 的类型，一般由bash或者sh，默认不设置是sh类型</li></ul><p><strong>group文件中的每项信息说明, 以laowang:x:1001:为例:</strong></p><ul><li>第一个：用户组名</li><li>第二个：用户组密码占位符，一般Linux系统的用户组都没有密码的</li><li>第三个：组id</li></ul><h5 id="3-18-id命令查看用户信息"><a href="#3-18-id命令查看用户信息" class="headerlink" title="3.18 id命令查看用户信息"></a>3.18 id命令查看用户信息</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">查看用户信息</td></tr></tbody></table><p><strong>每项信息说明:</strong></p><p>uid=1001(laowang) gid=1001(laowang) 组=1001(laowang)</p><ul><li>第一个: uid 表示用户id</li><li>第二个: gid 表示用户组id</li><li>第三个: 组 表示用户所在的用户组</li></ul><h5 id="3-19-su切换用户"><a href="#3-19-su切换用户" class="headerlink" title="3.19 su切换用户"></a>3.19 su切换用户</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">su</td><td align="left">切换用户</td></tr></tbody></table><p><strong>语法格式: su - 用户名</strong></p><h5 id="3-20-userdel删除用户"><a href="#3-20-userdel删除用户" class="headerlink" title="3.20 userdel删除用户"></a>3.20 userdel删除用户</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">userdel</td><td align="left">删除用户</td></tr></tbody></table><p><strong>语法格式: userdel 用户名</strong></p><p><strong>userdel命令选项:</strong></p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-r 用户名</td><td align="left">删除用户主目录，必须要设置，否则用户主目录不会删除</td></tr></tbody></table><p><strong>说明:</strong></p><ul><li>删除用户，默认同名的用户组也会被删除</li></ul><h5 id="3-21-groupadd创建用户组"><a href="#3-21-groupadd创建用户组" class="headerlink" title="3.21 groupadd创建用户组"></a>3.21 groupadd创建用户组</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">groupadd</td><td align="left">创建(添加)用户组</td></tr></tbody></table><p>创建用户并指定用户组 :</p><pre><code class="shell"> sudo useradd -m ubuntu -g root </code></pre><h4 id="4-远程登录和远程拷贝"><a href="#4-远程登录和远程拷贝" class="headerlink" title="4. 远程登录和远程拷贝"></a>4. 远程登录和远程拷贝</h4><h5 id="4-1-ssh命令的使用"><a href="#4-1-ssh命令的使用" class="headerlink" title="4.1 ssh命令的使用"></a>4.1 ssh命令的使用</h5><p><strong>ssh命令格式:</strong></p><p>ssh 用户名@ip地址</p><p>示例：</p><pre><code class="shell">ssh root@192.168.1.24</code></pre><p>安装：</p><pre><code class="shell">sudo apt install openssh-serveryum install openssh-serversudo pacman -S openssh-server</code></pre><p>启动服务：</p><pre><code class="shell">sudo systemctl start sshsudo service ssh start</code></pre><h5 id="4-2-scp命令的使用"><a href="#4-2-scp命令的使用" class="headerlink" title="4.2 scp命令的使用"></a>4.2 scp命令的使用</h5><p><strong>scp命令格式</strong></p><p>scp 源文件 目标</p><p>示例：从本地拷贝到远程目标</p><pre><code class="shell">scp test.txt root@192.168.1.24:/home/</code></pre><p>从远程拷贝文件到本地</p><pre><code class="shell">scp root@192.168.1.24:/home/test.txt /home/</code></pre><h4 id="5-vim编辑器使用"><a href="#5-vim编辑器使用" class="headerlink" title="5. vim编辑器使用"></a>5. vim编辑器使用</h4><h5 id="5-1-vim-的工作模式"><a href="#5-1-vim-的工作模式" class="headerlink" title="5.1 vim 的工作模式"></a>5.1 vim 的工作模式</h5><ul><li>命令模式</li><li>编辑模式</li><li>末行模式</li></ul><h5 id="5-2-vim-的末行模式命令"><a href="#5-2-vim-的末行模式命令" class="headerlink" title="5.2 vim 的末行模式命令"></a>5.2 vim 的末行模式命令</h5><ul><li>:w 保存</li><li>:wq 保存退出</li><li>:x 保存退出</li><li>:q! 强制退出</li></ul><h5 id="5-3-vim-的常用命令"><a href="#5-3-vim-的常用命令" class="headerlink" title="5.3 vim 的常用命令"></a>5.3 vim 的常用命令</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">yy</td><td align="left">复制光标所在行</td></tr><tr><td align="left">p</td><td align="left">粘贴</td></tr><tr><td align="left">dd</td><td align="left">删除/剪切当前行</td></tr><tr><td align="left">u</td><td align="left">撤销</td></tr><tr><td align="left">/搜索的内容</td><td align="left">搜索指定内容</td></tr><tr><td align="left">G</td><td align="left">回到最后一行</td></tr><tr><td align="left">gg</td><td align="left">回到第一行</td></tr><tr><td align="left">数字+G</td><td align="left">回到指定行</td></tr></tbody></table><p>常用命令扩展</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">&gt;&gt;</td><td align="left">往右缩进</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">往左缩进</td></tr><tr><td align="left">:%s/要替换的内容/替换后的内容/g</td><td align="left">全局替换</td></tr><tr><td align="left">:开始行数,结束行数s/要替换的内容/替换后的内容</td><td align="left">局部替换</td></tr><tr><td align="left">.</td><td align="left">重复上一次命令操作</td></tr><tr><td align="left">shift+6</td><td align="left">回到当前行的行首</td></tr><tr><td align="left">shift+4</td><td align="left">回到当前行的行末</td></tr><tr><td align="left">ctr+f</td><td align="left">下一屏</td></tr><tr><td align="left">ctr+b</td><td align="left">上一屏</td></tr><tr><td align="left">V</td><td align="left">按行选中</td></tr><tr><td align="left">ctr+r</td><td align="left">反撤销</td></tr></tbody></table><h4 id="6-ubuntu软件安装和软件卸载"><a href="#6-ubuntu软件安装和软件卸载" class="headerlink" title="6. ubuntu软件安装和软件卸载"></a>6. ubuntu软件安装和软件卸载</h4><h5 id="6-1-deb文件格式安装"><a href="#6-1-deb文件格式安装" class="headerlink" title="6.1 deb文件格式安装"></a>6.1 deb文件格式安装</h5><p>是 Ubuntu 的安装包格式，可以使用 <strong>dpkg</strong> 命令进行软件的安装和卸载。</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">dpkg</td><td align="left">安装和卸载deb安装包</td></tr></tbody></table><p><strong>dpkg命令选项:</strong></p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-i</td><td align="left">离线安装deb安装包</td></tr></tbody></table><h5 id="6-2-apt方式安装"><a href="#6-2-apt方式安装" class="headerlink" title="6.2 apt方式安装"></a>6.2 apt方式安装</h5><p>是在线安装deb软件包的命令，主要用于在线从互联网的软件仓库中<strong>搜索、安装、升级、卸载</strong>软件。</p><p><strong>在线安装软件命令格式:</strong></p><ul><li><strong>sudo apt install 安装包</strong> , 表示在线安装deb安装包</li></ul><h5 id="6-3-更改镜像源"><a href="#6-3-更改镜像源" class="headerlink" title="6.3 更改镜像源"></a>6.3 更改镜像源</h5><p>因为使用 apt-get 命令默认是从国外的服务器下载安装软件的，会导致下载安装速度很慢，所以需要更改成国内的镜像源服务器。</p><p><strong>镜像源说明:</strong></p><p>镜像源就是下载软件来源的服务器。</p><p><strong>更改镜像源的方式:</strong></p><ol><li>可视化方式更改镜像源</li><li>手动方式更改镜像源</li></ol><p><strong>说明:</strong></p><ol><li>手动修改镜像源，配置完成以后需要执行 <strong>sudo apt update</strong> 这个命令，更新镜像源保证可以下载最新的软件。</li><li><strong>使用apt方式安装软件一定要联网</strong></li></ol><h5 id="6-4-deb-文件格式卸载"><a href="#6-4-deb-文件格式卸载" class="headerlink" title="6.4 deb 文件格式卸载"></a>6.4 deb 文件格式卸载</h5><p><strong>命令格式:</strong></p><p><strong>sudo dpkg –r 安装包名</strong></p><p>-r 选项表示安装的卸载</p><h5 id="6-5-apt-方式卸载"><a href="#6-5-apt-方式卸载" class="headerlink" title="6.5 apt 方式卸载"></a>6.5 apt 方式卸载</h5><p><strong>命令格式:</strong></p><p>**sudo apt remove 安装包名</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一章：Linux基本使用&quot;&gt;&lt;a href=&quot;#第一章：Linux基本使用&quot; class=&quot;headerlink&quot; title=&quot;第一章：Linux基本使用&quot;&gt;&lt;/a&gt;第一章：Linux基本使用&lt;/h2&gt;&lt;h3 id=&quot;第1节：Linux系统使用&quot;&gt;&lt;a href=&quot;#第1节：Linux系统使用&quot; class=&quot;headerlink&quot; title=&quot;第1节：Linux系统使用&quot;&gt;&lt;/a&gt;第1节：Linux系统使用&lt;/h3&gt;&lt;h4 id=&quot;1-Linux基础命令使用&quot;&gt;&lt;a href=&quot;#1-Linux基础命令使用&quot; class=&quot;headerlink&quot; title=&quot;1.Linux基础命令使用&quot;&gt;&lt;/a&gt;1.Linux基础命令使用&lt;/h4&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://caijinbo.work/categories/python/"/>
    
    
      <category term="python" scheme="https://caijinbo.work/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python基础10-包、代码规范、案例</title>
    <link href="https://caijinbo.work/2020/08/02/2020-08-03-python%E5%9F%BA%E7%A1%8010-%E5%8C%85%E3%80%81%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E3%80%81%E6%A1%88%E4%BE%8B/"/>
    <id>https://caijinbo.work/2020/08/02/2020-08-03-python%E5%9F%BA%E7%A1%8010-%E5%8C%85%E3%80%81%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E3%80%81%E6%A1%88%E4%BE%8B/</id>
    <published>2020-08-02T16:00:00.000Z</published>
    <updated>2020-11-23T10:13:25.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="包、代码规范、案例"><a href="#包、代码规范、案例" class="headerlink" title="包、代码规范、案例"></a>包、代码规范、案例</h1><h2 id="一、Python中的包"><a href="#一、Python中的包" class="headerlink" title="一、Python中的包"></a>一、Python中的包</h2><h3 id="1-创建包"><a href="#1-创建包" class="headerlink" title="1. 创建包"></a>1. 创建包</h3><a id="more"></a><ul><li>有 2 个模块功能有些联系，可以将其放到同一个文件夹下</li><li>要组成包，还需要在该文件夹中创建<code>__init__.py</code>文件</li></ul><p><strong>总结：</strong></p><ul><li>把有联系的多个模块文件，放到同一个文件夹下，并且在这个文件夹创建一个名字为<code>__init__</code>.py 文件，那么这个文件夹就称之为包</li><li>包的本质就是一个文件夹，包的作用将模块文件组织起来</li><li>包能有效避免模块名称冲突问题，提高程序的结构性和可维护性</li></ul><h3 id="2-导入包中模块"><a href="#2-导入包中模块" class="headerlink" title="2. 导入包中模块"></a>2. 导入包中模块</h3><ul><li>使用 <code>import 包名.模块名</code> 能够导入包中的模块</li><li>使用 <code>from 包名.模块名 import...</code>能够导入模块中的符号</li></ul><p>示例代码：</p><pre><code class="python">&quot;&quot;&quot;方式1：导入格式：   import 包名.模块名            包名就是文件夹名    模块名就是文件名字使用格式：   包名.模块名.工具   (类名、函数、变量)&quot;&quot;&quot;import msg.sendmsgmsg.sendmsg.send_test()&quot;&quot;&quot;方式2：导入格式：   from 包名.模块名 import 所需的工具使用格式：   工具   (类名、函数、变量)&quot;&quot;&quot;from msg.sendmsg import send_test# from msg.sendmsg import *send_test()</code></pre><h3 id="3-init-py文件有什么用"><a href="#3-init-py文件有什么用" class="headerlink" title="3. __init__.py文件有什么用"></a>3. <code>__init__.py</code>文件有什么用</h3><ul><li>包被导入时，会执行 <code>__init__.py</code>文件的内容</li><li><code>__init__.py</code> 的作用：控制包的导入行为，管理模块文件</li></ul><h4 id="3-1-导包执行-init-py内容"><a href="#3-1-导包执行-init-py内容" class="headerlink" title="3.1 导包执行__init__.py内容"></a>3.1 导包执行<code>__init__.py</code>内容</h4><ul><li>包被导入时，会执行 <code>__init__.py</code>文件的内容</li></ul><h2 id="二、PEP8-Python代码风格指南"><a href="#二、PEP8-Python代码风格指南" class="headerlink" title="二、PEP8: Python代码风格指南"></a>二、PEP8: Python代码风格指南</h2><p>PEP8 提供了 Python 代码的编写约定，本节知识点旨在提高代码的可读性，并使其在各种 Python 代码中编写风格保持一致。</p><ol><li><p>缩进使用4个空格, 空格是首选的缩进方式. Python3 不允许混合使用制表符和空格来缩进.</p></li><li><p>每一行最大长度限制在79个字符以内.</p></li><li><p>顶层函数、类的定义, 前后使用两个空行隔开.</p></li><li><p>import 导入</p><ol><li><p>导入建议在不同的行, 例如:</p><pre><code class="python">import osimport sys# 不建议如下导包import os, sys# 但是可以如下:from subprocess import Popen, PIPE</code></pre></li><li><p>导包位于文件顶部, 在模块注释、文档字符串之后, 全局变量、常量之前. 导入按照以下顺序分组:</p><ol><li>标准库导入</li><li>相关第三方导入</li><li>本地应用/库导入</li><li>在每一组导入之间加入空行</li></ol></li></ol></li><li><p>Python 中定义字符串使用双引号、单引号是相同的, 尽量保持使用同一方式定义字符串. 当一个字符串包含单引号或者双引号时, 在最外层使用不同的符号来避免使用反斜杠转义, 从而提高可读性.</p></li><li><p>表达式和语句中的空格:</p><ol><li>避免在小括号、方括号、花括号后跟空格.</li><li>避免在逗号、分好、冒号之前添加空格.</li><li>冒号在切片中就像二元运算符, 两边要有相同数量的空格. 如果某个切片参数省略, 空格也省略.</li><li>避免为了和另外一个赋值语句对齐, 在赋值运算符附加多个空格.</li><li>避免在表达式尾部添加空格, 因为尾部空格通常看不见, 会产生混乱.</li><li>总是在二元运算符两边加一个空格, 赋值（=），增量赋值（+=，-=），比较（==,&lt;,&gt;,!=,&lt;&gt;,&lt;=,&gt;=,in,not,in,is,is not），布尔（and, or, not</li></ol></li><li><p>避免将小的代码块和 if/for/while 放在同一行, 要避免代码行太长.</p><pre><code class="python">if foo == &#39;blah&#39;: do_blah_thing()for x in lst: total += xwhile t &lt; 10: t = delay()</code></pre></li><li><p>永远不要使用字母 ‘l’(小写的L), ‘O’(大写的O), 或者 ‘I’(大写的I) 作为单字符变量名. 在有些字体里, 这些字符无法和数字0和1区分, 如果想用 ‘l’, 用 ‘L’ 代替.</p></li><li><p>类名一般使用首字母大写的约定.</p></li><li><p>函数名应该小写, 如果想提高可读性可以用下划线分隔.</p></li><li><p>如果函数的参数名和已有的关键词冲突, 在最后加单一下划线比缩写或随意拼写更好. 因此 class_ 比 clss 更好.(也许最好用同义词来避免这种冲突).</p></li><li><p>方法名和实例变量使用下划线分割的小写单词, 以提高可读性.</p></li></ol><h2 id="三、学生名片管理系统：面向对象版"><a href="#三、学生名片管理系统：面向对象版" class="headerlink" title="三、学生名片管理系统：面向对象版"></a>三、学生名片管理系统：面向对象版</h2><h3 id="1-示例代码"><a href="#1-示例代码" class="headerlink" title="1. 示例代码"></a>1. 示例代码</h3><pre><code class="python">import osclass Student(object):    &quot;&quot;&quot;学生类：保存学生的基本信息&quot;&quot;&quot;    def __init__(self, name, age, tel):        self.name = name        self.age = age        self.tel = tel    def __str__(self):        return f&#39;{self.name}\t{self.age}\t{self.tel}&#39;    def to_dict(self):        &quot;&quot;&quot;将属性内容以字典的形式返回&quot;&quot;&quot;        return {&#39;name&#39;: self.name, &#39;age&#39;: self.age, &#39;tel&#39;: self.tel}class ManagerStuSys(object):    &quot;&quot;&quot;管理学生：增删改查学生信息&quot;&quot;&quot;    def __init__(self):        self.user_list = []    def test(self):        s1 = Student(&#39;mike&#39;, 34, &#39;110&#39;)        s2 = Student(&#39;tom&#39;, 24, &#39;120&#39;)        self.user_list.append(s1)        self.user_list.append(s2)        for obj in self.user_list:            print(obj)    def start(self):        self.load_info()        while True:            self.help_menu()            cmd = input(&#39;请输入功能数字：&#39;)            if cmd == &#39;1&#39;:                print(&#39;添加学生&#39;)                self.add_info()            elif cmd == &#39;2&#39;:                print(&#39;显示所有学生&#39;)                self.show_all_stu()            elif cmd == &#39;3&#39;:                print(&#39;查询学生信息&#39;)                self.find_stu_by_name()            elif cmd == &#39;4&#39;:                print(&#39;修改学生名片信息&#39;)                self.update_stu_by_name()            elif cmd == &#39;5&#39;:                print(&#39;删除学生信息&#39;)                self.del_stu_by_name()            elif cmd == &#39;6&#39;:                print(&#39;保存信息&#39;)                self.save_info()            elif cmd == &#39;7&#39;:                print(&#39;退出系统&#39;)                break            else:                print(&#39;输入错误，请重新输入&#39;)    @staticmethod    def help_menu():        print(&#39;=&#39; * 30)        print(&#39;= 1.添加学生名片信息&#39;)        print(&#39;= 2.显示所有学生名片信息&#39;)        print(&#39;= 3.查询学生名片信息&#39;)        print(&#39;= 4.修改学生名片信息&#39;)        print(&#39;= 5.删除学生名片信息&#39;)        print(&#39;= 6.保存学生名片信息&#39;)        print(&#39;= 7.退出系统&#39;)        print(&#39;=&#39; * 30)    def add_info(self):        &quot;&quot;&quot;添加学生名片信息&quot;&quot;&quot;        name = input(&#39;请输入姓名：&#39;)        age = int(input(&#39;请输入年龄：&#39;))        tel = input(&#39;请输入电话：&#39;)        # 通过for遍历，取出某个元素后，这个元素就是对象        for obj in self.user_list:            if obj.name == name:                print(f&#39;已经存在{name}学生，不能添加&#39;)                break        else:            obj = Student(name, age, tel)            self.user_list.append(obj)            print(f&#39;{name}学生添加成功&#39;)    def show_all_stu(self):        &quot;&quot;&quot;显示所有学生名片信息&quot;&quot;&quot;        if len(self.user_list) == 0:            print(&#39;当前没有任何名片信息&#39;)            return        # 打印表头        print(&#39;序号\t姓名\t年龄\t电话&#39;)        for i, obj in enumerate(self.user_list):            print(f&#39;{i+1}\t{obj}&#39;)    def find_stu_by_name(self):        &quot;&quot;&quot;查找学生名片信息&quot;&quot;&quot;        name = input(&#39;请输入需要查找的姓名：&#39;)        for obj in self.user_list:            if obj.name == name:                print(obj)                break        else:            print(f&#39;{name}用户不存在&#39;)    def update_stu_by_name(self):        &quot;&quot;&quot;修改学生名片信息&quot;&quot;&quot;        name = input(&#39;请输入想要修改的姓名：&#39;)        for i, obj in enumerate(self.user_list):            if obj.name == name:                new_name = input(&#39;请输入新的名字：&#39;)                new_age = input(&#39;请输入新的年龄：&#39;)                new_tel = input(&#39;请输入新的电话：&#39;)                self.user_list[i].name = new_name                self.user_list[i].age = new_age                self.user_list[i].tel = new_tel                print(&#39;修改成功&#39;)                break        else:            print(f&#39;{name}用户不存在&#39;)    def del_stu_by_name(self):        &quot;&quot;&quot;删除学生名片信息&quot;&quot;&quot;        name = input(&#39;请输入想要删除的姓名：&#39;)        for i, obj in enumerate(self.user_list):            if obj.name == name:                del self.user_list[i]                print(&#39;删除成功&#39;)                break        else:            print(f&#39;{name}用户不存在&#39;)    def save_info(self):        &quot;&quot;&quot;保存学生名片信息&quot;&quot;&quot;        new_list = []        for obj in self.user_list:            new_list.append(obj.to_dict())        with open(&#39;stu.txt&#39;, &#39;w&#39;) as f:            f.write(str(new_list))            print(&#39;保存成功&#39;)    def load_info(self):        &quot;&quot;&quot;加载文件内容&quot;&quot;&quot;        if not os.path.exists(&#39;stu.txt&#39;):            print(&#39;文件不存在，无法加载&#39;)            return        with open(&#39;stu.txt&#39;) as f:            content = f.read()            temp_list = eval(content)            print(&#39;加载成功&#39;)        for user_dict in temp_list:            obj = Student(user_dict[&#39;name&#39;], user_dict[&#39;age&#39;], user_dict[&#39;tel&#39;])            self.user_list.append(obj)mss = ManagerStuSys()mss.start()</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;包、代码规范、案例&quot;&gt;&lt;a href=&quot;#包、代码规范、案例&quot; class=&quot;headerlink&quot; title=&quot;包、代码规范、案例&quot;&gt;&lt;/a&gt;包、代码规范、案例&lt;/h1&gt;&lt;h2 id=&quot;一、Python中的包&quot;&gt;&lt;a href=&quot;#一、Python中的包&quot; class=&quot;headerlink&quot; title=&quot;一、Python中的包&quot;&gt;&lt;/a&gt;一、Python中的包&lt;/h2&gt;&lt;h3 id=&quot;1-创建包&quot;&gt;&lt;a href=&quot;#1-创建包&quot; class=&quot;headerlink&quot; title=&quot;1. 创建包&quot;&gt;&lt;/a&gt;1. 创建包&lt;/h3&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://caijinbo.work/categories/python/"/>
    
    
      <category term="python" scheme="https://caijinbo.work/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python基础09-异常、模块</title>
    <link href="https://caijinbo.work/2020/08/02/2020-08-03-python%E5%9F%BA%E7%A1%8009-%E5%BC%82%E5%B8%B8%E3%80%81%E6%A8%A1%E5%9D%97/"/>
    <id>https://caijinbo.work/2020/08/02/2020-08-03-python%E5%9F%BA%E7%A1%8009-%E5%BC%82%E5%B8%B8%E3%80%81%E6%A8%A1%E5%9D%97/</id>
    <published>2020-08-02T16:00:00.000Z</published>
    <updated>2020-11-23T10:13:24.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异常、模块"><a href="#异常、模块" class="headerlink" title="异常、模块"></a>异常、模块</h1><h2 id="一、捕获异常"><a href="#一、捕获异常" class="headerlink" title="一、捕获异常"></a>一、捕获异常</h2><h3 id="1-处理异常目的"><a href="#1-处理异常目的" class="headerlink" title="1. 处理异常目的"></a>1. 处理异常目的</h3><a id="more"></a><ul><li>只要解释器检查到异常错误，默认执行的动作是终止程序</li><li>处理异常目的：防止程序退出，保证程序正常执行</li></ul><h3 id="2-捕获异常"><a href="#2-捕获异常" class="headerlink" title="2. 捕获异常"></a>2. 捕获异常</h3><h4 id="2-1-try…except…"><a href="#2-1-try…except…" class="headerlink" title="2.1 try…except…"></a>2.1 try…except…</h4><p>语法格式：</p><pre><code class="python">try:    可能发生异常的代码except:      # 处理异常的代码    1. 如果try里面发生异常    2. 自动跳转到except里面</code></pre><ul><li>把可能出现问题的代码，放在try中</li><li>把处理异常的代码，放在except中</li><li>except后面没有指定异常类型，可以捕获任意类型的异常</li></ul><p>示例代码：</p><pre><code class="python">try:    print(&#39;=&#39; * 20)    open(&#39;xxx.txt&#39;, &#39;r&#39;)  # 发生了异常，自动跳转到except里面    print(&#39;=&#39; * 20)except:    print(&#39;try里面发生了异常&#39;)</code></pre><p>运行结果：</p><pre><code class="python">====================try里面发生了异常</code></pre><h4 id="2-2-捕获指定异常类型"><a href="#2-2-捕获指定异常类型" class="headerlink" title="2.2 捕获指定异常类型"></a>2.2 捕获指定异常类型</h4><p>语法格式：</p><pre><code class="python">try:    可能发生异常的代码except 异常类型:      处理异常的代码</code></pre><p>示例代码：</p><pre><code class="python">try:    print(&#39;=&#39; * 20)    open(&#39;xxx.txt&#39;, &#39;r&#39;)  # 发生了异常，自动跳转到except里面    print(&#39;=&#39; * 20)except FileNotFoundError:    print(&#39;try里面发生了异常&#39;)</code></pre><p>运行结果：</p><pre><code class="python">====================try里面发生了异常</code></pre><h4 id="2-3-except捕获多个异常"><a href="#2-3-except捕获多个异常" class="headerlink" title="2.3 except捕获多个异常"></a>2.3 except捕获多个异常</h4><p>语法格式：</p><pre><code class="python">try:    可能发生异常的代码except (异常类型1, 异常类型2):      处理异常的代码</code></pre><p>示例代码：</p><pre><code class="python">try:    print(&#39;=&#39; * 20)    # open(&#39;xxx.txt&#39;, &#39;r&#39;)    print(&#39;=&#39; * 20)    print(num)    print(&#39;=&#39; * 20)except (FileNotFoundError, NameError):    print(&#39;try里面发生了异常&#39;)</code></pre><h4 id="2-4-获取异常的信息描述"><a href="#2-4-获取异常的信息描述" class="headerlink" title="2.4 获取异常的信息描述"></a>2.4 获取异常的信息描述</h4><p>语法格式：</p><pre><code class="python">&quot;&quot;&quot;try:    可能发生异常的代码except 异常类型 as 异常对象名:    print(异常对象名) 即可获取异常的信息描述&quot;&quot;&quot;</code></pre><p>示例代码：</p><pre><code class="python">try:    print(&#39;=&#39; * 20)    open(&#39;xxx.txt&#39;, &#39;r&#39;)    print(&#39;=&#39; * 20)except FileNotFoundError as e:    print(&#39;异常信息为：&#39;, e)</code></pre><p>运行结果：</p><pre><code class="shell">====================异常信息为： [Errno 2] No such file or directory: &#39;xxx.txt&#39;</code></pre><h4 id="2-5-捕获任意类型的异常"><a href="#2-5-捕获任意类型的异常" class="headerlink" title="2.5 捕获任意类型的异常"></a>2.5 捕获任意类型的异常</h4><p>语法格式：</p><pre><code class="python">&quot;&quot;&quot;try:    可能发生异常的代码except Exception as 异常对象名:    Exception 为异常类的父类&quot;&quot;&quot;</code></pre><p>示例代码：</p><pre><code class="python">try:    print(&#39;=&#39; * 20)    open(&#39;xxx.txt&#39;, &#39;r&#39;)    print(&#39;=&#39; * 20)# except Exception: 捕获任意异常的类型except Exception as e:    print(&#39;异常信息为：&#39;, e)</code></pre><h4 id="2-6-异常中else"><a href="#2-6-异常中else" class="headerlink" title="2.6 异常中else"></a>2.6 异常中else</h4><ul><li>在 if 中，它的作用是当条件不满足时执行的实行</li><li>同样在 try…except… 中也是如此，即如果没有捕获到异常，那么就执行else中的事情</li></ul><p>语法格式：</p><pre><code class="python">&quot;&quot;&quot;try:    可能发生异常的代码except:    处理异常的代码else:    没有发生异常，except不满足执行else&quot;&quot;&quot;</code></pre><p>示例代码：</p><pre><code class="python">try:    num = 100   print(num)except NameError as errorMsg:    print(&#39;产生错误了:%s&#39;%errorMsg)else:    print(&#39;没有捕获到异常，真高兴&#39;)</code></pre><p>运行结果：</p><pre><code>====================666====================没有发生异常，很开心</code></pre><h4 id="2-7-try…finally…"><a href="#2-7-try…finally…" class="headerlink" title="2.7 try…finally…"></a>2.7 try…finally…</h4><h5 id="2-7-1-语法格式"><a href="#2-7-1-语法格式" class="headerlink" title="2.7.1 语法格式"></a>2.7.1 语法格式</h5><p>语法格式：</p><pre><code class="python">&quot;&quot;&quot;try:    可能发生异常的代码except:    处理异常的代码else:    没有发生异常，except不满足执行elsefinally:    不管有没有异常，最终都要执行&quot;&quot;&quot;</code></pre><p>示例代码：</p><pre><code class="python">try:    print(&#39;=&#39; * 20)    # num = 666    print(num)    print(&#39;=&#39; * 20)except Exception as e:    print(&#39;异常信息为：&#39;, e)else:    print(&#39;没有发生异常，很开心&#39;)finally:    print(&#39;不管有没有异常，最终都要执行&#39;)</code></pre><p>运行结果：</p><pre><code class="python">====================异常信息为： name &#39;num&#39; is not defined不管有没有异常，最终都要执行</code></pre><h5 id="2-7-2-应用场景"><a href="#2-7-2-应用场景" class="headerlink" title="2.7.2 应用场景"></a>2.7.2 应用场景</h5><ul><li>对于文件操作，在文件打开的前提下，后面文件的其它操作，不管有没有发生异常，最终都应该关闭文件</li></ul><pre><code class="python">f = open(&#39;yyy.txt&#39;, &#39;w&#39;)  # 前提是，成功打开文件try:    # ret = f.read()    # print(ret)    f.write(&#39;hello mike&#39;)    print(&#39;=&#39;*20)except Exception as e:    print(&#39;产出异常，异常信息为：&#39;, e)else:    print(&#39;没有产生异常&#39;)finally:    print(&#39;不管有没有异常，都要关闭文件&#39;)    f.close()</code></pre><h2 id="二、异常传递"><a href="#二、异常传递" class="headerlink" title="二、异常传递"></a>二、异常传递</h2><h3 id="1-异常传递特点"><a href="#1-异常传递特点" class="headerlink" title="1. 异常传递特点"></a>1. 异常传递特点</h3><ul><li>如果异常在内部产生，如果内部不捕获处理，这个异常会向外部传递</li></ul><h3 id="2-异常嵌套"><a href="#2-异常嵌套" class="headerlink" title="2. 异常嵌套"></a>2. 异常嵌套</h3><ul><li>try嵌套时，如果内层try没有捕获处理该异常，就会向外层try进行传递</li></ul><pre><code class="python">try:    f = open(&#39;yyy.txt&#39;, &#39;w&#39;)    # 内部语句执行完，才向外部传递异常    try:        # 前面只写方式打开文件，不能读文件，产生异常        # 内部没有捕获处理异常        ret = f.read()        print(ret)    finally:        print(&#39;关闭文件&#39;)        f.close()except Exception as e:    print(&#39;外层捕获异常：&#39;, e)</code></pre><p>运行结果：</p><pre><code class="python">关闭文件外层捕获异常： not readable</code></pre><h3 id="3-函数嵌套"><a href="#3-函数嵌套" class="headerlink" title="3. 函数嵌套"></a>3. 函数嵌套</h3><ul><li>函数嵌套时，如果内层函数没有捕获处理该异常，就会向外层函数进行传递</li></ul><pre><code class="python"># 定义1个函数，函数内部发生了异常 test01()，没有捕获处理def test01():    print(&#39;开始执行test0111111&#39;)    print(num)    print(&#39;结束执行test0111111&#39;)# 定义另外一个函数 test02, 在函数内部调用test01def test02():    print(&#39;开始执行test02222222&#39;)    test01()    print(&#39;结束执行test02222222&#39;)# 定义一个test03函数，函数内部调用test01，但是对test01做异常处理def test03():    print(&#39;开始执行test0333333&#39;)    try:        test01()    except Exception as e:        print(&#39;外层函数捕获异常：&#39;, e)    print(&#39;结束执行test0333333&#39;)# 调用test02()# test02()test03()</code></pre><p>运行结果：</p><pre><code class="python">开始执行test0333333开始执行test0111111外层函数捕获异常： name &#39;num&#39; is not defined结束执行test0333333</code></pre><h2 id="三、抛出自定义的异常"><a href="#三、抛出自定义的异常" class="headerlink" title="三、抛出自定义的异常"></a>三、抛出自定义的异常</h2><h3 id="1-抛出自定义的异常"><a href="#1-抛出自定义的异常" class="headerlink" title="1. 抛出自定义的异常"></a>1. 抛出自定义的异常</h3><ul><li>用户可用 raise语句 来人为抛出一个异常。</li><li>异常/错误对象必须有一个名字，且它们应是Exception类的子类</li></ul><p>语法格式：</p><pre><code class="python"># 1. 自定义异常类class 自定义异常类名字(Exception):    1.1 重新写__init__(self, 形参1， 形参2，……)        # 建议调用父类的init，先做父类的初始化工作        super().__init__()        咱们自己写的代码    1.2 重新写__str__()，返回提示信息# 2. 抛出异常类raise 自定义异常类名字(实参1， 实参2，……)</code></pre><p>示例代码：</p><pre><code class="python">&quot;&quot;&quot;需求：1. 自定义异常类，电话号码长度异常类    1.1 __init__，添加2个属性，用户电话的长度，要求的长度    1.2 __str__ 返回提示描述意思，如：用户电话长度为：xx位, 这边要求长度为：11位2. 只要用户输入的手机号码不为11位，抛出自定义异常类&quot;&quot;&quot;# 1. 自定义异常类，电话号码长度异常类class NumberError(Exception):    &quot;&quot;&quot;自定义异常类，电话号码长度异常类&quot;&quot;&quot;    # 添加2个属性，用户电话的长度，要求的长度    def __init__(self, _user_len, _match_len=11):        super().__init__()  # 调用父类的init        self.user_len = _user_len  # 用户电话的长度        self.match_len = _match_len  # 要求号码的长度    def __str__(self):        return f&#39;用户电话长度为：{self.user_len} 位, 这边要求的长度为：{self.match_len} 位&#39;# 2. 只要用户输入的手机号码不为11位，抛出自定义异常类try:    num_str = input(&#39;请输入你的号码：&#39;)    if num_str != 11:        raise NumberError(len(num_str))  # 抛出自定义异常类except NumberError as e:  # e 为 NumberError(len(num_str))实例对象 的别名    print(&#39;异常信息为：&#39;, e)</code></pre><p>运行结果：</p><pre><code class="python">请输入你的号码：11232异常信息为： 用户电话长度为：5 位, 这边要求的长度为：11 位</code></pre><h2 id="四、模块"><a href="#四、模块" class="headerlink" title="四、模块"></a>四、模块</h2><h3 id="1-模块介绍"><a href="#1-模块介绍" class="headerlink" title="1. 模块介绍"></a>1. 模块介绍</h3><ul><li>模块是一个由Python代码组成的文件，就是一个以<code>.py</code>结尾的文件。</li><li>模块包含函数、类和变量，还可以包括可运行的代码。</li><li>模块的主要作用：<ul><li>提高了代码的可维护性</li><li>一个模块编写完毕之后，其他模块直接调用，不用再从零开始写代码了，节约了工作时间</li><li>避免名字冲突</li></ul></li></ul><h3 id="2-模块的导入"><a href="#2-模块的导入" class="headerlink" title="2. 模块的导入"></a>2. 模块的导入</h3><h4 id="2-1-import"><a href="#2-1-import" class="headerlink" title="2.1 import"></a>2.1 import</h4><ul><li>import导入模块，把整个模块都加载进来</li></ul><p>语法格式：</p><pre><code class="python">&quot;&quot;&quot;导入格式：     import 模块名使用格式：     模块名.函数  模块名.类名  模块名.变量名&quot;&quot;&quot;</code></pre><p>示例代码：</p><pre><code class="python"># 导入模块import random# 模块名.函数num = random.randint(1, 3)print(num)# 模块名.类名# 创建对象ran = random.Random()print(type(ran))# 模块名.变量名print(random.TWOPI)</code></pre><h4 id="2-2-from…import导入模块中需要的内容"><a href="#2-2-from…import导入模块中需要的内容" class="headerlink" title="2.2 from…import导入模块中需要的内容"></a>2.2 from…import导入模块中需要的内容</h4><ul><li>from…import可以只导入模块中需要使用的内容</li></ul><p>语法格式：</p><pre><code class="python">&quot;&quot;&quot;导入格式：     from 模块名 import 需使用的函数、类、变量使用格式：     函数、类、变量   无需通过模块名引用&quot;&quot;&quot;</code></pre><p>示例代码：</p><pre><code class="python">from random import randint, Random, TWOPI# 函数num = randint(1, 3)print(num)# 类ran = Random()print(type(ran))# 变量print(TWOPI)</code></pre><h4 id="2-3-from…import导入模块中所有的内容"><a href="#2-3-from…import导入模块中所有的内容" class="headerlink" title="2.3 from…import导入模块中所有的内容"></a>2.3 from…import导入模块中所有的内容</h4><p>语法格式：</p><pre><code class="python">&quot;&quot;&quot;导入格式：     from 模块名 import *使用格式：     函数、类、变量   无需通过模块名引用&quot;&quot;&quot;</code></pre><p>示例代码：</p><pre><code class="python">from random import *# 函数num = randint(1, 3)print(num)# 类ran = Random()print(type(ran))</code></pre><h4 id="2-4-import…as…给导入的模块取别名"><a href="#2-4-import…as…给导入的模块取别名" class="headerlink" title="2.4 import…as…给导入的模块取别名"></a>2.4 import…as…给导入的模块取别名</h4><ul><li>把复杂名字改简单些</li><li>把已经同名的名字改一个不同名的名字</li></ul><p>语法格式：</p><pre><code class="python">&quot;&quot;&quot;模块起别名导入格式：import 模块 as 模块别名使用格式：模块别名.工具(工具指函数、类、变量)模块工具起别名导入格式：from 模块 import 工具 as 工具别名使用格式：工具别名        无需通过模块名引用&quot;&quot;&quot;</code></pre><p>示例代码：</p><pre><code class="python"># 将模块random取别名为rimport random as r# 模块别名.方法num = r.randint(1, 3)print(num)# 模块工具randint取别名为rifrom random import randint as rinum = ri(1, 3)print(num)</code></pre><h4 id="2-5-模块搜索路径"><a href="#2-5-模块搜索路径" class="headerlink" title="2.5 模块搜索路径"></a>2.5 模块搜索路径</h4><p>当你导入一个模块，Python解析器对模块位置的搜索顺序是：</p><ol><li>当前目录</li><li>如果不在当前目录，Python则搜索系统路劲</li><li>模块搜索路径存储在system模块的sys.path变量中。</li></ol><p>示例代码：</p><pre><code class="python">import sys# 模块搜索路径存储在system模块的sys.path变量中print(sys.path)</code></pre><h2 id="五、模块制作"><a href="#五、模块制作" class="headerlink" title="五、模块制作"></a>五、模块制作</h2><h3 id="1-定义自己的模块"><a href="#1-定义自己的模块" class="headerlink" title="1. 定义自己的模块"></a>1. 定义自己的模块</h3><p>在Python中，每个Python文件都可以作为一个模块，模块的名字就是文件的名字。比如有这样一个文件<code>module.py</code>，在<code>module.py</code>中定义了所需的函数：</p><pre><code class="python">def my_add(a, b):    &quot;&quot;&quot;返回2个数相加结果&quot;&quot;&quot;    return a+bdef my_sub(a, b):    &quot;&quot;&quot;返回2个数相减结果&quot;&quot;&quot;    return a-b</code></pre><h3 id="2-调用自己定义的模块"><a href="#2-调用自己定义的模块" class="headerlink" title="2. 调用自己定义的模块"></a>2. 调用自己定义的模块</h3><pre><code class="python">import module   # 导入模块# 调用模块中的函数ret = module.my_add(1, 1)print(ret)ret = module.my_sub(10, 20)print(ret)</code></pre><h3 id="3-测试模块"><a href="#3-测试模块" class="headerlink" title="3. 测试模块"></a>3. 测试模块</h3><h4 id="3-1-测试模块"><a href="#3-1-测试模块" class="headerlink" title="3.1 测试模块"></a>3.1 测试模块</h4><p>在实际开中，当一个开发人员编写完一个模块后，为了让模块能够在项目中达到想要的效果，这个开发人员会自行在模块文件中添加一些测试信息，例如：</p><p>module.py:</p><pre><code>def my_add(a, b):    &quot;&quot;&quot;返回2个数相加结果&quot;&quot;&quot;    return a+bdef my_sub(a, b):    &quot;&quot;&quot;返回2个数相减结果&quot;&quot;&quot;    return a-bret = my_add(2, 2)print(&#39;模块中测试代码：my_add(2, 2) = &#39;, ret)ret = my_sub(10, 2)print(&#39;模块中测试代码：my_sub(10, 2) = &#39;, ret)</code></pre><p>导入模块文件，默认执行模块文件的内容：</p><pre><code class="python">import module </code></pre><h4 id="3-2-模块中的-name"><a href="#3-2-模块中的-name" class="headerlink" title="3.2 模块中的__name__"></a>3.2 模块中的<code>__name__</code></h4><ul><li><p>直接运行此文件，<code>__name__</code>的结果为<code>__main__</code></p></li><li><p>此文件被当做模块文件导入时，<code>__name__</code>的结果不为<code>__main__</code></p></li><li><p>如果不想导包把模块的测试代码也运行，把模块的测试代码放在<code>if __name__ == &#39;__main__&#39;:</code>条件语句里面</p></li></ul><h4 id="4-模块中的-all"><a href="#4-模块中的-all" class="headerlink" title="4. 模块中的__all__"></a>4. 模块中的<code>__all__</code></h4><ul><li><p>模块中<code>__all__</code>变量，<strong>只对</strong><code>from xxx import *</code>这种导入方式有效</p></li><li><p>模块中<code>__all__</code>变量包含的元素，才能会被<code>from xxx import *</code>导入</p></li><li><p><code>__all__</code>格式：</p><pre><code class="python"> __all__ = [&#39;变量名&#39;, &#39;类名&#39;, &#39;函数名&#39;, ……]</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;异常、模块&quot;&gt;&lt;a href=&quot;#异常、模块&quot; class=&quot;headerlink&quot; title=&quot;异常、模块&quot;&gt;&lt;/a&gt;异常、模块&lt;/h1&gt;&lt;h2 id=&quot;一、捕获异常&quot;&gt;&lt;a href=&quot;#一、捕获异常&quot; class=&quot;headerlink&quot; title=&quot;一、捕获异常&quot;&gt;&lt;/a&gt;一、捕获异常&lt;/h2&gt;&lt;h3 id=&quot;1-处理异常目的&quot;&gt;&lt;a href=&quot;#1-处理异常目的&quot; class=&quot;headerlink&quot; title=&quot;1. 处理异常目的&quot;&gt;&lt;/a&gt;1. 处理异常目的&lt;/h3&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://caijinbo.work/categories/python/"/>
    
    
      <category term="python" scheme="https://caijinbo.work/tags/python/"/>
    
  </entry>
  
</feed>
