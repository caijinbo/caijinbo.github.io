<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="这是始于兴趣搭建的个人博客。"><meta name="baidu-site-verification"><title>python高级02-多任务编程 | CAIJINBO</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="CAIJINBO" type="application/atom+xml">
</head><link rel="stylesheet" type="text/css" href="/plugins/prettify/doxy.css"><script type="text/javascript" src="/js/ready.js" async></script><body class="night"><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">CAIJINBO</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">CAIJINBO</a></h1></div><p class="m-desc">懒人在思考......,<br>解决不了问题，就解决提出问题的人！</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/categories/">分类</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li><span class="dot">●</span><a href="/about/">关于</a></li><li><span class="dot">●</span><a href="/atom.xml">RSS</a></li><li class="m-sch"><form class="form" id="j-formsch" method="get"><input class="txt" type="text" id="local-search-input" name="q" value="搜索" onfocus="if(this.value=='搜索'){this.value='';}" onblur="if(this.value==''){this.value='搜索';}"><input type="text" style="display:none;"></form></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">python高级02-多任务编程</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/2020/08/05/2020-08-06-python%E9%AB%98%E7%BA%A702-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B/">2020-08-05</a></span><span class="p-category"><i class="fa fa-folder"></i><a href="/categories/python/">python</a></span><span class="p-view" id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span></span></div></div><div class="p-content"><h3 id="第2节：多任务编程"><a href="#第2节：多任务编程" class="headerlink" title="第2节：多任务编程"></a>第2节：多任务编程</h3><h4 id="1-多任务介绍"><a href="#1-多任务介绍" class="headerlink" title="1. 多任务介绍"></a>1. 多任务介绍</h4><h5 id="1-1-多任务的概念"><a href="#1-1-多任务的概念" class="headerlink" title="1.1 多任务的概念"></a>1.1 多任务的概念</h5><a id="more"></a>

<p>多任务是指在<strong>同一时间内</strong>执行<strong>多个任务</strong>，例如: 现在电脑安装的操作系统都是多任务操作系统，可以同时运行着多个软件。</p>
<h5 id="1-2-多任务的执行方式"><a href="#1-2-多任务的执行方式" class="headerlink" title="1.2 多任务的执行方式"></a>1.2 多任务的执行方式</h5><ul>
<li>并发</li>
<li>并行</li>
</ul>
<p><strong>并发:</strong></p>
<p>在一段时间内<strong>交替</strong>去执行任务。</p>
<p><strong>例如:</strong></p>
<p>对于单核cpu处理多任务,操作系统轮流<strong>让各个软件交替执行</strong>，假如:软件1执行0.01秒，切换到软件2，软件2执行0.01秒，再切换到软件3，执行0.01秒……这样反复执行下去。表面上看，每个软件都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像这些软件都在同时执行一样，这里需要注意单核cpu是并发的执行多任务的。</p>
<p><strong>并行:</strong></p>
<p>对于多核cpu处理多任务，操作系统会给cpu的每个内核安排一个执行的软件，<strong>多个内核是真正的一起执行软件</strong>。这里需要注意<strong>多核cpu是并行的执行多任务，始终有多个软件一起执行</strong>。</p>
<h4 id="2-进程的使用"><a href="#2-进程的使用" class="headerlink" title="2. 进程的使用"></a>2. 进程的使用</h4><h5 id="2-1-进程的介绍"><a href="#2-1-进程的介绍" class="headerlink" title="2.1 进程的介绍"></a>2.1 进程的介绍</h5><p>在Python程序中，想要实现多任务可以使用进程来完成，进程是实现多任务的一种方式。</p>
<h5 id="2-2-进程的概念"><a href="#2-2-进程的概念" class="headerlink" title="2.2 进程的概念"></a>2.2 进程的概念</h5><p>一个正在运行的程序或者软件就是一个进程，<strong>它是操作系统进行资源分配的基本单位</strong>，也就是说每启动一个进程，操作系统都会给其分配一定的运行资源(内存资源)保证进程的运行。</p>
<p>比如:现实生活中的公司可以理解成是一个进程，公司提供办公资源(电脑、办公桌椅等)，真正干活的是员工，员工可以理解成线程。</p>
<p><strong>注意:</strong></p>
<p><strong>一个程序运行后至少有一个进程，一个进程默认有一个线程</strong>，进程里面可以创建多个线程，<strong>线程是依附在进程里面的，没有进程就没有线程</strong>。</p>
<p><strong>说明:</strong></p>
<p>多进程可以完成多任务，每个进程就好比一家独立的公司，每个公司都各自在运营，每个进程也各自在运行，执行各自的任务。</p>
<h5 id="2-3-多进程的使用"><a href="#2-3-多进程的使用" class="headerlink" title="2.3 多进程的使用"></a>2.3 多进程的使用</h5><h6 id="2-3-1-导入进程包"><a href="#2-3-1-导入进程包" class="headerlink" title="2.3.1 导入进程包"></a>2.3.1 导入进程包</h6><pre><code class="python">#导入进程包
import multiprocessing</code></pre>
<h6 id="2-3-2-Process进程类的说明"><a href="#2-3-2-Process进程类的说明" class="headerlink" title="2.3.2 Process进程类的说明"></a>2.3.2 Process进程类的说明</h6><p><strong>Process([group [, target [, name [, args [, kwargs]]]]])</strong></p>
<ul>
<li>group：指定进程组，目前只能使用None</li>
<li>target：执行的目标任务名</li>
<li>name：进程名字</li>
<li>args：以元组方式给执行任务传参</li>
<li>kwargs：以字典方式给执行任务传参</li>
</ul>
<p><strong>Process创建的实例对象的常用方法:</strong></p>
<ul>
<li>start()：启动子进程实例（创建子进程）</li>
<li>join()：等待子进程执行结束</li>
<li>terminate()：不管任务是否完成，立即终止子进程</li>
</ul>
<p><strong>Process创建的实例对象的常用属性:</strong></p>
<p>name：当前进程的别名，默认为Process-N，N为从1开始递增的整数</p>
<h6 id="2-3-3-多进程完成多任务的代码"><a href="#2-3-3-多进程完成多任务的代码" class="headerlink" title="2.3.3 多进程完成多任务的代码"></a>2.3.3 多进程完成多任务的代码</h6><pre><code class="python">import multiprocessing
import time


# 跳舞任务
def dance():
    for i in range(5):
        print(&quot;跳舞中...&quot;)
        time.sleep(0.2)


# 唱歌任务
def sing():
    for i in range(5):
        print(&quot;唱歌中...&quot;)
        time.sleep(0.2)

if __name__ == &#39;__main__&#39;:
    # 创建跳舞的子进程
    # group: 表示进程组，目前只能使用None
    # target: 表示执行的目标任务名(函数名、方法名)
    # name: 进程名称, 默认是Process-1, .....
    dance_process = multiprocessing.Process(target=dance, name=&quot;process1&quot;)
    sing_process = multiprocessing.Process(target=sing)

    # 启动子进程执行对应的任务
    dance_process.start()
    sing_process.start()</code></pre>
<p><strong>执行结果:</strong></p>
<pre><code class="python">唱歌中...
跳舞中...
唱歌中...
跳舞中...
唱歌中...
跳舞中...
唱歌中...
跳舞中...
唱歌中...
跳舞中...</code></pre>
<h5 id="2-4-获取进程编号"><a href="#2-4-获取进程编号" class="headerlink" title="2.4 获取进程编号"></a>2.4 获取进程编号</h5><h6 id="2-4-1-获取进程编号的目的"><a href="#2-4-1-获取进程编号的目的" class="headerlink" title="2.4.1 获取进程编号的目的"></a>2.4.1 获取进程编号的目的</h6><p><strong>获取进程编号的目的是验证主进程和子进程的关系，可以得知子进程是由那个主进程创建出来的。</strong></p>
<p>获取进程编号的两种操作</p>
<ul>
<li>获取当前进程编号</li>
<li>获取当前父进程编号</li>
</ul>
<h6 id="2-4-2-获取当前进程编号"><a href="#2-4-2-获取当前进程编号" class="headerlink" title="2.4.2 获取当前进程编号"></a>2.4.2 获取当前进程编号</h6><p><strong>os.getpid()</strong> 表示获取当前进程编号</p>
<p><strong>示例代码:</strong></p>
<pre><code class="python">import multiprocessing
import time
import os


# 跳舞任务
def dance():
    # 获取当前进程的编号
    print(&quot;dance:&quot;, os.getpid())
    # 获取当前进程
    print(&quot;dance:&quot;, multiprocessing.current_process())
    for i in range(5):
        print(&quot;跳舞中...&quot;)
        time.sleep(0.2)
        # 扩展:根据进程编号杀死指定进程
        os.kill(os.getpid(), 9)


# 唱歌任务
def sing():
    # 获取当前进程的编号
    print(&quot;sing:&quot;, os.getpid())
    # 获取当前进程
    print(&quot;sing:&quot;, multiprocessing.current_process())
    for i in range(5):
        print(&quot;唱歌中...&quot;)
        time.sleep(0.2)


if __name__ == &#39;__main__&#39;:

    # 获取当前进程的编号
    print(&quot;main:&quot;, os.getpid())
    # 获取当前进程
    print(&quot;main:&quot;, multiprocessing.current_process())
    # 创建跳舞的子进程
    # group: 表示进程组，目前只能使用None
    # target: 表示执行的目标任务名(函数名、方法名)
    # name: 进程名称, 默认是Process-1, .....
    dance_process = multiprocessing.Process(target=dance, name=&quot;process1&quot;)
    sing_process = multiprocessing.Process(target=sing)

    # 启动子进程执行对应的任务
    dance_process.start()
    sing_process.start()</code></pre>
<p><strong>执行结果:</strong></p>
<pre><code class="python">main: 70763
main: &lt;_MainProcess(MainProcess, started)&gt;
dance: 70768
dance: &lt;Process(myprocess1, started)&gt;
跳舞中...
sing: 70769
sing: &lt;Process(Process-2, started)&gt;
唱歌中...
唱歌中...
唱歌中...
唱歌中...
唱歌中...</code></pre>
<h6 id="2-4-3-获取当前父进程编号"><a href="#2-4-3-获取当前父进程编号" class="headerlink" title="2.4.3 获取当前父进程编号"></a>2.4.3 获取当前父进程编号</h6><p><strong>os.getppid()</strong> 表示获取当前父进程编号</p>
<p><strong>示例代码:</strong></p>
<pre><code class="python">import multiprocessing
import time
import os


# 跳舞任务
def dance():
    # 获取当前进程的编号
    print(&quot;dance:&quot;, os.getpid())
    # 获取当前进程
    print(&quot;dance:&quot;, multiprocessing.current_process())
    # 获取父进程的编号
    print(&quot;dance的父进程编号:&quot;, os.getppid())
    for i in range(5):
        print(&quot;跳舞中...&quot;)
        time.sleep(0.2)
        # 扩展:根据进程编号杀死指定进程
        os.kill(os.getpid(), 9)


# 唱歌任务
def sing():
    # 获取当前进程的编号
    print(&quot;sing:&quot;, os.getpid())
    # 获取当前进程
    print(&quot;sing:&quot;, multiprocessing.current_process())
    # 获取父进程的编号
    print(&quot;sing的父进程编号:&quot;, os.getppid())
    for i in range(5):
        print(&quot;唱歌中...&quot;)
        time.sleep(0.2)


if __name__ == &#39;__main__&#39;:

    # 获取当前进程的编号
    print(&quot;main:&quot;, os.getpid())
    # 获取当前进程
    print(&quot;main:&quot;, multiprocessing.current_process())
    # 创建跳舞的子进程
    # group: 表示进程组，目前只能使用None
    # target: 表示执行的目标任务名(函数名、方法名)
    # name: 进程名称, 默认是Process-1, .....
    dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;)
    sing_process = multiprocessing.Process(target=sing)

    # 启动子进程执行对应的任务
    dance_process.start()
    sing_process.start()
main: 70860
main: &lt;_MainProcess(MainProcess, started)&gt;
dance: 70861
dance: &lt;Process(myprocess1, started)&gt;
dance的父进程编号: 70860
跳舞中...
sing: 70862
sing: &lt;Process(Process-2, started)&gt;
sing的父进程编号: 70860
唱歌中...
唱歌中...
唱歌中...
唱歌中...
唱歌中...</code></pre>
<h5 id="2-5-进程执行带有参数的任务"><a href="#2-5-进程执行带有参数的任务" class="headerlink" title="2.5 进程执行带有参数的任务"></a>2.5 进程执行带有参数的任务</h5><h6 id="2-5-1-进程执行带有参数的任务的介绍"><a href="#2-5-1-进程执行带有参数的任务的介绍" class="headerlink" title="2.5.1 进程执行带有参数的任务的介绍"></a>2.5.1 进程执行带有参数的任务的介绍</h6><p>前面我们使用进程执行的任务是没有参数的，假如我们使用进程执行的任务带有参数，如何给函数传参呢?</p>
<p>Process类执行任务并给任务传参数有两种方式:</p>
<ul>
<li>args 表示以元组的方式给执行任务传参</li>
<li>kwargs 表示以字典方式给执行任务传参</li>
</ul>
<h6 id="2-5-2-args参数的使用"><a href="#2-5-2-args参数的使用" class="headerlink" title="2.5.2 args参数的使用"></a>2.5.2 args参数的使用</h6><p><strong>示例代码:</strong></p>
<pre><code class="python">import multiprocessing
import time


# 带有参数的任务
def task(count):
    for i in range(count):
        print(&quot;任务执行中..&quot;)
        time.sleep(0.2)
    else:
        print(&quot;任务执行完成&quot;)


if __name__ == &#39;__main__&#39;:
    # 创建子进程
    # args: 以元组的方式给任务传入参数
    sub_process = multiprocessing.Process(target=task, args=(5,))
    sub_process.start()</code></pre>
<p><strong>执行结果:</strong></p>
<pre><code class="python">任务执行中..
任务执行中..
任务执行中..
任务执行中..
任务执行中..
任务执行完成</code></pre>
<h6 id="2-5-3-kwargs参数的使用"><a href="#2-5-3-kwargs参数的使用" class="headerlink" title="2.5.3 kwargs参数的使用"></a>2.5.3 kwargs参数的使用</h6><p><strong>示例代码:</strong></p>
<pre><code class="python">import multiprocessing
import time


# 带有参数的任务
def task(count):
    for i in range(count):
        print(&quot;任务执行中..&quot;)
        time.sleep(0.2)
    else:
        print(&quot;任务执行完成&quot;)


if __name__ == &#39;__main__&#39;:
    # 创建子进程

    # kwargs: 表示以字典方式传入参数
    sub_process = multiprocessing.Process(target=task, kwargs={&quot;count&quot;: 3})
    sub_process.start()</code></pre>
<p><strong>执行结果:</strong></p>
<pre><code class="python">任务执行中..
任务执行中..
任务执行中..
任务执行完成</code></pre>
<h5 id="2-6-进程的注意点"><a href="#2-6-进程的注意点" class="headerlink" title="2.6 进程的注意点"></a>2.6 进程的注意点</h5><h6 id="2-6-1-进程的注意点介绍"><a href="#2-6-1-进程的注意点介绍" class="headerlink" title="2.6.1 进程的注意点介绍"></a>2.6.1 进程的注意点介绍</h6><ol>
<li>进程之间不共享全局变量</li>
<li>主进程会等待所有的子进程执行结束再结束</li>
</ol>
<h6 id="2-6-2-进程之间不共享全局变量"><a href="#2-6-2-进程之间不共享全局变量" class="headerlink" title="2.6.2 进程之间不共享全局变量"></a>2.6.2 进程之间不共享全局变量</h6><pre><code class="python">import multiprocessing
import time

# 定义全局变量
g_list = list()


# 添加数据的任务
def add_data():
    for i in range(5):
        g_list.append(i)
        print(&quot;add:&quot;, i)
        time.sleep(0.2)

    # 代码执行到此，说明数据添加完成
    print(&quot;add_data:&quot;, g_list)


def read_data():
    print(&quot;read_data&quot;, g_list)


if __name__ == &#39;__main__&#39;:
    # 创建添加数据的子进程
    add_data_process = multiprocessing.Process(target=add_data)
    # 创建读取数据的子进程
    read_data_process = multiprocessing.Process(target=read_data)

    # 启动子进程执行对应的任务
    add_data_process.start()
    # 主进程等待添加数据的子进程执行完成以后程序再继续往下执行，读取数据
    add_data_process.join()
    read_data_process.start()

    print(&quot;main:&quot;, g_list)

    # 总结: 多进程之间不共享全局变量</code></pre>
<p><strong>执行结果:</strong></p>
<pre><code class="python">add: 0
add: 1
add: 2
add: 3
add: 4
add_data: [0, 1, 2, 3, 4]
main: []
read_data []</code></pre>
<h6 id="2-6-3-进程之间不共享全局变量的小结"><a href="#2-6-3-进程之间不共享全局变量的小结" class="headerlink" title="2.6.3 进程之间不共享全局变量的小结"></a>2.6.3 进程之间不共享全局变量的小结</h6><ul>
<li>创建子进程会对主进程资源进行拷贝，也就是说子进程是主进程的一个副本，好比是一对双胞胎，之所以进程之间不共享全局变量，是因为操作的不是同一个进程里面的全局变量，只不过不同进程里面的全局变量名字相同而已。</li>
</ul>
<h6 id="2-6-4-主进程会等待所有的子进程执行结束再结束"><a href="#2-6-4-主进程会等待所有的子进程执行结束再结束" class="headerlink" title="2.6.4 主进程会等待所有的子进程执行结束再结束"></a>2.6.4 主进程会等待所有的子进程执行结束再结束</h6><p>假如我们现在创建一个子进程，这个子进程执行完大概需要2秒钟，现在让主进程执行0.5秒钟就退出程序，查看一下执行结果，示例代码如下:</p>
<pre><code class="python">import multiprocessing
import time


# 定义进程所需要执行的任务
def task():
    for i in range(10):
        print(&quot;任务执行中...&quot;)
        time.sleep(0.2)

if __name__ == &#39;__main__&#39;:
    # 创建子进程
    sub_process = multiprocessing.Process(target=task)
    sub_process.start()

    # 主进程延时0.5秒钟
    time.sleep(0.5)
    print(&quot;over&quot;)
    exit()

    # 总结： 主进程会等待所有的子进程执行完成以后程序再退出</code></pre>
<p><strong>执行结果:</strong></p>
<pre><code class="python">任务执行中...
任务执行中...
任务执行中...
over
任务执行中...
任务执行中...
任务执行中...
任务执行中...
任务执行中...
任务执行中...
任务执行中...</code></pre>
<p><strong>说明:</strong></p>
<p>通过上面代码的执行结果，我们可以得知: <strong>主进程会等待所有的子进程执行结束再结束</strong></p>
<p>假如我们就让主进程执行0.5秒钟，子进程就销毁不再执行，那怎么办呢?</p>
<ul>
<li>我们可以设置<strong>守护主进程</strong> 或者 在主进程退出之前 <strong>让子进程销毁</strong></li>
</ul>
<p><strong>守护主进程:</strong></p>
<ul>
<li>守护主进程就是主进程退出子进程销毁不再执行</li>
</ul>
<p><strong>子进程销毁:</strong></p>
<ul>
<li>子进程执行结束</li>
</ul>
<p><strong>保证主进程正常退出的示例代码:</strong></p>
<pre><code class="python">import multiprocessing
import time


# 定义进程所需要执行的任务
def task():
    for i in range(10):
        print(&quot;任务执行中...&quot;)
        time.sleep(0.2)

if __name__ == &#39;__main__&#39;:
    # 创建子进程
    sub_process = multiprocessing.Process(target=task)
    # 设置守护主进程，主进程退出子进程直接销毁，子进程的生命周期依赖与主进程
    # sub_process.daemon = True
    sub_process.start()

    time.sleep(0.5)
    print(&quot;over&quot;)
    # 让子进程销毁
    sub_process.terminate()
    exit()

    # 总结： 主进程会等待所有的子进程执行完成以后程序再退出
    # 如果想要主进程退出子进程销毁，可以设置守护主进程或者在主进程退出之前让子进程销毁</code></pre>
<p><strong>执行结果:</strong></p>
<pre><code class="python">任务执行中...
任务执行中...
任务执行中...
over</code></pre>
<h6 id="2-6-5-主进程会等待所有的子进程执行结束再结束的小结"><a href="#2-6-5-主进程会等待所有的子进程执行结束再结束的小结" class="headerlink" title="2.6.5 主进程会等待所有的子进程执行结束再结束的小结"></a>2.6.5 主进程会等待所有的子进程执行结束再结束的小结</h6><ul>
<li>为了保证子进程能够正常的运行，主进程会等所有的子进程执行完成以后再销毁，设置守护主进程的目的是<strong>主进程退出子进程销毁，不让主进程再等待子进程去执行</strong>。</li>
<li>设置守护主进程方式： <strong>子进程对象.daemon = True</strong></li>
<li>销毁子进程方式： <strong>子进程对象.terminate()</strong></li>
</ul>
<h4 id="3-线程的使用"><a href="#3-线程的使用" class="headerlink" title="3. 线程的使用"></a>3. 线程的使用</h4><h5 id="3-1-线程的介绍"><a href="#3-1-线程的介绍" class="headerlink" title="3.1 线程的介绍"></a>3.1 线程的介绍</h5><p>在Python中，想要实现多任务除了使用进程，还可以使用线程来完成，线程是实现多任务的另外一种方式。</p>
<h5 id="3-2-线程的概念"><a href="#3-2-线程的概念" class="headerlink" title="3.2 线程的概念"></a>3.2 线程的概念</h5><p>线程是进程中执行代码的一个分支，每个执行分支（线程）要想工作执行代码需要cpu进行调度 ，也就是说线程是cpu调度的基本单位，每个进程至少都有一个线程，而这个线程就是我们通常说的主线程。</p>
<h5 id="3-3-线程的作用"><a href="#3-3-线程的作用" class="headerlink" title="3.3 线程的作用"></a>3.3 线程的作用</h5><p>多线程可以完成多任务</p>
<h5 id="3-4-多线程的使用"><a href="#3-4-多线程的使用" class="headerlink" title="3.4 多线程的使用"></a>3.4 多线程的使用</h5><h6 id="3-4-1-导入线程模块"><a href="#3-4-1-导入线程模块" class="headerlink" title="3.4.1 导入线程模块"></a>3.4.1 导入线程模块</h6><pre><code class="python">#导入线程模块
import threading</code></pre>
<h6 id="3-4-2-线程类Thread参数说明"><a href="#3-4-2-线程类Thread参数说明" class="headerlink" title="3.4.2 线程类Thread参数说明"></a>3.4.2 线程类Thread参数说明</h6><p>Thread([group [, target [, name [, args [, kwargs]]]]])</p>
<ul>
<li>group: 线程组，目前只能使用None</li>
<li>target: 执行的目标任务名</li>
<li>args: 以元组的方式给执行任务传参</li>
<li>kwargs: 以字典方式给执行任务传参</li>
<li>name: 线程名，一般不用设置</li>
</ul>
<h6 id="3-4-3-启动线程"><a href="#3-4-3-启动线程" class="headerlink" title="3.4.3 启动线程"></a>3.4.3 启动线程</h6><p>启动线程使用start方法</p>
<h6 id="3-4-4-多线程完成多任务的代码"><a href="#3-4-4-多线程完成多任务的代码" class="headerlink" title="3.4.4 多线程完成多任务的代码"></a>3.4.4 多线程完成多任务的代码</h6><pre><code class="python">import threading
import time

# 唱歌任务
def sing():
    # 扩展： 获取当前线程
    # print(&quot;sing当前执行的线程为：&quot;, threading.current_thread())
    for i in range(3):
        print(&quot;正在唱歌...%d&quot; % i)
        time.sleep(1)

# 跳舞任务
def dance():
    # 扩展： 获取当前线程
    # print(&quot;dance当前执行的线程为：&quot;, threading.current_thread())
    for i in range(3):
        print(&quot;正在跳舞...%d&quot; % i)
        time.sleep(1)


if __name__ == &#39;__main__&#39;:
    # 扩展： 获取当前线程
    # print(&quot;当前执行的线程为：&quot;, threading.current_thread())
    # 创建唱歌的线程
    # target： 线程执行的函数名
    sing_thread = threading.Thread(target=sing)

    # 创建跳舞的线程
    dance_thread = threading.Thread(target=dance)

    # 开启线程
    sing_thread.start()
    dance_thread.start()</code></pre>
<p><strong>执行结果:</strong></p>
<pre><code class="python">正在唱歌...0
正在跳舞...0
正在唱歌...1
正在跳舞...1
正在唱歌...2
正在跳舞...2</code></pre>
<h5 id="3-5-线程执行带有参数的任务"><a href="#3-5-线程执行带有参数的任务" class="headerlink" title="3.5 线程执行带有参数的任务"></a>3.5 线程执行带有参数的任务</h5><h6 id="3-5-1-线程执行带有参数的任务的介绍"><a href="#3-5-1-线程执行带有参数的任务的介绍" class="headerlink" title="3.5.1 线程执行带有参数的任务的介绍"></a>3.5.1 线程执行带有参数的任务的介绍</h6><p>前面我们使用线程执行的任务是没有参数的，假如我们使用线程执行的任务带有参数，如何给函数传参呢?</p>
<p>Thread类执行任务并给任务传参数有两种方式:</p>
<ul>
<li>args 表示以元组的方式给执行任务传参</li>
<li>kwargs 表示以字典方式给执行任务传参</li>
</ul>
<h6 id="3-5-2-args参数的使用"><a href="#3-5-2-args参数的使用" class="headerlink" title="3.5.2 args参数的使用"></a>3.5.2 args参数的使用</h6><p><strong>示例代码:</strong></p>
<pre><code class="python">import threading
import time


# 带有参数的任务
def task(count):
    for i in range(count):
        print(&quot;任务执行中..&quot;)
        time.sleep(0.2)
    else:
        print(&quot;任务执行完成&quot;)


if __name__ == &#39;__main__&#39;:
    # 创建子线程
    # args: 以元组的方式给任务传入参数
    sub_thread = threading.Thread(target=task, args=(5,))
    sub_thread.start()</code></pre>
<p><strong>执行结果:</strong></p>
<pre><code class="python">任务执行中..
任务执行中..
任务执行中..
任务执行中..
任务执行中..
任务执行完成</code></pre>
<h6 id="3-5-3-kwargs参数的使用"><a href="#3-5-3-kwargs参数的使用" class="headerlink" title="3.5.3 kwargs参数的使用"></a>3.5.3 kwargs参数的使用</h6><p><strong>示例代码:</strong></p>
<pre><code class="python">import threading
import time


# 带有参数的任务
def task(count):
    for i in range(count):
        print(&quot;任务执行中..&quot;)
        time.sleep(0.2)
    else:
        print(&quot;任务执行完成&quot;)


if __name__ == &#39;__main__&#39;:
    # 创建子线程
    # kwargs: 表示以字典方式传入参数
    sub_thread = threading.Thread(target=task, kwargs={&quot;count&quot;: 3})
    sub_thread.start()</code></pre>
<p><strong>执行结果:</strong></p>
<pre><code class="python">任务执行中..
任务执行中..
任务执行中..
任务执行完成</code></pre>
<h5 id="3-6-线程的注意点"><a href="#3-6-线程的注意点" class="headerlink" title="3.6 线程的注意点"></a>3.6 线程的注意点</h5><h6 id="3-6-1-线程的注意点介绍"><a href="#3-6-1-线程的注意点介绍" class="headerlink" title="3.6.1 线程的注意点介绍"></a>3.6.1 线程的注意点介绍</h6><ol>
<li>线程之间执行是无序的</li>
<li>主线程会等待所有的子线程执行结束再结束</li>
<li>线程之间共享全局变量</li>
<li>线程之间共享全局变量数据出现错误问题</li>
</ol>
<h6 id="3-6-2-线程之间执行是无序的"><a href="#3-6-2-线程之间执行是无序的" class="headerlink" title="3.6.2 线程之间执行是无序的"></a>3.6.2 线程之间执行是无序的</h6><pre><code class="python">import threading
import time


def task():
    time.sleep(1)
    print(&quot;当前线程:&quot;, threading.current_thread().name)


if __name__ == &#39;__main__&#39;:

   for _ in range(5):
       sub_thread = threading.Thread(target=task)
       sub_thread.start()</code></pre>
<p><strong>执行结果:</strong></p>
<pre><code class="python">当前线程: Thread-1
当前线程: Thread-2
当前线程: Thread-4
当前线程: Thread-5
当前线程: Thread-3</code></pre>
<p><strong>说明:</strong></p>
<ul>
<li>线程之间执行是无序的，它是由cpu调度决定的 ，cpu调度哪个线程，哪个线程就先执行，没有调度的线程不能执行。</li>
<li>进程之间执行也是无序的，它是由操作系统调度决定的，操作系统调度哪个进程，哪个进程就先执行，没有调度的进程不能执行。</li>
</ul>
<h6 id="3-6-3-主线程会等待所有的子线程执行结束再结束"><a href="#3-6-3-主线程会等待所有的子线程执行结束再结束" class="headerlink" title="3.6.3 主线程会等待所有的子线程执行结束再结束"></a>3.6.3 主线程会等待所有的子线程执行结束再结束</h6><p>假如我们现在创建一个子线程，这个子线程执行完大概需要2.5秒钟，现在让主线程执行1秒钟就退出程序，查看一下执行结果，示例代码如下:</p>
<pre><code class="python">import threading
import time


# 测试主线程是否会等待子线程执行完成以后程序再退出
def show_info():
    for i in range(5):
        print(&quot;test:&quot;, i)
        time.sleep(0.5)


if __name__ == &#39;__main__&#39;:
    sub_thread = threading.Thread(target=show_info)
    sub_thread.start()

    # 主线程延时1秒
    time.sleep(1)
    print(&quot;over&quot;)</code></pre>
<p><strong>执行结果:</strong></p>
<pre><code class="python">test: 0
test: 1
over
test: 2
test: 3
test: 4</code></pre>
<p><strong>说明:</strong></p>
<p>通过上面代码的执行结果，我们可以得知: <strong>主线程会等待所有的子线程执行结束再结束</strong></p>
<p>假如我们就让主线程执行1秒钟，子线程就销毁不再执行，那怎么办呢?</p>
<ul>
<li>我们可以设置<strong>守护主线程</strong></li>
</ul>
<p><strong>守护主线程:</strong></p>
<ul>
<li>守护主线程就是主线程退出子线程销毁不再执行</li>
</ul>
<p><strong>设置守护主线程有两种方式：</strong></p>
<ol>
<li>threading.Thread(target=show_info, daemon=True)</li>
<li>线程对象.setDaemon(True)</li>
</ol>
<p><strong>设置守护主线程的示例代码:</strong></p>
<pre><code class="python">import threading
import time


# 测试主线程是否会等待子线程执行完成以后程序再退出
def show_info():
    for i in range(5):
        print(&quot;test:&quot;, i)
        time.sleep(0.5)


if __name__ == &#39;__main__&#39;:
    # 创建子线程守护主线程 
    # daemon=True 守护主线程
    # 守护主线程方式1
    sub_thread = threading.Thread(target=show_info, daemon=True)
    # 设置成为守护主线程，主线程退出后子线程直接销毁不再执行子线程的代码
    # 守护主线程方式2
    # sub_thread.setDaemon(True)
    sub_thread.start()

    # 主线程延时1秒
    time.sleep(1)
    print(&quot;over&quot;)</code></pre>
<p><strong>执行结果:</strong></p>
<pre><code class="python">test: 0
test: 1
over</code></pre>
<h6 id="3-6-4-线程之间共享全局变量"><a href="#3-6-4-线程之间共享全局变量" class="headerlink" title="3.6.4 线程之间共享全局变量"></a>3.6.4 线程之间共享全局变量</h6><p><strong>需求:</strong></p>
<ol>
<li>定义一个列表类型的全局变量</li>
<li>创建两个子线程分别执行向全局变量添加数据的任务和向全局变量读取数据的任务</li>
<li>查看线程之间是否共享全局变量数据</li>
</ol>
<pre><code class="python">import threading
import time


# 定义全局变量
my_list = list()

# 写入数据任务
def write_data():
    for i in range(5):
        my_list.append(i)
        time.sleep(0.1)
    print(&quot;write_data:&quot;, my_list)


# 读取数据任务
def read_data():
    print(&quot;read_data:&quot;, my_list)


if __name__ == &#39;__main__&#39;:
    # 创建写入数据的线程
    write_thread = threading.Thread(target=write_data)
    # 创建读取数据的线程
    read_thread = threading.Thread(target=read_data)

    write_thread.start()
    # 延时
    # time.sleep(1)
    # 主线程等待写入线程执行完成以后代码在继续往下执行
    write_thread.join()
    print(&quot;开始读取数据啦&quot;)
    read_thread.start()</code></pre>
<p><strong>执行结果:</strong></p>
<pre><code class="python">write_data: [0, 1, 2, 3, 4]
开始读取数据啦
read_data: [0, 1, 2, 3, 4]</code></pre>
<h6 id="3-6-5-线程之间共享全局变量数据出现错误问题"><a href="#3-6-5-线程之间共享全局变量数据出现错误问题" class="headerlink" title="3.6.5 线程之间共享全局变量数据出现错误问题"></a>3.6.5 线程之间共享全局变量数据出现错误问题</h6><p><strong>需求:</strong></p>
<ol>
<li>定义两个函数，实现循环100万次，每循环一次给全局变量加1</li>
<li>创建两个子线程执行对应的两个函数，查看计算后的结果</li>
</ol>
<pre><code class="python">import threading

# 定义全局变量
g_num = 0


# 循环一次给全局变量加1
def sum_num1():
    for i in range(1000000):
        global g_num
        g_num += 1

    print(&quot;sum1:&quot;, g_num)


# 循环一次给全局变量加1
def sum_num2():
    for i in range(1000000):
        global g_num
        g_num += 1
    print(&quot;sum2:&quot;, g_num)


if __name__ == &#39;__main__&#39;:
    # 创建两个线程
    first_thread = threading.Thread(target=sum_num1)
    second_thread = threading.Thread(target=sum_num2)

    # 启动线程
    first_thread.start()
    # 启动线程
    second_thread.start()</code></pre>
<p><strong>执行结果:</strong></p>
<pre><code class="python">sum1: 1210949
sum2: 1496035</code></pre>
<p><strong>注意点:</strong></p>
<p><strong>多线程同时对全局变量操作数据发生了错误</strong></p>
<p><strong>错误分析:</strong></p>
<p>两个线程first_thread和second_thread都要对全局变量g_num(默认是0)进行加1运算，但是由于是多线程同时操作，有可能出现下面情况：</p>
<ol>
<li>在g_num=0时，first_thread取得g_num=0。此时系统把first_thread调度为”sleeping”状态，把second_thread转换为”running”状态，t2也获得g_num=0</li>
<li>然后second_thread对得到的值进行加1并赋给g_num，使得g_num=1</li>
<li>然后系统又把second_thread调度为”sleeping”，把first_thread转为”running”。线程t1又把它之前得到的0加1后赋值给g_num。</li>
<li>这样导致虽然first_thread和first_thread都对g_num加1，但结果仍然是g_num=1</li>
</ol>
<p><strong>全局变量数据错误的解决办法:</strong></p>
<p>线程同步: 保证同一时刻只能有一个线程去操作全局变量 同步: 就是协同步调，按预定的先后次序进行运行。如:你说完，我再说, 好比现实生活中的对讲机</p>
<p>线程同步的方式:</p>
<ol>
<li><strong>线程等待(join)</strong></li>
<li><strong>互斥锁</strong></li>
</ol>
<h4 id="4-线程同步与互斥锁"><a href="#4-线程同步与互斥锁" class="headerlink" title="4. 线程同步与互斥锁"></a>4. 线程同步与互斥锁</h4><h5 id="4-1线程同步"><a href="#4-1线程同步" class="headerlink" title="4.1线程同步:"></a>4.1线程同步:</h5><p>线程同步: 保证同一时刻只能有一个线程去操作全局变量 同步: 就是协同步调，按预定的先后次序进行运行。如:你说完，我再说, 好比现实生活中的对讲机</p>
<p><strong>线程等待的示例代码:</strong></p>
<pre><code class="python">import threading

# 定义全局变量
g_num = 0


# 循环1000000次每次给全局变量加1
def sum_num1():
    for i in range(1000000):
        global g_num
        g_num += 1

    print(&quot;sum1:&quot;, g_num)


# 循环1000000次每次给全局变量加1
def sum_num2():
    for i in range(1000000):
        global g_num
        g_num += 1
    print(&quot;sum2:&quot;, g_num)


if __name__ == &#39;__main__&#39;:
    # 创建两个线程
    first_thread = threading.Thread(target=sum_num1)
    second_thread = threading.Thread(target=sum_num2)

    # 启动线程
    first_thread.start()
    # 主线程等待第一个线程执行完成以后代码再继续执行，让其执行第二个线程
    # 线程同步： 一个任务执行完成以后另外一个任务才能执行，同一个时刻只有一个任务在执行
    first_thread.join()
    # 启动线程
    second_thread.start()</code></pre>
<p><strong>执行结果:</strong></p>
<pre><code class="python">sum1: 1000000
sum2: 2000000</code></pre>
<h5 id="4-2-互斥锁的概念"><a href="#4-2-互斥锁的概念" class="headerlink" title="4.2 互斥锁的概念"></a>4.2 互斥锁的概念</h5><p>互斥锁: 对共享数据进行锁定，保证同一时刻只能有一个线程去操作。</p>
<p>注意:</p>
<ul>
<li>互斥锁是<strong>多个线程一起去抢</strong>，抢到锁的线程先执行，没有抢到锁的线程需要等待，等互斥锁使用完释放后，其它等待的线程再去抢这个锁。</li>
</ul>
<h5 id="4-3-互斥锁的使用"><a href="#4-3-互斥锁的使用" class="headerlink" title="4.3 互斥锁的使用"></a>4.3 互斥锁的使用</h5><p>threading模块中定义了Lock变量，这个变量本质上是一个函数，通过调用这个函数可以获取一把互斥锁。</p>
<p><strong>互斥锁使用步骤:</strong></p>
<pre><code class="python"># 创建锁
mutex = threading.Lock()

# 上锁
mutex.acquire()

...这里编写代码能保证同一时刻只能有一个线程去操作, 对共享数据进行锁定...

# 释放锁
mutex.release()</code></pre>
<p><strong>注意点:</strong></p>
<ul>
<li><strong>acquire和release方法之间的代码同一时刻只能有一个线程去操作</strong></li>
<li><strong>如果在调用acquire方法的时候 其他线程已经使用了这个互斥锁，那么此时acquire方法会堵塞，直到这个互斥锁释放后才能再次上锁。</strong></li>
</ul>
<h5 id="4-4-使用互斥锁完成2个线程对同一个全局变量各加100万次的操作"><a href="#4-4-使用互斥锁完成2个线程对同一个全局变量各加100万次的操作" class="headerlink" title="4.4 使用互斥锁完成2个线程对同一个全局变量各加100万次的操作"></a>4.4 使用互斥锁完成2个线程对同一个全局变量各加100万次的操作</h5><pre><code class="python">import threading


# 定义全局变量
g_num = 0

# 创建全局互斥锁
lock = threading.Lock()


# 循环一次给全局变量加1
def sum_num1():
    # 上锁
    lock.acquire()
    for i in range(1000000):
        global g_num
        g_num += 1

    print(&quot;sum1:&quot;, g_num)
    # 释放锁
    lock.release()


# 循环一次给全局变量加1
def sum_num2():
    # 上锁
    lock.acquire()
    for i in range(1000000):
        global g_num
        g_num += 1
    print(&quot;sum2:&quot;, g_num)
    # 释放锁
    lock.release()


if __name__ == &#39;__main__&#39;:
    # 创建两个线程
    first_thread = threading.Thread(target=sum_num1)
    second_thread = threading.Thread(target=sum_num2)
    # 启动线程
    first_thread.start()
    second_thread.start()

    # 提示：加上互斥锁，那个线程抢到这个锁我们决定不了，那线程抢到锁那个线程先执行，没有抢到的线程需要等待
    # 加上互斥锁多任务瞬间变成单任务，性能会下降，也就是说同一时刻只能有一个线程去执行</code></pre>
<p><strong>执行结果:</strong></p>
<pre><code class="python">sum1: 1000000
sum2: 2000000</code></pre>
<p><strong>说明:</strong></p>
<p>通过执行结果可以地址<strong>互斥锁能够保证多个线程访问共享数据不会出现数据错误问题</strong></p>
<h4 id="5-死锁介绍"><a href="#5-死锁介绍" class="headerlink" title="5. 死锁介绍"></a>5. 死锁介绍</h4><h5 id="5-1-死锁的概念"><a href="#5-1-死锁的概念" class="headerlink" title="5.1 死锁的概念"></a>5.1 死锁的概念</h5><p>死锁: 一直等待对方释放锁的情景就是死锁</p>
<p><strong>说明:</strong></p>
<p>现实社会中，男女双方一直等待对方先道歉的这种行为就好比是死锁。</p>
<p><strong>死锁的结果</strong></p>
<ul>
<li>会造成应用程序的停止响应，不能再处理其它任务了。</li>
</ul>
<h5 id="5-2-死锁示例"><a href="#5-2-死锁示例" class="headerlink" title="5.2 死锁示例"></a>5.2 死锁示例</h5><p><strong>需求:</strong></p>
<p>根据下标在列表中取值, 保证同一时刻只能有一个线程去取值</p>
<pre><code class="python">import threading
import time

# 创建互斥锁
lock = threading.Lock()


# 根据下标去取值， 保证同一时刻只能有一个线程去取值
def get_value(index):

    # 上锁
    lock.acquire()
    print(threading.current_thread())
    my_list = [3,6,8,1]
    # 判断下标释放越界
    if index &gt;= len(my_list):
        print(&quot;下标越界:&quot;, index)
        return
    value = my_list[index]
    print(value)
    time.sleep(0.2)
    # 释放锁
    lock.release()


if __name__ == &#39;__main__&#39;:
    # 模拟大量线程去执行取值操作
    for i in range(30):
        sub_thread = threading.Thread(target=get_value, args=(i,))
        sub_thread.start()</code></pre>
<h5 id="5-3-避免死锁"><a href="#5-3-避免死锁" class="headerlink" title="5.3 避免死锁"></a>5.3 避免死锁</h5><ul>
<li>在合适的地方释放锁</li>
</ul>
<pre><code class="python">import threading
import time

# 创建互斥锁
lock = threading.Lock()


# 根据下标去取值， 保证同一时刻只能有一个线程去取值
def get_value(index):

    # 上锁
    lock.acquire()
    print(threading.current_thread())
    my_list = [3,6,8,1]
    if index &gt;= len(my_list):
        print(&quot;下标越界:&quot;, index)
        # 当下标越界需要释放锁，让后面的线程还可以取值
        lock.release()
        return
    value = my_list[index]
    print(value)
    time.sleep(0.2)
    # 释放锁
    lock.release()


if __name__ == &#39;__main__&#39;:
    # 模拟大量线程去执行取值操作
    for i in range(30):
        sub_thread = threading.Thread(target=get_value, args=(i,))
        sub_thread.start()</code></pre>
<h4 id="6-进程和线程的对比"><a href="#6-进程和线程的对比" class="headerlink" title="6.进程和线程的对比"></a>6.进程和线程的对比</h4><h5 id="6-1-进程和线程的对比的三个方向"><a href="#6-1-进程和线程的对比的三个方向" class="headerlink" title="6.1 进程和线程的对比的三个方向"></a>6.1 进程和线程的对比的三个方向</h5><ol>
<li>关系对比</li>
<li>区别对比</li>
<li>优缺点对比</li>
</ol>
<h5 id="6-2-关系对比"><a href="#6-2-关系对比" class="headerlink" title="6.2 关系对比"></a>6.2 关系对比</h5><ol>
<li>线程是依附在进程里面的，没有进程就没有线程。</li>
<li>一个进程默认提供一条线程，进程可以创建多个线程。</li>
</ol>
<h5 id="6-3-区别对比"><a href="#6-3-区别对比" class="headerlink" title="6.3 区别对比"></a>6.3 区别对比</h5><ol>
<li>进程之间不共享全局变量</li>
<li>线程之间共享全局变量，但是要注意资源竞争的问题，解决办法: 互斥锁或者线程同步</li>
<li>创建进程的资源开销要比创建线程的资源开销要大</li>
<li>进程是操作系统资源分配的基本单位，线程是CPU调度的基本单位</li>
<li>线程不能够独立执行，必须依存在进程中</li>
<li>多进程开发比单进程多线程开发稳定性要强</li>
</ol>
<h5 id="6-4-优缺点对比"><a href="#6-4-优缺点对比" class="headerlink" title="6.4 优缺点对比"></a>6.4 优缺点对比</h5><ul>
<li>进程优缺点:<ul>
<li>优点：可以用多核</li>
<li>缺点：资源开销大</li>
</ul>
</li>
<li>线程优缺点:<ul>
<li>优点：资源开销小</li>
<li>缺点：不能使用多核</li>
</ul>
</li>
</ul>
<h4 id="7-协程"><a href="#7-协程" class="headerlink" title="7.协程"></a>7.协程</h4><h5 id="7-1-协程是啥"><a href="#7-1-协程是啥" class="headerlink" title="7.1 协程是啥"></a>7.1 协程是啥</h5><p>协程是python个中另外一种实现多任务的方式。</p>
<p>只不过比线程更小占用更小执行单元（理解为需要的资源）。</p>
<p>通俗的理解：</p>
<p>在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行，注意不是通过调用函数的方式做到的，并且切换的次数以及什么时候再切换到原来的函数都由开发者自己确定。</p>
<h5 id="7-2-协程的优点"><a href="#7-2-协程的优点" class="headerlink" title="7.2 协程的优点"></a>7.2 协程的优点</h5><p>最大的优势就是协程极高的执行效率。因为函数切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p>
<p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<h5 id="7-3-gevent"><a href="#7-3-gevent" class="headerlink" title="7.3 gevent"></a>7.3 gevent</h5><p>gevent 是一个第三方库。</p>
<p>Python中仅提供了对协程的基本支持，但是不完全。而第三方的gevent为Python提供了比较完善的协程支持。</p>
<p>其原理是当一个任务函数遇到IO(指的是input output 输入输出，比如网络、文件操作等)操作时，比如访问网络，就自动切换到其他的任务函数执行，等到IO操作完成，再在适当的时候切换回来继续执行。</p>
<p>由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有任务函数在运行，而不是等待IO,得以实现多任务,提高程序执行效率。</p>
<h5 id="7-4-安装"><a href="#7-4-安装" class="headerlink" title="7.4 安装"></a>7.4 安装</h5><pre><code class="python">pip3 install gevent</code></pre>
<h5 id="7-5-gevent的使用"><a href="#7-5-gevent的使用" class="headerlink" title="7.5 gevent的使用"></a>7.5 gevent的使用</h5><pre><code class="python">import gevent

def f(n):
    for i in range(n):
        print(gevent.getcurrent(), i)

g1 = gevent.spawn(f, 5)
g2 = gevent.spawn(f, 5)
g3 = gevent.spawn(f, 5)
g1.join()
g2.join()
g3.join()</code></pre>
<p>运行结果</p>
<pre><code class="python">&lt;Greenlet at 0x10e49f550: f(5)&gt; 0
&lt;Greenlet at 0x10e49f550: f(5)&gt; 1
&lt;Greenlet at 0x10e49f550: f(5)&gt; 2
&lt;Greenlet at 0x10e49f550: f(5)&gt; 3
&lt;Greenlet at 0x10e49f550: f(5)&gt; 4
&lt;Greenlet at 0x10e49f910: f(5)&gt; 0
&lt;Greenlet at 0x10e49f910: f(5)&gt; 1
&lt;Greenlet at 0x10e49f910: f(5)&gt; 2
&lt;Greenlet at 0x10e49f910: f(5)&gt; 3
&lt;Greenlet at 0x10e49f910: f(5)&gt; 4
&lt;Greenlet at 0x10e49f4b0: f(5)&gt; 0
&lt;Greenlet at 0x10e49f4b0: f(5)&gt; 1
&lt;Greenlet at 0x10e49f4b0: f(5)&gt; 2
&lt;Greenlet at 0x10e49f4b0: f(5)&gt; 3
&lt;Greenlet at 0x10e49f4b0: f(5)&gt; 4</code></pre>
<p>可以看到，3个greenlet是依次运行而不是交替运行</p>
<h5 id="7-6-gevent切换执行"><a href="#7-6-gevent切换执行" class="headerlink" title="7.6 gevent切换执行"></a>7.6 gevent切换执行</h5><pre><code class="python">import gevent

def f(n):
    for i in range(n):
        print(gevent.getcurrent(), i)
        #用来模拟一个耗时操作，注意不是time模块中的sleep
        gevent.sleep(1)

g1 = gevent.spawn(f, 5)
g2 = gevent.spawn(f, 5)
g3 = gevent.spawn(f, 5)
g1.join()
g2.join()
g3.join()</code></pre>
<p>运行结果</p>
<pre><code class="python">&lt;Greenlet at 0x7fa70ffa1c30: f(5)&gt; 0
&lt;Greenlet at 0x7fa70ffa1870: f(5)&gt; 0
&lt;Greenlet at 0x7fa70ffa1eb0: f(5)&gt; 0
&lt;Greenlet at 0x7fa70ffa1c30: f(5)&gt; 1
&lt;Greenlet at 0x7fa70ffa1870: f(5)&gt; 1
&lt;Greenlet at 0x7fa70ffa1eb0: f(5)&gt; 1
&lt;Greenlet at 0x7fa70ffa1c30: f(5)&gt; 2
&lt;Greenlet at 0x7fa70ffa1870: f(5)&gt; 2
&lt;Greenlet at 0x7fa70ffa1eb0: f(5)&gt; 2
&lt;Greenlet at 0x7fa70ffa1c30: f(5)&gt; 3
&lt;Greenlet at 0x7fa70ffa1870: f(5)&gt; 3
&lt;Greenlet at 0x7fa70ffa1eb0: f(5)&gt; 3
&lt;Greenlet at 0x7fa70ffa1c30: f(5)&gt; 4
&lt;Greenlet at 0x7fa70ffa1870: f(5)&gt; 4
&lt;Greenlet at 0x7fa70ffa1eb0: f(5)&gt; 4</code></pre>
<h5 id="7-7-给程序打补丁"><a href="#7-7-给程序打补丁" class="headerlink" title="7.7 给程序打补丁"></a>7.7 给程序打补丁</h5><pre><code class="python">from gevent import monkey
import gevent
import random
import time

def coroutine_work(coroutine_name):
    for i in range(10):
        print(coroutine_name, i)
        time.sleep(random.random())

gevent.joinall([
        gevent.spawn(coroutine_work, &quot;work1&quot;),
        gevent.spawn(coroutine_work, &quot;work2&quot;)
])</code></pre>
<p>运行结果</p>
<pre><code class="python">work1 0
work1 1
work1 2
work1 3
work1 4
work1 5
work1 6
work1 7
work1 8
work1 9
work2 0
work2 1
work2 2
work2 3
work2 4
work2 5
work2 6
work2 7
work2 8
work2 9
from gevent import monkey
import gevent
import random
import time

# 有耗时操作时需要
monkey.patch_all()  # 将程序中用到的耗时操作的代码，换为gevent中自己实现的模块

def coroutine_work(coroutine_name):
    for i in range(10):
        print(coroutine_name, i)
        time.sleep(random.random())

gevent.joinall([
        gevent.spawn(coroutine_work, &quot;work1&quot;),
        gevent.spawn(coroutine_work, &quot;work2&quot;)
])</code></pre>
<p>运行结果</p>
<pre><code class="python">work1 0
work2 0
work1 1
work1 2
work1 3
work2 1
work1 4
work2 2
work1 5
work2 3
work1 6
work1 7
work1 8
work2 4
work2 5
work1 9
work2 6
work2 7
work2 8
work2 9</code></pre>
</div><div class="p-copyright"><blockquote><div class="p-copyright-author"><span class="p-copyright-key">本文作者：</span><span class="p-copytight-value"><a href="mailto:litreily@163.com">caijinbo</a></span></div><div class="p-copyright-link"><span class="p-copyright-key">本文链接：</span><span class="p-copytight-value"><a href="/2020/08/05/2020-08-06-python%E9%AB%98%E7%BA%A702-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B/">https://caijinbo.work/2020/08/05/2020-08-06-python高级02-多任务编程/</a></span></div><div class="p-copyright-note"><span class="p-copyright-key">版权声明：</span><span class="p-copytight-value">本博客所有文章除特殊声明外，均采用<a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/"> CC BY-NC 4.0 </a>许可协议。转载请注明出处 <a href="https://caijinbo.work">caijinbo的博客</a>！</span></div></blockquote></div></article><div class="p-info box"><span class="p-tags"><i class="fa fa-tag"></i><a href="/tags/python/">python</a></span></div><aside id="toc"><div class="toc-title">目录</div><nav><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#第2节：多任务编程"><span class="toc-number">1.</span> <span class="toc-text">第2节：多任务编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-多任务介绍"><span class="toc-number">1.1.</span> <span class="toc-text">1. 多任务介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-多任务的概念"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 多任务的概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-多任务的执行方式"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 多任务的执行方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-进程的使用"><span class="toc-number">1.2.</span> <span class="toc-text">2. 进程的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-进程的介绍"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 进程的介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-进程的概念"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 进程的概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-多进程的使用"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 多进程的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-3-1-导入进程包"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">2.3.1 导入进程包</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-3-2-Process进程类的说明"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2.3.2 Process进程类的说明</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-3-3-多进程完成多任务的代码"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">2.3.3 多进程完成多任务的代码</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-获取进程编号"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 获取进程编号</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-4-1-获取进程编号的目的"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">2.4.1 获取进程编号的目的</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-4-2-获取当前进程编号"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2.4.2 获取当前进程编号</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-4-3-获取当前父进程编号"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">2.4.3 获取当前父进程编号</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-进程执行带有参数的任务"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5 进程执行带有参数的任务</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-5-1-进程执行带有参数的任务的介绍"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">2.5.1 进程执行带有参数的任务的介绍</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-5-2-args参数的使用"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">2.5.2 args参数的使用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-5-3-kwargs参数的使用"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">2.5.3 kwargs参数的使用</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-进程的注意点"><span class="toc-number">1.2.6.</span> <span class="toc-text">2.6 进程的注意点</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-6-1-进程的注意点介绍"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">2.6.1 进程的注意点介绍</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-6-2-进程之间不共享全局变量"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">2.6.2 进程之间不共享全局变量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-6-3-进程之间不共享全局变量的小结"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">2.6.3 进程之间不共享全局变量的小结</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-6-4-主进程会等待所有的子进程执行结束再结束"><span class="toc-number">1.2.6.4.</span> <span class="toc-text">2.6.4 主进程会等待所有的子进程执行结束再结束</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-6-5-主进程会等待所有的子进程执行结束再结束的小结"><span class="toc-number">1.2.6.5.</span> <span class="toc-text">2.6.5 主进程会等待所有的子进程执行结束再结束的小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-线程的使用"><span class="toc-number">1.3.</span> <span class="toc-text">3. 线程的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-线程的介绍"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 线程的介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-线程的概念"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 线程的概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-线程的作用"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 线程的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-多线程的使用"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 多线程的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3-4-1-导入线程模块"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">3.4.1 导入线程模块</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-4-2-线程类Thread参数说明"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">3.4.2 线程类Thread参数说明</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-4-3-启动线程"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">3.4.3 启动线程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-4-4-多线程完成多任务的代码"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">3.4.4 多线程完成多任务的代码</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-线程执行带有参数的任务"><span class="toc-number">1.3.5.</span> <span class="toc-text">3.5 线程执行带有参数的任务</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3-5-1-线程执行带有参数的任务的介绍"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">3.5.1 线程执行带有参数的任务的介绍</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-5-2-args参数的使用"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">3.5.2 args参数的使用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-5-3-kwargs参数的使用"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">3.5.3 kwargs参数的使用</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-6-线程的注意点"><span class="toc-number">1.3.6.</span> <span class="toc-text">3.6 线程的注意点</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3-6-1-线程的注意点介绍"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">3.6.1 线程的注意点介绍</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-6-2-线程之间执行是无序的"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">3.6.2 线程之间执行是无序的</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-6-3-主线程会等待所有的子线程执行结束再结束"><span class="toc-number">1.3.6.3.</span> <span class="toc-text">3.6.3 主线程会等待所有的子线程执行结束再结束</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-6-4-线程之间共享全局变量"><span class="toc-number">1.3.6.4.</span> <span class="toc-text">3.6.4 线程之间共享全局变量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-6-5-线程之间共享全局变量数据出现错误问题"><span class="toc-number">1.3.6.5.</span> <span class="toc-text">3.6.5 线程之间共享全局变量数据出现错误问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-线程同步与互斥锁"><span class="toc-number">1.4.</span> <span class="toc-text">4. 线程同步与互斥锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1线程同步"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1线程同步:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-互斥锁的概念"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 互斥锁的概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-互斥锁的使用"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 互斥锁的使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-使用互斥锁完成2个线程对同一个全局变量各加100万次的操作"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4 使用互斥锁完成2个线程对同一个全局变量各加100万次的操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-死锁介绍"><span class="toc-number">1.5.</span> <span class="toc-text">5. 死锁介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-死锁的概念"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 死锁的概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-死锁示例"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 死锁示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-避免死锁"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3 避免死锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-进程和线程的对比"><span class="toc-number">1.6.</span> <span class="toc-text">6.进程和线程的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-进程和线程的对比的三个方向"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1 进程和线程的对比的三个方向</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-关系对比"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2 关系对比</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-区别对比"><span class="toc-number">1.6.3.</span> <span class="toc-text">6.3 区别对比</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-4-优缺点对比"><span class="toc-number">1.6.4.</span> <span class="toc-text">6.4 优缺点对比</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-协程"><span class="toc-number">1.7.</span> <span class="toc-text">7.协程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-协程是啥"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.1 协程是啥</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-协程的优点"><span class="toc-number">1.7.2.</span> <span class="toc-text">7.2 协程的优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-gevent"><span class="toc-number">1.7.3.</span> <span class="toc-text">7.3 gevent</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-4-安装"><span class="toc-number">1.7.4.</span> <span class="toc-text">7.4 安装</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-5-gevent的使用"><span class="toc-number">1.7.5.</span> <span class="toc-text">7.5 gevent的使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-6-gevent切换执行"><span class="toc-number">1.7.6.</span> <span class="toc-text">7.6 gevent切换执行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-7-给程序打补丁"><span class="toc-number">1.7.7.</span> <span class="toc-text">7.7 给程序打补丁</span></a></li></ol></li></ol></li></ol></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="prev" href="/2020/08/21/2020-08-22-python%E9%AB%98%E7%BA%A708-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/">&lt; python高级08-MySQL数据库</a><a class="next" href="/2020/08/04/2020-08-05-python%E9%AB%98%E7%BA%A701-Linux%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">python高级01-Linux基本使用 &gt;</a></div></section><footer><p>Copyright © 2016 - 2021 <a href="/." rel="nofollow">CAIJINBO</a> | <strong><a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></strong><br><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span></span> <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> | Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/litreily/snark-hexo"> snark.</a></p></footer></div></div></div><script type="text/javascript" src="/plugins/prettify/prettify.js"></script><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
    search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"></body></html>