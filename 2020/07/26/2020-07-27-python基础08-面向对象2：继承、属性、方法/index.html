<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="这是始于兴趣搭建的个人博客。"><meta name="baidu-site-verification"><title>python基础08-面向对象2：继承、属性、方法 | CAIJINBO</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="CAIJINBO" type="application/atom+xml">
</head><link rel="stylesheet" type="text/css" href="/plugins/prettify/doxy.css"><script type="text/javascript" src="/js/ready.js" async></script><body class="night"><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">CAIJINBO</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">CAIJINBO</a></h1></div><p class="m-desc">懒人在思考......,<br>解决不了问题，就解决提出问题的人！</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/categories/">分类</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li><span class="dot">●</span><a href="/about/">关于</a></li><li><span class="dot">●</span><a href="/atom.xml">RSS</a></li><li class="m-sch"><form class="form" id="j-formsch" method="get"><input class="txt" type="text" id="local-search-input" name="q" value="搜索" onfocus="if(this.value=='搜索'){this.value='';}" onblur="if(this.value==''){this.value='搜索';}"><input type="text" style="display:none;"></form></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">python基础08-面向对象2：继承、属性、方法</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/2020/07/26/2020-07-27-python%E5%9F%BA%E7%A1%8008-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12%EF%BC%9A%E7%BB%A7%E6%89%BF%E3%80%81%E5%B1%9E%E6%80%A7%E3%80%81%E6%96%B9%E6%B3%95/">2020-07-26</a></span><span class="p-category"><i class="fa fa-folder"></i><a href="/categories/python/">python</a></span><span class="p-view" id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span></span></div></div><div class="p-content"><h1 id="面向对象2：继承、属性、方法"><a href="#面向对象2：继承、属性、方法" class="headerlink" title="面向对象2：继承、属性、方法"></a>面向对象2：继承、属性、方法</h1><h2 id="一、私有权限"><a href="#一、私有权限" class="headerlink" title="一、私有权限"></a>一、私有权限</h2><h3 id="1-面向对象的特性"><a href="#1-面向对象的特性" class="headerlink" title="1. 面向对象的特性"></a>1. 面向对象的特性</h3><a id="more"></a>

<ol>
<li>面向对象的的三大特性：封装、继承、多态</li>
<li>面向对象的封装特性：<ul>
<li>将属性和方法放到一起封装成一个整体，然后通过实例化对象来处理</li>
<li>对类的属性和方法增加访问权限控制</li>
</ul>
</li>
</ol>
<h3 id="2-私有属性"><a href="#2-私有属性" class="headerlink" title="2. 私有属性"></a>2. 私有属性</h3><ul>
<li>如果在属性名前面加了2个下划线’__’，则表明该属性是私有属性，否则为公有属性</li>
<li><strong>私有属性只能在类的内部访问</strong></li>
</ul>
<pre><code class="python">&quot;&quot;&quot;
私有属性：
    1. __(2个下划线)开头的属性，就是私有属性
    2. 只能在本类的内部访问，在类的外面无法直接访问
&quot;&quot;&quot;
class Dog(object):
    # 添加属性
    def __init__(self):
        self.__baby_count = 0   # 私有属性，以__(2个下划线)开头的属性
        self.age = 1    # 公有属性

    def print_info(self):
        print(self.__baby_count)


# 类的外部
# 创建对象
dog1 = Dog()
# print(dog1.__baby_count) # err, 私有属性，在类的外面无法直接访问
print(dog1.age)

dog1.print_info()</code></pre>
<h3 id="3-私有方法"><a href="#3-私有方法" class="headerlink" title="3. 私有方法"></a>3. 私有方法</h3><ul>
<li>私有方法和私有属性类似，在方法名前面加了2个下划线’__’，则表明该方法是私有方法</li>
<li><strong>私有方法只能在类内部使用</strong></li>
</ul>
<pre><code class="python">&quot;&quot;&quot;
私有方法：
    1. __(2个下划线)开头的方法，就是私有方法
    2. 只能在本类的内部访问，在类的外面无法直接访问
    3. 在类的内部调用实例方法的语法格式：self.方法名()
&quot;&quot;&quot;


class Dog(object):
    def __init__(self):
        self.__baby_count = 0 # 私有属性，以__(2个下划线)开头的属性
        self.age = 1

    def print_info(self):
        print(self.__baby_count)
        self.__leave()

    # 定义一个私有方法
    def __leave(self):
        print(&#39;休产假了&#39;)


dog1 = Dog()
dog1.print_info()
# AttributeError: &#39;Dog&#39; object has no attribute &#39;__leave&#39;
# dog1.__leave() # err, 外部不能访问私有方法</code></pre>
<h2 id="二、继承的作用"><a href="#二、继承的作用" class="headerlink" title="二、继承的作用"></a>二、继承的作用</h2><h3 id="1-继承的作用"><a href="#1-继承的作用" class="headerlink" title="1. 继承的作用"></a>1. 继承的作用</h3><ul>
<li>继承：子类直接具备父类的能力（属性和方法）</li>
<li>作用：解决代码重用问题，提高开发效率</li>
</ul>
<h3 id="2-继承的语法格式"><a href="#2-继承的语法格式" class="headerlink" title="2. 继承的语法格式"></a>2. 继承的语法格式</h3><p>继承的语法格式：</p>
<pre><code class="python">class 子类名(父类名)：
    pass</code></pre>
<p>示例代码：</p>
<pre><code class="python"># 定义一个父类
class Father(object):
    # 添加一个属性， money
    def __init__(self):
        self.money = 9999999

    def print_info(self):
        print(self.money)


# 定义一个子类，继承与Father
class Son(Father):
    pass


# 子类创建对象
s = Son()
print(s.money)  # 子类私用继承过来的属性
s.print_info()  # 子类使用继承过来的方法</code></pre>
<p><strong>注意：</strong></p>
<ul>
<li>子类对象调用方法有一个就近原则<ul>
<li>如果本类能找到方法，直接调用本类的方法</li>
<li>如果本类找不到，则调用父类继承过来的方法</li>
</ul>
</li>
</ul>
<h2 id="三、单继承和多层继承"><a href="#三、单继承和多层继承" class="headerlink" title="三、单继承和多层继承"></a>三、单继承和多层继承</h2><h3 id="1-单继承"><a href="#1-单继承" class="headerlink" title="1. 单继承"></a>1. 单继承</h3><ul>
<li>单继承：子类只继承一个父类</li>
</ul>
<pre><code class="python"># 定义一个父类， Animal
class Animal(object):
    def eat(self):
        print(&#39;吃东西&#39;)


# 定义一个子类，只有一个父类
class Dog(Animal):
    pass


# 创建一个子类对象
dog1 = Dog()
dog1.eat()</code></pre>
<h3 id="2-多层继承"><a href="#2-多层继承" class="headerlink" title="2. 多层继承"></a>2. 多层继承</h3><ul>
<li>多层继承：继承关系为多层传递，如生活中的<code>爷爷、父亲、儿子</code></li>
</ul>
<pre><code class="python"># 定义一个爷爷类， Animal
class Animal(object):
    def eat(self):
        print(&#39;吃东西&#39;)


# 定义一个父亲类
class Dog(Animal):
    def drink(self):
        print(&#39;喝东西&#39;)


# 定义一个儿子类
class SuperDog(Dog):
    pass


# 创建对象
sd = SuperDog()
sd.eat()
sd.drink()</code></pre>
<h2 id="四、重写父类方法"><a href="#四、重写父类方法" class="headerlink" title="四、重写父类方法"></a>四、重写父类方法</h2><h3 id="1-子类重写父类同名方法"><a href="#1-子类重写父类同名方法" class="headerlink" title="1. 子类重写父类同名方法"></a>1. 子类重写父类同名方法</h3><ul>
<li>父类的方法不能满足子类的需要，可以对父类的方法重写，重写父类方法的目的是为了给他扩展功能</li>
<li>在子类中定义了一个和父类同名的方法(参数也一样)，即为对父类的方法重写</li>
<li>子类调用同名方法，默认只会调用子类的</li>
</ul>
<p>示例代码：</p>
<pre><code class="python"># 定义一个父类， Animal
class Animal(object):
    # 添加一个type属性
    def __init__(self):
        print(&#39;Animal类中的__init__&#39;)
        self.type = &#39;动物&#39;

    # 设计一个方法，打印属性
    def print_type(self):
        print(&#39;Animal类中的print_type = &#39;, self.type)


# 定义一个子类，继承与Animal
class Dog(Animal):
    # __init__和父类的同名，重写父类同名方法
    def __init__(self):
        print(&#39;Dog类中的__init__&#39;)
        self.type = &#39;可爱的小狗&#39;

    # print_type和父类的同名，重写父类同名方法
    def print_type(self):
        print(&#39;Dog类中的print_type = &#39;, self.type)


# 定义一个子类对象
dog1 = Dog()  # 调用子类的__init__
dog1.print_type()  # 调用子类的print_type()</code></pre>
<p>运行结果：</p>
<pre><code class="python">Dog类中的__init__
Dog类中的print_type =  可爱的小狗</code></pre>
<h3 id="2-子类调用父类同名方法"><a href="#2-子类调用父类同名方法" class="headerlink" title="2. 子类调用父类同名方法"></a>2. 子类调用父类同名方法</h3><ul>
<li>子类调用父类同名方法：<ol>
<li><code>父类名.同名方法(self, 形参1, ……)</code></li>
<li><code>super(子类名, self).同名方法(形参1, ……)</code></li>
<li><code>super().同名方法(形参1, ……)</code>：是方法 2 的简写，推荐的写法</li>
</ol>
</li>
</ul>
<p>示例代码：</p>
<pre><code class="python"># 定义一个父类， Animal
class Animal(object):
    # 添加一个type属性
    def __init__(self):
        print(&#39;Animal类中的__init__&#39;)
        self.type = &#39;动物&#39;

    # 设计一个方法，打印属性
    def print_type(self):
        print(&#39;Animal类中的print_type = &#39;, self.type)


# 定义一个子类，继承与Animal
class Dog(Animal):
    # __init__和父类的同名，重写父类同名方法
    def __init__(self):
        print(&#39;Dog类中的__init__&#39;)
        self.type = &#39;可爱的小狗&#39;

    # print_type和父类的同名，重写父类同名方法
    def print_type(self):
        print(&#39;Dog类中的print_type = &#39;, self.type)
        print(&#39;=&#39;*20)

        # 调用父类同名函数
        # 方法1： 父类名.同名方法(self, 形参1, ……)
        Animal.__init__(self)
        Animal.print_type(self)
        print(&#39;=&#39; * 20)

        # 方法2：super(子类名, self).同名方法(形参1, ……)
        super(Dog, self).__init__()
        super(Dog, self).print_type()
        print(&#39;=&#39; * 20)

        # 方法3：super().同名方法(形参1, ……) # 是 4.2 方法的简写
        # 推荐使用的方法
        super().__init__()
        super().print_type()


# 定义一个子类对象
dog1 = Dog()  # 调用子类的__init__
dog1.print_type()  # 调用子类的print_type()</code></pre>
<p>运行结果：</p>
<pre><code class="python">Dog类中的__init__
Dog类中的print_type =  可爱的小狗
====================
Animal类中的__init__
Animal类中的print_type =  动物
====================
Animal类中的__init__
Animal类中的print_type =  动物
====================
Animal类中的__init__
Animal类中的print_type =  动物</code></pre>
<h2 id="五、多继承"><a href="#五、多继承" class="headerlink" title="五、多继承"></a>五、多继承</h2><h3 id="1-多继承"><a href="#1-多继承" class="headerlink" title="1. 多继承"></a>1. 多继承</h3><ul>
<li><p>所谓多继承，即子类有多个父类，并且具有它们的特征。</p>
</li>
<li><p>多继承的语法格式：</p>
<pre><code class="python">class 子类名(父类1, 父类2, ……)：
    pass</code></pre>
</li>
</ul>
<p>示例代码：</p>
<pre><code class="python"># 定义2个类，它们没有继承关系，是平级的
class SmallDog(object):
    def eat(self):
        print(&#39;吃小东西&#39;)


# 再定义一个类
class BigDog(object):
    def drink(self):
        print(&#39;大口喝水&#39;)


# 定义一个子类，多继承于上面2个父类
class SuperDog(SmallDog, BigDog):
    pass


# 定义子类对象，调用方法
sd = SuperDog()
sd.eat()
sd.drink()</code></pre>
<p>运行结果：</p>
<pre><code class="python">吃小东西
大口喝水</code></pre>
<h3 id="2-类的继承顺序"><a href="#2-类的继承顺序" class="headerlink" title="2. 类的继承顺序"></a>2. 类的继承顺序</h3><ul>
<li>查看类的继承顺序：<code>类名.__mro__</code></li>
</ul>
<p>示例代码：</p>
<pre><code class="python"># 定义2个类，它们没有继承关系，是平级的
class SmallDog(object):
    def eat(self):
        print(&#39;吃小东西&#39;)


# 再定义一个类
class BigDog(object):
    def drink(self):
        print(&#39;大口喝水&#39;)


# 定义一个子类，多继承于上面2个父类
class SuperDog(SmallDog, BigDog):
    pass


# 查看类的继承顺序
print(SuperDog.__mro__)</code></pre>
<p>运行结果：</p>
<pre><code class="python">(&lt;class &#39;__main__.SuperDog&#39;&gt;, &lt;class &#39;__main__.SmallDog&#39;&gt;, &lt;class &#39;__main__.BigDog&#39;&gt;, &lt;class &#39;object&#39;&gt;)</code></pre>
<h3 id="3-调用父类同名方法"><a href="#3-调用父类同名方法" class="headerlink" title="3. 调用父类同名方法"></a>3. 调用父类同名方法</h3><h4 id="3-1-默认调用情况"><a href="#3-1-默认调用情况" class="headerlink" title="3.1 默认调用情况"></a>3.1 默认调用情况</h4><ul>
<li>如果继承过来的2个父类的方法同名，默认调用先继承父类的同名方法</li>
</ul>
<pre><code class="python"># 定义2个类，它们没有继承关系，是平级的
class SmallDog(object):
    def eat(self):
        print(&#39;吃小东西&#39;)


# 再定义一个类
class BigDog(object):
    def eat(self):
        print(&#39;啃大骨头&#39;)


# 定义一个子类，多继承于上面2个父类
class SuperDog(SmallDog, BigDog):
    pass


# 定义子类对象，调用方法
sd = SuperDog()
sd.eat()  # 默认先调用先继承的父类，即 SmallDog</code></pre>
<p>运行结果：</p>
<pre><code class="python">吃小东西</code></pre>
<h4 id="3-2-子类调用父类同名方法"><a href="#3-2-子类调用父类同名方法" class="headerlink" title="3.2 子类调用父类同名方法"></a>3.2 子类调用父类同名方法</h4><ul>
<li>子类调用父类同名方法：<ol>
<li><code>父类名.同名方法(self, 形参1, ……)</code>：调用指定的父类</li>
<li><code>super(类名, self).同名方法(形参1, ……)</code>：调用继承顺序中类名的下一个类的同名方法</li>
<li><code>super().同名方法(形参1, ……)</code>：调用先继承父类的同名方法</li>
</ol>
</li>
</ul>
<p>示例代码：</p>
<pre><code class="python"># 定义2个类，它们没有继承关系，是平级的
class SmallDog(object):
    def eat(self):
        print(&#39;吃小东西&#39;)


# 再定义一个类
class BigDog(object):
    def eat(self):
        print(&#39;啃大骨头&#39;)


# 定义一个子类，多继承于上面2个父类
class SuperDog(SmallDog, BigDog):
    def eat(self):
        print(&#39;吃蟠桃&#39;)
        print(&#39;=&#39;*20)

        # 子类调用父类同名方法：
        # 1. 父类名.同名方法(self, 形参1, ……)
        SmallDog.eat(self)  # 调用SmallDog的eat()
        print(&#39;=&#39; * 20)

        # 2. super(类名, self).同名方法(形参1, ……)：调用继承顺序中类名的下一个类的同名方法
        # 继承顺序中，SmallDog的下一个类是BigDog,所以，调用BigDog的eat()
        super(SmallDog, self).eat()
        print(&#39;=&#39; * 20)

        # 3. super().同名方法(形参1, ……) ：调用先继承父类的同名方法
        super().eat()


# 定义子类对象，调用方法
sd = SuperDog()
sd.eat()</code></pre>
<p>运行结果：</p>
<pre><code class="python">吃蟠桃
====================
吃小东西
====================
啃大骨头
====================
吃小东西</code></pre>
<h2 id="六、私有和继承"><a href="#六、私有和继承" class="headerlink" title="六、私有和继承"></a>六、私有和继承</h2><h3 id="1-私有和继承"><a href="#1-私有和继承" class="headerlink" title="1. 私有和继承"></a>1. 私有和继承</h3><ul>
<li>父类中的私有方法、属性不能直接继承使用</li>
<li>可以通过调用继承的父类的共有方法，间接的访问父类的私有方法、属性</li>
</ul>
<pre><code class="python"># 定义一个父类， Animal
class Animal(object):
    # 添加一个type属性
    def __init__(self):
        self.__type = &#39;动物&#39;  # 私有

    def __leave(self):  # 私有
        print(&#39;休产假3个月&#39;)

    # 通过公有方法，间接访问私有元素
    def use_private(self):
        print(self.__type)
        self.__leave()


# 定义一个子类
class Dog(Animal):
    def test(self):
        # print(self.__type) # err，私有不能直接继承使用
        # self.__leave() # err，私有不能直接继承使用
        pass


# 创建子类对象
dog1 = Dog()
dog1.use_private()</code></pre>
<h2 id="七、多态"><a href="#七、多态" class="headerlink" title="七、多态"></a>七、多态</h2><h3 id="1-多态"><a href="#1-多态" class="headerlink" title="1. 多态"></a>1. 多态</h3><ul>
<li>多态：多种形态，调用同一个函数，不同表现</li>
<li>因为Python是动态语言，站在用户的角度，本身就是多态，不存在非多态的情况</li>
<li>实现多态的步骤:<ol>
<li>实现继承关系</li>
<li>子类重写父类方法</li>
<li>通过对象调用该方法</li>
</ol>
</li>
</ul>
<p>示例代码：</p>
<pre><code class="python">&quot;&quot;&quot;
1. 多态：多种形态，调用同一个函数，不同表现

2. 实现多态的步骤:
  1. 实现继承关系
  2. 子类重写父类方法
  3. 通过对象调用该方法

&quot;&quot;&quot;


# 定义一个父类， Animal
class Animal(object):
    def eat(self):
        print(&#39;吃东西&#39;)


# 定义一个子类Dog，继承于Animal
class Dog(Animal):
    def eat(self):
        &quot;&quot;&quot;重写父类方法&quot;&quot;&quot;
        print(&#39;啃骨头&#39;)


# 定义一个子类Cat，继承于Animal
class Cat(Animal):
    def eat(self):
        &quot;&quot;&quot;重写父类方法&quot;&quot;&quot;
        print(&#39;吃小鱼&#39;)


# 定义一个函数，用于测试多态
def func(temp):
    temp.eat()


# 创建子类对象
d = Dog()
c = Cat()

# 调用同一个函数，不同表现
# 传递d参数，调用Dog的eat()
# 传递c参数，调用Cat的eat()
func(d)  # 啃骨头
func(c)  # 吃小鱼</code></pre>
<h2 id="八、实例属性、类属性"><a href="#八、实例属性、类属性" class="headerlink" title="八、实例属性、类属性"></a>八、实例属性、类属性</h2><h3 id="1-实例属性和类属性"><a href="#1-实例属性和类属性" class="headerlink" title="1. 实例属性和类属性"></a>1. 实例属性和类属性</h3><h4 id="1-1-专业名词说明"><a href="#1-1-专业名词说明" class="headerlink" title="1.1 专业名词说明"></a>1.1 专业名词说明</h4><ul>
<li>在Python中 “万物皆对象”</li>
<li>通过类创建的对象 又称为 <strong>实例对象</strong>，<strong>对象属性 又称为 实例属性</strong></li>
<li>类本身也是一个对象，执行class语句时会被创建，称为 <strong>类对象</strong>，为了和实例对象区分开来，我们习惯叫类</li>
</ul>
<h4 id="1-2-实例属性"><a href="#1-2-实例属性" class="headerlink" title="1.2 实例属性"></a>1.2 实例属性</h4><ul>
<li><p>通过在<code>__init__</code>方法里面给实例对象添加的属性</p>
</li>
<li><p>在类的外面，直接通过实例对象添加的属性</p>
</li>
<li><p><strong>实例属性</strong>必须通过<strong>实例对象</strong>才能访问</p>
<pre><code class="python"># 定义类
class 类名(object):
    def __init__(self):
        self.实例属性变量1 = 数值1
        self.实例属性变量2 = 数值3

# 创建实例对象
实例对象名 = 类名()

# 添加属性
实例对象名.实例属性变量3 = 数值3</code></pre>
</li>
</ul>
<h4 id="1-3-类属性"><a href="#1-3-类属性" class="headerlink" title="1.3 类属性"></a>1.3 类属性</h4><ul>
<li><p>类属性就是 <strong>类对象</strong> 所拥有的属性，它被 <strong>该类的所有实例对象 所共有</strong>。</p>
</li>
<li><p>定义在<strong>类里面，类方法外面</strong>的变量就是<strong>类属性</strong></p>
</li>
<li><p>类属性可以使用 <strong>类名</strong> 或 <strong>实例对象</strong> 访问，<strong>推荐使用类名访问</strong></p>
<pre><code class="python"># 定义类
class 类名(object):
    类属性变量 = 数值1

    def __init__(self):
        pass</code></pre>
</li>
</ul>
<h4 id="1-4-示例代码"><a href="#1-4-示例代码" class="headerlink" title="1.4 示例代码"></a>1.4 示例代码</h4><pre><code class="python">class Dog(object):
    # 类属性
    count = 0

    def __init__(self):
        # 实例属性
        self.name = &#39;大黄狗&#39;


# 类属性同构类名访问，格式：类名.类属性名字
print(Dog.count)

# 创建实例对象
dog1 = Dog()
print(dog1.count)  # 实例对象访问类属性
print(dog1.name)  # 实例属性</code></pre>
<p>运行结果：</p>
<pre><code class="python">0
0
大黄狗</code></pre>
<h3 id="2-类属性和实例属性的区别"><a href="#2-类属性和实例属性的区别" class="headerlink" title="2. 类属性和实例属性的区别"></a>2. 类属性和实例属性的区别</h3><ul>
<li>类属性就是 <strong>类对象</strong> 所拥有的属性，它被 <strong>该类的所有实例对象 所共有</strong>。</li>
<li><strong>实例属性</strong> 要求 <strong>每个对象</strong> 为其 <strong>单独开辟一份内存空间</strong> ，只属于某个实例对象的</li>
</ul>
<p>示例代码：</p>
<pre><code class="python">&quot;&quot;&quot;
1. 定义一个类属性count，用于记录实例对象初始化的次数
2. __init__添加实例属性name，每初始化1次，类属性count加1
&quot;&quot;&quot;

class Dog(object):
    # 类属性
    count = 0

    def __init__(self, _name):
        # 实例属性
        self.name = _name

        # 每初始化一次，类属性数量加1
        Dog.count += 1


# 打印类属性的值
print(Dog.count)

# 创建1个对象
d1 = Dog(&#39;旺财&#39;)
# 打印：实例属性，类属性
print(d1.name, Dog.count)

d2 = Dog(&#39;旺钱&#39;)
print(d2.name, Dog.count)

d3 = Dog(&#39;旺仔&#39;)
print(d3.name, Dog.count)

# 通过实例对象，访问类属性
print(d1.count, d2.count, d3.count)</code></pre>
<p>运行结果：</p>
<pre><code>0
旺财 1
旺钱 2
旺仔 3
3 3 3</code></pre><h3 id="3-注意点"><a href="#3-注意点" class="headerlink" title="3. 注意点"></a>3. 注意点</h3><h4 id="3-1-修改类属性"><a href="#3-1-修改类属性" class="headerlink" title="3.1 修改类属性"></a>3.1 修改类属性</h4><ul>
<li><strong>类属性只能通过类对象修改，不能通过实例对象修改</strong></li>
</ul>
<pre><code class="python"># 类属性修改，只能通过类名修改，不能通过对象名修改

class Dog(object):
    # 类属性
    count = 0

# 通过类名修改
Dog.count = 1
print(Dog.count)

print(&#39;=&#39;*30)
# 对象名.变量 = 数据 默认操作给实例对象添加实例属性，已经不能操作类属性
# 如果类属性名字和实例属性名字相同，实例对象名只能操作实例属性
d1 = Dog()
d1.count = 250

print(Dog.count, d1.count)</code></pre>
<p>运行结果：</p>
<pre><code class="python">1
==============================
1 250</code></pre>
<h4 id="3-2-类属性和实例属性同名"><a href="#3-2-类属性和实例属性同名" class="headerlink" title="3.2 类属性和实例属性同名"></a>3.2 类属性和实例属性同名</h4><ul>
<li>如果类属性和实例属性同名，实例对象名只能操作实例属性</li>
<li>结论：<strong>操作类属性建议使用类名</strong>，避免不必要的麻烦</li>
</ul>
<pre><code class="python">class Dog(object):
    # 类属性
    count = 666

    def __init__(self):
        self.count = 250  # 实例属性

# 创建对象
# 如果类属性和实例属性同名，实例对象名只能操作实例属性
d1 = Dog()
print(Dog.count, d1.count)</code></pre>
<p>运行结果：</p>
<pre><code class="python">666 250</code></pre>
<h4 id="3-3-私有类属性"><a href="#3-3-私有类属性" class="headerlink" title="3.3 私有类属性"></a>3.3 私有类属性</h4><ul>
<li><p>类属性也可以设置为 <strong>私有</strong>，前边添加两个下划线<code>__</code></p>
<pre><code class="python">class Dog(object):
    # 类属性
    __count = 0

print(Dog.__count)  # 类的外面，不能直接访问私有类属性，err</code></pre>
</li>
</ul>
<h2 id="九、类方法、静态方法"><a href="#九、类方法、静态方法" class="headerlink" title="九、类方法、静态方法"></a>九、类方法、静态方法</h2><h3 id="1-类方法"><a href="#1-类方法" class="headerlink" title="1. 类方法"></a>1. 类方法</h3><ul>
<li><strong>类对象所拥有的方法</strong>，主要为了在没有创建实例对象前提下，处理类属性</li>
<li>需要用装饰器<code>@classmethod</code>来标识其为类方法</li>
<li>对于类方法，<strong>第一个参数必须是类对象(代表类)</strong>，一般以<code>cls</code>作为第一个参数，这个参数不用人为传参，解释器会自动处理</li>
</ul>
<pre><code class="python">&quot;&quot;&quot;
类方法：为了方便处理类属性
    1. 用装饰器 @classmethod 来标识其为类方法
    2. 一般以 cls 作为第一个参数，代表当前这个类，这个参数不用人为传参，解释器会自动处理
    3. 类方法调用：
        3.1 类名.类方法()    推荐用法
        3.2 实例对象名.类方法()
&quot;&quot;&quot;


class Dog(object):
    # 类属性
    count = 0

    # 定义类方法
    @classmethod
    def print_num(cls):  # 参数cls代表当前的类
        # print(&#39;count = &#39;, Dog.count)
        print(&#39;count = &#39;, cls.count)


# 调用类方法
Dog.print_num()</code></pre>
<h3 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2. 静态方法"></a>2. 静态方法</h3><ul>
<li>需要通过装饰器<code>@staticmethod</code>来进行修饰，<strong>静态方法默认情况下, 既不传递类对象也不传递实例对象（形参没有self/cls）</strong>。</li>
<li>当方法中 <strong>既不需要使用实例对象</strong>，<strong>也不需要使用类对象</strong>时，定义静态方法</li>
<li><strong>取消不需要的参数传递</strong>，有利于 <strong>减少不必要的内存占用和性能消耗</strong></li>
<li>静态方法 也能够通过 <strong>实例对象</strong> 和 <strong>类对象(类名)</strong> 去访问。</li>
</ul>
<pre><code class="python">&quot;&quot;&quot;
静态方法：
    1. 需要通过装饰器@staticmethod来进行修饰默认情况下
    2. 既不传递类对象也不传递实例对象（形参没有self/cls）
    3. 静态方法调用：
        3.1 类名.静态方法()    推荐用法
        3.2 实例对象名.静态方法()
&quot;&quot;&quot;


class Dog(object):
    # 定义静态方法
    @staticmethod
    def normal_func():
        print(&#39;一个和实例属性、类属性没有关系的普通方法&#39;)


# 调用静态方法
Dog.normal_func()</code></pre>
</div><div class="p-copyright"><blockquote><div class="p-copyright-author"><span class="p-copyright-key">本文作者：</span><span class="p-copytight-value"><a href="mailto:litreily@163.com">caijinbo</a></span></div><div class="p-copyright-link"><span class="p-copyright-key">本文链接：</span><span class="p-copytight-value"><a href="/2020/07/26/2020-07-27-python%E5%9F%BA%E7%A1%8008-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12%EF%BC%9A%E7%BB%A7%E6%89%BF%E3%80%81%E5%B1%9E%E6%80%A7%E3%80%81%E6%96%B9%E6%B3%95/">https://caijinbo.work/2020/07/26/2020-07-27-python基础08-面向对象2：继承、属性、方法/</a></span></div><div class="p-copyright-note"><span class="p-copyright-key">版权声明：</span><span class="p-copytight-value">本博客所有文章除特殊声明外，均采用<a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/"> CC BY-NC 4.0 </a>许可协议。转载请注明出处 <a href="https://caijinbo.work">caijinbo的博客</a>！</span></div></blockquote></div></article><div class="p-info box"><span class="p-tags"><i class="fa fa-tag"></i><a href="/tags/python/">python</a></span></div><aside id="toc"><div class="toc-title">目录</div><nav><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#面向对象2：继承、属性、方法"><span class="toc-number">1.</span> <span class="toc-text">面向对象2：继承、属性、方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、私有权限"><span class="toc-number">1.1.</span> <span class="toc-text">一、私有权限</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-面向对象的特性"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. 面向对象的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-私有属性"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. 私有属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-私有方法"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. 私有方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、继承的作用"><span class="toc-number">1.2.</span> <span class="toc-text">二、继承的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-继承的作用"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 继承的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-继承的语法格式"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 继承的语法格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、单继承和多层继承"><span class="toc-number">1.3.</span> <span class="toc-text">三、单继承和多层继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-单继承"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 单继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-多层继承"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. 多层继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、重写父类方法"><span class="toc-number">1.4.</span> <span class="toc-text">四、重写父类方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-子类重写父类同名方法"><span class="toc-number">1.4.1.</span> <span class="toc-text">1. 子类重写父类同名方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-子类调用父类同名方法"><span class="toc-number">1.4.2.</span> <span class="toc-text">2. 子类调用父类同名方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、多继承"><span class="toc-number">1.5.</span> <span class="toc-text">五、多继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-多继承"><span class="toc-number">1.5.1.</span> <span class="toc-text">1. 多继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-类的继承顺序"><span class="toc-number">1.5.2.</span> <span class="toc-text">2. 类的继承顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-调用父类同名方法"><span class="toc-number">1.5.3.</span> <span class="toc-text">3. 调用父类同名方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-默认调用情况"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">3.1 默认调用情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-子类调用父类同名方法"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">3.2 子类调用父类同名方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、私有和继承"><span class="toc-number">1.6.</span> <span class="toc-text">六、私有和继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-私有和继承"><span class="toc-number">1.6.1.</span> <span class="toc-text">1. 私有和继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、多态"><span class="toc-number">1.7.</span> <span class="toc-text">七、多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-多态"><span class="toc-number">1.7.1.</span> <span class="toc-text">1. 多态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、实例属性、类属性"><span class="toc-number">1.8.</span> <span class="toc-text">八、实例属性、类属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-实例属性和类属性"><span class="toc-number">1.8.1.</span> <span class="toc-text">1. 实例属性和类属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-专业名词说明"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">1.1 专业名词说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-实例属性"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">1.2 实例属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-类属性"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">1.3 类属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-示例代码"><span class="toc-number">1.8.1.4.</span> <span class="toc-text">1.4 示例代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-类属性和实例属性的区别"><span class="toc-number">1.8.2.</span> <span class="toc-text">2. 类属性和实例属性的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-注意点"><span class="toc-number">1.8.3.</span> <span class="toc-text">3. 注意点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-修改类属性"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">3.1 修改类属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-类属性和实例属性同名"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">3.2 类属性和实例属性同名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-私有类属性"><span class="toc-number">1.8.3.3.</span> <span class="toc-text">3.3 私有类属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九、类方法、静态方法"><span class="toc-number">1.9.</span> <span class="toc-text">九、类方法、静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-类方法"><span class="toc-number">1.9.1.</span> <span class="toc-text">1. 类方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-静态方法"><span class="toc-number">1.9.2.</span> <span class="toc-text">2. 静态方法</span></a></li></ol></li></ol></li></ol></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="prev" href="/2020/07/26/2020-07-27-python%E5%9F%BA%E7%A1%8003-%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B/">&lt; python基础03-容器类型</a><a class="next" href="/2020/07/26/2020-07-27-python%E5%9F%BA%E7%A1%8002-%E9%80%89%E6%8B%A9%E5%92%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/">python基础02-选择和循环语句 &gt;</a></div></section><footer><p>Copyright © 2016 - 2021 <a href="/." rel="nofollow">CAIJINBO</a> | <strong><a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></strong><br><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span></span> <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> | Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/litreily/snark-hexo"> snark.</a></p></footer></div></div></div><script type="text/javascript" src="/plugins/prettify/prettify.js"></script><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
    search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"></body></html>